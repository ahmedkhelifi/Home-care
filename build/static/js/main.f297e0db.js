/******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId])
/******/ 			return installedModules[moduleId].exports;
/******/
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			exports: {},
/******/ 			id: moduleId,
/******/ 			loaded: false
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.loaded = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "/";
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(0);
/******/ })
/************************************************************************/
/******/ ((function(modules) {
	// Check all modules for deduplicated modules
	for(var i in modules) {
		if(Object.prototype.hasOwnProperty.call(modules, i)) {
			switch(typeof modules[i]) {
			case "function": break;
			case "object":
				// Module can be created from a template
				modules[i] = (function(_m) {
					var args = _m.slice(1), fn = modules[_m[0]];
					return function (a,b,c) {
						fn.apply(this, [a,b,c].concat(args));
					};
				}(modules[i]));
				break;
			default:
				// Module is a copy of another module
				modules[i] = modules[modules[i]];
				break;
			}
		}
	}
	return modules;
}([
/* 0 */
/***/ function(module, exports, __webpack_require__) {

	__webpack_require__(414);
	module.exports = __webpack_require__(283);


/***/ },
/* 1 */
/***/ function(module, exports) {

	"use strict";
	exports.__esModule = true;
	var BUILTIN_OBJECT = {
	    '[object Function]': true,
	    '[object RegExp]': true,
	    '[object Date]': true,
	    '[object Error]': true,
	    '[object CanvasGradient]': true,
	    '[object CanvasPattern]': true,
	    '[object Image]': true,
	    '[object Canvas]': true
	};
	var TYPED_ARRAY = {
	    '[object Int8Array]': true,
	    '[object Uint8Array]': true,
	    '[object Uint8ClampedArray]': true,
	    '[object Int16Array]': true,
	    '[object Uint16Array]': true,
	    '[object Int32Array]': true,
	    '[object Uint32Array]': true,
	    '[object Float32Array]': true,
	    '[object Float64Array]': true
	};
	var objToString = Object.prototype.toString;
	var arrayProto = Array.prototype;
	var nativeForEach = arrayProto.forEach;
	var nativeFilter = arrayProto.filter;
	var nativeSlice = arrayProto.slice;
	var nativeMap = arrayProto.map;
	var ctorFunction = (function () { }).constructor;
	var protoFunction = ctorFunction ? ctorFunction.prototype : null;
	var methods = {};
	function $override(name, fn) {
	    methods[name] = fn;
	}
	exports.$override = $override;
	var idStart = 0x0907;
	function guid() {
	    return idStart++;
	}
	exports.guid = guid;
	function logError() {
	    var args = [];
	    for (var _i = 0; _i < arguments.length; _i++) {
	        args[_i] = arguments[_i];
	    }
	    if (typeof console !== 'undefined') {
	        console.error.apply(console, args);
	    }
	}
	exports.logError = logError;
	function clone(source) {
	    if (source == null || typeof source !== 'object') {
	        return source;
	    }
	    var result = source;
	    var typeStr = objToString.call(source);
	    if (typeStr === '[object Array]') {
	        if (!isPrimitive(source)) {
	            result = [];
	            for (var i = 0, len = source.length; i < len; i++) {
	                result[i] = clone(source[i]);
	            }
	        }
	    }
	    else if (TYPED_ARRAY[typeStr]) {
	        if (!isPrimitive(source)) {
	            var Ctor = source.constructor;
	            if (Ctor.from) {
	                result = Ctor.from(source);
	            }
	            else {
	                result = new Ctor(source.length);
	                for (var i = 0, len = source.length; i < len; i++) {
	                    result[i] = clone(source[i]);
	                }
	            }
	        }
	    }
	    else if (!BUILTIN_OBJECT[typeStr] && !isPrimitive(source) && !isDom(source)) {
	        result = {};
	        for (var key in source) {
	            if (source.hasOwnProperty(key)) {
	                result[key] = clone(source[key]);
	            }
	        }
	    }
	    return result;
	}
	exports.clone = clone;
	function merge(target, source, overwrite) {
	    if (!isObject(source) || !isObject(target)) {
	        return overwrite ? clone(source) : target;
	    }
	    for (var key in source) {
	        if (source.hasOwnProperty(key)) {
	            var targetProp = target[key];
	            var sourceProp = source[key];
	            if (isObject(sourceProp)
	                && isObject(targetProp)
	                && !isArray(sourceProp)
	                && !isArray(targetProp)
	                && !isDom(sourceProp)
	                && !isDom(targetProp)
	                && !isBuiltInObject(sourceProp)
	                && !isBuiltInObject(targetProp)
	                && !isPrimitive(sourceProp)
	                && !isPrimitive(targetProp)) {
	                merge(targetProp, sourceProp, overwrite);
	            }
	            else if (overwrite || !(key in target)) {
	                target[key] = clone(source[key]);
	            }
	        }
	    }
	    return target;
	}
	exports.merge = merge;
	function mergeAll(targetAndSources, overwrite) {
	    var result = targetAndSources[0];
	    for (var i = 1, len = targetAndSources.length; i < len; i++) {
	        result = merge(result, targetAndSources[i], overwrite);
	    }
	    return result;
	}
	exports.mergeAll = mergeAll;
	function extend(target, source) {
	    if (Object.assign) {
	        Object.assign(target, source);
	    }
	    else {
	        for (var key in source) {
	            if (source.hasOwnProperty(key)) {
	                target[key] = source[key];
	            }
	        }
	    }
	    return target;
	}
	exports.extend = extend;
	function defaults(target, source, overlay) {
	    var keysArr = keys(source);
	    for (var i = 0; i < keysArr.length; i++) {
	        var key = keysArr[i];
	        if ((overlay ? source[key] != null : target[key] == null)) {
	            target[key] = source[key];
	        }
	    }
	    return target;
	}
	exports.defaults = defaults;
	exports.createCanvas = function () {
	    return methods.createCanvas();
	};
	methods.createCanvas = function () {
	    return document.createElement('canvas');
	};
	function indexOf(array, value) {
	    if (array) {
	        if (array.indexOf) {
	            return array.indexOf(value);
	        }
	        for (var i = 0, len = array.length; i < len; i++) {
	            if (array[i] === value) {
	                return i;
	            }
	        }
	    }
	    return -1;
	}
	exports.indexOf = indexOf;
	function inherits(clazz, baseClazz) {
	    var clazzPrototype = clazz.prototype;
	    function F() { }
	    F.prototype = baseClazz.prototype;
	    clazz.prototype = new F();
	    for (var prop in clazzPrototype) {
	        if (clazzPrototype.hasOwnProperty(prop)) {
	            clazz.prototype[prop] = clazzPrototype[prop];
	        }
	    }
	    clazz.prototype.constructor = clazz;
	    clazz.superClass = baseClazz;
	}
	exports.inherits = inherits;
	function mixin(target, source, override) {
	    target = 'prototype' in target ? target.prototype : target;
	    source = 'prototype' in source ? source.prototype : source;
	    if (Object.getOwnPropertyNames) {
	        var keyList = Object.getOwnPropertyNames(source);
	        for (var i = 0; i < keyList.length; i++) {
	            var key = keyList[i];
	            if (key !== 'constructor') {
	                if ((override ? source[key] != null : target[key] == null)) {
	                    target[key] = source[key];
	                }
	            }
	        }
	    }
	    else {
	        defaults(target, source, override);
	    }
	}
	exports.mixin = mixin;
	function isArrayLike(data) {
	    if (!data) {
	        return false;
	    }
	    if (typeof data === 'string') {
	        return false;
	    }
	    return typeof data.length === 'number';
	}
	exports.isArrayLike = isArrayLike;
	function each(arr, cb, context) {
	    if (!(arr && cb)) {
	        return;
	    }
	    if (arr.forEach && arr.forEach === nativeForEach) {
	        arr.forEach(cb, context);
	    }
	    else if (arr.length === +arr.length) {
	        for (var i = 0, len = arr.length; i < len; i++) {
	            cb.call(context, arr[i], i, arr);
	        }
	    }
	    else {
	        for (var key in arr) {
	            if (arr.hasOwnProperty(key)) {
	                cb.call(context, arr[key], key, arr);
	            }
	        }
	    }
	}
	exports.each = each;
	function map(arr, cb, context) {
	    if (!arr) {
	        return [];
	    }
	    if (!cb) {
	        return slice(arr);
	    }
	    if (arr.map && arr.map === nativeMap) {
	        return arr.map(cb, context);
	    }
	    else {
	        var result = [];
	        for (var i = 0, len = arr.length; i < len; i++) {
	            result.push(cb.call(context, arr[i], i, arr));
	        }
	        return result;
	    }
	}
	exports.map = map;
	function reduce(arr, cb, memo, context) {
	    if (!(arr && cb)) {
	        return;
	    }
	    for (var i = 0, len = arr.length; i < len; i++) {
	        memo = cb.call(context, memo, arr[i], i, arr);
	    }
	    return memo;
	}
	exports.reduce = reduce;
	function filter(arr, cb, context) {
	    if (!arr) {
	        return [];
	    }
	    if (!cb) {
	        return slice(arr);
	    }
	    if (arr.filter && arr.filter === nativeFilter) {
	        return arr.filter(cb, context);
	    }
	    else {
	        var result = [];
	        for (var i = 0, len = arr.length; i < len; i++) {
	            if (cb.call(context, arr[i], i, arr)) {
	                result.push(arr[i]);
	            }
	        }
	        return result;
	    }
	}
	exports.filter = filter;
	function find(arr, cb, context) {
	    if (!(arr && cb)) {
	        return;
	    }
	    for (var i = 0, len = arr.length; i < len; i++) {
	        if (cb.call(context, arr[i], i, arr)) {
	            return arr[i];
	        }
	    }
	}
	exports.find = find;
	function keys(obj) {
	    if (!obj) {
	        return [];
	    }
	    if (Object.keys) {
	        return Object.keys(obj);
	    }
	    var keyList = [];
	    for (var key in obj) {
	        if (obj.hasOwnProperty(key)) {
	            keyList.push(key);
	        }
	    }
	    return keyList;
	}
	exports.keys = keys;
	function bindPolyfill(func, context) {
	    var args = [];
	    for (var _i = 2; _i < arguments.length; _i++) {
	        args[_i - 2] = arguments[_i];
	    }
	    return function () {
	        return func.apply(context, args.concat(nativeSlice.call(arguments)));
	    };
	}
	exports.bind = (protoFunction && isFunction(protoFunction.bind))
	    ? protoFunction.call.bind(protoFunction.bind)
	    : bindPolyfill;
	function curry(func) {
	    var args = [];
	    for (var _i = 1; _i < arguments.length; _i++) {
	        args[_i - 1] = arguments[_i];
	    }
	    return function () {
	        return func.apply(this, args.concat(nativeSlice.call(arguments)));
	    };
	}
	exports.curry = curry;
	function isArray(value) {
	    if (Array.isArray) {
	        return Array.isArray(value);
	    }
	    return objToString.call(value) === '[object Array]';
	}
	exports.isArray = isArray;
	function isFunction(value) {
	    return typeof value === 'function';
	}
	exports.isFunction = isFunction;
	function isString(value) {
	    return typeof value === 'string';
	}
	exports.isString = isString;
	function isStringSafe(value) {
	    return objToString.call(value) === '[object String]';
	}
	exports.isStringSafe = isStringSafe;
	function isNumber(value) {
	    return typeof value === 'number';
	}
	exports.isNumber = isNumber;
	function isObject(value) {
	    var type = typeof value;
	    return type === 'function' || (!!value && type === 'object');
	}
	exports.isObject = isObject;
	function isBuiltInObject(value) {
	    return !!BUILTIN_OBJECT[objToString.call(value)];
	}
	exports.isBuiltInObject = isBuiltInObject;
	function isTypedArray(value) {
	    return !!TYPED_ARRAY[objToString.call(value)];
	}
	exports.isTypedArray = isTypedArray;
	function isDom(value) {
	    return typeof value === 'object'
	        && typeof value.nodeType === 'number'
	        && typeof value.ownerDocument === 'object';
	}
	exports.isDom = isDom;
	function isGradientObject(value) {
	    return value.colorStops != null;
	}
	exports.isGradientObject = isGradientObject;
	function isPatternObject(value) {
	    return value.image != null;
	}
	exports.isPatternObject = isPatternObject;
	function isRegExp(value) {
	    return objToString.call(value) === '[object RegExp]';
	}
	exports.isRegExp = isRegExp;
	function eqNaN(value) {
	    return value !== value;
	}
	exports.eqNaN = eqNaN;
	function retrieve() {
	    var args = [];
	    for (var _i = 0; _i < arguments.length; _i++) {
	        args[_i] = arguments[_i];
	    }
	    for (var i = 0, len = args.length; i < len; i++) {
	        if (args[i] != null) {
	            return args[i];
	        }
	    }
	}
	exports.retrieve = retrieve;
	function retrieve2(value0, value1) {
	    return value0 != null
	        ? value0
	        : value1;
	}
	exports.retrieve2 = retrieve2;
	function retrieve3(value0, value1, value2) {
	    return value0 != null
	        ? value0
	        : value1 != null
	            ? value1
	            : value2;
	}
	exports.retrieve3 = retrieve3;
	function slice(arr) {
	    var args = [];
	    for (var _i = 1; _i < arguments.length; _i++) {
	        args[_i - 1] = arguments[_i];
	    }
	    return nativeSlice.apply(arr, args);
	}
	exports.slice = slice;
	function normalizeCssArray(val) {
	    if (typeof (val) === 'number') {
	        return [val, val, val, val];
	    }
	    var len = val.length;
	    if (len === 2) {
	        return [val[0], val[1], val[0], val[1]];
	    }
	    else if (len === 3) {
	        return [val[0], val[1], val[2], val[1]];
	    }
	    return val;
	}
	exports.normalizeCssArray = normalizeCssArray;
	function assert(condition, message) {
	    if (!condition) {
	        throw new Error(message);
	    }
	}
	exports.assert = assert;
	function trim(str) {
	    if (str == null) {
	        return null;
	    }
	    else if (typeof str.trim === 'function') {
	        return str.trim();
	    }
	    else {
	        return str.replace(/^[\s\uFEFF\xA0]+|[\s\uFEFF\xA0]+$/g, '');
	    }
	}
	exports.trim = trim;
	var primitiveKey = '__ec_primitive__';
	function setAsPrimitive(obj) {
	    obj[primitiveKey] = true;
	}
	exports.setAsPrimitive = setAsPrimitive;
	function isPrimitive(obj) {
	    return obj[primitiveKey];
	}
	exports.isPrimitive = isPrimitive;
	var HashMap = (function () {
	    function HashMap(obj) {
	        this.data = {};
	        var isArr = isArray(obj);
	        this.data = {};
	        var thisMap = this;
	        (obj instanceof HashMap)
	            ? obj.each(visit)
	            : (obj && each(obj, visit));
	        function visit(value, key) {
	            isArr ? thisMap.set(value, key) : thisMap.set(key, value);
	        }
	    }
	    HashMap.prototype.get = function (key) {
	        return this.data.hasOwnProperty(key) ? this.data[key] : null;
	    };
	    HashMap.prototype.set = function (key, value) {
	        return (this.data[key] = value);
	    };
	    HashMap.prototype.each = function (cb, context) {
	        for (var key in this.data) {
	            if (this.data.hasOwnProperty(key)) {
	                cb.call(context, this.data[key], key);
	            }
	        }
	    };
	    HashMap.prototype.keys = function () {
	        return keys(this.data);
	    };
	    HashMap.prototype.removeKey = function (key) {
	        delete this.data[key];
	    };
	    return HashMap;
	}());
	exports.HashMap = HashMap;
	function createHashMap(obj) {
	    return new HashMap(obj);
	}
	exports.createHashMap = createHashMap;
	function concatArray(a, b) {
	    var newArray = new a.constructor(a.length + b.length);
	    for (var i = 0; i < a.length; i++) {
	        newArray[i] = a[i];
	    }
	    var offset = a.length;
	    for (var i = 0; i < b.length; i++) {
	        newArray[i + offset] = b[i];
	    }
	    return newArray;
	}
	exports.concatArray = concatArray;
	function createObject(proto, properties) {
	    var obj;
	    if (Object.create) {
	        obj = Object.create(proto);
	    }
	    else {
	        var StyleCtor = function () { };
	        StyleCtor.prototype = proto;
	        obj = new StyleCtor();
	    }
	    if (properties) {
	        extend(obj, properties);
	    }
	    return obj;
	}
	exports.createObject = createObject;
	function hasOwn(own, prop) {
	    return own.hasOwnProperty(prop);
	}
	exports.hasOwn = hasOwn;
	function noop() { }
	exports.noop = noop;


/***/ },
/* 2 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	if (true) {
	  module.exports = __webpack_require__(420);
	} else {
	  module.exports = require('./cjs/react.development.js');
	}


/***/ },
/* 3 */
/***/ function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;/* WEBPACK VAR INJECTION */(function(global) {/*! *****************************************************************************
	Copyright (c) Microsoft Corporation. All rights reserved.
	Licensed under the Apache License, Version 2.0 (the "License"); you may not use
	this file except in compliance with the License. You may obtain a copy of the
	License at http://www.apache.org/licenses/LICENSE-2.0
	
	THIS CODE IS PROVIDED ON AN *AS IS* BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
	KIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION ANY IMPLIED
	WARRANTIES OR CONDITIONS OF TITLE, FITNESS FOR A PARTICULAR PURPOSE,
	MERCHANTABLITY OR NON-INFRINGEMENT.
	
	See the Apache Version 2.0 License for specific language governing permissions
	and limitations under the License.
	***************************************************************************** */
	/* global global, define, System, Reflect, Promise */
	var __extends;
	var __assign;
	var __rest;
	var __decorate;
	var __param;
	var __metadata;
	var __awaiter;
	var __generator;
	var __exportStar;
	var __values;
	var __read;
	var __spread;
	var __spreadArrays;
	var __await;
	var __asyncGenerator;
	var __asyncDelegator;
	var __asyncValues;
	var __makeTemplateObject;
	var __importStar;
	var __importDefault;
	(function (factory) {
	    var root = typeof global === "object" ? global : typeof self === "object" ? self : typeof this === "object" ? this : {};
	    if (true) {
	        !(__WEBPACK_AMD_DEFINE_ARRAY__ = [exports], __WEBPACK_AMD_DEFINE_RESULT__ = function (exports) { factory(createExporter(root, createExporter(exports))); }.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
	    }
	    else if (typeof module === "object" && typeof module.exports === "object") {
	        factory(createExporter(root, createExporter(module.exports)));
	    }
	    else {
	        factory(createExporter(root));
	    }
	    function createExporter(exports, previous) {
	        if (exports !== root) {
	            if (typeof Object.create === "function") {
	                Object.defineProperty(exports, "__esModule", { value: true });
	            }
	            else {
	                exports.__esModule = true;
	            }
	        }
	        return function (id, v) { return exports[id] = previous ? previous(id, v) : v; };
	    }
	})
	(function (exporter) {
	    var extendStatics = Object.setPrototypeOf ||
	        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
	        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
	
	    __extends = function (d, b) {
	        extendStatics(d, b);
	        function __() { this.constructor = d; }
	        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	    };
	
	    __assign = Object.assign || function (t) {
	        for (var s, i = 1, n = arguments.length; i < n; i++) {
	            s = arguments[i];
	            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];
	        }
	        return t;
	    };
	
	    __rest = function (s, e) {
	        var t = {};
	        for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
	            t[p] = s[p];
	        if (s != null && typeof Object.getOwnPropertySymbols === "function")
	            for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
	                if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
	                    t[p[i]] = s[p[i]];
	            }
	        return t;
	    };
	
	    __decorate = function (decorators, target, key, desc) {
	        var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
	        if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
	        else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
	        return c > 3 && r && Object.defineProperty(target, key, r), r;
	    };
	
	    __param = function (paramIndex, decorator) {
	        return function (target, key) { decorator(target, key, paramIndex); }
	    };
	
	    __metadata = function (metadataKey, metadataValue) {
	        if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(metadataKey, metadataValue);
	    };
	
	    __awaiter = function (thisArg, _arguments, P, generator) {
	        return new (P || (P = Promise))(function (resolve, reject) {
	            function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
	            function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
	            function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }
	            step((generator = generator.apply(thisArg, _arguments || [])).next());
	        });
	    };
	
	    __generator = function (thisArg, body) {
	        var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;
	        return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() { return this; }), g;
	        function verb(n) { return function (v) { return step([n, v]); }; }
	        function step(op) {
	            if (f) throw new TypeError("Generator is already executing.");
	            while (_) try {
	                if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
	                if (y = 0, t) op = [op[0] & 2, t.value];
	                switch (op[0]) {
	                    case 0: case 1: t = op; break;
	                    case 4: _.label++; return { value: op[1], done: false };
	                    case 5: _.label++; y = op[1]; op = [0]; continue;
	                    case 7: op = _.ops.pop(); _.trys.pop(); continue;
	                    default:
	                        if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }
	                        if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }
	                        if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }
	                        if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }
	                        if (t[2]) _.ops.pop();
	                        _.trys.pop(); continue;
	                }
	                op = body.call(thisArg, _);
	            } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }
	            if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };
	        }
	    };
	
	    __exportStar = function (m, exports) {
	        for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];
	    };
	
	    __values = function (o) {
	        var m = typeof Symbol === "function" && o[Symbol.iterator], i = 0;
	        if (m) return m.call(o);
	        return {
	            next: function () {
	                if (o && i >= o.length) o = void 0;
	                return { value: o && o[i++], done: !o };
	            }
	        };
	    };
	
	    __read = function (o, n) {
	        var m = typeof Symbol === "function" && o[Symbol.iterator];
	        if (!m) return o;
	        var i = m.call(o), r, ar = [], e;
	        try {
	            while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);
	        }
	        catch (error) { e = { error: error }; }
	        finally {
	            try {
	                if (r && !r.done && (m = i["return"])) m.call(i);
	            }
	            finally { if (e) throw e.error; }
	        }
	        return ar;
	    };
	
	    __spread = function () {
	        for (var ar = [], i = 0; i < arguments.length; i++)
	            ar = ar.concat(__read(arguments[i]));
	        return ar;
	    };
	
	    __spreadArrays = function () {
	        for (var s = 0, i = 0, il = arguments.length; i < il; i++) s += arguments[i].length;
	        for (var r = Array(s), k = 0, i = 0; i < il; i++)
	            for (var a = arguments[i], j = 0, jl = a.length; j < jl; j++, k++)
	                r[k] = a[j];
	        return r;
	    };
	
	    __await = function (v) {
	        return this instanceof __await ? (this.v = v, this) : new __await(v);
	    };
	
	    __asyncGenerator = function (thisArg, _arguments, generator) {
	        if (!Symbol.asyncIterator) throw new TypeError("Symbol.asyncIterator is not defined.");
	        var g = generator.apply(thisArg, _arguments || []), i, q = [];
	        return i = {}, verb("next"), verb("throw"), verb("return"), i[Symbol.asyncIterator] = function () { return this; }, i;
	        function verb(n) { if (g[n]) i[n] = function (v) { return new Promise(function (a, b) { q.push([n, v, a, b]) > 1 || resume(n, v); }); }; }
	        function resume(n, v) { try { step(g[n](v)); } catch (e) { settle(q[0][3], e); } }
	        function step(r) { r.value instanceof __await ? Promise.resolve(r.value.v).then(fulfill, reject) : settle(q[0][2], r);  }
	        function fulfill(value) { resume("next", value); }
	        function reject(value) { resume("throw", value); }
	        function settle(f, v) { if (f(v), q.shift(), q.length) resume(q[0][0], q[0][1]); }
	    };
	
	    __asyncDelegator = function (o) {
	        var i, p;
	        return i = {}, verb("next"), verb("throw", function (e) { throw e; }), verb("return"), i[Symbol.iterator] = function () { return this; }, i;
	        function verb(n, f) { i[n] = o[n] ? function (v) { return (p = !p) ? { value: __await(o[n](v)), done: n === "return" } : f ? f(v) : v; } : f; }
	    };
	
	    __asyncValues = function (o) {
	        if (!Symbol.asyncIterator) throw new TypeError("Symbol.asyncIterator is not defined.");
	        var m = o[Symbol.asyncIterator], i;
	        return m ? m.call(o) : (o = typeof __values === "function" ? __values(o) : o[Symbol.iterator](), i = {}, verb("next"), verb("throw"), verb("return"), i[Symbol.asyncIterator] = function () { return this; }, i);
	        function verb(n) { i[n] = o[n] && function (v) { return new Promise(function (resolve, reject) { v = o[n](v), settle(resolve, reject, v.done, v.value); }); }; }
	        function settle(resolve, reject, d, v) { Promise.resolve(v).then(function(v) { resolve({ value: v, done: d }); }, reject); }
	    };
	
	    __makeTemplateObject = function (cooked, raw) {
	        if (Object.defineProperty) { Object.defineProperty(cooked, "raw", { value: raw }); } else { cooked.raw = raw; }
	        return cooked;
	    };
	
	    __importStar = function (mod) {
	        if (mod && mod.__esModule) return mod;
	        var result = {};
	        if (mod != null) for (var k in mod) if (Object.hasOwnProperty.call(mod, k)) result[k] = mod[k];
	        result["default"] = mod;
	        return result;
	    };
	
	    __importDefault = function (mod) {
	        return (mod && mod.__esModule) ? mod : { "default": mod };
	    };
	
	    exporter("__extends", __extends);
	    exporter("__assign", __assign);
	    exporter("__rest", __rest);
	    exporter("__decorate", __decorate);
	    exporter("__param", __param);
	    exporter("__metadata", __metadata);
	    exporter("__awaiter", __awaiter);
	    exporter("__generator", __generator);
	    exporter("__exportStar", __exportStar);
	    exporter("__values", __values);
	    exporter("__read", __read);
	    exporter("__spread", __spread);
	    exporter("__spreadArrays", __spreadArrays);
	    exporter("__await", __await);
	    exporter("__asyncGenerator", __asyncGenerator);
	    exporter("__asyncDelegator", __asyncDelegator);
	    exporter("__asyncValues", __asyncValues);
	    exporter("__makeTemplateObject", __makeTemplateObject);
	    exporter("__importStar", __importStar);
	    exporter("__importDefault", __importDefault);
	});
	
	/* WEBPACK VAR INJECTION */}.call(exports, (function() { return this; }())))

/***/ },
/* 4 */
/***/ function(module, exports, __webpack_require__) {

	
	/*
	* Licensed to the Apache Software Foundation (ASF) under one
	* or more contributor license agreements.  See the NOTICE file
	* distributed with this work for additional information
	* regarding copyright ownership.  The ASF licenses this file
	* to you under the Apache License, Version 2.0 (the
	* "License"); you may not use this file except in compliance
	* with the License.  You may obtain a copy of the License at
	*
	*   http://www.apache.org/licenses/LICENSE-2.0
	*
	* Unless required by applicable law or agreed to in writing,
	* software distributed under the License is distributed on an
	* "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
	* KIND, either express or implied.  See the License for the
	* specific language governing permissions and limitations
	* under the License.
	*/
	
	
	
	/**
	 * AUTO-GENERATED FILE. DO NOT MODIFY.
	 */
	
	"use strict";
	
	exports.__esModule = true;
	
	var util_1 = __webpack_require__(1);
	
	var env_1 = __webpack_require__(13);
	
	var number_1 = __webpack_require__(9);
	
	var Animator_1 = __webpack_require__(107);
	
	var log_1 = __webpack_require__(12);
	
	var DUMMY_COMPONENT_NAME_PREFIX = 'series\0';
	var INTERNAL_COMPONENT_ID_PREFIX = '\0_ec_\0';
	
	function normalizeToArray(value) {
	  return value instanceof Array ? value : value == null ? [] : [value];
	}
	
	exports.normalizeToArray = normalizeToArray;
	
	function defaultEmphasis(opt, key, subOpts) {
	  if (opt) {
	    opt[key] = opt[key] || {};
	    opt.emphasis = opt.emphasis || {};
	    opt.emphasis[key] = opt.emphasis[key] || {};
	
	    for (var i = 0, len = subOpts.length; i < len; i++) {
	      var subOptName = subOpts[i];
	
	      if (!opt.emphasis[key].hasOwnProperty(subOptName) && opt[key].hasOwnProperty(subOptName)) {
	        opt.emphasis[key][subOptName] = opt[key][subOptName];
	      }
	    }
	  }
	}
	
	exports.defaultEmphasis = defaultEmphasis;
	exports.TEXT_STYLE_OPTIONS = ['fontStyle', 'fontWeight', 'fontSize', 'fontFamily', 'rich', 'tag', 'color', 'textBorderColor', 'textBorderWidth', 'width', 'height', 'lineHeight', 'align', 'verticalAlign', 'baseline', 'shadowColor', 'shadowBlur', 'shadowOffsetX', 'shadowOffsetY', 'textShadowColor', 'textShadowBlur', 'textShadowOffsetX', 'textShadowOffsetY', 'backgroundColor', 'borderColor', 'borderWidth', 'borderRadius', 'padding'];
	
	function getDataItemValue(dataItem) {
	  return util_1.isObject(dataItem) && !util_1.isArray(dataItem) && !(dataItem instanceof Date) ? dataItem.value : dataItem;
	}
	
	exports.getDataItemValue = getDataItemValue;
	
	function isDataItemOption(dataItem) {
	  return util_1.isObject(dataItem) && !(dataItem instanceof Array);
	}
	
	exports.isDataItemOption = isDataItemOption;
	;
	
	function mappingToExists(existings, newCmptOptions, mode) {
	  var isNormalMergeMode = mode === 'normalMerge';
	  var isReplaceMergeMode = mode === 'replaceMerge';
	  var isReplaceAllMode = mode === 'replaceAll';
	  existings = existings || [];
	  newCmptOptions = (newCmptOptions || []).slice();
	  var existingIdIdxMap = util_1.createHashMap();
	  util_1.each(newCmptOptions, function (cmptOption, index) {
	    if (!util_1.isObject(cmptOption)) {
	      newCmptOptions[index] = null;
	      return;
	    }
	
	    if (false) {
	      if (cmptOption.id != null && !isValidIdOrName(cmptOption.id)) {
	        warnInvalidateIdOrName(cmptOption.id);
	      }
	
	      if (cmptOption.name != null && !isValidIdOrName(cmptOption.name)) {
	        warnInvalidateIdOrName(cmptOption.name);
	      }
	    }
	  });
	  var result = prepareResult(existings, existingIdIdxMap, mode);
	
	  if (isNormalMergeMode || isReplaceMergeMode) {
	    mappingById(result, existings, existingIdIdxMap, newCmptOptions);
	  }
	
	  if (isNormalMergeMode) {
	    mappingByName(result, newCmptOptions);
	  }
	
	  if (isNormalMergeMode || isReplaceMergeMode) {
	    mappingByIndex(result, newCmptOptions, isReplaceMergeMode);
	  } else if (isReplaceAllMode) {
	    mappingInReplaceAllMode(result, newCmptOptions);
	  }
	
	  makeIdAndName(result);
	  return result;
	}
	
	exports.mappingToExists = mappingToExists;
	
	function prepareResult(existings, existingIdIdxMap, mode) {
	  var result = [];
	
	  if (mode === 'replaceAll') {
	    return result;
	  }
	
	  for (var index = 0; index < existings.length; index++) {
	    var existing = existings[index];
	
	    if (existing && existing.id != null) {
	      existingIdIdxMap.set(existing.id, index);
	    }
	
	    result.push({
	      existing: mode === 'replaceMerge' || isComponentIdInternal(existing) ? null : existing,
	      newOption: null,
	      keyInfo: null,
	      brandNew: null
	    });
	  }
	
	  return result;
	}
	
	function mappingById(result, existings, existingIdIdxMap, newCmptOptions) {
	  util_1.each(newCmptOptions, function (cmptOption, index) {
	    if (!cmptOption || cmptOption.id == null) {
	      return;
	    }
	
	    var optionId = makeComparableKey(cmptOption.id);
	    var existingIdx = existingIdIdxMap.get(optionId);
	
	    if (existingIdx != null) {
	      var resultItem = result[existingIdx];
	      util_1.assert(!resultItem.newOption, 'Duplicated option on id "' + optionId + '".');
	      resultItem.newOption = cmptOption;
	      resultItem.existing = existings[existingIdx];
	      newCmptOptions[index] = null;
	    }
	  });
	}
	
	function mappingByName(result, newCmptOptions) {
	  util_1.each(newCmptOptions, function (cmptOption, index) {
	    if (!cmptOption || cmptOption.name == null) {
	      return;
	    }
	
	    for (var i = 0; i < result.length; i++) {
	      var existing = result[i].existing;
	
	      if (!result[i].newOption && existing && (existing.id == null || cmptOption.id == null) && !isComponentIdInternal(cmptOption) && !isComponentIdInternal(existing) && keyExistAndEqual('name', existing, cmptOption)) {
	        result[i].newOption = cmptOption;
	        newCmptOptions[index] = null;
	        return;
	      }
	    }
	  });
	}
	
	function mappingByIndex(result, newCmptOptions, brandNew) {
	  util_1.each(newCmptOptions, function (cmptOption) {
	    if (!cmptOption) {
	      return;
	    }
	
	    var resultItem;
	    var nextIdx = 0;
	
	    while ((resultItem = result[nextIdx]) && (resultItem.newOption || isComponentIdInternal(resultItem.existing) || resultItem.existing && cmptOption.id != null && !keyExistAndEqual('id', cmptOption, resultItem.existing))) {
	      nextIdx++;
	    }
	
	    if (resultItem) {
	      resultItem.newOption = cmptOption;
	      resultItem.brandNew = brandNew;
	    } else {
	      result.push({
	        newOption: cmptOption,
	        brandNew: brandNew,
	        existing: null,
	        keyInfo: null
	      });
	    }
	
	    nextIdx++;
	  });
	}
	
	function mappingInReplaceAllMode(result, newCmptOptions) {
	  util_1.each(newCmptOptions, function (cmptOption) {
	    result.push({
	      newOption: cmptOption,
	      brandNew: true,
	      existing: null,
	      keyInfo: null
	    });
	  });
	}
	
	function makeIdAndName(mapResult) {
	  var idMap = util_1.createHashMap();
	  util_1.each(mapResult, function (item) {
	    var existing = item.existing;
	    existing && idMap.set(existing.id, item);
	  });
	  util_1.each(mapResult, function (item) {
	    var opt = item.newOption;
	    util_1.assert(!opt || opt.id == null || !idMap.get(opt.id) || idMap.get(opt.id) === item, 'id duplicates: ' + (opt && opt.id));
	    opt && opt.id != null && idMap.set(opt.id, item);
	    !item.keyInfo && (item.keyInfo = {});
	  });
	  util_1.each(mapResult, function (item, index) {
	    var existing = item.existing;
	    var opt = item.newOption;
	    var keyInfo = item.keyInfo;
	
	    if (!util_1.isObject(opt)) {
	      return;
	    }
	
	    keyInfo.name = opt.name != null ? makeComparableKey(opt.name) : existing ? existing.name : DUMMY_COMPONENT_NAME_PREFIX + index;
	
	    if (existing) {
	      keyInfo.id = makeComparableKey(existing.id);
	    } else if (opt.id != null) {
	      keyInfo.id = makeComparableKey(opt.id);
	    } else {
	      var idNum = 0;
	
	      do {
	        keyInfo.id = '\0' + keyInfo.name + '\0' + idNum++;
	      } while (idMap.get(keyInfo.id));
	    }
	
	    idMap.set(keyInfo.id, item);
	  });
	}
	
	function keyExistAndEqual(attr, obj1, obj2) {
	  var key1 = convertOptionIdName(obj1[attr], null);
	  var key2 = convertOptionIdName(obj2[attr], null);
	  return key1 != null && key2 != null && key1 === key2;
	}
	
	function makeComparableKey(val) {
	  if (false) {
	    if (val == null) {
	      throw new Error();
	    }
	  }
	
	  return convertOptionIdName(val, '');
	}
	
	function convertOptionIdName(idOrName, defaultValue) {
	  if (idOrName == null) {
	    return defaultValue;
	  }
	
	  var type = typeof idOrName;
	  return type === 'string' ? idOrName : type === 'number' || util_1.isStringSafe(idOrName) ? idOrName + '' : defaultValue;
	}
	
	exports.convertOptionIdName = convertOptionIdName;
	
	function warnInvalidateIdOrName(idOrName) {
	  if (false) {
	    log_1.warn('`' + idOrName + '` is invalid id or name. Must be a string or number.');
	  }
	}
	
	function isValidIdOrName(idOrName) {
	  return util_1.isStringSafe(idOrName) || number_1.isNumeric(idOrName);
	}
	
	function isNameSpecified(componentModel) {
	  var name = componentModel.name;
	  return !!(name && name.indexOf(DUMMY_COMPONENT_NAME_PREFIX));
	}
	
	exports.isNameSpecified = isNameSpecified;
	
	function isComponentIdInternal(cmptOption) {
	  return cmptOption && cmptOption.id != null && makeComparableKey(cmptOption.id).indexOf(INTERNAL_COMPONENT_ID_PREFIX) === 0;
	}
	
	exports.isComponentIdInternal = isComponentIdInternal;
	
	function makeInternalComponentId(idSuffix) {
	  return INTERNAL_COMPONENT_ID_PREFIX + idSuffix;
	}
	
	exports.makeInternalComponentId = makeInternalComponentId;
	
	function setComponentTypeToKeyInfo(mappingResult, mainType, componentModelCtor) {
	  util_1.each(mappingResult, function (item) {
	    var newOption = item.newOption;
	
	    if (util_1.isObject(newOption)) {
	      item.keyInfo.mainType = mainType;
	      item.keyInfo.subType = determineSubType(mainType, newOption, item.existing, componentModelCtor);
	    }
	  });
	}
	
	exports.setComponentTypeToKeyInfo = setComponentTypeToKeyInfo;
	
	function determineSubType(mainType, newCmptOption, existComponent, componentModelCtor) {
	  var subType = newCmptOption.type ? newCmptOption.type : existComponent ? existComponent.subType : componentModelCtor.determineSubType(mainType, newCmptOption);
	  return subType;
	}
	
	function compressBatches(batchA, batchB) {
	  var mapA = {};
	  var mapB = {};
	  makeMap(batchA || [], mapA);
	  makeMap(batchB || [], mapB, mapA);
	  return [mapToArray(mapA), mapToArray(mapB)];
	
	  function makeMap(sourceBatch, map, otherMap) {
	    for (var i = 0, len = sourceBatch.length; i < len; i++) {
	      var seriesId = convertOptionIdName(sourceBatch[i].seriesId, null);
	
	      if (seriesId == null) {
	        return;
	      }
	
	      var dataIndices = normalizeToArray(sourceBatch[i].dataIndex);
	      var otherDataIndices = otherMap && otherMap[seriesId];
	
	      for (var j = 0, lenj = dataIndices.length; j < lenj; j++) {
	        var dataIndex = dataIndices[j];
	
	        if (otherDataIndices && otherDataIndices[dataIndex]) {
	          otherDataIndices[dataIndex] = null;
	        } else {
	          (map[seriesId] || (map[seriesId] = {}))[dataIndex] = 1;
	        }
	      }
	    }
	  }
	
	  function mapToArray(map, isData) {
	    var result = [];
	
	    for (var i in map) {
	      if (map.hasOwnProperty(i) && map[i] != null) {
	        if (isData) {
	          result.push(+i);
	        } else {
	          var dataIndices = mapToArray(map[i], true);
	          dataIndices.length && result.push({
	            seriesId: i,
	            dataIndex: dataIndices
	          });
	        }
	      }
	    }
	
	    return result;
	  }
	}
	
	exports.compressBatches = compressBatches;
	
	function queryDataIndex(data, payload) {
	  if (payload.dataIndexInside != null) {
	    return payload.dataIndexInside;
	  } else if (payload.dataIndex != null) {
	    return util_1.isArray(payload.dataIndex) ? util_1.map(payload.dataIndex, function (value) {
	      return data.indexOfRawIndex(value);
	    }) : data.indexOfRawIndex(payload.dataIndex);
	  } else if (payload.name != null) {
	    return util_1.isArray(payload.name) ? util_1.map(payload.name, function (value) {
	      return data.indexOfName(value);
	    }) : data.indexOfName(payload.name);
	  }
	}
	
	exports.queryDataIndex = queryDataIndex;
	
	function makeInner() {
	  var key = '__ec_inner_' + innerUniqueIndex++;
	  return function (hostObj) {
	    return hostObj[key] || (hostObj[key] = {});
	  };
	}
	
	exports.makeInner = makeInner;
	var innerUniqueIndex = number_1.getRandomIdBase();
	
	function parseFinder(ecModel, finderInput, opt) {
	  var finder;
	
	  if (util_1.isString(finderInput)) {
	    var obj = {};
	    obj[finderInput + 'Index'] = 0;
	    finder = obj;
	  } else {
	    finder = finderInput;
	  }
	
	  var queryOptionMap = util_1.createHashMap();
	  var result = {};
	  var mainTypeSpecified = false;
	  util_1.each(finder, function (value, key) {
	    if (key === 'dataIndex' || key === 'dataIndexInside') {
	      result[key] = value;
	      return;
	    }
	
	    var parsedKey = key.match(/^(\w+)(Index|Id|Name)$/) || [];
	    var mainType = parsedKey[1];
	    var queryType = (parsedKey[2] || '').toLowerCase();
	
	    if (!mainType || !queryType || opt && opt.includeMainTypes && util_1.indexOf(opt.includeMainTypes, mainType) < 0) {
	      return;
	    }
	
	    mainTypeSpecified = mainTypeSpecified || !!mainType;
	    var queryOption = queryOptionMap.get(mainType) || queryOptionMap.set(mainType, {});
	    queryOption[queryType] = value;
	  });
	  var defaultMainType = opt ? opt.defaultMainType : null;
	
	  if (!mainTypeSpecified && defaultMainType) {
	    queryOptionMap.set(defaultMainType, {});
	  }
	
	  queryOptionMap.each(function (queryOption, mainType) {
	    var queryResult = queryReferringComponents(ecModel, mainType, queryOption, {
	      useDefault: defaultMainType === mainType,
	      enableAll: opt && opt.enableAll != null ? opt.enableAll : true,
	      enableNone: opt && opt.enableNone != null ? opt.enableNone : true
	    });
	    result[mainType + 'Models'] = queryResult.models;
	    result[mainType + 'Model'] = queryResult.models[0];
	  });
	  return result;
	}
	
	exports.parseFinder = parseFinder;
	exports.SINGLE_REFERRING = {
	  useDefault: true,
	  enableAll: false,
	  enableNone: false
	};
	exports.MULTIPLE_REFERRING = {
	  useDefault: false,
	  enableAll: true,
	  enableNone: true
	};
	
	function queryReferringComponents(ecModel, mainType, userOption, opt) {
	  opt = opt || exports.SINGLE_REFERRING;
	  var indexOption = userOption.index;
	  var idOption = userOption.id;
	  var nameOption = userOption.name;
	  var result = {
	    models: null,
	    specified: indexOption != null || idOption != null || nameOption != null
	  };
	
	  if (!result.specified) {
	    var firstCmpt = void 0;
	    result.models = opt.useDefault && (firstCmpt = ecModel.getComponent(mainType)) ? [firstCmpt] : [];
	    return result;
	  }
	
	  if (indexOption === 'none' || indexOption === false) {
	    util_1.assert(opt.enableNone, '`"none"` or `false` is not a valid value on index option.');
	    result.models = [];
	    return result;
	  }
	
	  if (indexOption === 'all') {
	    util_1.assert(opt.enableAll, '`"all"` is not a valid value on index option.');
	    indexOption = idOption = nameOption = null;
	  }
	
	  result.models = ecModel.queryComponents({
	    mainType: mainType,
	    index: indexOption,
	    id: idOption,
	    name: nameOption
	  });
	  return result;
	}
	
	exports.queryReferringComponents = queryReferringComponents;
	
	function setAttribute(dom, key, value) {
	  dom.setAttribute ? dom.setAttribute(key, value) : dom[key] = value;
	}
	
	exports.setAttribute = setAttribute;
	
	function getAttribute(dom, key) {
	  return dom.getAttribute ? dom.getAttribute(key) : dom[key];
	}
	
	exports.getAttribute = getAttribute;
	
	function getTooltipRenderMode(renderModeOption) {
	  if (renderModeOption === 'auto') {
	    return env_1["default"].domSupported ? 'html' : 'richText';
	  } else {
	    return renderModeOption || 'html';
	  }
	}
	
	exports.getTooltipRenderMode = getTooltipRenderMode;
	
	function groupData(array, getKey) {
	  var buckets = util_1.createHashMap();
	  var keys = [];
	  util_1.each(array, function (item) {
	    var key = getKey(item);
	    (buckets.get(key) || (keys.push(key), buckets.set(key, []))).push(item);
	  });
	  return {
	    keys: keys,
	    buckets: buckets
	  };
	}
	
	exports.groupData = groupData;
	
	function interpolateRawValues(data, precision, sourceValue, targetValue, percent) {
	  var isAutoPrecision = precision == null || precision === 'auto';
	
	  if (targetValue == null) {
	    return targetValue;
	  }
	
	  if (typeof targetValue === 'number') {
	    var value = Animator_1.interpolateNumber(sourceValue || 0, targetValue, percent);
	    return number_1.round(value, isAutoPrecision ? Math.max(number_1.getPrecisionSafe(sourceValue || 0), number_1.getPrecisionSafe(targetValue)) : precision);
	  } else if (typeof targetValue === 'string') {
	    return percent < 1 ? sourceValue : targetValue;
	  } else {
	    var interpolated = [];
	    var leftArr = sourceValue || [];
	    var rightArr = targetValue;
	    var length_1 = Math.max(leftArr.length, rightArr.length);
	
	    for (var i = 0; i < length_1; ++i) {
	      var info = data.getDimensionInfo(i);
	
	      if (info.type === 'ordinal') {
	        interpolated[i] = (percent < 1 ? leftArr : rightArr)[i];
	      } else {
	        var leftVal = leftArr && leftArr[i] ? leftArr[i] : 0;
	        var rightVal = rightArr[i];
	        var value = leftArr == null ? targetValue[i] : Animator_1.interpolateNumber(leftVal, rightVal, percent);
	        interpolated[i] = number_1.round(value, isAutoPrecision ? Math.max(number_1.getPrecisionSafe(leftVal), number_1.getPrecisionSafe(rightVal)) : precision);
	      }
	    }
	
	    return interpolated;
	  }
	}
	
	exports.interpolateRawValues = interpolateRawValues;

/***/ },
/* 5 */
3,
/* 6 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(global) {
	/*
	* Licensed to the Apache Software Foundation (ASF) under one
	* or more contributor license agreements.  See the NOTICE file
	* distributed with this work for additional information
	* regarding copyright ownership.  The ASF licenses this file
	* to you under the Apache License, Version 2.0 (the
	* "License"); you may not use this file except in compliance
	* with the License.  You may obtain a copy of the License at
	*
	*   http://www.apache.org/licenses/LICENSE-2.0
	*
	* Unless required by applicable law or agreed to in writing,
	* software distributed under the License is distributed on an
	* "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
	* KIND, either express or implied.  See the License for the
	* specific language governing permissions and limitations
	* under the License.
	*/
	
	
	
	/**
	 * AUTO-GENERATED FILE. DO NOT MODIFY.
	 */
	
	"use strict";
	
	var tslib_1 = __webpack_require__(3);
	
	var zrender = __webpack_require__(195);
	
	var zrUtil = __webpack_require__(1);
	
	var colorTool = __webpack_require__(34);
	
	var env_1 = __webpack_require__(13);
	
	var timsort_1 = __webpack_require__(182);
	
	var Eventful_1 = __webpack_require__(37);
	
	var Global_1 = __webpack_require__(150);
	
	var ExtensionAPI_1 = __webpack_require__(126);
	
	var CoordinateSystem_1 = __webpack_require__(81);
	
	var OptionManager_1 = __webpack_require__(358);
	
	var backwardCompat_1 = __webpack_require__(364);
	
	var dataStack_1 = __webpack_require__(366);
	
	var Component_1 = __webpack_require__(10);
	
	var Series_1 = __webpack_require__(68);
	
	var Component_2 = __webpack_require__(18);
	
	var Chart_1 = __webpack_require__(96);
	
	var graphic = __webpack_require__(7);
	
	var innerStore_1 = __webpack_require__(21);
	
	var states_1 = __webpack_require__(22);
	
	var modelUtil = __webpack_require__(4);
	
	var throttle_1 = __webpack_require__(56);
	
	var style_1 = __webpack_require__(377);
	
	var default_1 = __webpack_require__(357);
	
	var Scheduler_1 = __webpack_require__(370);
	
	var light_1 = __webpack_require__(372);
	
	var dark_1 = __webpack_require__(371);
	
	__webpack_require__(316);
	
	var mapDataStorage_1 = __webpack_require__(345);
	
	var clazz_1 = __webpack_require__(28);
	
	var ECEventProcessor_1 = __webpack_require__(373);
	
	var symbol_1 = __webpack_require__(378);
	
	var helper_1 = __webpack_require__(156);
	
	var LabelManager_1 = __webpack_require__(351);
	
	var log_1 = __webpack_require__(12);
	
	var dataSelectAction_1 = __webpack_require__(355);
	
	__webpack_require__(449);
	
	var transform_1 = __webpack_require__(148);
	
	var locale_1 = __webpack_require__(90);
	
	var event_1 = __webpack_require__(155);
	
	var decal_1 = __webpack_require__(376);
	
	var assert = zrUtil.assert;
	var each = zrUtil.each;
	var isFunction = zrUtil.isFunction;
	var isObject = zrUtil.isObject;
	exports.version = '5.0.0';
	exports.dependencies = {
	  zrender: '5.0.1'
	};
	var TEST_FRAME_REMAIN_TIME = 1;
	var PRIORITY_PROCESSOR_SERIES_FILTER = 800;
	var PRIORITY_PROCESSOR_DATASTACK = 900;
	var PRIORITY_PROCESSOR_FILTER = 1000;
	var PRIORITY_PROCESSOR_DEFAULT = 2000;
	var PRIORITY_PROCESSOR_STATISTIC = 5000;
	var PRIORITY_VISUAL_LAYOUT = 1000;
	var PRIORITY_VISUAL_PROGRESSIVE_LAYOUT = 1100;
	var PRIORITY_VISUAL_GLOBAL = 2000;
	var PRIORITY_VISUAL_CHART = 3000;
	var PRIORITY_VISUAL_COMPONENT = 4000;
	var PRIORITY_VISUAL_CHART_DATA_CUSTOM = 4500;
	var PRIORITY_VISUAL_POST_CHART_LAYOUT = 4600;
	var PRIORITY_VISUAL_BRUSH = 5000;
	var PRIORITY_VISUAL_ARIA = 6000;
	var PRIORITY_VISUAL_DECAL = 7000;
	exports.PRIORITY = {
	  PROCESSOR: {
	    FILTER: PRIORITY_PROCESSOR_FILTER,
	    SERIES_FILTER: PRIORITY_PROCESSOR_SERIES_FILTER,
	    STATISTIC: PRIORITY_PROCESSOR_STATISTIC
	  },
	  VISUAL: {
	    LAYOUT: PRIORITY_VISUAL_LAYOUT,
	    PROGRESSIVE_LAYOUT: PRIORITY_VISUAL_PROGRESSIVE_LAYOUT,
	    GLOBAL: PRIORITY_VISUAL_GLOBAL,
	    CHART: PRIORITY_VISUAL_CHART,
	    POST_CHART_LAYOUT: PRIORITY_VISUAL_POST_CHART_LAYOUT,
	    COMPONENT: PRIORITY_VISUAL_COMPONENT,
	    BRUSH: PRIORITY_VISUAL_BRUSH,
	    CHART_ITEM: PRIORITY_VISUAL_CHART_DATA_CUSTOM,
	    ARIA: PRIORITY_VISUAL_ARIA,
	    DECAL: PRIORITY_VISUAL_DECAL
	  }
	};
	var IN_MAIN_PROCESS_KEY = '__flagInMainProcess';
	var OPTION_UPDATED_KEY = '__optionUpdated';
	var STATUS_NEEDS_UPDATE_KEY = '__needsUpdateStatus';
	var ACTION_REG = /^[a-zA-Z0-9_]+$/;
	var CONNECT_STATUS_KEY = '__connectUpdateStatus';
	var CONNECT_STATUS_PENDING = 0;
	var CONNECT_STATUS_UPDATING = 1;
	var CONNECT_STATUS_UPDATED = 2;
	;
	
	function createRegisterEventWithLowercaseECharts(method) {
	  return function () {
	    var args = [];
	
	    for (var _i = 0; _i < arguments.length; _i++) {
	      args[_i] = arguments[_i];
	    }
	
	    if (this.isDisposed()) {
	      disposedWarning(this.id);
	      return;
	    }
	
	    return toLowercaseNameAndCallEventful(this, method, args);
	  };
	}
	
	function createRegisterEventWithLowercaseMessageCenter(method) {
	  return function () {
	    var args = [];
	
	    for (var _i = 0; _i < arguments.length; _i++) {
	      args[_i] = arguments[_i];
	    }
	
	    return toLowercaseNameAndCallEventful(this, method, args);
	  };
	}
	
	function toLowercaseNameAndCallEventful(host, method, args) {
	  args[0] = args[0] && args[0].toLowerCase();
	  return Eventful_1["default"].prototype[method].apply(host, args);
	}
	
	var MessageCenter = function (_super) {
	  tslib_1.__extends(MessageCenter, _super);
	
	  function MessageCenter() {
	    return _super !== null && _super.apply(this, arguments) || this;
	  }
	
	  return MessageCenter;
	}(Eventful_1["default"]);
	
	var messageCenterProto = MessageCenter.prototype;
	messageCenterProto.on = createRegisterEventWithLowercaseMessageCenter('on');
	messageCenterProto.off = createRegisterEventWithLowercaseMessageCenter('off');
	var prepare;
	var prepareView;
	var updateDirectly;
	var updateMethods;
	var doConvertPixel;
	var updateStreamModes;
	var doDispatchAction;
	var flushPendingActions;
	var triggerUpdatedEvent;
	var bindRenderedEvent;
	var bindMouseEvent;
	var clearColorPalette;
	var render;
	var renderComponents;
	var renderSeries;
	var performPostUpdateFuncs;
	var createExtensionAPI;
	var enableConnect;
	var setTransitionOpt;
	var markStatusToUpdate;
	var applyChangedStates;
	
	var ECharts = function (_super) {
	  tslib_1.__extends(ECharts, _super);
	
	  function ECharts(dom, theme, opts) {
	    var _this = _super.call(this, new ECEventProcessor_1.ECEventProcessor()) || this;
	
	    _this._chartsViews = [];
	    _this._chartsMap = {};
	    _this._componentsViews = [];
	    _this._componentsMap = {};
	    _this._pendingActions = [];
	    opts = opts || {};
	
	    if (typeof theme === 'string') {
	      theme = themeStorage[theme];
	    }
	
	    _this._dom = dom;
	    var root = typeof window === 'undefined' ? global : window;
	    var defaultRenderer = 'canvas';
	    var defaultUseDirtyRect = false;
	
	    if (false) {
	      defaultRenderer = root.__ECHARTS__DEFAULT__RENDERER__ || defaultRenderer;
	      var devUseDirtyRect = root.__ECHARTS__DEFAULT__USE_DIRTY_RECT__;
	      defaultUseDirtyRect = devUseDirtyRect == null ? defaultUseDirtyRect : devUseDirtyRect;
	    }
	
	    var zr = _this._zr = zrender.init(dom, {
	      renderer: opts.renderer || defaultRenderer,
	      devicePixelRatio: opts.devicePixelRatio,
	      width: opts.width,
	      height: opts.height,
	      useDirtyRect: opts.useDirtyRect == null ? defaultUseDirtyRect : opts.useDirtyRect
	    });
	    _this._throttledZrFlush = throttle_1.throttle(zrUtil.bind(zr.flush, zr), 17);
	    theme = zrUtil.clone(theme);
	    theme && backwardCompat_1["default"](theme, true);
	    _this._theme = theme;
	    _this._locale = locale_1.createLocaleObject(opts.locale || locale_1.SYSTEM_LANG);
	    _this._coordSysMgr = new CoordinateSystem_1["default"]();
	    var api = _this._api = createExtensionAPI(_this);
	
	    function prioritySortFunc(a, b) {
	      return a.__prio - b.__prio;
	    }
	
	    timsort_1["default"](visualFuncs, prioritySortFunc);
	    timsort_1["default"](dataProcessorFuncs, prioritySortFunc);
	    _this._scheduler = new Scheduler_1["default"](_this, api, dataProcessorFuncs, visualFuncs);
	    _this._messageCenter = new MessageCenter();
	    _this._labelManager = new LabelManager_1["default"]();
	
	    _this._initEvents();
	
	    _this.resize = zrUtil.bind(_this.resize, _this);
	    zr.animation.on('frame', _this._onframe, _this);
	    bindRenderedEvent(zr, _this);
	    bindMouseEvent(zr, _this);
	    zrUtil.setAsPrimitive(_this);
	    return _this;
	  }
	
	  ECharts.prototype._onframe = function () {
	    if (this._disposed) {
	      return;
	    }
	
	    applyChangedStates(this);
	    var scheduler = this._scheduler;
	
	    if (this[OPTION_UPDATED_KEY]) {
	      var silent = this[OPTION_UPDATED_KEY].silent;
	      this[IN_MAIN_PROCESS_KEY] = true;
	      prepare(this);
	      updateMethods.update.call(this);
	
	      this._zr.flush();
	
	      this[IN_MAIN_PROCESS_KEY] = false;
	      this[OPTION_UPDATED_KEY] = false;
	      flushPendingActions.call(this, silent);
	      triggerUpdatedEvent.call(this, silent);
	    } else if (scheduler.unfinished) {
	      var remainTime = TEST_FRAME_REMAIN_TIME;
	      var ecModel = this._model;
	      var api = this._api;
	      scheduler.unfinished = false;
	
	      do {
	        var startTime = +new Date();
	        scheduler.performSeriesTasks(ecModel);
	        scheduler.performDataProcessorTasks(ecModel);
	        updateStreamModes(this, ecModel);
	        scheduler.performVisualTasks(ecModel);
	        renderSeries(this, this._model, api, 'remain');
	        remainTime -= +new Date() - startTime;
	      } while (remainTime > 0 && scheduler.unfinished);
	
	      if (!scheduler.unfinished) {
	        this._zr.flush();
	      }
	    }
	  };
	
	  ECharts.prototype.getDom = function () {
	    return this._dom;
	  };
	
	  ECharts.prototype.getId = function () {
	    return this.id;
	  };
	
	  ECharts.prototype.getZr = function () {
	    return this._zr;
	  };
	
	  ECharts.prototype.setOption = function (option, notMerge, lazyUpdate) {
	    if (false) {
	      assert(!this[IN_MAIN_PROCESS_KEY], '`setOption` should not be called during main process.');
	    }
	
	    if (this._disposed) {
	      disposedWarning(this.id);
	      return;
	    }
	
	    var silent;
	    var replaceMerge;
	    var transitionOpt;
	
	    if (isObject(notMerge)) {
	      lazyUpdate = notMerge.lazyUpdate;
	      silent = notMerge.silent;
	      replaceMerge = notMerge.replaceMerge;
	      transitionOpt = notMerge.transition;
	      notMerge = notMerge.notMerge;
	    }
	
	    this[IN_MAIN_PROCESS_KEY] = true;
	
	    if (!this._model || notMerge) {
	      var optionManager = new OptionManager_1["default"](this._api);
	      var theme = this._theme;
	      var ecModel = this._model = new Global_1["default"]();
	      ecModel.scheduler = this._scheduler;
	      ecModel.init(null, null, null, theme, this._locale, optionManager);
	    }
	
	    this._model.setOption(option, {
	      replaceMerge: replaceMerge
	    }, optionPreprocessorFuncs);
	
	    setTransitionOpt(this, transitionOpt);
	
	    if (lazyUpdate) {
	      this[OPTION_UPDATED_KEY] = {
	        silent: silent
	      };
	      this[IN_MAIN_PROCESS_KEY] = false;
	      this.getZr().wakeUp();
	    } else {
	      prepare(this);
	      updateMethods.update.call(this);
	
	      this._zr.flush();
	
	      this[OPTION_UPDATED_KEY] = false;
	      this[IN_MAIN_PROCESS_KEY] = false;
	      flushPendingActions.call(this, silent);
	      triggerUpdatedEvent.call(this, silent);
	    }
	  };
	
	  ECharts.prototype.setTheme = function () {
	    console.error('ECharts#setTheme() is DEPRECATED in ECharts 3.0');
	  };
	
	  ECharts.prototype.getModel = function () {
	    return this._model;
	  };
	
	  ECharts.prototype.getOption = function () {
	    return this._model && this._model.getOption();
	  };
	
	  ECharts.prototype.getWidth = function () {
	    return this._zr.getWidth();
	  };
	
	  ECharts.prototype.getHeight = function () {
	    return this._zr.getHeight();
	  };
	
	  ECharts.prototype.getDevicePixelRatio = function () {
	    return this._zr.painter.dpr || window.devicePixelRatio || 1;
	  };
	
	  ECharts.prototype.getRenderedCanvas = function (opts) {
	    if (!env_1["default"].canvasSupported) {
	      return;
	    }
	
	    opts = zrUtil.extend({}, opts || {});
	    opts.pixelRatio = opts.pixelRatio || 1;
	    opts.backgroundColor = opts.backgroundColor || this._model.get('backgroundColor');
	    var zr = this._zr;
	    return zr.painter.getRenderedCanvas(opts);
	  };
	
	  ECharts.prototype.getSvgDataURL = function () {
	    if (!env_1["default"].svgSupported) {
	      return;
	    }
	
	    var zr = this._zr;
	    var list = zr.storage.getDisplayList();
	    zrUtil.each(list, function (el) {
	      el.stopAnimation(null, true);
	    });
	    return zr.painter.toDataURL();
	  };
	
	  ECharts.prototype.getDataURL = function (opts) {
	    if (this._disposed) {
	      disposedWarning(this.id);
	      return;
	    }
	
	    opts = opts || {};
	    var excludeComponents = opts.excludeComponents;
	    var ecModel = this._model;
	    var excludesComponentViews = [];
	    var self = this;
	    each(excludeComponents, function (componentType) {
	      ecModel.eachComponent({
	        mainType: componentType
	      }, function (component) {
	        var view = self._componentsMap[component.__viewId];
	
	        if (!view.group.ignore) {
	          excludesComponentViews.push(view);
	          view.group.ignore = true;
	        }
	      });
	    });
	    var url = this._zr.painter.getType() === 'svg' ? this.getSvgDataURL() : this.getRenderedCanvas(opts).toDataURL('image/' + (opts && opts.type || 'png'));
	    each(excludesComponentViews, function (view) {
	      view.group.ignore = false;
	    });
	    return url;
	  };
	
	  ECharts.prototype.getConnectedDataURL = function (opts) {
	    if (this._disposed) {
	      disposedWarning(this.id);
	      return;
	    }
	
	    if (!env_1["default"].canvasSupported) {
	      return;
	    }
	
	    var isSvg = opts.type === 'svg';
	    var groupId = this.group;
	    var mathMin = Math.min;
	    var mathMax = Math.max;
	    var MAX_NUMBER = Infinity;
	
	    if (connectedGroups[groupId]) {
	      var left_1 = MAX_NUMBER;
	      var top_1 = MAX_NUMBER;
	      var right_1 = -MAX_NUMBER;
	      var bottom_1 = -MAX_NUMBER;
	      var canvasList_1 = [];
	      var dpr_1 = opts && opts.pixelRatio || 1;
	      zrUtil.each(instances, function (chart, id) {
	        if (chart.group === groupId) {
	          var canvas = isSvg ? chart.getZr().painter.getSvgDom().innerHTML : chart.getRenderedCanvas(zrUtil.clone(opts));
	          var boundingRect = chart.getDom().getBoundingClientRect();
	          left_1 = mathMin(boundingRect.left, left_1);
	          top_1 = mathMin(boundingRect.top, top_1);
	          right_1 = mathMax(boundingRect.right, right_1);
	          bottom_1 = mathMax(boundingRect.bottom, bottom_1);
	          canvasList_1.push({
	            dom: canvas,
	            left: boundingRect.left,
	            top: boundingRect.top
	          });
	        }
	      });
	      left_1 *= dpr_1;
	      top_1 *= dpr_1;
	      right_1 *= dpr_1;
	      bottom_1 *= dpr_1;
	      var width = right_1 - left_1;
	      var height = bottom_1 - top_1;
	      var targetCanvas = zrUtil.createCanvas();
	      var zr_1 = zrender.init(targetCanvas, {
	        renderer: isSvg ? 'svg' : 'canvas'
	      });
	      zr_1.resize({
	        width: width,
	        height: height
	      });
	
	      if (isSvg) {
	        var content_1 = '';
	        each(canvasList_1, function (item) {
	          var x = item.left - left_1;
	          var y = item.top - top_1;
	          content_1 += '<g transform="translate(' + x + ',' + y + ')">' + item.dom + '</g>';
	        });
	        zr_1.painter.getSvgRoot().innerHTML = content_1;
	
	        if (opts.connectedBackgroundColor) {
	          zr_1.painter.setBackgroundColor(opts.connectedBackgroundColor);
	        }
	
	        zr_1.refreshImmediately();
	        return zr_1.painter.toDataURL();
	      } else {
	        if (opts.connectedBackgroundColor) {
	          zr_1.add(new graphic.Rect({
	            shape: {
	              x: 0,
	              y: 0,
	              width: width,
	              height: height
	            },
	            style: {
	              fill: opts.connectedBackgroundColor
	            }
	          }));
	        }
	
	        each(canvasList_1, function (item) {
	          var img = new graphic.Image({
	            style: {
	              x: item.left * dpr_1 - left_1,
	              y: item.top * dpr_1 - top_1,
	              image: item.dom
	            }
	          });
	          zr_1.add(img);
	        });
	        zr_1.refreshImmediately();
	        return targetCanvas.toDataURL('image/' + (opts && opts.type || 'png'));
	      }
	    } else {
	      return this.getDataURL(opts);
	    }
	  };
	
	  ECharts.prototype.convertToPixel = function (finder, value) {
	    return doConvertPixel(this, 'convertToPixel', finder, value);
	  };
	
	  ECharts.prototype.convertFromPixel = function (finder, value) {
	    return doConvertPixel(this, 'convertFromPixel', finder, value);
	  };
	
	  ECharts.prototype.containPixel = function (finder, value) {
	    if (this._disposed) {
	      disposedWarning(this.id);
	      return;
	    }
	
	    var ecModel = this._model;
	    var result;
	    var findResult = modelUtil.parseFinder(ecModel, finder);
	    zrUtil.each(findResult, function (models, key) {
	      key.indexOf('Models') >= 0 && zrUtil.each(models, function (model) {
	        var coordSys = model.coordinateSystem;
	
	        if (coordSys && coordSys.containPoint) {
	          result = result || !!coordSys.containPoint(value);
	        } else if (key === 'seriesModels') {
	          var view = this._chartsMap[model.__viewId];
	
	          if (view && view.containPoint) {
	            result = result || view.containPoint(value, model);
	          } else {
	            if (false) {
	              console.warn(key + ': ' + (view ? 'The found component do not support containPoint.' : 'No view mapping to the found component.'));
	            }
	          }
	        } else {
	          if (false) {
	            console.warn(key + ': containPoint is not supported');
	          }
	        }
	      }, this);
	    }, this);
	    return !!result;
	  };
	
	  ECharts.prototype.getVisual = function (finder, visualType) {
	    var ecModel = this._model;
	    var parsedFinder = modelUtil.parseFinder(ecModel, finder, {
	      defaultMainType: 'series'
	    });
	    var seriesModel = parsedFinder.seriesModel;
	
	    if (false) {
	      if (!seriesModel) {
	        console.warn('There is no specified seires model');
	      }
	    }
	
	    var data = seriesModel.getData();
	    var dataIndexInside = parsedFinder.hasOwnProperty('dataIndexInside') ? parsedFinder.dataIndexInside : parsedFinder.hasOwnProperty('dataIndex') ? data.indexOfRawIndex(parsedFinder.dataIndex) : null;
	    return dataIndexInside != null ? helper_1.getItemVisualFromData(data, dataIndexInside, visualType) : helper_1.getVisualFromData(data, visualType);
	  };
	
	  ECharts.prototype.getViewOfComponentModel = function (componentModel) {
	    return this._componentsMap[componentModel.__viewId];
	  };
	
	  ECharts.prototype.getViewOfSeriesModel = function (seriesModel) {
	    return this._chartsMap[seriesModel.__viewId];
	  };
	
	  ECharts.prototype._initEvents = function () {
	    var _this = this;
	
	    each(MOUSE_EVENT_NAMES, function (eveName) {
	      var handler = function (e) {
	        var ecModel = _this.getModel();
	
	        var el = e.target;
	        var params;
	        var isGlobalOut = eveName === 'globalout';
	
	        if (isGlobalOut) {
	          params = {};
	        } else {
	          el && event_1.findEventDispatcher(el, function (parent) {
	            var ecData = innerStore_1.getECData(parent);
	
	            if (ecData && ecData.dataIndex != null) {
	              var dataModel = ecData.dataModel || ecModel.getSeriesByIndex(ecData.seriesIndex);
	              params = dataModel && dataModel.getDataParams(ecData.dataIndex, ecData.dataType) || {};
	              return true;
	            } else if (ecData.eventData) {
	              params = zrUtil.extend({}, ecData.eventData);
	              return true;
	            }
	          }, true);
	        }
	
	        if (params) {
	          var componentType = params.componentType;
	          var componentIndex = params.componentIndex;
	
	          if (componentType === 'markLine' || componentType === 'markPoint' || componentType === 'markArea') {
	            componentType = 'series';
	            componentIndex = params.seriesIndex;
	          }
	
	          var model = componentType && componentIndex != null && ecModel.getComponent(componentType, componentIndex);
	          var view = model && _this[model.mainType === 'series' ? '_chartsMap' : '_componentsMap'][model.__viewId];
	
	          if (false) {
	            if (!isGlobalOut && !(model && view)) {
	              console.warn('model or view can not be found by params');
	            }
	          }
	
	          params.event = e;
	          params.type = eveName;
	          _this._$eventProcessor.eventInfo = {
	            targetEl: el,
	            packedEvent: params,
	            model: model,
	            view: view
	          };
	
	          _this.trigger(eveName, params);
	        }
	      };
	
	      handler.zrEventfulCallAtLast = true;
	
	      _this._zr.on(eveName, handler, _this);
	    });
	    each(eventActionMap, function (actionType, eventType) {
	      _this._messageCenter.on(eventType, function (event) {
	        this.trigger(eventType, event);
	      }, _this);
	    });
	    each(['selectchanged'], function (eventType) {
	      _this._messageCenter.on(eventType, function (event) {
	        this.trigger(eventType, event);
	      }, _this);
	    });
	    dataSelectAction_1.handleLegacySelectEvents(this._messageCenter, this, this._model);
	  };
	
	  ECharts.prototype.isDisposed = function () {
	    return this._disposed;
	  };
	
	  ECharts.prototype.clear = function () {
	    if (this._disposed) {
	      disposedWarning(this.id);
	      return;
	    }
	
	    this.setOption({
	      series: []
	    }, true);
	  };
	
	  ECharts.prototype.dispose = function () {
	    if (this._disposed) {
	      disposedWarning(this.id);
	      return;
	    }
	
	    this._disposed = true;
	    modelUtil.setAttribute(this.getDom(), DOM_ATTRIBUTE_KEY, '');
	    var api = this._api;
	    var ecModel = this._model;
	    each(this._componentsViews, function (component) {
	      component.dispose(ecModel, api);
	    });
	    each(this._chartsViews, function (chart) {
	      chart.dispose(ecModel, api);
	    });
	
	    this._zr.dispose();
	
	    delete instances[this.id];
	  };
	
	  ECharts.prototype.resize = function (opts) {
	    if (false) {
	      assert(!this[IN_MAIN_PROCESS_KEY], '`resize` should not be called during main process.');
	    }
	
	    if (this._disposed) {
	      disposedWarning(this.id);
	      return;
	    }
	
	    this._zr.resize(opts);
	
	    var ecModel = this._model;
	    this._loadingFX && this._loadingFX.resize();
	
	    if (!ecModel) {
	      return;
	    }
	
	    var optionChanged = ecModel.resetOption('media');
	    var silent = opts && opts.silent;
	    this[IN_MAIN_PROCESS_KEY] = true;
	    optionChanged && prepare(this);
	    updateMethods.update.call(this, {
	      type: 'resize',
	      animation: {
	        duration: 0
	      }
	    });
	    this[IN_MAIN_PROCESS_KEY] = false;
	    flushPendingActions.call(this, silent);
	    triggerUpdatedEvent.call(this, silent);
	  };
	
	  ECharts.prototype.showLoading = function (name, cfg) {
	    if (this._disposed) {
	      disposedWarning(this.id);
	      return;
	    }
	
	    if (isObject(name)) {
	      cfg = name;
	      name = '';
	    }
	
	    name = name || 'default';
	    this.hideLoading();
	
	    if (!loadingEffects[name]) {
	      if (false) {
	        console.warn('Loading effects ' + name + ' not exists.');
	      }
	
	      return;
	    }
	
	    var el = loadingEffects[name](this._api, cfg);
	    var zr = this._zr;
	    this._loadingFX = el;
	    zr.add(el);
	  };
	
	  ECharts.prototype.hideLoading = function () {
	    if (this._disposed) {
	      disposedWarning(this.id);
	      return;
	    }
	
	    this._loadingFX && this._zr.remove(this._loadingFX);
	    this._loadingFX = null;
	  };
	
	  ECharts.prototype.makeActionFromEvent = function (eventObj) {
	    var payload = zrUtil.extend({}, eventObj);
	    payload.type = eventActionMap[eventObj.type];
	    return payload;
	  };
	
	  ECharts.prototype.dispatchAction = function (payload, opt) {
	    if (this._disposed) {
	      disposedWarning(this.id);
	      return;
	    }
	
	    if (!isObject(opt)) {
	      opt = {
	        silent: !!opt
	      };
	    }
	
	    if (!actions[payload.type]) {
	      return;
	    }
	
	    if (!this._model) {
	      return;
	    }
	
	    if (this[IN_MAIN_PROCESS_KEY]) {
	      this._pendingActions.push(payload);
	
	      return;
	    }
	
	    var silent = opt.silent;
	    doDispatchAction.call(this, payload, silent);
	    var flush = opt.flush;
	
	    if (flush) {
	      this._zr.flush();
	    } else if (flush !== false && env_1["default"].browser.weChat) {
	      this._throttledZrFlush();
	    }
	
	    flushPendingActions.call(this, silent);
	    triggerUpdatedEvent.call(this, silent);
	  };
	
	  ECharts.prototype.updateLabelLayout = function () {
	    var labelManager = this._labelManager;
	    labelManager.updateLayoutConfig(this._api);
	    labelManager.layout(this._api);
	    labelManager.processLabelsOverall();
	  };
	
	  ECharts.prototype.appendData = function (params) {
	    if (this._disposed) {
	      disposedWarning(this.id);
	      return;
	    }
	
	    var seriesIndex = params.seriesIndex;
	    var ecModel = this.getModel();
	    var seriesModel = ecModel.getSeriesByIndex(seriesIndex);
	
	    if (false) {
	      assert(params.data && seriesModel);
	    }
	
	    seriesModel.appendData(params);
	    this._scheduler.unfinished = true;
	    this.getZr().wakeUp();
	  };
	
	  ECharts.internalField = function () {
	    prepare = function (ecIns) {
	      var scheduler = ecIns._scheduler;
	      scheduler.restorePipelines(ecIns._model);
	      scheduler.prepareStageTasks();
	      prepareView(ecIns, true);
	      prepareView(ecIns, false);
	      scheduler.plan();
	    };
	
	    prepareView = function (ecIns, isComponent) {
	      var ecModel = ecIns._model;
	      var scheduler = ecIns._scheduler;
	      var viewList = isComponent ? ecIns._componentsViews : ecIns._chartsViews;
	      var viewMap = isComponent ? ecIns._componentsMap : ecIns._chartsMap;
	      var zr = ecIns._zr;
	      var api = ecIns._api;
	
	      for (var i = 0; i < viewList.length; i++) {
	        viewList[i].__alive = false;
	      }
	
	      isComponent ? ecModel.eachComponent(function (componentType, model) {
	        componentType !== 'series' && doPrepare(model);
	      }) : ecModel.eachSeries(doPrepare);
	
	      function doPrepare(model) {
	        var requireNewView = model.__requireNewView;
	        model.__requireNewView = false;
	        var viewId = '_ec_' + model.id + '_' + model.type;
	        var view = !requireNewView && viewMap[viewId];
	
	        if (!view) {
	          var classType = clazz_1.parseClassType(model.type);
	          var Clazz = isComponent ? Component_2["default"].getClass(classType.main, classType.sub) : Chart_1["default"].getClass(classType.sub);
	
	          if (false) {
	            assert(Clazz, classType.sub + ' does not exist.');
	          }
	
	          view = new Clazz();
	          view.init(ecModel, api);
	          viewMap[viewId] = view;
	          viewList.push(view);
	          zr.add(view.group);
	        }
	
	        model.__viewId = view.__id = viewId;
	        view.__alive = true;
	        view.__model = model;
	        view.group.__ecComponentInfo = {
	          mainType: model.mainType,
	          index: model.componentIndex
	        };
	        !isComponent && scheduler.prepareView(view, model, ecModel, api);
	      }
	
	      for (var i = 0; i < viewList.length;) {
	        var view = viewList[i];
	
	        if (!view.__alive) {
	          !isComponent && view.renderTask.dispose();
	          zr.remove(view.group);
	          view.dispose(ecModel, api);
	          viewList.splice(i, 1);
	
	          if (viewMap[view.__id] === view) {
	            delete viewMap[view.__id];
	          }
	
	          view.__id = view.group.__ecComponentInfo = null;
	        } else {
	          i++;
	        }
	      }
	    };
	
	    updateDirectly = function (ecIns, method, payload, mainType, subType) {
	      var ecModel = ecIns._model;
	      ecModel.setUpdatePayload(payload);
	
	      if (!mainType) {
	        each([].concat(ecIns._componentsViews).concat(ecIns._chartsViews), callView);
	        return;
	      }
	
	      var query = {};
	      query[mainType + 'Id'] = payload[mainType + 'Id'];
	      query[mainType + 'Index'] = payload[mainType + 'Index'];
	      query[mainType + 'Name'] = payload[mainType + 'Name'];
	      var condition = {
	        mainType: mainType,
	        query: query
	      };
	      subType && (condition.subType = subType);
	      var excludeSeriesId = payload.excludeSeriesId;
	      var excludeSeriesIdMap;
	
	      if (excludeSeriesId != null) {
	        excludeSeriesIdMap = zrUtil.createHashMap();
	        each(modelUtil.normalizeToArray(excludeSeriesId), function (id) {
	          var modelId = modelUtil.convertOptionIdName(id, null);
	
	          if (modelId != null) {
	            excludeSeriesIdMap.set(modelId, true);
	          }
	        });
	      }
	
	      ecModel && ecModel.eachComponent(condition, function (model) {
	        if (!excludeSeriesIdMap || excludeSeriesIdMap.get(model.id) == null) {
	          if (states_1.isHighDownPayload(payload) && !payload.notBlur) {
	            if (model instanceof Series_1["default"]) {
	              states_1.toggleSeriesBlurStateFromPayload(model, payload, ecIns._api);
	            }
	          } else if (states_1.isSelectChangePayload(payload)) {
	            if (model instanceof Series_1["default"]) {
	              states_1.toggleSelectionFromPayload(model, payload, ecIns._api);
	              states_1.updateSeriesElementSelection(model);
	              markStatusToUpdate(ecIns);
	            }
	          }
	
	          callView(ecIns[mainType === 'series' ? '_chartsMap' : '_componentsMap'][model.__viewId]);
	        }
	      }, ecIns);
	
	      function callView(view) {
	        view && view.__alive && view[method] && view[method](view.__model, ecModel, ecIns._api, payload);
	      }
	    };
	
	    updateMethods = {
	      prepareAndUpdate: function (payload) {
	        prepare(this);
	        updateMethods.update.call(this, payload);
	      },
	      update: function (payload) {
	        var ecModel = this._model;
	        var api = this._api;
	        var zr = this._zr;
	        var coordSysMgr = this._coordSysMgr;
	        var scheduler = this._scheduler;
	
	        if (!ecModel) {
	          return;
	        }
	
	        ecModel.setUpdatePayload(payload);
	        scheduler.restoreData(ecModel, payload);
	        scheduler.performSeriesTasks(ecModel);
	        coordSysMgr.create(ecModel, api);
	        scheduler.performDataProcessorTasks(ecModel, payload);
	        updateStreamModes(this, ecModel);
	        coordSysMgr.update(ecModel, api);
	        clearColorPalette(ecModel);
	        scheduler.performVisualTasks(ecModel, payload);
	        render(this, ecModel, api, payload);
	        var backgroundColor = ecModel.get('backgroundColor') || 'transparent';
	        var darkMode = ecModel.get('darkMode');
	
	        if (!env_1["default"].canvasSupported) {
	          var colorArr = colorTool.parse(backgroundColor);
	          backgroundColor = colorTool.stringify(colorArr, 'rgb');
	
	          if (colorArr[3] === 0) {
	            backgroundColor = 'transparent';
	          }
	        } else {
	          zr.setBackgroundColor(backgroundColor);
	
	          if (darkMode != null && darkMode !== 'auto') {
	            zr.setDarkMode(darkMode);
	          }
	        }
	
	        performPostUpdateFuncs(ecModel, api);
	      },
	      updateTransform: function (payload) {
	        var _this = this;
	
	        var ecModel = this._model;
	        var api = this._api;
	
	        if (!ecModel) {
	          return;
	        }
	
	        ecModel.setUpdatePayload(payload);
	        var componentDirtyList = [];
	        ecModel.eachComponent(function (componentType, componentModel) {
	          if (componentType === 'series') {
	            return;
	          }
	
	          var componentView = _this.getViewOfComponentModel(componentModel);
	
	          if (componentView && componentView.__alive) {
	            if (componentView.updateTransform) {
	              var result = componentView.updateTransform(componentModel, ecModel, api, payload);
	              result && result.update && componentDirtyList.push(componentView);
	            } else {
	              componentDirtyList.push(componentView);
	            }
	          }
	        });
	        var seriesDirtyMap = zrUtil.createHashMap();
	        ecModel.eachSeries(function (seriesModel) {
	          var chartView = _this._chartsMap[seriesModel.__viewId];
	
	          if (chartView.updateTransform) {
	            var result = chartView.updateTransform(seriesModel, ecModel, api, payload);
	            result && result.update && seriesDirtyMap.set(seriesModel.uid, 1);
	          } else {
	            seriesDirtyMap.set(seriesModel.uid, 1);
	          }
	        });
	        clearColorPalette(ecModel);
	
	        this._scheduler.performVisualTasks(ecModel, payload, {
	          setDirty: true,
	          dirtyMap: seriesDirtyMap
	        });
	
	        renderSeries(this, ecModel, api, payload, seriesDirtyMap);
	        performPostUpdateFuncs(ecModel, this._api);
	      },
	      updateView: function (payload) {
	        var ecModel = this._model;
	
	        if (!ecModel) {
	          return;
	        }
	
	        ecModel.setUpdatePayload(payload);
	        Chart_1["default"].markUpdateMethod(payload, 'updateView');
	        clearColorPalette(ecModel);
	
	        this._scheduler.performVisualTasks(ecModel, payload, {
	          setDirty: true
	        });
	
	        render(this, this._model, this._api, payload);
	        performPostUpdateFuncs(ecModel, this._api);
	      },
	      updateVisual: function (payload) {
	        var _this = this;
	
	        var ecModel = this._model;
	
	        if (!ecModel) {
	          return;
	        }
	
	        ecModel.setUpdatePayload(payload);
	        ecModel.eachSeries(function (seriesModel) {
	          seriesModel.getData().clearAllVisual();
	        });
	        Chart_1["default"].markUpdateMethod(payload, 'updateVisual');
	        clearColorPalette(ecModel);
	
	        this._scheduler.performVisualTasks(ecModel, payload, {
	          visualType: 'visual',
	          setDirty: true
	        });
	
	        ecModel.eachComponent(function (componentType, componentModel) {
	          if (componentType !== 'series') {
	            var componentView = _this.getViewOfComponentModel(componentModel);
	
	            componentView && componentView.__alive && componentView.updateVisual(componentModel, ecModel, _this._api, payload);
	          }
	        });
	        ecModel.eachSeries(function (seriesModel) {
	          var chartView = _this._chartsMap[seriesModel.__viewId];
	          chartView.updateVisual(seriesModel, ecModel, _this._api, payload);
	        });
	        performPostUpdateFuncs(ecModel, this._api);
	      },
	      updateLayout: function (payload) {
	        updateMethods.update.call(this, payload);
	      }
	    };
	
	    doConvertPixel = function (ecIns, methodName, finder, value) {
	      if (ecIns._disposed) {
	        disposedWarning(ecIns.id);
	        return;
	      }
	
	      var ecModel = ecIns._model;
	
	      var coordSysList = ecIns._coordSysMgr.getCoordinateSystems();
	
	      var result;
	      var parsedFinder = modelUtil.parseFinder(ecModel, finder);
	
	      for (var i = 0; i < coordSysList.length; i++) {
	        var coordSys = coordSysList[i];
	
	        if (coordSys[methodName] && (result = coordSys[methodName](ecModel, parsedFinder, value)) != null) {
	          return result;
	        }
	      }
	
	      if (false) {
	        console.warn('No coordinate system that supports ' + methodName + ' found by the given finder.');
	      }
	    };
	
	    updateStreamModes = function (ecIns, ecModel) {
	      var chartsMap = ecIns._chartsMap;
	      var scheduler = ecIns._scheduler;
	      ecModel.eachSeries(function (seriesModel) {
	        scheduler.updateStreamModes(seriesModel, chartsMap[seriesModel.__viewId]);
	      });
	    };
	
	    doDispatchAction = function (payload, silent) {
	      var _this = this;
	
	      var ecModel = this.getModel();
	      var payloadType = payload.type;
	      var escapeConnect = payload.escapeConnect;
	      var actionWrap = actions[payloadType];
	      var actionInfo = actionWrap.actionInfo;
	      var cptTypeTmp = (actionInfo.update || 'update').split(':');
	      var updateMethod = cptTypeTmp.pop();
	      var cptType = cptTypeTmp[0] != null && clazz_1.parseClassType(cptTypeTmp[0]);
	      this[IN_MAIN_PROCESS_KEY] = true;
	      var payloads = [payload];
	      var batched = false;
	
	      if (payload.batch) {
	        batched = true;
	        payloads = zrUtil.map(payload.batch, function (item) {
	          item = zrUtil.defaults(zrUtil.extend({}, item), payload);
	          item.batch = null;
	          return item;
	        });
	      }
	
	      var eventObjBatch = [];
	      var eventObj;
	      var isSelectChange = states_1.isSelectChangePayload(payload);
	      var isStatusChange = states_1.isHighDownPayload(payload) || isSelectChange;
	      each(payloads, function (batchItem) {
	        eventObj = actionWrap.action(batchItem, _this._model, _this._api);
	        eventObj = eventObj || zrUtil.extend({}, batchItem);
	        eventObj.type = actionInfo.event || eventObj.type;
	        eventObjBatch.push(eventObj);
	
	        if (isStatusChange) {
	          updateDirectly(_this, updateMethod, batchItem, 'series');
	          markStatusToUpdate(_this);
	        } else if (cptType) {
	          updateDirectly(_this, updateMethod, batchItem, cptType.main, cptType.sub);
	        }
	      });
	
	      if (updateMethod !== 'none' && !isStatusChange && !cptType) {
	        if (this[OPTION_UPDATED_KEY]) {
	          prepare(this);
	          updateMethods.update.call(this, payload);
	          this[OPTION_UPDATED_KEY] = false;
	        } else {
	          updateMethods[updateMethod].call(this, payload);
	        }
	      }
	
	      if (batched) {
	        eventObj = {
	          type: actionInfo.event || payloadType,
	          escapeConnect: escapeConnect,
	          batch: eventObjBatch
	        };
	      } else {
	        eventObj = eventObjBatch[0];
	      }
	
	      this[IN_MAIN_PROCESS_KEY] = false;
	
	      if (!silent) {
	        var messageCenter = this._messageCenter;
	        messageCenter.trigger(eventObj.type, eventObj);
	
	        if (isSelectChange) {
	          var newObj = {
	            type: 'selectchanged',
	            escapeConnect: escapeConnect,
	            selected: states_1.getAllSelectedIndices(ecModel),
	            isFromClick: payload.isFromClick || false,
	            fromAction: payload.type,
	            fromActionPayload: payload
	          };
	          messageCenter.trigger(newObj.type, newObj);
	        }
	      }
	    };
	
	    flushPendingActions = function (silent) {
	      var pendingActions = this._pendingActions;
	
	      while (pendingActions.length) {
	        var payload = pendingActions.shift();
	        doDispatchAction.call(this, payload, silent);
	      }
	    };
	
	    triggerUpdatedEvent = function (silent) {
	      !silent && this.trigger('updated');
	    };
	
	    bindRenderedEvent = function (zr, ecIns) {
	      zr.on('rendered', function (params) {
	        ecIns.trigger('rendered', params);
	
	        if (zr.animation.isFinished() && !ecIns[OPTION_UPDATED_KEY] && !ecIns._scheduler.unfinished && !ecIns._pendingActions.length) {
	          ecIns.trigger('finished');
	        }
	      });
	    };
	
	    bindMouseEvent = function (zr, ecIns) {
	      zr.on('mouseover', function (e) {
	        var el = e.target;
	        var dispatcher = event_1.findEventDispatcher(el, states_1.isHighDownDispatcher);
	
	        if (dispatcher) {
	          var ecData = innerStore_1.getECData(dispatcher);
	          states_1.toggleSeriesBlurState(ecData.seriesIndex, ecData.focus, ecData.blurScope, ecIns._api, true);
	          states_1.enterEmphasisWhenMouseOver(dispatcher, e);
	          markStatusToUpdate(ecIns);
	        }
	      }).on('mouseout', function (e) {
	        var el = e.target;
	        var dispatcher = event_1.findEventDispatcher(el, states_1.isHighDownDispatcher);
	
	        if (dispatcher) {
	          var ecData = innerStore_1.getECData(dispatcher);
	          states_1.toggleSeriesBlurState(ecData.seriesIndex, ecData.focus, ecData.blurScope, ecIns._api, false);
	          states_1.leaveEmphasisWhenMouseOut(dispatcher, e);
	          markStatusToUpdate(ecIns);
	        }
	      }).on('click', function (e) {
	        var el = e.target;
	        var dispatcher = event_1.findEventDispatcher(el, function (target) {
	          return innerStore_1.getECData(target).dataIndex != null;
	        }, true);
	
	        if (dispatcher) {
	          var actionType = dispatcher.selected ? 'unselect' : 'select';
	          var ecData = innerStore_1.getECData(dispatcher);
	
	          ecIns._api.dispatchAction({
	            type: actionType,
	            dataType: ecData.dataType,
	            dataIndexInside: ecData.dataIndex,
	            seriesIndex: ecData.seriesIndex,
	            isFromClick: true
	          });
	        }
	      });
	    };
	
	    clearColorPalette = function (ecModel) {
	      ecModel.clearColorPalette();
	      ecModel.eachSeries(function (seriesModel) {
	        seriesModel.clearColorPalette();
	      });
	    };
	
	    render = function (ecIns, ecModel, api, payload) {
	      renderComponents(ecIns, ecModel, api, payload);
	      each(ecIns._chartsViews, function (chart) {
	        chart.__alive = false;
	      });
	      renderSeries(ecIns, ecModel, api, payload);
	      each(ecIns._chartsViews, function (chart) {
	        if (!chart.__alive) {
	          chart.remove(ecModel, api);
	        }
	      });
	    };
	
	    renderComponents = function (ecIns, ecModel, api, payload, dirtyList) {
	      each(dirtyList || ecIns._componentsViews, function (componentView) {
	        var componentModel = componentView.__model;
	        clearStates(componentModel, componentView);
	        componentView.render(componentModel, ecModel, api, payload);
	        updateZ(componentModel, componentView);
	        updateStates(componentModel, componentView);
	      });
	    };
	
	    renderSeries = function (ecIns, ecModel, api, payload, dirtyMap) {
	      var scheduler = ecIns._scheduler;
	      var labelManager = ecIns._labelManager;
	      labelManager.clearLabels();
	      var unfinished = false;
	      ecModel.eachSeries(function (seriesModel) {
	        var chartView = ecIns._chartsMap[seriesModel.__viewId];
	        chartView.__alive = true;
	        var renderTask = chartView.renderTask;
	        scheduler.updatePayload(renderTask, payload);
	        clearStates(seriesModel, chartView);
	
	        if (dirtyMap && dirtyMap.get(seriesModel.uid)) {
	          renderTask.dirty();
	        }
	
	        if (renderTask.perform(scheduler.getPerformArgs(renderTask))) {
	          unfinished = true;
	        }
	
	        seriesModel.__transientTransitionOpt = null;
	        chartView.group.silent = !!seriesModel.get('silent');
	        updateBlend(seriesModel, chartView);
	        states_1.updateSeriesElementSelection(seriesModel);
	        labelManager.addLabelsOfSeries(chartView);
	      });
	      scheduler.unfinished = unfinished || scheduler.unfinished;
	      labelManager.updateLayoutConfig(api);
	      labelManager.layout(api);
	      labelManager.processLabelsOverall();
	      ecModel.eachSeries(function (seriesModel) {
	        var chartView = ecIns._chartsMap[seriesModel.__viewId];
	        updateZ(seriesModel, chartView);
	        updateStates(seriesModel, chartView);
	      });
	      updateHoverLayerStatus(ecIns, ecModel);
	    };
	
	    performPostUpdateFuncs = function (ecModel, api) {
	      each(postUpdateFuncs, function (func) {
	        func(ecModel, api);
	      });
	    };
	
	    markStatusToUpdate = function (ecIns) {
	      ecIns[STATUS_NEEDS_UPDATE_KEY] = true;
	      ecIns.getZr().wakeUp();
	    };
	
	    applyChangedStates = function (ecIns) {
	      if (!ecIns[STATUS_NEEDS_UPDATE_KEY]) {
	        return;
	      }
	
	      ecIns.getZr().storage.traverse(function (el) {
	        if (graphic.isElementRemoved(el)) {
	          return;
	        }
	
	        applyElementStates(el);
	      });
	      ecIns[STATUS_NEEDS_UPDATE_KEY] = false;
	    };
	
	    function applyElementStates(el) {
	      var newStates = [];
	      var oldStates = el.currentStates;
	
	      for (var i = 0; i < oldStates.length; i++) {
	        var stateName = oldStates[i];
	
	        if (!(stateName === 'emphasis' || stateName === 'blur' || stateName === 'select')) {
	          newStates.push(stateName);
	        }
	      }
	
	      if (el.selected && el.states.select) {
	        newStates.push('select');
	      }
	
	      if (el.hoverState === states_1.HOVER_STATE_EMPHASIS && el.states.emphasis) {
	        newStates.push('emphasis');
	      } else if (el.hoverState === states_1.HOVER_STATE_BLUR && el.states.blur) {
	        newStates.push('blur');
	      }
	
	      el.useStates(newStates);
	    }
	
	    function updateHoverLayerStatus(ecIns, ecModel) {
	      var zr = ecIns._zr;
	      var storage = zr.storage;
	      var elCount = 0;
	      storage.traverse(function (el) {
	        if (!el.isGroup) {
	          elCount++;
	        }
	      });
	
	      if (elCount > ecModel.get('hoverLayerThreshold') && !env_1["default"].node && !env_1["default"].worker) {
	        ecModel.eachSeries(function (seriesModel) {
	          if (seriesModel.preventUsingHoverLayer) {
	            return;
	          }
	
	          var chartView = ecIns._chartsMap[seriesModel.__viewId];
	
	          if (chartView.__alive) {
	            chartView.group.traverse(function (el) {
	              if (el.states.emphasis) {
	                el.states.emphasis.hoverLayer = true;
	              }
	            });
	          }
	        });
	      }
	    }
	
	    ;
	
	    function updateBlend(seriesModel, chartView) {
	      var blendMode = seriesModel.get('blendMode') || null;
	
	      if (false) {
	        if (!env_1["default"].canvasSupported && blendMode && blendMode !== 'source-over') {
	          console.warn('Only canvas support blendMode');
	        }
	      }
	
	      chartView.group.traverse(function (el) {
	        if (!el.isGroup) {
	          el.style.blend = blendMode;
	        }
	
	        if (el.eachPendingDisplayable) {
	          el.eachPendingDisplayable(function (displayable) {
	            displayable.style.blend = blendMode;
	          });
	        }
	      });
	    }
	
	    ;
	
	    function updateZ(model, view) {
	      if (model.preventAutoZ) {
	        return;
	      }
	
	      var z = model.get('z');
	      var zlevel = model.get('zlevel');
	      view.group.traverse(function (el) {
	        if (!el.isGroup) {
	          z != null && (el.z = z);
	          zlevel != null && (el.zlevel = zlevel);
	          var label = el.getTextContent();
	          var labelLine = el.getTextGuideLine();
	
	          if (label) {
	            label.z = el.z;
	            label.zlevel = el.zlevel;
	            label.z2 = el.z2 + 2;
	          }
	
	          if (labelLine) {
	            var showAbove = el.textGuideLineConfig && el.textGuideLineConfig.showAbove;
	            labelLine.z = el.z;
	            labelLine.zlevel = el.zlevel;
	            labelLine.z2 = el.z2 + (showAbove ? 1 : -1);
	          }
	        }
	      });
	    }
	
	    ;
	
	    function clearStates(model, view) {
	      view.group.traverse(function (el) {
	        if (graphic.isElementRemoved(el)) {
	          return;
	        }
	
	        var textContent = el.getTextContent();
	        var textGuide = el.getTextGuideLine();
	
	        if (el.stateTransition) {
	          el.stateTransition = null;
	        }
	
	        if (textContent && textContent.stateTransition) {
	          textContent.stateTransition = null;
	        }
	
	        if (textGuide && textGuide.stateTransition) {
	          textGuide.stateTransition = null;
	        }
	
	        if (el.hasState()) {
	          el.prevStates = el.currentStates;
	          el.clearStates();
	        } else if (el.prevStates) {
	          el.prevStates = null;
	        }
	      });
	    }
	
	    function updateStates(model, view) {
	      var stateAnimationModel = model.getModel('stateAnimation');
	      var enableAnimation = model.isAnimationEnabled();
	      var duration = stateAnimationModel.get('duration');
	      var stateTransition = duration > 0 ? {
	        duration: duration,
	        delay: stateAnimationModel.get('delay'),
	        easing: stateAnimationModel.get('easing')
	      } : null;
	      view.group.traverse(function (el) {
	        if (el.states && el.states.emphasis) {
	          if (graphic.isElementRemoved(el)) {
	            return;
	          }
	
	          if (el instanceof graphic.Path) {
	            states_1.savePathStates(el);
	          }
	
	          if (el.__dirty) {
	            var prevStates = el.prevStates;
	
	            if (prevStates) {
	              el.useStates(prevStates);
	            }
	          }
	
	          if (enableAnimation) {
	            el.stateTransition = stateTransition;
	            var textContent = el.getTextContent();
	            var textGuide = el.getTextGuideLine();
	
	            if (textContent) {
	              textContent.stateTransition = stateTransition;
	            }
	
	            if (textGuide) {
	              textGuide.stateTransition = stateTransition;
	            }
	          }
	
	          if (el.__dirty) {
	            applyElementStates(el);
	          }
	        }
	      });
	    }
	
	    ;
	
	    createExtensionAPI = function (ecIns) {
	      return new (function (_super) {
	        tslib_1.__extends(class_1, _super);
	
	        function class_1() {
	          return _super !== null && _super.apply(this, arguments) || this;
	        }
	
	        class_1.prototype.getCoordinateSystems = function () {
	          return ecIns._coordSysMgr.getCoordinateSystems();
	        };
	
	        class_1.prototype.getComponentByElement = function (el) {
	          while (el) {
	            var modelInfo = el.__ecComponentInfo;
	
	            if (modelInfo != null) {
	              return ecIns._model.getComponent(modelInfo.mainType, modelInfo.index);
	            }
	
	            el = el.parent;
	          }
	        };
	
	        class_1.prototype.enterEmphasis = function (el, highlightDigit) {
	          states_1.enterEmphasis(el, highlightDigit);
	          markStatusToUpdate(ecIns);
	        };
	
	        class_1.prototype.leaveEmphasis = function (el, highlightDigit) {
	          states_1.leaveEmphasis(el, highlightDigit);
	          markStatusToUpdate(ecIns);
	        };
	
	        class_1.prototype.enterBlur = function (el) {
	          states_1.enterBlur(el);
	          markStatusToUpdate(ecIns);
	        };
	
	        class_1.prototype.leaveBlur = function (el) {
	          states_1.leaveBlur(el);
	          markStatusToUpdate(ecIns);
	        };
	
	        class_1.prototype.enterSelect = function (el) {
	          states_1.enterSelect(el);
	          markStatusToUpdate(ecIns);
	        };
	
	        class_1.prototype.leaveSelect = function (el) {
	          states_1.leaveSelect(el);
	          markStatusToUpdate(ecIns);
	        };
	
	        class_1.prototype.getModel = function () {
	          return ecIns.getModel();
	        };
	
	        class_1.prototype.getViewOfComponentModel = function (componentModel) {
	          return ecIns.getViewOfComponentModel(componentModel);
	        };
	
	        class_1.prototype.getViewOfSeriesModel = function (seriesModel) {
	          return ecIns.getViewOfSeriesModel(seriesModel);
	        };
	
	        return class_1;
	      }(ExtensionAPI_1["default"]))(ecIns);
	    };
	
	    enableConnect = function (chart) {
	      function updateConnectedChartsStatus(charts, status) {
	        for (var i = 0; i < charts.length; i++) {
	          var otherChart = charts[i];
	          otherChart[CONNECT_STATUS_KEY] = status;
	        }
	      }
	
	      each(eventActionMap, function (actionType, eventType) {
	        chart._messageCenter.on(eventType, function (event) {
	          if (connectedGroups[chart.group] && chart[CONNECT_STATUS_KEY] !== CONNECT_STATUS_PENDING) {
	            if (event && event.escapeConnect) {
	              return;
	            }
	
	            var action_1 = chart.makeActionFromEvent(event);
	            var otherCharts_1 = [];
	            each(instances, function (otherChart) {
	              if (otherChart !== chart && otherChart.group === chart.group) {
	                otherCharts_1.push(otherChart);
	              }
	            });
	            updateConnectedChartsStatus(otherCharts_1, CONNECT_STATUS_PENDING);
	            each(otherCharts_1, function (otherChart) {
	              if (otherChart[CONNECT_STATUS_KEY] !== CONNECT_STATUS_UPDATING) {
	                otherChart.dispatchAction(action_1);
	              }
	            });
	            updateConnectedChartsStatus(otherCharts_1, CONNECT_STATUS_UPDATED);
	          }
	        });
	      });
	    };
	
	    setTransitionOpt = function (chart, transitionOpt) {
	      var ecModel = chart._model;
	      zrUtil.each(modelUtil.normalizeToArray(transitionOpt), function (transOpt) {
	        var errMsg;
	        var fromOpt = transOpt.from;
	        var toOpt = transOpt.to;
	
	        if (toOpt == null) {
	          if (false) {
	            errMsg = '`transition.to` must be specified.';
	          }
	
	          log_1.throwError(errMsg);
	        }
	
	        var finderOpt = {
	          includeMainTypes: ['series'],
	          enableAll: false,
	          enableNone: false
	        };
	        var fromResult = fromOpt ? modelUtil.parseFinder(ecModel, fromOpt, finderOpt) : null;
	        var toResult = modelUtil.parseFinder(ecModel, toOpt, finderOpt);
	        var toSeries = toResult.seriesModel;
	
	        if (toSeries == null) {
	          errMsg = '';
	
	          if (false) {
	            errMsg = '`transition` is only supported on series.';
	          }
	        }
	
	        if (fromResult && fromResult.seriesModel !== toSeries) {
	          errMsg = '';
	
	          if (false) {
	            errMsg = '`transition.from` and `transition.to` must be specified to the same series.';
	          }
	        }
	
	        if (errMsg != null) {
	          log_1.throwError(errMsg);
	        }
	
	        toSeries.__transientTransitionOpt = {
	          from: fromOpt ? fromOpt.dimension : null,
	          to: toOpt.dimension,
	          dividingMethod: transOpt.dividingMethod
	        };
	      });
	    };
	  }();
	
	  return ECharts;
	}(Eventful_1["default"]);
	
	var echartsProto = ECharts.prototype;
	echartsProto.on = createRegisterEventWithLowercaseECharts('on');
	echartsProto.off = createRegisterEventWithLowercaseECharts('off');
	
	echartsProto.one = function (eventName, cb, ctx) {
	  var self = this;
	  log_1.deprecateLog('ECharts#one is deprecated.');
	
	  function wrapped() {
	    var args2 = [];
	
	    for (var _i = 0; _i < arguments.length; _i++) {
	      args2[_i] = arguments[_i];
	    }
	
	    cb && cb.apply && cb.apply(this, args2);
	    self.off(eventName, wrapped);
	  }
	
	  ;
	  this.on.call(this, eventName, wrapped, ctx);
	};
	
	var MOUSE_EVENT_NAMES = ['click', 'dblclick', 'mouseover', 'mouseout', 'mousemove', 'mousedown', 'mouseup', 'globalout', 'contextmenu'];
	
	function disposedWarning(id) {
	  if (false) {
	    console.warn('Instance ' + id + ' has been disposed');
	  }
	}
	
	var actions = {};
	var eventActionMap = {};
	var dataProcessorFuncs = [];
	var optionPreprocessorFuncs = [];
	var postInitFuncs = [];
	var postUpdateFuncs = [];
	var visualFuncs = [];
	var themeStorage = {};
	var loadingEffects = {};
	var instances = {};
	var connectedGroups = {};
	var idBase = +new Date() - 0;
	var groupIdBase = +new Date() - 0;
	var DOM_ATTRIBUTE_KEY = '_echarts_instance_';
	
	function init(dom, theme, opts) {
	  if (false) {
	    if (!dom) {
	      throw new Error('Initialize failed: invalid dom.');
	    }
	  }
	
	  var existInstance = getInstanceByDom(dom);
	
	  if (existInstance) {
	    if (false) {
	      console.warn('There is a chart instance already initialized on the dom.');
	    }
	
	    return existInstance;
	  }
	
	  if (false) {
	    if (zrUtil.isDom(dom) && dom.nodeName.toUpperCase() !== 'CANVAS' && (!dom.clientWidth && (!opts || opts.width == null) || !dom.clientHeight && (!opts || opts.height == null))) {
	      console.warn('Can\'t get DOM width or height. Please check ' + 'dom.clientWidth and dom.clientHeight. They should not be 0.' + 'For example, you may need to call this in the callback ' + 'of window.onload.');
	    }
	  }
	
	  var chart = new ECharts(dom, theme, opts);
	  chart.id = 'ec_' + idBase++;
	  instances[chart.id] = chart;
	  modelUtil.setAttribute(dom, DOM_ATTRIBUTE_KEY, chart.id);
	  enableConnect(chart);
	  each(postInitFuncs, function (postInitFunc) {
	    postInitFunc(chart);
	  });
	  return chart;
	}
	
	exports.init = init;
	
	function connect(groupId) {
	  if (zrUtil.isArray(groupId)) {
	    var charts = groupId;
	    groupId = null;
	    each(charts, function (chart) {
	      if (chart.group != null) {
	        groupId = chart.group;
	      }
	    });
	    groupId = groupId || 'g_' + groupIdBase++;
	    each(charts, function (chart) {
	      chart.group = groupId;
	    });
	  }
	
	  connectedGroups[groupId] = true;
	  return groupId;
	}
	
	exports.connect = connect;
	
	function disConnect(groupId) {
	  connectedGroups[groupId] = false;
	}
	
	exports.disConnect = disConnect;
	exports.disconnect = disConnect;
	
	function dispose(chart) {
	  if (typeof chart === 'string') {
	    chart = instances[chart];
	  } else if (!(chart instanceof ECharts)) {
	    chart = getInstanceByDom(chart);
	  }
	
	  if (chart instanceof ECharts && !chart.isDisposed()) {
	    chart.dispose();
	  }
	}
	
	exports.dispose = dispose;
	
	function getInstanceByDom(dom) {
	  return instances[modelUtil.getAttribute(dom, DOM_ATTRIBUTE_KEY)];
	}
	
	exports.getInstanceByDom = getInstanceByDom;
	
	function getInstanceById(key) {
	  return instances[key];
	}
	
	exports.getInstanceById = getInstanceById;
	
	function registerTheme(name, theme) {
	  themeStorage[name] = theme;
	}
	
	exports.registerTheme = registerTheme;
	
	function registerPreprocessor(preprocessorFunc) {
	  optionPreprocessorFuncs.push(preprocessorFunc);
	}
	
	exports.registerPreprocessor = registerPreprocessor;
	
	function registerProcessor(priority, processor) {
	  normalizeRegister(dataProcessorFuncs, priority, processor, PRIORITY_PROCESSOR_DEFAULT);
	}
	
	exports.registerProcessor = registerProcessor;
	
	function registerPostInit(postInitFunc) {
	  postInitFunc && postInitFuncs.push(postInitFunc);
	}
	
	exports.registerPostInit = registerPostInit;
	
	function registerPostUpdate(postUpdateFunc) {
	  postUpdateFunc && postUpdateFuncs.push(postUpdateFunc);
	}
	
	exports.registerPostUpdate = registerPostUpdate;
	
	function registerAction(actionInfo, eventName, action) {
	  if (typeof eventName === 'function') {
	    action = eventName;
	    eventName = '';
	  }
	
	  var actionType = isObject(actionInfo) ? actionInfo.type : [actionInfo, actionInfo = {
	    event: eventName
	  }][0];
	  actionInfo.event = (actionInfo.event || actionType).toLowerCase();
	  eventName = actionInfo.event;
	  assert(ACTION_REG.test(actionType) && ACTION_REG.test(eventName));
	
	  if (!actions[actionType]) {
	    actions[actionType] = {
	      action: action,
	      actionInfo: actionInfo
	    };
	  }
	
	  eventActionMap[eventName] = actionType;
	}
	
	exports.registerAction = registerAction;
	
	function registerCoordinateSystem(type, coordSysCreator) {
	  CoordinateSystem_1["default"].register(type, coordSysCreator);
	}
	
	exports.registerCoordinateSystem = registerCoordinateSystem;
	
	function getCoordinateSystemDimensions(type) {
	  var coordSysCreator = CoordinateSystem_1["default"].get(type);
	
	  if (coordSysCreator) {
	    return coordSysCreator.getDimensionsInfo ? coordSysCreator.getDimensionsInfo() : coordSysCreator.dimensions.slice();
	  }
	}
	
	exports.getCoordinateSystemDimensions = getCoordinateSystemDimensions;
	
	var locale_2 = __webpack_require__(90);
	
	exports.registerLocale = locale_2.registerLocale;
	
	function registerLayout(priority, layoutTask) {
	  normalizeRegister(visualFuncs, priority, layoutTask, PRIORITY_VISUAL_LAYOUT, 'layout');
	}
	
	exports.registerLayout = registerLayout;
	
	function registerVisual(priority, visualTask) {
	  normalizeRegister(visualFuncs, priority, visualTask, PRIORITY_VISUAL_CHART, 'visual');
	}
	
	exports.registerVisual = registerVisual;
	
	function normalizeRegister(targetList, priority, fn, defaultPriority, visualType) {
	  if (isFunction(priority) || isObject(priority)) {
	    fn = priority;
	    priority = defaultPriority;
	  }
	
	  if (false) {
	    if (isNaN(priority) || priority == null) {
	      throw new Error('Illegal priority');
	    }
	
	    each(targetList, function (wrap) {
	      assert(wrap.__raw !== fn);
	    });
	  }
	
	  var stageHandler = Scheduler_1["default"].wrapStageHandler(fn, visualType);
	  stageHandler.__prio = priority;
	  stageHandler.__raw = fn;
	  targetList.push(stageHandler);
	}
	
	function registerLoading(name, loadingFx) {
	  loadingEffects[name] = loadingFx;
	}
	
	exports.registerLoading = registerLoading;
	
	function extendComponentModel(proto) {
	  return Component_1["default"].extend(proto);
	}
	
	exports.extendComponentModel = extendComponentModel;
	
	function extendComponentView(proto) {
	  return Component_2["default"].extend(proto);
	}
	
	exports.extendComponentView = extendComponentView;
	
	function extendSeriesModel(proto) {
	  return Series_1["default"].extend(proto);
	}
	
	exports.extendSeriesModel = extendSeriesModel;
	
	function extendChartView(proto) {
	  return Chart_1["default"].extend(proto);
	}
	
	exports.extendChartView = extendChartView;
	
	function setCanvasCreator(creator) {
	  zrUtil.$override('createCanvas', creator);
	}
	
	exports.setCanvasCreator = setCanvasCreator;
	
	function registerMap(mapName, geoJson, specialAreas) {
	  mapDataStorage_1["default"].registerMap(mapName, geoJson, specialAreas);
	}
	
	exports.registerMap = registerMap;
	
	function getMap(mapName) {
	  var records = mapDataStorage_1["default"].retrieveMap(mapName);
	  return records && records[0] && {
	    geoJson: records[0].geoJSON,
	    specialAreas: records[0].specialAreas
	  };
	}
	
	exports.getMap = getMap;
	exports.registerTransform = transform_1.registerExternalTransform;
	registerVisual(PRIORITY_VISUAL_GLOBAL, style_1.seriesStyleTask);
	registerVisual(PRIORITY_VISUAL_CHART_DATA_CUSTOM, style_1.dataStyleTask);
	registerVisual(PRIORITY_VISUAL_CHART_DATA_CUSTOM, style_1.dataColorPaletteTask);
	registerVisual(PRIORITY_VISUAL_GLOBAL, symbol_1.seriesSymbolTask);
	registerVisual(PRIORITY_VISUAL_CHART_DATA_CUSTOM, symbol_1.dataSymbolTask);
	registerVisual(PRIORITY_VISUAL_DECAL, decal_1["default"]);
	registerPreprocessor(backwardCompat_1["default"]);
	registerProcessor(PRIORITY_PROCESSOR_DATASTACK, dataStack_1["default"]);
	registerLoading('default', default_1["default"]);
	registerAction({
	  type: states_1.HIGHLIGHT_ACTION_TYPE,
	  event: states_1.HIGHLIGHT_ACTION_TYPE,
	  update: states_1.HIGHLIGHT_ACTION_TYPE
	}, zrUtil.noop);
	registerAction({
	  type: states_1.DOWNPLAY_ACTION_TYPE,
	  event: states_1.DOWNPLAY_ACTION_TYPE,
	  update: states_1.DOWNPLAY_ACTION_TYPE
	}, zrUtil.noop);
	registerAction({
	  type: states_1.SELECT_ACTION_TYPE,
	  event: states_1.SELECT_ACTION_TYPE,
	  update: states_1.SELECT_ACTION_TYPE
	}, zrUtil.noop);
	registerAction({
	  type: states_1.UNSELECT_ACTION_TYPE,
	  event: states_1.UNSELECT_ACTION_TYPE,
	  update: states_1.UNSELECT_ACTION_TYPE
	}, zrUtil.noop);
	registerAction({
	  type: states_1.TOGGLE_SELECT_ACTION_TYPE,
	  event: states_1.TOGGLE_SELECT_ACTION_TYPE,
	  update: states_1.TOGGLE_SELECT_ACTION_TYPE
	}, zrUtil.noop);
	registerTheme('light', light_1["default"]);
	registerTheme('dark', dark_1["default"]);
	exports.dataTool = {};
	/* WEBPACK VAR INJECTION */}.call(exports, (function() { return this; }())))

/***/ },
/* 7 */
/***/ function(module, exports, __webpack_require__) {

	
	/*
	* Licensed to the Apache Software Foundation (ASF) under one
	* or more contributor license agreements.  See the NOTICE file
	* distributed with this work for additional information
	* regarding copyright ownership.  The ASF licenses this file
	* to you under the Apache License, Version 2.0 (the
	* "License"); you may not use this file except in compliance
	* with the License.  You may obtain a copy of the License at
	*
	*   http://www.apache.org/licenses/LICENSE-2.0
	*
	* Unless required by applicable law or agreed to in writing,
	* software distributed under the License is distributed on an
	* "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
	* KIND, either express or implied.  See the License for the
	* specific language governing permissions and limitations
	* under the License.
	*/
	
	
	
	/**
	 * AUTO-GENERATED FILE. DO NOT MODIFY.
	 */
	
	"use strict";
	
	exports.__esModule = true;
	
	var pathTool = __webpack_require__(117);
	
	var matrix = __webpack_require__(27);
	
	var vector = __webpack_require__(11);
	
	var Path_1 = __webpack_require__(8);
	
	exports.Path = Path_1["default"];
	
	var Transformable_1 = __webpack_require__(108);
	
	var Image_1 = __webpack_require__(43);
	
	exports.Image = Image_1["default"];
	
	var Group_1 = __webpack_require__(51);
	
	exports.Group = Group_1["default"];
	
	var Text_1 = __webpack_require__(60);
	
	exports.Text = Text_1["default"];
	
	var Circle_1 = __webpack_require__(111);
	
	exports.Circle = Circle_1["default"];
	
	var Ellipse_1 = __webpack_require__(112);
	
	exports.Ellipse = Ellipse_1["default"];
	
	var Sector_1 = __webpack_require__(116);
	
	exports.Sector = Sector_1["default"];
	
	var Ring_1 = __webpack_require__(193);
	
	exports.Ring = Ring_1["default"];
	
	var Polygon_1 = __webpack_require__(114);
	
	exports.Polygon = Polygon_1["default"];
	
	var Polyline_1 = __webpack_require__(115);
	
	exports.Polyline = Polyline_1["default"];
	
	var Rect_1 = __webpack_require__(61);
	
	exports.Rect = Rect_1["default"];
	
	var Line_1 = __webpack_require__(113);
	
	exports.Line = Line_1["default"];
	
	var BezierCurve_1 = __webpack_require__(192);
	
	exports.BezierCurve = BezierCurve_1["default"];
	
	var Arc_1 = __webpack_require__(191);
	
	exports.Arc = Arc_1["default"];
	
	var CompoundPath_1 = __webpack_require__(184);
	
	exports.CompoundPath = CompoundPath_1["default"];
	
	var LinearGradient_1 = __webpack_require__(109);
	
	exports.LinearGradient = LinearGradient_1["default"];
	
	var RadialGradient_1 = __webpack_require__(187);
	
	exports.RadialGradient = RadialGradient_1["default"];
	
	var BoundingRect_1 = __webpack_require__(17);
	
	exports.BoundingRect = BoundingRect_1["default"];
	
	var OrientedBoundingRect_1 = __webpack_require__(180);
	
	exports.OrientedBoundingRect = OrientedBoundingRect_1["default"];
	
	var Point_1 = __webpack_require__(79);
	
	exports.Point = Point_1["default"];
	
	var IncrementalDisplayable_1 = __webpack_require__(186);
	
	exports.IncrementalDisplayable = IncrementalDisplayable_1["default"];
	
	var subPixelOptimizeUtil = __webpack_require__(110);
	
	var util_1 = __webpack_require__(1);
	
	var innerStore_1 = __webpack_require__(21);
	
	var mathMax = Math.max;
	var mathMin = Math.min;
	var _customShapeMap = {};
	
	function extendShape(opts) {
	  return Path_1["default"].extend(opts);
	}
	
	exports.extendShape = extendShape;
	var extendPathFromString = pathTool.extendFromString;
	
	function extendPath(pathData, opts) {
	  return extendPathFromString(pathData, opts);
	}
	
	exports.extendPath = extendPath;
	
	function registerShape(name, ShapeClass) {
	  _customShapeMap[name] = ShapeClass;
	}
	
	exports.registerShape = registerShape;
	
	function getShapeClass(name) {
	  if (_customShapeMap.hasOwnProperty(name)) {
	    return _customShapeMap[name];
	  }
	}
	
	exports.getShapeClass = getShapeClass;
	
	function makePath(pathData, opts, rect, layout) {
	  var path = pathTool.createFromString(pathData, opts);
	
	  if (rect) {
	    if (layout === 'center') {
	      rect = centerGraphic(rect, path.getBoundingRect());
	    }
	
	    resizePath(path, rect);
	  }
	
	  return path;
	}
	
	exports.makePath = makePath;
	
	function makeImage(imageUrl, rect, layout) {
	  var zrImg = new Image_1["default"]({
	    style: {
	      image: imageUrl,
	      x: rect.x,
	      y: rect.y,
	      width: rect.width,
	      height: rect.height
	    },
	    onload: function (img) {
	      if (layout === 'center') {
	        var boundingRect = {
	          width: img.width,
	          height: img.height
	        };
	        zrImg.setStyle(centerGraphic(rect, boundingRect));
	      }
	    }
	  });
	  return zrImg;
	}
	
	exports.makeImage = makeImage;
	
	function centerGraphic(rect, boundingRect) {
	  var aspect = boundingRect.width / boundingRect.height;
	  var width = rect.height * aspect;
	  var height;
	
	  if (width <= rect.width) {
	    height = rect.height;
	  } else {
	    width = rect.width;
	    height = width / aspect;
	  }
	
	  var cx = rect.x + rect.width / 2;
	  var cy = rect.y + rect.height / 2;
	  return {
	    x: cx - width / 2,
	    y: cy - height / 2,
	    width: width,
	    height: height
	  };
	}
	
	exports.mergePath = pathTool.mergePath;
	
	function resizePath(path, rect) {
	  if (!path.applyTransform) {
	    return;
	  }
	
	  var pathRect = path.getBoundingRect();
	  var m = pathRect.calculateTransform(rect);
	  path.applyTransform(m);
	}
	
	exports.resizePath = resizePath;
	
	function subPixelOptimizeLine(param) {
	  subPixelOptimizeUtil.subPixelOptimizeLine(param.shape, param.shape, param.style);
	  return param;
	}
	
	exports.subPixelOptimizeLine = subPixelOptimizeLine;
	
	function subPixelOptimizeRect(param) {
	  subPixelOptimizeUtil.subPixelOptimizeRect(param.shape, param.shape, param.style);
	  return param;
	}
	
	exports.subPixelOptimizeRect = subPixelOptimizeRect;
	exports.subPixelOptimize = subPixelOptimizeUtil.subPixelOptimize;
	
	function animateOrSetProps(animationType, el, props, animatableModel, dataIndex, cb, during) {
	  var isFrom = false;
	  var removeOpt;
	
	  if (typeof dataIndex === 'function') {
	    during = cb;
	    cb = dataIndex;
	    dataIndex = null;
	  } else if (util_1.isObject(dataIndex)) {
	    cb = dataIndex.cb;
	    during = dataIndex.during;
	    isFrom = dataIndex.isFrom;
	    removeOpt = dataIndex.removeOpt;
	    dataIndex = dataIndex.dataIndex;
	  }
	
	  var isUpdate = animationType === 'update';
	  var isRemove = animationType === 'remove';
	  var animationPayload;
	
	  if (animatableModel && animatableModel.ecModel) {
	    var updatePayload = animatableModel.ecModel.getUpdatePayload();
	    animationPayload = updatePayload && updatePayload.animation;
	  }
	
	  var animationEnabled = animatableModel && animatableModel.isAnimationEnabled();
	
	  if (!isRemove) {
	    el.stopAnimation('remove');
	  }
	
	  if (animationEnabled) {
	    var duration = void 0;
	    var animationEasing = void 0;
	    var animationDelay = void 0;
	
	    if (animationPayload) {
	      duration = animationPayload.duration || 0;
	      animationEasing = animationPayload.easing || 'cubicOut';
	      animationDelay = animationPayload.delay || 0;
	    } else if (isRemove) {
	      removeOpt = removeOpt || {};
	      duration = util_1.retrieve2(removeOpt.duration, 200);
	      animationEasing = util_1.retrieve2(removeOpt.easing, 'cubicOut');
	      animationDelay = 0;
	    } else {
	      duration = animatableModel.getShallow(isUpdate ? 'animationDurationUpdate' : 'animationDuration');
	      animationEasing = animatableModel.getShallow(isUpdate ? 'animationEasingUpdate' : 'animationEasing');
	      animationDelay = animatableModel.getShallow(isUpdate ? 'animationDelayUpdate' : 'animationDelay');
	    }
	
	    if (typeof animationDelay === 'function') {
	      animationDelay = animationDelay(dataIndex, animatableModel.getAnimationDelayParams ? animatableModel.getAnimationDelayParams(el, dataIndex) : null);
	    }
	
	    if (typeof duration === 'function') {
	      duration = duration(dataIndex);
	    }
	
	    duration > 0 ? isFrom ? el.animateFrom(props, {
	      duration: duration,
	      delay: animationDelay || 0,
	      easing: animationEasing,
	      done: cb,
	      force: !!cb || !!during,
	      scope: animationType,
	      during: during
	    }) : el.animateTo(props, {
	      duration: duration,
	      delay: animationDelay || 0,
	      easing: animationEasing,
	      done: cb,
	      force: !!cb || !!during,
	      setToFinal: true,
	      scope: animationType,
	      during: during
	    }) : (el.stopAnimation(), !isFrom && el.attr(props), cb && cb());
	  } else {
	    el.stopAnimation();
	    !isFrom && el.attr(props);
	    during && during(1);
	    cb && cb();
	  }
	}
	
	function updateProps(el, props, animatableModel, dataIndex, cb, during) {
	  animateOrSetProps('update', el, props, animatableModel, dataIndex, cb, during);
	}
	
	exports.updateProps = updateProps;
	
	function initProps(el, props, animatableModel, dataIndex, cb, during) {
	  animateOrSetProps('init', el, props, animatableModel, dataIndex, cb, during);
	}
	
	exports.initProps = initProps;
	
	function removeElement(el, props, animatableModel, dataIndex, cb, during) {
	  if (isElementRemoved(el)) {
	    return;
	  }
	
	  animateOrSetProps('remove', el, props, animatableModel, dataIndex, cb, during);
	}
	
	exports.removeElement = removeElement;
	
	function fadeOutDisplayable(el, animatableModel, dataIndex, done) {
	  el.removeTextContent();
	  el.removeTextGuideLine();
	  removeElement(el, {
	    style: {
	      opacity: 0
	    }
	  }, animatableModel, dataIndex, done);
	}
	
	function removeElementWithFadeOut(el, animatableModel, dataIndex) {
	  function doRemove() {
	    el.parent && el.parent.remove(el);
	  }
	
	  if (!el.isGroup) {
	    fadeOutDisplayable(el, animatableModel, dataIndex, doRemove);
	  } else {
	    el.traverse(function (disp) {
	      if (!disp.isGroup) {
	        fadeOutDisplayable(disp, animatableModel, dataIndex, doRemove);
	      }
	    });
	  }
	}
	
	exports.removeElementWithFadeOut = removeElementWithFadeOut;
	
	function isElementRemoved(el) {
	  if (!el.__zr) {
	    return true;
	  }
	
	  for (var i = 0; i < el.animators.length; i++) {
	    var animator = el.animators[i];
	
	    if (animator.scope === 'remove') {
	      return true;
	    }
	  }
	
	  return false;
	}
	
	exports.isElementRemoved = isElementRemoved;
	
	function getTransform(target, ancestor) {
	  var mat = matrix.identity([]);
	
	  while (target && target !== ancestor) {
	    matrix.mul(mat, target.getLocalTransform(), mat);
	    target = target.parent;
	  }
	
	  return mat;
	}
	
	exports.getTransform = getTransform;
	
	function applyTransform(target, transform, invert) {
	  if (transform && !util_1.isArrayLike(transform)) {
	    transform = Transformable_1["default"].getLocalTransform(transform);
	  }
	
	  if (invert) {
	    transform = matrix.invert([], transform);
	  }
	
	  return vector.applyTransform([], target, transform);
	}
	
	exports.applyTransform = applyTransform;
	
	function transformDirection(direction, transform, invert) {
	  var hBase = transform[4] === 0 || transform[5] === 0 || transform[0] === 0 ? 1 : Math.abs(2 * transform[4] / transform[0]);
	  var vBase = transform[4] === 0 || transform[5] === 0 || transform[2] === 0 ? 1 : Math.abs(2 * transform[4] / transform[2]);
	  var vertex = [direction === 'left' ? -hBase : direction === 'right' ? hBase : 0, direction === 'top' ? -vBase : direction === 'bottom' ? vBase : 0];
	  vertex = applyTransform(vertex, transform, invert);
	  return Math.abs(vertex[0]) > Math.abs(vertex[1]) ? vertex[0] > 0 ? 'right' : 'left' : vertex[1] > 0 ? 'bottom' : 'top';
	}
	
	exports.transformDirection = transformDirection;
	
	function isNotGroup(el) {
	  return !el.isGroup;
	}
	
	function isPath(el) {
	  return el.shape != null;
	}
	
	function groupTransition(g1, g2, animatableModel) {
	  if (!g1 || !g2) {
	    return;
	  }
	
	  function getElMap(g) {
	    var elMap = {};
	    g.traverse(function (el) {
	      if (isNotGroup(el) && el.anid) {
	        elMap[el.anid] = el;
	      }
	    });
	    return elMap;
	  }
	
	  function getAnimatableProps(el) {
	    var obj = {
	      x: el.x,
	      y: el.y,
	      rotation: el.rotation
	    };
	
	    if (isPath(el)) {
	      obj.shape = util_1.extend({}, el.shape);
	    }
	
	    return obj;
	  }
	
	  var elMap1 = getElMap(g1);
	  g2.traverse(function (el) {
	    if (isNotGroup(el) && el.anid) {
	      var oldEl = elMap1[el.anid];
	
	      if (oldEl) {
	        var newProp = getAnimatableProps(el);
	        el.attr(getAnimatableProps(oldEl));
	        updateProps(el, newProp, animatableModel, innerStore_1.getECData(el).dataIndex);
	      }
	    }
	  });
	}
	
	exports.groupTransition = groupTransition;
	
	function clipPointsByRect(points, rect) {
	  return util_1.map(points, function (point) {
	    var x = point[0];
	    x = mathMax(x, rect.x);
	    x = mathMin(x, rect.x + rect.width);
	    var y = point[1];
	    y = mathMax(y, rect.y);
	    y = mathMin(y, rect.y + rect.height);
	    return [x, y];
	  });
	}
	
	exports.clipPointsByRect = clipPointsByRect;
	
	function clipRectByRect(targetRect, rect) {
	  var x = mathMax(targetRect.x, rect.x);
	  var x2 = mathMin(targetRect.x + targetRect.width, rect.x + rect.width);
	  var y = mathMax(targetRect.y, rect.y);
	  var y2 = mathMin(targetRect.y + targetRect.height, rect.y + rect.height);
	
	  if (x2 >= x && y2 >= y) {
	    return {
	      x: x,
	      y: y,
	      width: x2 - x,
	      height: y2 - y
	    };
	  }
	}
	
	exports.clipRectByRect = clipRectByRect;
	
	function createIcon(iconStr, opt, rect) {
	  var innerOpts = util_1.extend({
	    rectHover: true
	  }, opt);
	  var style = innerOpts.style = {
	    strokeNoScale: true
	  };
	  rect = rect || {
	    x: -1,
	    y: -1,
	    width: 2,
	    height: 2
	  };
	
	  if (iconStr) {
	    return iconStr.indexOf('image://') === 0 ? (style.image = iconStr.slice(8), util_1.defaults(style, rect), new Image_1["default"](innerOpts)) : makePath(iconStr.replace('path://', ''), innerOpts, rect, 'center');
	  }
	}
	
	exports.createIcon = createIcon;
	
	function linePolygonIntersect(a1x, a1y, a2x, a2y, points) {
	  for (var i = 0, p2 = points[points.length - 1]; i < points.length; i++) {
	    var p = points[i];
	
	    if (lineLineIntersect(a1x, a1y, a2x, a2y, p[0], p[1], p2[0], p2[1])) {
	      return true;
	    }
	
	    p2 = p;
	  }
	}
	
	exports.linePolygonIntersect = linePolygonIntersect;
	
	function lineLineIntersect(a1x, a1y, a2x, a2y, b1x, b1y, b2x, b2y) {
	  var mx = a2x - a1x;
	  var my = a2y - a1y;
	  var nx = b2x - b1x;
	  var ny = b2y - b1y;
	  var nmCrossProduct = crossProduct2d(nx, ny, mx, my);
	
	  if (nearZero(nmCrossProduct)) {
	    return false;
	  }
	
	  var b1a1x = a1x - b1x;
	  var b1a1y = a1y - b1y;
	  var q = crossProduct2d(b1a1x, b1a1y, mx, my) / nmCrossProduct;
	
	  if (q < 0 || q > 1) {
	    return false;
	  }
	
	  var p = crossProduct2d(b1a1x, b1a1y, nx, ny) / nmCrossProduct;
	
	  if (p < 0 || p > 1) {
	    return false;
	  }
	
	  return true;
	}
	
	exports.lineLineIntersect = lineLineIntersect;
	
	function crossProduct2d(x1, y1, x2, y2) {
	  return x1 * y2 - x2 * y1;
	}
	
	function nearZero(val) {
	  return val <= 1e-6 && val >= -1e-6;
	}
	
	registerShape('circle', Circle_1["default"]);
	registerShape('ellipse', Ellipse_1["default"]);
	registerShape('sector', Sector_1["default"]);
	registerShape('ring', Ring_1["default"]);
	registerShape('polygon', Polygon_1["default"]);
	registerShape('polyline', Polyline_1["default"]);
	registerShape('rect', Rect_1["default"]);
	registerShape('line', Line_1["default"]);
	registerShape('bezierCurve', BezierCurve_1["default"]);
	registerShape('arc', Arc_1["default"]);

/***/ },
/* 8 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	exports.__esModule = true;
	var tslib_1 = __webpack_require__(5);
	var Displayable_1 = __webpack_require__(50);
	var Element_1 = __webpack_require__(36);
	var PathProxy_1 = __webpack_require__(32);
	var pathContain = __webpack_require__(453);
	var util_1 = __webpack_require__(1);
	var color_1 = __webpack_require__(34);
	var config_1 = __webpack_require__(49);
	exports.DEFAULT_PATH_STYLE = util_1.defaults({
	    fill: '#000',
	    stroke: null,
	    strokePercent: 1,
	    fillOpacity: 1,
	    strokeOpacity: 1,
	    lineDashOffset: 0,
	    lineWidth: 1,
	    lineCap: 'butt',
	    miterLimit: 10,
	    strokeNoScale: false,
	    strokeFirst: false
	}, Displayable_1.DEFAULT_COMMON_STYLE);
	exports.DEFAULT_PATH_ANIMATION_PROPS = {
	    style: util_1.defaults({
	        fill: true,
	        stroke: true,
	        strokePercent: true,
	        fillOpacity: true,
	        strokeOpacity: true,
	        lineDashOffset: true,
	        lineWidth: true,
	        miterLimit: true
	    }, Displayable_1.DEFAULT_COMMON_ANIMATION_PROPS.style)
	};
	var pathCopyParams = [
	    'x', 'y', 'rotation', 'scaleX', 'scaleY', 'originX', 'originY', 'invisible',
	    'culling', 'z', 'z2', 'zlevel', 'parent'
	];
	var Path = (function (_super) {
	    tslib_1.__extends(Path, _super);
	    function Path(opts) {
	        return _super.call(this, opts) || this;
	    }
	    Path.prototype.update = function () {
	        var _this = this;
	        _super.prototype.update.call(this);
	        var style = this.style;
	        if (style.decal) {
	            var decalEl = this._decalEl
	                = this._decalEl || new Path();
	            if (decalEl.buildPath === Path.prototype.buildPath) {
	                decalEl.buildPath = function (ctx) {
	                    _this.buildPath(ctx, _this.shape);
	                };
	            }
	            decalEl.silent = true;
	            var decalElStyle = decalEl.style;
	            for (var key in style) {
	                if (decalElStyle[key] !== style[key]) {
	                    decalElStyle[key] = style[key];
	                }
	            }
	            decalElStyle.fill = style.fill ? style.decal : null;
	            decalElStyle.decal = null;
	            decalElStyle.shadowColor = null;
	            style.strokeFirst && (decalElStyle.stroke = null);
	            for (var i = 0; i < pathCopyParams.length; ++i) {
	                decalEl[pathCopyParams[i]] = this[pathCopyParams[i]];
	            }
	            decalEl.__dirty |= Element_1["default"].REDARAW_BIT;
	        }
	        else if (this._decalEl) {
	            this._decalEl = null;
	        }
	    };
	    Path.prototype.getDecalElement = function () {
	        return this._decalEl;
	    };
	    Path.prototype._init = function (props) {
	        var keysArr = util_1.keys(props);
	        this.shape = this.getDefaultShape();
	        var defaultStyle = this.getDefaultStyle();
	        if (defaultStyle) {
	            this.useStyle(defaultStyle);
	        }
	        for (var i = 0; i < keysArr.length; i++) {
	            var key = keysArr[i];
	            var value = props[key];
	            if (key === 'style') {
	                if (!this.style) {
	                    this.useStyle(value);
	                }
	                else {
	                    util_1.extend(this.style, value);
	                }
	            }
	            else if (key === 'shape') {
	                util_1.extend(this.shape, value);
	            }
	            else {
	                _super.prototype.attrKV.call(this, key, value);
	            }
	        }
	        if (!this.style) {
	            this.useStyle({});
	        }
	    };
	    Path.prototype.getDefaultStyle = function () {
	        return null;
	    };
	    Path.prototype.getDefaultShape = function () {
	        return {};
	    };
	    Path.prototype.canBeInsideText = function () {
	        return this.hasFill();
	    };
	    Path.prototype.getInsideTextFill = function () {
	        var pathFill = this.style.fill;
	        if (pathFill !== 'none') {
	            if (util_1.isString(pathFill)) {
	                var fillLum = color_1.lum(pathFill, 0);
	                if (fillLum > 0.5) {
	                    return config_1.DARK_LABEL_COLOR;
	                }
	                else if (fillLum > 0.2) {
	                    return config_1.LIGHTER_LABEL_COLOR;
	                }
	                return config_1.LIGHT_LABEL_COLOR;
	            }
	            else if (pathFill) {
	                return config_1.LIGHT_LABEL_COLOR;
	            }
	        }
	        return config_1.DARK_LABEL_COLOR;
	    };
	    Path.prototype.getInsideTextStroke = function (textFill) {
	        var pathFill = this.style.fill;
	        if (util_1.isString(pathFill)) {
	            var zr = this.__zr;
	            var isDarkMode = !!(zr && zr.isDarkMode());
	            var isDarkLabel = color_1.lum(textFill, 0) < config_1.DARK_MODE_THRESHOLD;
	            if (isDarkMode === isDarkLabel) {
	                return pathFill;
	            }
	        }
	    };
	    Path.prototype.buildPath = function (ctx, shapeCfg, inBundle) { };
	    Path.prototype.pathUpdated = function () {
	        this.__dirty &= ~Path.SHAPE_CHANGED_BIT;
	    };
	    Path.prototype.createPathProxy = function () {
	        this.path = new PathProxy_1["default"](false);
	    };
	    Path.prototype.hasStroke = function () {
	        var style = this.style;
	        var stroke = style.stroke;
	        return !(stroke == null || stroke === 'none' || !(style.lineWidth > 0));
	    };
	    Path.prototype.hasFill = function () {
	        var style = this.style;
	        var fill = style.fill;
	        return fill != null && fill !== 'none';
	    };
	    Path.prototype.getBoundingRect = function () {
	        var rect = this._rect;
	        var style = this.style;
	        var needsUpdateRect = !rect;
	        if (needsUpdateRect) {
	            var firstInvoke = false;
	            if (!this.path) {
	                firstInvoke = true;
	                this.createPathProxy();
	            }
	            var path = this.path;
	            if (firstInvoke || (this.__dirty & Path.SHAPE_CHANGED_BIT)) {
	                path.beginPath();
	                this.buildPath(path, this.shape, false);
	                this.pathUpdated();
	            }
	            rect = path.getBoundingRect();
	        }
	        this._rect = rect;
	        if (this.hasStroke() && this.path && this.path.len() > 0) {
	            var rectWithStroke = this._rectWithStroke || (this._rectWithStroke = rect.clone());
	            if (this.__dirty || needsUpdateRect) {
	                rectWithStroke.copy(rect);
	                var lineScale = style.strokeNoScale ? this.getLineScale() : 1;
	                var w = style.lineWidth;
	                if (!this.hasFill()) {
	                    var strokeContainThreshold = this.strokeContainThreshold;
	                    w = Math.max(w, strokeContainThreshold == null ? 4 : strokeContainThreshold);
	                }
	                if (lineScale > 1e-10) {
	                    rectWithStroke.width += w / lineScale;
	                    rectWithStroke.height += w / lineScale;
	                    rectWithStroke.x -= w / lineScale / 2;
	                    rectWithStroke.y -= w / lineScale / 2;
	                }
	            }
	            return rectWithStroke;
	        }
	        return rect;
	    };
	    Path.prototype.contain = function (x, y) {
	        var localPos = this.transformCoordToLocal(x, y);
	        var rect = this.getBoundingRect();
	        var style = this.style;
	        x = localPos[0];
	        y = localPos[1];
	        if (rect.contain(x, y)) {
	            var pathProxy = this.path;
	            if (this.hasStroke()) {
	                var lineWidth = style.lineWidth;
	                var lineScale = style.strokeNoScale ? this.getLineScale() : 1;
	                if (lineScale > 1e-10) {
	                    if (!this.hasFill()) {
	                        lineWidth = Math.max(lineWidth, this.strokeContainThreshold);
	                    }
	                    if (pathContain.containStroke(pathProxy, lineWidth / lineScale, x, y)) {
	                        return true;
	                    }
	                }
	            }
	            if (this.hasFill()) {
	                return pathContain.contain(pathProxy, x, y);
	            }
	        }
	        return false;
	    };
	    Path.prototype.dirtyShape = function () {
	        this.__dirty |= Path.SHAPE_CHANGED_BIT;
	        if (this._rect) {
	            this._rect = null;
	        }
	        if (this._decalEl) {
	            this._decalEl.dirtyShape();
	        }
	        this.markRedraw();
	    };
	    Path.prototype.dirty = function () {
	        this.dirtyStyle();
	        this.dirtyShape();
	    };
	    Path.prototype.animateShape = function (loop) {
	        return this.animate('shape', loop);
	    };
	    Path.prototype.updateDuringAnimation = function (targetKey) {
	        if (targetKey === 'style') {
	            this.dirtyStyle();
	        }
	        else if (targetKey === 'shape') {
	            this.dirtyShape();
	        }
	        else {
	            this.markRedraw();
	        }
	    };
	    Path.prototype.attrKV = function (key, value) {
	        if (key === 'shape') {
	            this.setShape(value);
	        }
	        else {
	            _super.prototype.attrKV.call(this, key, value);
	        }
	    };
	    Path.prototype.setShape = function (keyOrObj, value) {
	        var shape = this.shape;
	        if (!shape) {
	            shape = this.shape = {};
	        }
	        if (typeof keyOrObj === 'string') {
	            shape[keyOrObj] = value;
	        }
	        else {
	            util_1.extend(shape, keyOrObj);
	        }
	        this.dirtyShape();
	        return this;
	    };
	    Path.prototype.shapeChanged = function () {
	        return !!(this.__dirty & Path.SHAPE_CHANGED_BIT);
	    };
	    Path.prototype.createStyle = function (obj) {
	        return util_1.createObject(exports.DEFAULT_PATH_STYLE, obj);
	    };
	    Path.prototype._innerSaveToNormal = function (toState) {
	        _super.prototype._innerSaveToNormal.call(this, toState);
	        var normalState = this._normalState;
	        if (toState.shape && !normalState.shape) {
	            normalState.shape = util_1.extend({}, this.shape);
	        }
	    };
	    Path.prototype._applyStateObj = function (stateName, state, normalState, keepCurrentStates, transition, animationCfg) {
	        _super.prototype._applyStateObj.call(this, stateName, state, normalState, keepCurrentStates, transition, animationCfg);
	        var needsRestoreToNormal = !(state && keepCurrentStates);
	        var targetShape;
	        if (state && state.shape) {
	            if (transition) {
	                if (keepCurrentStates) {
	                    targetShape = state.shape;
	                }
	                else {
	                    targetShape = util_1.extend({}, normalState.shape);
	                    util_1.extend(targetShape, state.shape);
	                }
	            }
	            else {
	                targetShape = util_1.extend({}, keepCurrentStates ? this.shape : normalState.shape);
	                util_1.extend(targetShape, state.shape);
	            }
	        }
	        else if (needsRestoreToNormal) {
	            targetShape = normalState.shape;
	        }
	        if (targetShape) {
	            if (transition) {
	                this.shape = util_1.extend({}, this.shape);
	                var targetShapePrimaryProps = {};
	                var shapeKeys = util_1.keys(targetShape);
	                for (var i = 0; i < shapeKeys.length; i++) {
	                    var key = shapeKeys[i];
	                    if (typeof targetShape[key] === 'object') {
	                        this.shape[key] = targetShape[key];
	                    }
	                    else {
	                        targetShapePrimaryProps[key] = targetShape[key];
	                    }
	                }
	                this._transitionState(stateName, {
	                    shape: targetShapePrimaryProps
	                }, animationCfg);
	            }
	            else {
	                this.shape = targetShape;
	                this.dirtyShape();
	            }
	        }
	    };
	    Path.prototype._mergeStates = function (states) {
	        var mergedState = _super.prototype._mergeStates.call(this, states);
	        var mergedShape;
	        for (var i = 0; i < states.length; i++) {
	            var state = states[i];
	            if (state.shape) {
	                mergedShape = mergedShape || {};
	                this._mergeStyle(mergedShape, state.shape);
	            }
	        }
	        if (mergedShape) {
	            mergedState.shape = mergedShape;
	        }
	        return mergedState;
	    };
	    Path.prototype.getAnimationStyleProps = function () {
	        return exports.DEFAULT_PATH_ANIMATION_PROPS;
	    };
	    Path.prototype.isZeroArea = function () {
	        return false;
	    };
	    Path.extend = function (defaultProps) {
	        var Sub = (function (_super) {
	            tslib_1.__extends(Sub, _super);
	            function Sub(opts) {
	                var _this = _super.call(this, opts) || this;
	                defaultProps.init && defaultProps.init.call(_this, opts);
	                return _this;
	            }
	            Sub.prototype.getDefaultStyle = function () {
	                return util_1.clone(defaultProps.style);
	            };
	            Sub.prototype.getDefaultShape = function () {
	                return util_1.clone(defaultProps.shape);
	            };
	            return Sub;
	        }(Path));
	        for (var key in defaultProps) {
	            if (typeof defaultProps[key] === 'function') {
	                Sub.prototype[key] = defaultProps[key];
	            }
	        }
	        return Sub;
	    };
	    Path.SHAPE_CHANGED_BIT = 4;
	    Path.initDefaultProps = (function () {
	        var pathProto = Path.prototype;
	        pathProto.type = 'path';
	        pathProto.strokeContainThreshold = 5;
	        pathProto.segmentIgnoreThreshold = 0;
	        pathProto.subPixelOptimize = false;
	        pathProto.autoBatch = false;
	        pathProto.__dirty = Element_1["default"].REDARAW_BIT | Displayable_1["default"].STYLE_CHANGED_BIT | Path.SHAPE_CHANGED_BIT;
	    })();
	    return Path;
	}(Displayable_1["default"]));
	exports["default"] = Path;


/***/ },
/* 9 */
/***/ function(module, exports, __webpack_require__) {

	
	/*
	* Licensed to the Apache Software Foundation (ASF) under one
	* or more contributor license agreements.  See the NOTICE file
	* distributed with this work for additional information
	* regarding copyright ownership.  The ASF licenses this file
	* to you under the Apache License, Version 2.0 (the
	* "License"); you may not use this file except in compliance
	* with the License.  You may obtain a copy of the License at
	*
	*   http://www.apache.org/licenses/LICENSE-2.0
	*
	* Unless required by applicable law or agreed to in writing,
	* software distributed under the License is distributed on an
	* "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
	* KIND, either express or implied.  See the License for the
	* specific language governing permissions and limitations
	* under the License.
	*/
	
	
	
	/**
	 * AUTO-GENERATED FILE. DO NOT MODIFY.
	 */
	
	"use strict";
	
	exports.__esModule = true;
	
	var zrUtil = __webpack_require__(1);
	
	var RADIAN_EPSILON = 1e-4;
	
	function _trim(str) {
	  return str.replace(/^\s+|\s+$/g, '');
	}
	
	function linearMap(val, domain, range, clamp) {
	  var subDomain = domain[1] - domain[0];
	  var subRange = range[1] - range[0];
	
	  if (subDomain === 0) {
	    return subRange === 0 ? range[0] : (range[0] + range[1]) / 2;
	  }
	
	  if (clamp) {
	    if (subDomain > 0) {
	      if (val <= domain[0]) {
	        return range[0];
	      } else if (val >= domain[1]) {
	        return range[1];
	      }
	    } else {
	      if (val >= domain[0]) {
	        return range[0];
	      } else if (val <= domain[1]) {
	        return range[1];
	      }
	    }
	  } else {
	    if (val === domain[0]) {
	      return range[0];
	    }
	
	    if (val === domain[1]) {
	      return range[1];
	    }
	  }
	
	  return (val - domain[0]) / subDomain * subRange + range[0];
	}
	
	exports.linearMap = linearMap;
	
	function parsePercent(percent, all) {
	  switch (percent) {
	    case 'center':
	    case 'middle':
	      percent = '50%';
	      break;
	
	    case 'left':
	    case 'top':
	      percent = '0%';
	      break;
	
	    case 'right':
	    case 'bottom':
	      percent = '100%';
	      break;
	  }
	
	  if (typeof percent === 'string') {
	    if (_trim(percent).match(/%$/)) {
	      return parseFloat(percent) / 100 * all;
	    }
	
	    return parseFloat(percent);
	  }
	
	  return percent == null ? NaN : +percent;
	}
	
	exports.parsePercent = parsePercent;
	
	function round(x, precision, returnStr) {
	  if (precision == null) {
	    precision = 10;
	  }
	
	  precision = Math.min(Math.max(0, precision), 20);
	  x = (+x).toFixed(precision);
	  return returnStr ? x : +x;
	}
	
	exports.round = round;
	
	function asc(arr) {
	  arr.sort(function (a, b) {
	    return a - b;
	  });
	  return arr;
	}
	
	exports.asc = asc;
	
	function getPrecision(val) {
	  val = +val;
	
	  if (isNaN(val)) {
	    return 0;
	  }
	
	  var e = 1;
	  var count = 0;
	
	  while (Math.round(val * e) / e !== val) {
	    e *= 10;
	    count++;
	  }
	
	  return count;
	}
	
	exports.getPrecision = getPrecision;
	
	function getPrecisionSafe(val) {
	  var str = val.toString();
	  var eIndex = str.indexOf('e');
	
	  if (eIndex > 0) {
	    var precision = +str.slice(eIndex + 1);
	    return precision < 0 ? -precision : 0;
	  } else {
	    var dotIndex = str.indexOf('.');
	    return dotIndex < 0 ? 0 : str.length - 1 - dotIndex;
	  }
	}
	
	exports.getPrecisionSafe = getPrecisionSafe;
	
	function getPixelPrecision(dataExtent, pixelExtent) {
	  var log = Math.log;
	  var LN10 = Math.LN10;
	  var dataQuantity = Math.floor(log(dataExtent[1] - dataExtent[0]) / LN10);
	  var sizeQuantity = Math.round(log(Math.abs(pixelExtent[1] - pixelExtent[0])) / LN10);
	  var precision = Math.min(Math.max(-dataQuantity + sizeQuantity, 0), 20);
	  return !isFinite(precision) ? 20 : precision;
	}
	
	exports.getPixelPrecision = getPixelPrecision;
	
	function getPercentWithPrecision(valueList, idx, precision) {
	  if (!valueList[idx]) {
	    return 0;
	  }
	
	  var sum = zrUtil.reduce(valueList, function (acc, val) {
	    return acc + (isNaN(val) ? 0 : val);
	  }, 0);
	
	  if (sum === 0) {
	    return 0;
	  }
	
	  var digits = Math.pow(10, precision);
	  var votesPerQuota = zrUtil.map(valueList, function (val) {
	    return (isNaN(val) ? 0 : val) / sum * digits * 100;
	  });
	  var targetSeats = digits * 100;
	  var seats = zrUtil.map(votesPerQuota, function (votes) {
	    return Math.floor(votes);
	  });
	  var currentSum = zrUtil.reduce(seats, function (acc, val) {
	    return acc + val;
	  }, 0);
	  var remainder = zrUtil.map(votesPerQuota, function (votes, idx) {
	    return votes - seats[idx];
	  });
	
	  while (currentSum < targetSeats) {
	    var max = Number.NEGATIVE_INFINITY;
	    var maxId = null;
	
	    for (var i = 0, len = remainder.length; i < len; ++i) {
	      if (remainder[i] > max) {
	        max = remainder[i];
	        maxId = i;
	      }
	    }
	
	    ++seats[maxId];
	    remainder[maxId] = 0;
	    ++currentSum;
	  }
	
	  return seats[idx] / digits;
	}
	
	exports.getPercentWithPrecision = getPercentWithPrecision;
	exports.MAX_SAFE_INTEGER = 9007199254740991;
	
	function remRadian(radian) {
	  var pi2 = Math.PI * 2;
	  return (radian % pi2 + pi2) % pi2;
	}
	
	exports.remRadian = remRadian;
	
	function isRadianAroundZero(val) {
	  return val > -RADIAN_EPSILON && val < RADIAN_EPSILON;
	}
	
	exports.isRadianAroundZero = isRadianAroundZero;
	var TIME_REG = /^(?:(\d{4})(?:[-\/](\d{1,2})(?:[-\/](\d{1,2})(?:[T ](\d{1,2})(?::(\d{1,2})(?::(\d{1,2})(?:[.,](\d+))?)?)?(Z|[\+\-]\d\d:?\d\d)?)?)?)?)?$/;
	
	function parseDate(value) {
	  if (value instanceof Date) {
	    return value;
	  } else if (typeof value === 'string') {
	    var match = TIME_REG.exec(value);
	
	    if (!match) {
	      return new Date(NaN);
	    }
	
	    if (!match[8]) {
	      return new Date(+match[1], +(match[2] || 1) - 1, +match[3] || 1, +match[4] || 0, +(match[5] || 0), +match[6] || 0, +match[7] || 0);
	    } else {
	      var hour = +match[4] || 0;
	
	      if (match[8].toUpperCase() !== 'Z') {
	        hour -= +match[8].slice(0, 3);
	      }
	
	      return new Date(Date.UTC(+match[1], +(match[2] || 1) - 1, +match[3] || 1, hour, +(match[5] || 0), +match[6] || 0, +match[7] || 0));
	    }
	  } else if (value == null) {
	    return new Date(NaN);
	  }
	
	  return new Date(Math.round(value));
	}
	
	exports.parseDate = parseDate;
	
	function quantity(val) {
	  return Math.pow(10, quantityExponent(val));
	}
	
	exports.quantity = quantity;
	
	function quantityExponent(val) {
	  if (val === 0) {
	    return 0;
	  }
	
	  var exp = Math.floor(Math.log(val) / Math.LN10);
	
	  if (val / Math.pow(10, exp) >= 10) {
	    exp++;
	  }
	
	  return exp;
	}
	
	exports.quantityExponent = quantityExponent;
	
	function nice(val, round) {
	  var exponent = quantityExponent(val);
	  var exp10 = Math.pow(10, exponent);
	  var f = val / exp10;
	  var nf;
	
	  if (round) {
	    if (f < 1.5) {
	      nf = 1;
	    } else if (f < 2.5) {
	      nf = 2;
	    } else if (f < 4) {
	      nf = 3;
	    } else if (f < 7) {
	      nf = 5;
	    } else {
	      nf = 10;
	    }
	  } else {
	    if (f < 1) {
	      nf = 1;
	    } else if (f < 2) {
	      nf = 2;
	    } else if (f < 3) {
	      nf = 3;
	    } else if (f < 5) {
	      nf = 5;
	    } else {
	      nf = 10;
	    }
	  }
	
	  val = nf * exp10;
	  return exponent >= -20 ? +val.toFixed(exponent < 0 ? -exponent : 0) : val;
	}
	
	exports.nice = nice;
	
	function quantile(ascArr, p) {
	  var H = (ascArr.length - 1) * p + 1;
	  var h = Math.floor(H);
	  var v = +ascArr[h - 1];
	  var e = H - h;
	  return e ? v + e * (ascArr[h] - v) : v;
	}
	
	exports.quantile = quantile;
	
	function reformIntervals(list) {
	  list.sort(function (a, b) {
	    return littleThan(a, b, 0) ? -1 : 1;
	  });
	  var curr = -Infinity;
	  var currClose = 1;
	
	  for (var i = 0; i < list.length;) {
	    var interval = list[i].interval;
	    var close_1 = list[i].close;
	
	    for (var lg = 0; lg < 2; lg++) {
	      if (interval[lg] <= curr) {
	        interval[lg] = curr;
	        close_1[lg] = !lg ? 1 - currClose : 1;
	      }
	
	      curr = interval[lg];
	      currClose = close_1[lg];
	    }
	
	    if (interval[0] === interval[1] && close_1[0] * close_1[1] !== 1) {
	      list.splice(i, 1);
	    } else {
	      i++;
	    }
	  }
	
	  return list;
	
	  function littleThan(a, b, lg) {
	    return a.interval[lg] < b.interval[lg] || a.interval[lg] === b.interval[lg] && (a.close[lg] - b.close[lg] === (!lg ? 1 : -1) || !lg && littleThan(a, b, 1));
	  }
	}
	
	exports.reformIntervals = reformIntervals;
	
	function numericToNumber(val) {
	  var valFloat = parseFloat(val);
	  return valFloat == val && (valFloat !== 0 || typeof val !== 'string' || val.indexOf('x') <= 0) ? valFloat : NaN;
	}
	
	exports.numericToNumber = numericToNumber;
	
	function isNumeric(val) {
	  return !isNaN(numericToNumber(val));
	}
	
	exports.isNumeric = isNumeric;
	
	function getRandomIdBase() {
	  return Math.round(Math.random() * 9);
	}
	
	exports.getRandomIdBase = getRandomIdBase;
	
	function getGreatestCommonDividor(a, b) {
	  if (b === 0) {
	    return a;
	  }
	
	  return getGreatestCommonDividor(b, a % b);
	}
	
	exports.getGreatestCommonDividor = getGreatestCommonDividor;
	
	function getLeastCommonMultiple(a, b) {
	  if (a == null) {
	    return b;
	  }
	
	  if (b == null) {
	    return a;
	  }
	
	  return a * b / getGreatestCommonDividor(a, b);
	}
	
	exports.getLeastCommonMultiple = getLeastCommonMultiple;

/***/ },
/* 10 */
/***/ function(module, exports, __webpack_require__) {

	
	/*
	* Licensed to the Apache Software Foundation (ASF) under one
	* or more contributor license agreements.  See the NOTICE file
	* distributed with this work for additional information
	* regarding copyright ownership.  The ASF licenses this file
	* to you under the Apache License, Version 2.0 (the
	* "License"); you may not use this file except in compliance
	* with the License.  You may obtain a copy of the License at
	*
	*   http://www.apache.org/licenses/LICENSE-2.0
	*
	* Unless required by applicable law or agreed to in writing,
	* software distributed under the License is distributed on an
	* "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
	* KIND, either express or implied.  See the License for the
	* specific language governing permissions and limitations
	* under the License.
	*/
	
	
	
	/**
	 * AUTO-GENERATED FILE. DO NOT MODIFY.
	 */
	
	"use strict";
	
	exports.__esModule = true;
	
	var tslib_1 = __webpack_require__(3);
	
	var zrUtil = __webpack_require__(1);
	
	var Model_1 = __webpack_require__(24);
	
	var componentUtil = __webpack_require__(41);
	
	var clazz_1 = __webpack_require__(28);
	
	var model_1 = __webpack_require__(4);
	
	var layout = __webpack_require__(30);
	
	var inner = model_1.makeInner();
	
	var ComponentModel = function (_super) {
	  tslib_1.__extends(ComponentModel, _super);
	
	  function ComponentModel(option, parentModel, ecModel) {
	    var _this = _super.call(this, option, parentModel, ecModel) || this;
	
	    _this.uid = componentUtil.getUID('ec_cpt_model');
	    return _this;
	  }
	
	  ComponentModel.prototype.init = function (option, parentModel, ecModel) {
	    this.mergeDefaultAndTheme(option, ecModel);
	  };
	
	  ComponentModel.prototype.mergeDefaultAndTheme = function (option, ecModel) {
	    var layoutMode = layout.fetchLayoutMode(this);
	    var inputPositionParams = layoutMode ? layout.getLayoutParams(option) : {};
	    var themeModel = ecModel.getTheme();
	    zrUtil.merge(option, themeModel.get(this.mainType));
	    zrUtil.merge(option, this.getDefaultOption());
	
	    if (layoutMode) {
	      layout.mergeLayoutParam(option, inputPositionParams, layoutMode);
	    }
	  };
	
	  ComponentModel.prototype.mergeOption = function (option, ecModel) {
	    zrUtil.merge(this.option, option, true);
	    var layoutMode = layout.fetchLayoutMode(this);
	
	    if (layoutMode) {
	      layout.mergeLayoutParam(this.option, option, layoutMode);
	    }
	  };
	
	  ComponentModel.prototype.optionUpdated = function (newCptOption, isInit) {};
	
	  ComponentModel.prototype.getDefaultOption = function () {
	    var ctor = this.constructor;
	
	    if (!clazz_1.isExtendedClass(ctor)) {
	      return ctor.defaultOption;
	    }
	
	    var fields = inner(this);
	
	    if (!fields.defaultOption) {
	      var optList = [];
	      var clz = ctor;
	
	      while (clz) {
	        var opt = clz.prototype.defaultOption;
	        opt && optList.push(opt);
	        clz = clz.superClass;
	      }
	
	      var defaultOption = {};
	
	      for (var i = optList.length - 1; i >= 0; i--) {
	        defaultOption = zrUtil.merge(defaultOption, optList[i], true);
	      }
	
	      fields.defaultOption = defaultOption;
	    }
	
	    return fields.defaultOption;
	  };
	
	  ComponentModel.prototype.getReferringComponents = function (mainType, opt) {
	    var indexKey = mainType + 'Index';
	    var idKey = mainType + 'Id';
	    return model_1.queryReferringComponents(this.ecModel, mainType, {
	      index: this.get(indexKey, true),
	      id: this.get(idKey, true)
	    }, opt);
	  };
	
	  ComponentModel.prototype.getBoxLayoutParams = function () {
	    var boxLayoutModel = this;
	    return {
	      left: boxLayoutModel.get('left'),
	      top: boxLayoutModel.get('top'),
	      right: boxLayoutModel.get('right'),
	      bottom: boxLayoutModel.get('bottom'),
	      width: boxLayoutModel.get('width'),
	      height: boxLayoutModel.get('height')
	    };
	  };
	
	  ComponentModel.protoInitialize = function () {
	    var proto = ComponentModel.prototype;
	    proto.type = 'component';
	    proto.id = '';
	    proto.name = '';
	    proto.mainType = '';
	    proto.subType = '';
	    proto.componentIndex = 0;
	  }();
	
	  return ComponentModel;
	}(Model_1["default"]);
	
	clazz_1.mountExtend(ComponentModel, Model_1["default"]);
	clazz_1.enableClassManagement(ComponentModel, {
	  registerWhenExtend: true
	});
	componentUtil.enableSubTypeDefaulter(ComponentModel);
	componentUtil.enableTopologicalTravel(ComponentModel, getDependencies);
	
	function getDependencies(componentType) {
	  var deps = [];
	  zrUtil.each(ComponentModel.getClassesByMainType(componentType), function (clz) {
	    deps = deps.concat(clz.dependencies || clz.prototype.dependencies || []);
	  });
	  deps = zrUtil.map(deps, function (type) {
	    return clazz_1.parseClassType(type).main;
	  });
	
	  if (componentType !== 'dataset' && zrUtil.indexOf(deps, 'dataset') <= 0) {
	    deps.unshift('dataset');
	  }
	
	  return deps;
	}
	
	exports["default"] = ComponentModel;

/***/ },
/* 11 */
/***/ function(module, exports) {

	"use strict";
	exports.__esModule = true;
	function create(x, y) {
	    if (x == null) {
	        x = 0;
	    }
	    if (y == null) {
	        y = 0;
	    }
	    return [x, y];
	}
	exports.create = create;
	function copy(out, v) {
	    out[0] = v[0];
	    out[1] = v[1];
	    return out;
	}
	exports.copy = copy;
	function clone(v) {
	    return [v[0], v[1]];
	}
	exports.clone = clone;
	function set(out, a, b) {
	    out[0] = a;
	    out[1] = b;
	    return out;
	}
	exports.set = set;
	function add(out, v1, v2) {
	    out[0] = v1[0] + v2[0];
	    out[1] = v1[1] + v2[1];
	    return out;
	}
	exports.add = add;
	function scaleAndAdd(out, v1, v2, a) {
	    out[0] = v1[0] + v2[0] * a;
	    out[1] = v1[1] + v2[1] * a;
	    return out;
	}
	exports.scaleAndAdd = scaleAndAdd;
	function sub(out, v1, v2) {
	    out[0] = v1[0] - v2[0];
	    out[1] = v1[1] - v2[1];
	    return out;
	}
	exports.sub = sub;
	function len(v) {
	    return Math.sqrt(lenSquare(v));
	}
	exports.len = len;
	exports.length = len;
	function lenSquare(v) {
	    return v[0] * v[0] + v[1] * v[1];
	}
	exports.lenSquare = lenSquare;
	exports.lengthSquare = lenSquare;
	function mul(out, v1, v2) {
	    out[0] = v1[0] * v2[0];
	    out[1] = v1[1] * v2[1];
	    return out;
	}
	exports.mul = mul;
	function div(out, v1, v2) {
	    out[0] = v1[0] / v2[0];
	    out[1] = v1[1] / v2[1];
	    return out;
	}
	exports.div = div;
	function dot(v1, v2) {
	    return v1[0] * v2[0] + v1[1] * v2[1];
	}
	exports.dot = dot;
	function scale(out, v, s) {
	    out[0] = v[0] * s;
	    out[1] = v[1] * s;
	    return out;
	}
	exports.scale = scale;
	function normalize(out, v) {
	    var d = len(v);
	    if (d === 0) {
	        out[0] = 0;
	        out[1] = 0;
	    }
	    else {
	        out[0] = v[0] / d;
	        out[1] = v[1] / d;
	    }
	    return out;
	}
	exports.normalize = normalize;
	function distance(v1, v2) {
	    return Math.sqrt((v1[0] - v2[0]) * (v1[0] - v2[0])
	        + (v1[1] - v2[1]) * (v1[1] - v2[1]));
	}
	exports.distance = distance;
	exports.dist = distance;
	function distanceSquare(v1, v2) {
	    return (v1[0] - v2[0]) * (v1[0] - v2[0])
	        + (v1[1] - v2[1]) * (v1[1] - v2[1]);
	}
	exports.distanceSquare = distanceSquare;
	exports.distSquare = distanceSquare;
	function negate(out, v) {
	    out[0] = -v[0];
	    out[1] = -v[1];
	    return out;
	}
	exports.negate = negate;
	function lerp(out, v1, v2, t) {
	    out[0] = v1[0] + t * (v2[0] - v1[0]);
	    out[1] = v1[1] + t * (v2[1] - v1[1]);
	    return out;
	}
	exports.lerp = lerp;
	function applyTransform(out, v, m) {
	    var x = v[0];
	    var y = v[1];
	    out[0] = m[0] * x + m[2] * y + m[4];
	    out[1] = m[1] * x + m[3] * y + m[5];
	    return out;
	}
	exports.applyTransform = applyTransform;
	function min(out, v1, v2) {
	    out[0] = Math.min(v1[0], v2[0]);
	    out[1] = Math.min(v1[1], v2[1]);
	    return out;
	}
	exports.min = min;
	function max(out, v1, v2) {
	    out[0] = Math.max(v1[0], v2[0]);
	    out[1] = Math.max(v1[1], v2[1]);
	    return out;
	}
	exports.max = max;


/***/ },
/* 12 */
/***/ function(module, exports, __webpack_require__) {

	
	/*
	* Licensed to the Apache Software Foundation (ASF) under one
	* or more contributor license agreements.  See the NOTICE file
	* distributed with this work for additional information
	* regarding copyright ownership.  The ASF licenses this file
	* to you under the Apache License, Version 2.0 (the
	* "License"); you may not use this file except in compliance
	* with the License.  You may obtain a copy of the License at
	*
	*   http://www.apache.org/licenses/LICENSE-2.0
	*
	* Unless required by applicable law or agreed to in writing,
	* software distributed under the License is distributed on an
	* "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
	* KIND, either express or implied.  See the License for the
	* specific language governing permissions and limitations
	* under the License.
	*/
	
	
	
	/**
	 * AUTO-GENERATED FILE. DO NOT MODIFY.
	 */
	
	"use strict";
	
	exports.__esModule = true;
	
	var util_1 = __webpack_require__(1);
	
	var ECHARTS_PREFIX = '[ECharts] ';
	var storedLogs = {};
	var hasConsole = typeof console !== 'undefined' && console.warn && console.log;
	
	function log(str) {
	  if (hasConsole) {
	    console.log(ECHARTS_PREFIX + str);
	  }
	}
	
	exports.log = log;
	
	function warn(str) {
	  if (hasConsole) {
	    console.warn(ECHARTS_PREFIX + str);
	  }
	}
	
	exports.warn = warn;
	
	function error(str) {
	  if (hasConsole) {
	    console.error(ECHARTS_PREFIX + str);
	  }
	}
	
	exports.error = error;
	
	function deprecateLog(str) {
	  if (false) {
	    if (storedLogs[str]) {
	      return;
	    }
	
	    if (hasConsole) {
	      storedLogs[str] = true;
	      console.warn(ECHARTS_PREFIX + 'DEPRECATED: ' + str);
	    }
	  }
	}
	
	exports.deprecateLog = deprecateLog;
	
	function deprecateReplaceLog(oldOpt, newOpt, scope) {
	  if (false) {
	    deprecateLog((scope ? "[" + scope + "]" : '') + (oldOpt + " is deprecated, use " + newOpt + " instead."));
	  }
	}
	
	exports.deprecateReplaceLog = deprecateReplaceLog;
	
	function consoleLog() {
	  var args = [];
	
	  for (var _i = 0; _i < arguments.length; _i++) {
	    args[_i] = arguments[_i];
	  }
	
	  if (false) {
	    if (typeof console !== 'undefined' && console.log) {
	      console.log.apply(console, args);
	    }
	  }
	}
	
	exports.consoleLog = consoleLog;
	
	function makePrintable() {
	  var hintInfo = [];
	
	  for (var _i = 0; _i < arguments.length; _i++) {
	    hintInfo[_i] = arguments[_i];
	  }
	
	  var msg = '';
	
	  if (false) {
	    var makePrintableStringIfPossible_1 = function (val) {
	      return val === void 0 ? 'undefined' : val === Infinity ? 'Infinity' : val === -Infinity ? '-Infinity' : util_1.eqNaN(val) ? 'NaN' : val instanceof Date ? 'Date(' + val.toISOString() + ')' : util_1.isFunction(val) ? 'function () { ... }' : util_1.isRegExp(val) ? val + '' : null;
	    };
	
	    msg = util_1.map(hintInfo, function (arg) {
	      if (util_1.isString(arg)) {
	        return arg;
	      } else {
	        var printableStr = makePrintableStringIfPossible_1(arg);
	
	        if (printableStr != null) {
	          return printableStr;
	        } else if (typeof JSON !== 'undefined' && JSON.stringify) {
	          try {
	            return JSON.stringify(arg, function (n, val) {
	              var printableStr = makePrintableStringIfPossible_1(val);
	              return printableStr == null ? val : printableStr;
	            });
	          } catch (err) {
	            return '?';
	          }
	        } else {
	          return '?';
	        }
	      }
	    }).join(' ');
	  }
	
	  return msg;
	}
	
	exports.makePrintable = makePrintable;
	
	function throwError(msg) {
	  throw new Error(msg);
	}
	
	exports.throwError = throwError;

/***/ },
/* 13 */
/***/ function(module, exports) {

	"use strict";
	exports.__esModule = true;
	var Browser = (function () {
	    function Browser() {
	        this.firefox = false;
	        this.ie = false;
	        this.edge = false;
	        this.weChat = false;
	    }
	    return Browser;
	}());
	var Env = (function () {
	    function Env() {
	        this.browser = new Browser();
	        this.node = false;
	        this.wxa = false;
	        this.worker = false;
	        this.canvasSupported = false;
	        this.svgSupported = false;
	        this.touchEventsSupported = false;
	        this.pointerEventsSupported = false;
	        this.domSupported = false;
	    }
	    return Env;
	}());
	var env = new Env();
	if (typeof wx === 'object' && typeof wx.getSystemInfoSync === 'function') {
	    env.wxa = true;
	    env.canvasSupported = true;
	    env.touchEventsSupported = true;
	}
	else if (typeof document === 'undefined' && typeof self !== 'undefined') {
	    env.worker = true;
	    env.canvasSupported = true;
	}
	else if (typeof navigator === 'undefined') {
	    env.node = true;
	    env.canvasSupported = true;
	    env.svgSupported = true;
	}
	else {
	    detect(navigator.userAgent, env);
	}
	function detect(ua, env) {
	    var browser = env.browser;
	    var firefox = ua.match(/Firefox\/([\d.]+)/);
	    var ie = ua.match(/MSIE\s([\d.]+)/)
	        || ua.match(/Trident\/.+?rv:(([\d.]+))/);
	    var edge = ua.match(/Edge\/([\d.]+)/);
	    var weChat = (/micromessenger/i).test(ua);
	    if (firefox) {
	        browser.firefox = true;
	        browser.version = firefox[1];
	    }
	    if (ie) {
	        browser.ie = true;
	        browser.version = ie[1];
	    }
	    if (edge) {
	        browser.edge = true;
	        browser.version = edge[1];
	    }
	    if (weChat) {
	        browser.weChat = true;
	    }
	    env.canvasSupported = !!document.createElement('canvas').getContext;
	    env.svgSupported = typeof SVGRect !== 'undefined';
	    env.touchEventsSupported = 'ontouchstart' in window && !browser.ie && !browser.edge;
	    env.pointerEventsSupported = 'onpointerdown' in window
	        && (browser.edge || (browser.ie && +browser.version >= 11));
	    env.domSupported = typeof document !== 'undefined';
	}
	exports["default"] = env;


/***/ },
/* 14 */
/***/ function(module, exports, __webpack_require__) {

	
	/*
	* Licensed to the Apache Software Foundation (ASF) under one
	* or more contributor license agreements.  See the NOTICE file
	* distributed with this work for additional information
	* regarding copyright ownership.  The ASF licenses this file
	* to you under the Apache License, Version 2.0 (the
	* "License"); you may not use this file except in compliance
	* with the License.  You may obtain a copy of the License at
	*
	*   http://www.apache.org/licenses/LICENSE-2.0
	*
	* Unless required by applicable law or agreed to in writing,
	* software distributed under the License is distributed on an
	* "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
	* KIND, either express or implied.  See the License for the
	* specific language governing permissions and limitations
	* under the License.
	*/
	
	
	
	/**
	 * AUTO-GENERATED FILE. DO NOT MODIFY.
	 */
	
	"use strict";
	
	exports.__esModule = true;
	
	__webpack_require__(84);
	
	__webpack_require__(134);
	
	__webpack_require__(133);

/***/ },
/* 15 */
/***/ function(module, exports, __webpack_require__) {

	
	/*
	* Licensed to the Apache Software Foundation (ASF) under one
	* or more contributor license agreements.  See the NOTICE file
	* distributed with this work for additional information
	* regarding copyright ownership.  The ASF licenses this file
	* to you under the Apache License, Version 2.0 (the
	* "License"); you may not use this file except in compliance
	* with the License.  You may obtain a copy of the License at
	*
	*   http://www.apache.org/licenses/LICENSE-2.0
	*
	* Unless required by applicable law or agreed to in writing,
	* software distributed under the License is distributed on an
	* "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
	* KIND, either express or implied.  See the License for the
	* specific language governing permissions and limitations
	* under the License.
	*/
	
	
	
	/**
	 * AUTO-GENERATED FILE. DO NOT MODIFY.
	 */
	
	"use strict";
	
	exports.__esModule = true;
	
	var tslib_1 = __webpack_require__(3);
	
	var zrUtil = __webpack_require__(1);
	
	var graphic = __webpack_require__(7);
	
	var innerStore_1 = __webpack_require__(21);
	
	var labelStyle_1 = __webpack_require__(20);
	
	var layout_1 = __webpack_require__(30);
	
	var Component_1 = __webpack_require__(10);
	
	var Component_2 = __webpack_require__(18);
	
	var format_1 = __webpack_require__(29);
	
	var TitleModel = function (_super) {
	  tslib_1.__extends(TitleModel, _super);
	
	  function TitleModel() {
	    var _this = _super !== null && _super.apply(this, arguments) || this;
	
	    _this.type = TitleModel.type;
	    _this.layoutMode = {
	      type: 'box',
	      ignoreSize: true
	    };
	    return _this;
	  }
	
	  TitleModel.type = 'title';
	  TitleModel.defaultOption = {
	    zlevel: 0,
	    z: 6,
	    show: true,
	    text: '',
	    target: 'blank',
	    subtext: '',
	    subtarget: 'blank',
	    left: 0,
	    top: 0,
	    backgroundColor: 'rgba(0,0,0,0)',
	    borderColor: '#ccc',
	    borderWidth: 0,
	    padding: 5,
	    itemGap: 10,
	    textStyle: {
	      fontSize: 18,
	      fontWeight: 'bold',
	      color: '#464646'
	    },
	    subtextStyle: {
	      fontSize: 12,
	      color: '#6E7079'
	    }
	  };
	  return TitleModel;
	}(Component_1["default"]);
	
	Component_1["default"].registerClass(TitleModel);
	
	var TitleView = function (_super) {
	  tslib_1.__extends(TitleView, _super);
	
	  function TitleView() {
	    var _this = _super !== null && _super.apply(this, arguments) || this;
	
	    _this.type = TitleView.type;
	    return _this;
	  }
	
	  TitleView.prototype.render = function (titleModel, ecModel, api) {
	    this.group.removeAll();
	
	    if (!titleModel.get('show')) {
	      return;
	    }
	
	    var group = this.group;
	    var textStyleModel = titleModel.getModel('textStyle');
	    var subtextStyleModel = titleModel.getModel('subtextStyle');
	    var textAlign = titleModel.get('textAlign');
	    var textVerticalAlign = zrUtil.retrieve2(titleModel.get('textBaseline'), titleModel.get('textVerticalAlign'));
	    var textEl = new graphic.Text({
	      style: labelStyle_1.createTextStyle(textStyleModel, {
	        text: titleModel.get('text'),
	        fill: textStyleModel.getTextColor()
	      }, {
	        disableBox: true
	      }),
	      z2: 10
	    });
	    var textRect = textEl.getBoundingRect();
	    var subText = titleModel.get('subtext');
	    var subTextEl = new graphic.Text({
	      style: labelStyle_1.createTextStyle(subtextStyleModel, {
	        text: subText,
	        fill: subtextStyleModel.getTextColor(),
	        y: textRect.height + titleModel.get('itemGap'),
	        verticalAlign: 'top'
	      }, {
	        disableBox: true
	      }),
	      z2: 10
	    });
	    var link = titleModel.get('link');
	    var sublink = titleModel.get('sublink');
	    var triggerEvent = titleModel.get('triggerEvent', true);
	    textEl.silent = !link && !triggerEvent;
	    subTextEl.silent = !sublink && !triggerEvent;
	
	    if (link) {
	      textEl.on('click', function () {
	        format_1.windowOpen(link, '_' + titleModel.get('target'));
	      });
	    }
	
	    if (sublink) {
	      subTextEl.on('click', function () {
	        format_1.windowOpen(sublink, '_' + titleModel.get('subtarget'));
	      });
	    }
	
	    innerStore_1.getECData(textEl).eventData = innerStore_1.getECData(subTextEl).eventData = triggerEvent ? {
	      componentType: 'title',
	      componentIndex: titleModel.componentIndex
	    } : null;
	    group.add(textEl);
	    subText && group.add(subTextEl);
	    var groupRect = group.getBoundingRect();
	    var layoutOption = titleModel.getBoxLayoutParams();
	    layoutOption.width = groupRect.width;
	    layoutOption.height = groupRect.height;
	    var layoutRect = layout_1.getLayoutRect(layoutOption, {
	      width: api.getWidth(),
	      height: api.getHeight()
	    }, titleModel.get('padding'));
	
	    if (!textAlign) {
	      textAlign = titleModel.get('left') || titleModel.get('right');
	
	      if (textAlign === 'middle') {
	        textAlign = 'center';
	      }
	
	      if (textAlign === 'right') {
	        layoutRect.x += layoutRect.width;
	      } else if (textAlign === 'center') {
	        layoutRect.x += layoutRect.width / 2;
	      }
	    }
	
	    if (!textVerticalAlign) {
	      textVerticalAlign = titleModel.get('top') || titleModel.get('bottom');
	
	      if (textVerticalAlign === 'center') {
	        textVerticalAlign = 'middle';
	      }
	
	      if (textVerticalAlign === 'bottom') {
	        layoutRect.y += layoutRect.height;
	      } else if (textVerticalAlign === 'middle') {
	        layoutRect.y += layoutRect.height / 2;
	      }
	
	      textVerticalAlign = textVerticalAlign || 'top';
	    }
	
	    group.x = layoutRect.x;
	    group.y = layoutRect.y;
	    group.markRedraw();
	    var alignStyle = {
	      align: textAlign,
	      verticalAlign: textVerticalAlign
	    };
	    textEl.setStyle(alignStyle);
	    subTextEl.setStyle(alignStyle);
	    groupRect = group.getBoundingRect();
	    var padding = layoutRect.margin;
	    var style = titleModel.getItemStyle(['color', 'opacity']);
	    style.fill = titleModel.get('backgroundColor');
	    var rect = new graphic.Rect({
	      shape: {
	        x: groupRect.x - padding[3],
	        y: groupRect.y - padding[0],
	        width: groupRect.width + padding[1] + padding[3],
	        height: groupRect.height + padding[0] + padding[2],
	        r: titleModel.get('borderRadius')
	      },
	      style: style,
	      subPixelOptimize: true,
	      silent: true
	    });
	    group.add(rect);
	  };
	
	  TitleView.type = 'title';
	  return TitleView;
	}(Component_2["default"]);
	
	Component_2["default"].registerClass(TitleView);

/***/ },
/* 16 */
/***/ function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;/*!
	 * jQuery JavaScript Library v3.5.1
	 * https://jquery.com/
	 *
	 * Includes Sizzle.js
	 * https://sizzlejs.com/
	 *
	 * Copyright JS Foundation and other contributors
	 * Released under the MIT license
	 * https://jquery.org/license
	 *
	 * Date: 2020-05-04T22:49Z
	 */
	( function( global, factory ) {
	
		"use strict";
	
		if ( typeof module === "object" && typeof module.exports === "object" ) {
	
			// For CommonJS and CommonJS-like environments where a proper `window`
			// is present, execute the factory and get jQuery.
			// For environments that do not have a `window` with a `document`
			// (such as Node.js), expose a factory as module.exports.
			// This accentuates the need for the creation of a real `window`.
			// e.g. var jQuery = require("jquery")(window);
			// See ticket #14549 for more info.
			module.exports = global.document ?
				factory( global, true ) :
				function( w ) {
					if ( !w.document ) {
						throw new Error( "jQuery requires a window with a document" );
					}
					return factory( w );
				};
		} else {
			factory( global );
		}
	
	// Pass this if window is not defined yet
	} )( typeof window !== "undefined" ? window : this, function( window, noGlobal ) {
	
	// Edge <= 12 - 13+, Firefox <=18 - 45+, IE 10 - 11, Safari 5.1 - 9+, iOS 6 - 9.1
	// throw exceptions when non-strict code (e.g., ASP.NET 4.5) accesses strict mode
	// arguments.callee.caller (trac-13335). But as of jQuery 3.0 (2016), strict mode should be common
	// enough that all such attempts are guarded in a try block.
	"use strict";
	
	var arr = [];
	
	var getProto = Object.getPrototypeOf;
	
	var slice = arr.slice;
	
	var flat = arr.flat ? function( array ) {
		return arr.flat.call( array );
	} : function( array ) {
		return arr.concat.apply( [], array );
	};
	
	
	var push = arr.push;
	
	var indexOf = arr.indexOf;
	
	var class2type = {};
	
	var toString = class2type.toString;
	
	var hasOwn = class2type.hasOwnProperty;
	
	var fnToString = hasOwn.toString;
	
	var ObjectFunctionString = fnToString.call( Object );
	
	var support = {};
	
	var isFunction = function isFunction( obj ) {
	
	      // Support: Chrome <=57, Firefox <=52
	      // In some browsers, typeof returns "function" for HTML <object> elements
	      // (i.e., `typeof document.createElement( "object" ) === "function"`).
	      // We don't want to classify *any* DOM node as a function.
	      return typeof obj === "function" && typeof obj.nodeType !== "number";
	  };
	
	
	var isWindow = function isWindow( obj ) {
			return obj != null && obj === obj.window;
		};
	
	
	var document = window.document;
	
	
	
		var preservedScriptAttributes = {
			type: true,
			src: true,
			nonce: true,
			noModule: true
		};
	
		function DOMEval( code, node, doc ) {
			doc = doc || document;
	
			var i, val,
				script = doc.createElement( "script" );
	
			script.text = code;
			if ( node ) {
				for ( i in preservedScriptAttributes ) {
	
					// Support: Firefox 64+, Edge 18+
					// Some browsers don't support the "nonce" property on scripts.
					// On the other hand, just using `getAttribute` is not enough as
					// the `nonce` attribute is reset to an empty string whenever it
					// becomes browsing-context connected.
					// See https://github.com/whatwg/html/issues/2369
					// See https://html.spec.whatwg.org/#nonce-attributes
					// The `node.getAttribute` check was added for the sake of
					// `jQuery.globalEval` so that it can fake a nonce-containing node
					// via an object.
					val = node[ i ] || node.getAttribute && node.getAttribute( i );
					if ( val ) {
						script.setAttribute( i, val );
					}
				}
			}
			doc.head.appendChild( script ).parentNode.removeChild( script );
		}
	
	
	function toType( obj ) {
		if ( obj == null ) {
			return obj + "";
		}
	
		// Support: Android <=2.3 only (functionish RegExp)
		return typeof obj === "object" || typeof obj === "function" ?
			class2type[ toString.call( obj ) ] || "object" :
			typeof obj;
	}
	/* global Symbol */
	// Defining this global in .eslintrc.json would create a danger of using the global
	// unguarded in another place, it seems safer to define global only for this module
	
	
	
	var
		version = "3.5.1",
	
		// Define a local copy of jQuery
		jQuery = function( selector, context ) {
	
			// The jQuery object is actually just the init constructor 'enhanced'
			// Need init if jQuery is called (just allow error to be thrown if not included)
			return new jQuery.fn.init( selector, context );
		};
	
	jQuery.fn = jQuery.prototype = {
	
		// The current version of jQuery being used
		jquery: version,
	
		constructor: jQuery,
	
		// The default length of a jQuery object is 0
		length: 0,
	
		toArray: function() {
			return slice.call( this );
		},
	
		// Get the Nth element in the matched element set OR
		// Get the whole matched element set as a clean array
		get: function( num ) {
	
			// Return all the elements in a clean array
			if ( num == null ) {
				return slice.call( this );
			}
	
			// Return just the one element from the set
			return num < 0 ? this[ num + this.length ] : this[ num ];
		},
	
		// Take an array of elements and push it onto the stack
		// (returning the new matched element set)
		pushStack: function( elems ) {
	
			// Build a new jQuery matched element set
			var ret = jQuery.merge( this.constructor(), elems );
	
			// Add the old object onto the stack (as a reference)
			ret.prevObject = this;
	
			// Return the newly-formed element set
			return ret;
		},
	
		// Execute a callback for every element in the matched set.
		each: function( callback ) {
			return jQuery.each( this, callback );
		},
	
		map: function( callback ) {
			return this.pushStack( jQuery.map( this, function( elem, i ) {
				return callback.call( elem, i, elem );
			} ) );
		},
	
		slice: function() {
			return this.pushStack( slice.apply( this, arguments ) );
		},
	
		first: function() {
			return this.eq( 0 );
		},
	
		last: function() {
			return this.eq( -1 );
		},
	
		even: function() {
			return this.pushStack( jQuery.grep( this, function( _elem, i ) {
				return ( i + 1 ) % 2;
			} ) );
		},
	
		odd: function() {
			return this.pushStack( jQuery.grep( this, function( _elem, i ) {
				return i % 2;
			} ) );
		},
	
		eq: function( i ) {
			var len = this.length,
				j = +i + ( i < 0 ? len : 0 );
			return this.pushStack( j >= 0 && j < len ? [ this[ j ] ] : [] );
		},
	
		end: function() {
			return this.prevObject || this.constructor();
		},
	
		// For internal use only.
		// Behaves like an Array's method, not like a jQuery method.
		push: push,
		sort: arr.sort,
		splice: arr.splice
	};
	
	jQuery.extend = jQuery.fn.extend = function() {
		var options, name, src, copy, copyIsArray, clone,
			target = arguments[ 0 ] || {},
			i = 1,
			length = arguments.length,
			deep = false;
	
		// Handle a deep copy situation
		if ( typeof target === "boolean" ) {
			deep = target;
	
			// Skip the boolean and the target
			target = arguments[ i ] || {};
			i++;
		}
	
		// Handle case when target is a string or something (possible in deep copy)
		if ( typeof target !== "object" && !isFunction( target ) ) {
			target = {};
		}
	
		// Extend jQuery itself if only one argument is passed
		if ( i === length ) {
			target = this;
			i--;
		}
	
		for ( ; i < length; i++ ) {
	
			// Only deal with non-null/undefined values
			if ( ( options = arguments[ i ] ) != null ) {
	
				// Extend the base object
				for ( name in options ) {
					copy = options[ name ];
	
					// Prevent Object.prototype pollution
					// Prevent never-ending loop
					if ( name === "__proto__" || target === copy ) {
						continue;
					}
	
					// Recurse if we're merging plain objects or arrays
					if ( deep && copy && ( jQuery.isPlainObject( copy ) ||
						( copyIsArray = Array.isArray( copy ) ) ) ) {
						src = target[ name ];
	
						// Ensure proper type for the source value
						if ( copyIsArray && !Array.isArray( src ) ) {
							clone = [];
						} else if ( !copyIsArray && !jQuery.isPlainObject( src ) ) {
							clone = {};
						} else {
							clone = src;
						}
						copyIsArray = false;
	
						// Never move original objects, clone them
						target[ name ] = jQuery.extend( deep, clone, copy );
	
					// Don't bring in undefined values
					} else if ( copy !== undefined ) {
						target[ name ] = copy;
					}
				}
			}
		}
	
		// Return the modified object
		return target;
	};
	
	jQuery.extend( {
	
		// Unique for each copy of jQuery on the page
		expando: "jQuery" + ( version + Math.random() ).replace( /\D/g, "" ),
	
		// Assume jQuery is ready without the ready module
		isReady: true,
	
		error: function( msg ) {
			throw new Error( msg );
		},
	
		noop: function() {},
	
		isPlainObject: function( obj ) {
			var proto, Ctor;
	
			// Detect obvious negatives
			// Use toString instead of jQuery.type to catch host objects
			if ( !obj || toString.call( obj ) !== "[object Object]" ) {
				return false;
			}
	
			proto = getProto( obj );
	
			// Objects with no prototype (e.g., `Object.create( null )`) are plain
			if ( !proto ) {
				return true;
			}
	
			// Objects with prototype are plain iff they were constructed by a global Object function
			Ctor = hasOwn.call( proto, "constructor" ) && proto.constructor;
			return typeof Ctor === "function" && fnToString.call( Ctor ) === ObjectFunctionString;
		},
	
		isEmptyObject: function( obj ) {
			var name;
	
			for ( name in obj ) {
				return false;
			}
			return true;
		},
	
		// Evaluates a script in a provided context; falls back to the global one
		// if not specified.
		globalEval: function( code, options, doc ) {
			DOMEval( code, { nonce: options && options.nonce }, doc );
		},
	
		each: function( obj, callback ) {
			var length, i = 0;
	
			if ( isArrayLike( obj ) ) {
				length = obj.length;
				for ( ; i < length; i++ ) {
					if ( callback.call( obj[ i ], i, obj[ i ] ) === false ) {
						break;
					}
				}
			} else {
				for ( i in obj ) {
					if ( callback.call( obj[ i ], i, obj[ i ] ) === false ) {
						break;
					}
				}
			}
	
			return obj;
		},
	
		// results is for internal usage only
		makeArray: function( arr, results ) {
			var ret = results || [];
	
			if ( arr != null ) {
				if ( isArrayLike( Object( arr ) ) ) {
					jQuery.merge( ret,
						typeof arr === "string" ?
						[ arr ] : arr
					);
				} else {
					push.call( ret, arr );
				}
			}
	
			return ret;
		},
	
		inArray: function( elem, arr, i ) {
			return arr == null ? -1 : indexOf.call( arr, elem, i );
		},
	
		// Support: Android <=4.0 only, PhantomJS 1 only
		// push.apply(_, arraylike) throws on ancient WebKit
		merge: function( first, second ) {
			var len = +second.length,
				j = 0,
				i = first.length;
	
			for ( ; j < len; j++ ) {
				first[ i++ ] = second[ j ];
			}
	
			first.length = i;
	
			return first;
		},
	
		grep: function( elems, callback, invert ) {
			var callbackInverse,
				matches = [],
				i = 0,
				length = elems.length,
				callbackExpect = !invert;
	
			// Go through the array, only saving the items
			// that pass the validator function
			for ( ; i < length; i++ ) {
				callbackInverse = !callback( elems[ i ], i );
				if ( callbackInverse !== callbackExpect ) {
					matches.push( elems[ i ] );
				}
			}
	
			return matches;
		},
	
		// arg is for internal usage only
		map: function( elems, callback, arg ) {
			var length, value,
				i = 0,
				ret = [];
	
			// Go through the array, translating each of the items to their new values
			if ( isArrayLike( elems ) ) {
				length = elems.length;
				for ( ; i < length; i++ ) {
					value = callback( elems[ i ], i, arg );
	
					if ( value != null ) {
						ret.push( value );
					}
				}
	
			// Go through every key on the object,
			} else {
				for ( i in elems ) {
					value = callback( elems[ i ], i, arg );
	
					if ( value != null ) {
						ret.push( value );
					}
				}
			}
	
			// Flatten any nested arrays
			return flat( ret );
		},
	
		// A global GUID counter for objects
		guid: 1,
	
		// jQuery.support is not used in Core but other projects attach their
		// properties to it so it needs to exist.
		support: support
	} );
	
	if ( typeof Symbol === "function" ) {
		jQuery.fn[ Symbol.iterator ] = arr[ Symbol.iterator ];
	}
	
	// Populate the class2type map
	jQuery.each( "Boolean Number String Function Array Date RegExp Object Error Symbol".split( " " ),
	function( _i, name ) {
		class2type[ "[object " + name + "]" ] = name.toLowerCase();
	} );
	
	function isArrayLike( obj ) {
	
		// Support: real iOS 8.2 only (not reproducible in simulator)
		// `in` check used to prevent JIT error (gh-2145)
		// hasOwn isn't used here due to false negatives
		// regarding Nodelist length in IE
		var length = !!obj && "length" in obj && obj.length,
			type = toType( obj );
	
		if ( isFunction( obj ) || isWindow( obj ) ) {
			return false;
		}
	
		return type === "array" || length === 0 ||
			typeof length === "number" && length > 0 && ( length - 1 ) in obj;
	}
	var Sizzle =
	/*!
	 * Sizzle CSS Selector Engine v2.3.5
	 * https://sizzlejs.com/
	 *
	 * Copyright JS Foundation and other contributors
	 * Released under the MIT license
	 * https://js.foundation/
	 *
	 * Date: 2020-03-14
	 */
	( function( window ) {
	var i,
		support,
		Expr,
		getText,
		isXML,
		tokenize,
		compile,
		select,
		outermostContext,
		sortInput,
		hasDuplicate,
	
		// Local document vars
		setDocument,
		document,
		docElem,
		documentIsHTML,
		rbuggyQSA,
		rbuggyMatches,
		matches,
		contains,
	
		// Instance-specific data
		expando = "sizzle" + 1 * new Date(),
		preferredDoc = window.document,
		dirruns = 0,
		done = 0,
		classCache = createCache(),
		tokenCache = createCache(),
		compilerCache = createCache(),
		nonnativeSelectorCache = createCache(),
		sortOrder = function( a, b ) {
			if ( a === b ) {
				hasDuplicate = true;
			}
			return 0;
		},
	
		// Instance methods
		hasOwn = ( {} ).hasOwnProperty,
		arr = [],
		pop = arr.pop,
		pushNative = arr.push,
		push = arr.push,
		slice = arr.slice,
	
		// Use a stripped-down indexOf as it's faster than native
		// https://jsperf.com/thor-indexof-vs-for/5
		indexOf = function( list, elem ) {
			var i = 0,
				len = list.length;
			for ( ; i < len; i++ ) {
				if ( list[ i ] === elem ) {
					return i;
				}
			}
			return -1;
		},
	
		booleans = "checked|selected|async|autofocus|autoplay|controls|defer|disabled|hidden|" +
			"ismap|loop|multiple|open|readonly|required|scoped",
	
		// Regular expressions
	
		// http://www.w3.org/TR/css3-selectors/#whitespace
		whitespace = "[\\x20\\t\\r\\n\\f]",
	
		// https://www.w3.org/TR/css-syntax-3/#ident-token-diagram
		identifier = "(?:\\\\[\\da-fA-F]{1,6}" + whitespace +
			"?|\\\\[^\\r\\n\\f]|[\\w-]|[^\0-\\x7f])+",
	
		// Attribute selectors: http://www.w3.org/TR/selectors/#attribute-selectors
		attributes = "\\[" + whitespace + "*(" + identifier + ")(?:" + whitespace +
	
			// Operator (capture 2)
			"*([*^$|!~]?=)" + whitespace +
	
			// "Attribute values must be CSS identifiers [capture 5]
			// or strings [capture 3 or capture 4]"
			"*(?:'((?:\\\\.|[^\\\\'])*)'|\"((?:\\\\.|[^\\\\\"])*)\"|(" + identifier + "))|)" +
			whitespace + "*\\]",
	
		pseudos = ":(" + identifier + ")(?:\\((" +
	
			// To reduce the number of selectors needing tokenize in the preFilter, prefer arguments:
			// 1. quoted (capture 3; capture 4 or capture 5)
			"('((?:\\\\.|[^\\\\'])*)'|\"((?:\\\\.|[^\\\\\"])*)\")|" +
	
			// 2. simple (capture 6)
			"((?:\\\\.|[^\\\\()[\\]]|" + attributes + ")*)|" +
	
			// 3. anything else (capture 2)
			".*" +
			")\\)|)",
	
		// Leading and non-escaped trailing whitespace, capturing some non-whitespace characters preceding the latter
		rwhitespace = new RegExp( whitespace + "+", "g" ),
		rtrim = new RegExp( "^" + whitespace + "+|((?:^|[^\\\\])(?:\\\\.)*)" +
			whitespace + "+$", "g" ),
	
		rcomma = new RegExp( "^" + whitespace + "*," + whitespace + "*" ),
		rcombinators = new RegExp( "^" + whitespace + "*([>+~]|" + whitespace + ")" + whitespace +
			"*" ),
		rdescend = new RegExp( whitespace + "|>" ),
	
		rpseudo = new RegExp( pseudos ),
		ridentifier = new RegExp( "^" + identifier + "$" ),
	
		matchExpr = {
			"ID": new RegExp( "^#(" + identifier + ")" ),
			"CLASS": new RegExp( "^\\.(" + identifier + ")" ),
			"TAG": new RegExp( "^(" + identifier + "|[*])" ),
			"ATTR": new RegExp( "^" + attributes ),
			"PSEUDO": new RegExp( "^" + pseudos ),
			"CHILD": new RegExp( "^:(only|first|last|nth|nth-last)-(child|of-type)(?:\\(" +
				whitespace + "*(even|odd|(([+-]|)(\\d*)n|)" + whitespace + "*(?:([+-]|)" +
				whitespace + "*(\\d+)|))" + whitespace + "*\\)|)", "i" ),
			"bool": new RegExp( "^(?:" + booleans + ")$", "i" ),
	
			// For use in libraries implementing .is()
			// We use this for POS matching in `select`
			"needsContext": new RegExp( "^" + whitespace +
				"*[>+~]|:(even|odd|eq|gt|lt|nth|first|last)(?:\\(" + whitespace +
				"*((?:-\\d)?\\d*)" + whitespace + "*\\)|)(?=[^-]|$)", "i" )
		},
	
		rhtml = /HTML$/i,
		rinputs = /^(?:input|select|textarea|button)$/i,
		rheader = /^h\d$/i,
	
		rnative = /^[^{]+\{\s*\[native \w/,
	
		// Easily-parseable/retrievable ID or TAG or CLASS selectors
		rquickExpr = /^(?:#([\w-]+)|(\w+)|\.([\w-]+))$/,
	
		rsibling = /[+~]/,
	
		// CSS escapes
		// http://www.w3.org/TR/CSS21/syndata.html#escaped-characters
		runescape = new RegExp( "\\\\[\\da-fA-F]{1,6}" + whitespace + "?|\\\\([^\\r\\n\\f])", "g" ),
		funescape = function( escape, nonHex ) {
			var high = "0x" + escape.slice( 1 ) - 0x10000;
	
			return nonHex ?
	
				// Strip the backslash prefix from a non-hex escape sequence
				nonHex :
	
				// Replace a hexadecimal escape sequence with the encoded Unicode code point
				// Support: IE <=11+
				// For values outside the Basic Multilingual Plane (BMP), manually construct a
				// surrogate pair
				high < 0 ?
					String.fromCharCode( high + 0x10000 ) :
					String.fromCharCode( high >> 10 | 0xD800, high & 0x3FF | 0xDC00 );
		},
	
		// CSS string/identifier serialization
		// https://drafts.csswg.org/cssom/#common-serializing-idioms
		rcssescape = /([\0-\x1f\x7f]|^-?\d)|^-$|[^\0-\x1f\x7f-\uFFFF\w-]/g,
		fcssescape = function( ch, asCodePoint ) {
			if ( asCodePoint ) {
	
				// U+0000 NULL becomes U+FFFD REPLACEMENT CHARACTER
				if ( ch === "\0" ) {
					return "\uFFFD";
				}
	
				// Control characters and (dependent upon position) numbers get escaped as code points
				return ch.slice( 0, -1 ) + "\\" +
					ch.charCodeAt( ch.length - 1 ).toString( 16 ) + " ";
			}
	
			// Other potentially-special ASCII characters get backslash-escaped
			return "\\" + ch;
		},
	
		// Used for iframes
		// See setDocument()
		// Removing the function wrapper causes a "Permission Denied"
		// error in IE
		unloadHandler = function() {
			setDocument();
		},
	
		inDisabledFieldset = addCombinator(
			function( elem ) {
				return elem.disabled === true && elem.nodeName.toLowerCase() === "fieldset";
			},
			{ dir: "parentNode", next: "legend" }
		);
	
	// Optimize for push.apply( _, NodeList )
	try {
		push.apply(
			( arr = slice.call( preferredDoc.childNodes ) ),
			preferredDoc.childNodes
		);
	
		// Support: Android<4.0
		// Detect silently failing push.apply
		// eslint-disable-next-line no-unused-expressions
		arr[ preferredDoc.childNodes.length ].nodeType;
	} catch ( e ) {
		push = { apply: arr.length ?
	
			// Leverage slice if possible
			function( target, els ) {
				pushNative.apply( target, slice.call( els ) );
			} :
	
			// Support: IE<9
			// Otherwise append directly
			function( target, els ) {
				var j = target.length,
					i = 0;
	
				// Can't trust NodeList.length
				while ( ( target[ j++ ] = els[ i++ ] ) ) {}
				target.length = j - 1;
			}
		};
	}
	
	function Sizzle( selector, context, results, seed ) {
		var m, i, elem, nid, match, groups, newSelector,
			newContext = context && context.ownerDocument,
	
			// nodeType defaults to 9, since context defaults to document
			nodeType = context ? context.nodeType : 9;
	
		results = results || [];
	
		// Return early from calls with invalid selector or context
		if ( typeof selector !== "string" || !selector ||
			nodeType !== 1 && nodeType !== 9 && nodeType !== 11 ) {
	
			return results;
		}
	
		// Try to shortcut find operations (as opposed to filters) in HTML documents
		if ( !seed ) {
			setDocument( context );
			context = context || document;
	
			if ( documentIsHTML ) {
	
				// If the selector is sufficiently simple, try using a "get*By*" DOM method
				// (excepting DocumentFragment context, where the methods don't exist)
				if ( nodeType !== 11 && ( match = rquickExpr.exec( selector ) ) ) {
	
					// ID selector
					if ( ( m = match[ 1 ] ) ) {
	
						// Document context
						if ( nodeType === 9 ) {
							if ( ( elem = context.getElementById( m ) ) ) {
	
								// Support: IE, Opera, Webkit
								// TODO: identify versions
								// getElementById can match elements by name instead of ID
								if ( elem.id === m ) {
									results.push( elem );
									return results;
								}
							} else {
								return results;
							}
	
						// Element context
						} else {
	
							// Support: IE, Opera, Webkit
							// TODO: identify versions
							// getElementById can match elements by name instead of ID
							if ( newContext && ( elem = newContext.getElementById( m ) ) &&
								contains( context, elem ) &&
								elem.id === m ) {
	
								results.push( elem );
								return results;
							}
						}
	
					// Type selector
					} else if ( match[ 2 ] ) {
						push.apply( results, context.getElementsByTagName( selector ) );
						return results;
	
					// Class selector
					} else if ( ( m = match[ 3 ] ) && support.getElementsByClassName &&
						context.getElementsByClassName ) {
	
						push.apply( results, context.getElementsByClassName( m ) );
						return results;
					}
				}
	
				// Take advantage of querySelectorAll
				if ( support.qsa &&
					!nonnativeSelectorCache[ selector + " " ] &&
					( !rbuggyQSA || !rbuggyQSA.test( selector ) ) &&
	
					// Support: IE 8 only
					// Exclude object elements
					( nodeType !== 1 || context.nodeName.toLowerCase() !== "object" ) ) {
	
					newSelector = selector;
					newContext = context;
	
					// qSA considers elements outside a scoping root when evaluating child or
					// descendant combinators, which is not what we want.
					// In such cases, we work around the behavior by prefixing every selector in the
					// list with an ID selector referencing the scope context.
					// The technique has to be used as well when a leading combinator is used
					// as such selectors are not recognized by querySelectorAll.
					// Thanks to Andrew Dupont for this technique.
					if ( nodeType === 1 &&
						( rdescend.test( selector ) || rcombinators.test( selector ) ) ) {
	
						// Expand context for sibling selectors
						newContext = rsibling.test( selector ) && testContext( context.parentNode ) ||
							context;
	
						// We can use :scope instead of the ID hack if the browser
						// supports it & if we're not changing the context.
						if ( newContext !== context || !support.scope ) {
	
							// Capture the context ID, setting it first if necessary
							if ( ( nid = context.getAttribute( "id" ) ) ) {
								nid = nid.replace( rcssescape, fcssescape );
							} else {
								context.setAttribute( "id", ( nid = expando ) );
							}
						}
	
						// Prefix every selector in the list
						groups = tokenize( selector );
						i = groups.length;
						while ( i-- ) {
							groups[ i ] = ( nid ? "#" + nid : ":scope" ) + " " +
								toSelector( groups[ i ] );
						}
						newSelector = groups.join( "," );
					}
	
					try {
						push.apply( results,
							newContext.querySelectorAll( newSelector )
						);
						return results;
					} catch ( qsaError ) {
						nonnativeSelectorCache( selector, true );
					} finally {
						if ( nid === expando ) {
							context.removeAttribute( "id" );
						}
					}
				}
			}
		}
	
		// All others
		return select( selector.replace( rtrim, "$1" ), context, results, seed );
	}
	
	/**
	 * Create key-value caches of limited size
	 * @returns {function(string, object)} Returns the Object data after storing it on itself with
	 *	property name the (space-suffixed) string and (if the cache is larger than Expr.cacheLength)
	 *	deleting the oldest entry
	 */
	function createCache() {
		var keys = [];
	
		function cache( key, value ) {
	
			// Use (key + " ") to avoid collision with native prototype properties (see Issue #157)
			if ( keys.push( key + " " ) > Expr.cacheLength ) {
	
				// Only keep the most recent entries
				delete cache[ keys.shift() ];
			}
			return ( cache[ key + " " ] = value );
		}
		return cache;
	}
	
	/**
	 * Mark a function for special use by Sizzle
	 * @param {Function} fn The function to mark
	 */
	function markFunction( fn ) {
		fn[ expando ] = true;
		return fn;
	}
	
	/**
	 * Support testing using an element
	 * @param {Function} fn Passed the created element and returns a boolean result
	 */
	function assert( fn ) {
		var el = document.createElement( "fieldset" );
	
		try {
			return !!fn( el );
		} catch ( e ) {
			return false;
		} finally {
	
			// Remove from its parent by default
			if ( el.parentNode ) {
				el.parentNode.removeChild( el );
			}
	
			// release memory in IE
			el = null;
		}
	}
	
	/**
	 * Adds the same handler for all of the specified attrs
	 * @param {String} attrs Pipe-separated list of attributes
	 * @param {Function} handler The method that will be applied
	 */
	function addHandle( attrs, handler ) {
		var arr = attrs.split( "|" ),
			i = arr.length;
	
		while ( i-- ) {
			Expr.attrHandle[ arr[ i ] ] = handler;
		}
	}
	
	/**
	 * Checks document order of two siblings
	 * @param {Element} a
	 * @param {Element} b
	 * @returns {Number} Returns less than 0 if a precedes b, greater than 0 if a follows b
	 */
	function siblingCheck( a, b ) {
		var cur = b && a,
			diff = cur && a.nodeType === 1 && b.nodeType === 1 &&
				a.sourceIndex - b.sourceIndex;
	
		// Use IE sourceIndex if available on both nodes
		if ( diff ) {
			return diff;
		}
	
		// Check if b follows a
		if ( cur ) {
			while ( ( cur = cur.nextSibling ) ) {
				if ( cur === b ) {
					return -1;
				}
			}
		}
	
		return a ? 1 : -1;
	}
	
	/**
	 * Returns a function to use in pseudos for input types
	 * @param {String} type
	 */
	function createInputPseudo( type ) {
		return function( elem ) {
			var name = elem.nodeName.toLowerCase();
			return name === "input" && elem.type === type;
		};
	}
	
	/**
	 * Returns a function to use in pseudos for buttons
	 * @param {String} type
	 */
	function createButtonPseudo( type ) {
		return function( elem ) {
			var name = elem.nodeName.toLowerCase();
			return ( name === "input" || name === "button" ) && elem.type === type;
		};
	}
	
	/**
	 * Returns a function to use in pseudos for :enabled/:disabled
	 * @param {Boolean} disabled true for :disabled; false for :enabled
	 */
	function createDisabledPseudo( disabled ) {
	
		// Known :disabled false positives: fieldset[disabled] > legend:nth-of-type(n+2) :can-disable
		return function( elem ) {
	
			// Only certain elements can match :enabled or :disabled
			// https://html.spec.whatwg.org/multipage/scripting.html#selector-enabled
			// https://html.spec.whatwg.org/multipage/scripting.html#selector-disabled
			if ( "form" in elem ) {
	
				// Check for inherited disabledness on relevant non-disabled elements:
				// * listed form-associated elements in a disabled fieldset
				//   https://html.spec.whatwg.org/multipage/forms.html#category-listed
				//   https://html.spec.whatwg.org/multipage/forms.html#concept-fe-disabled
				// * option elements in a disabled optgroup
				//   https://html.spec.whatwg.org/multipage/forms.html#concept-option-disabled
				// All such elements have a "form" property.
				if ( elem.parentNode && elem.disabled === false ) {
	
					// Option elements defer to a parent optgroup if present
					if ( "label" in elem ) {
						if ( "label" in elem.parentNode ) {
							return elem.parentNode.disabled === disabled;
						} else {
							return elem.disabled === disabled;
						}
					}
	
					// Support: IE 6 - 11
					// Use the isDisabled shortcut property to check for disabled fieldset ancestors
					return elem.isDisabled === disabled ||
	
						// Where there is no isDisabled, check manually
						/* jshint -W018 */
						elem.isDisabled !== !disabled &&
						inDisabledFieldset( elem ) === disabled;
				}
	
				return elem.disabled === disabled;
	
			// Try to winnow out elements that can't be disabled before trusting the disabled property.
			// Some victims get caught in our net (label, legend, menu, track), but it shouldn't
			// even exist on them, let alone have a boolean value.
			} else if ( "label" in elem ) {
				return elem.disabled === disabled;
			}
	
			// Remaining elements are neither :enabled nor :disabled
			return false;
		};
	}
	
	/**
	 * Returns a function to use in pseudos for positionals
	 * @param {Function} fn
	 */
	function createPositionalPseudo( fn ) {
		return markFunction( function( argument ) {
			argument = +argument;
			return markFunction( function( seed, matches ) {
				var j,
					matchIndexes = fn( [], seed.length, argument ),
					i = matchIndexes.length;
	
				// Match elements found at the specified indexes
				while ( i-- ) {
					if ( seed[ ( j = matchIndexes[ i ] ) ] ) {
						seed[ j ] = !( matches[ j ] = seed[ j ] );
					}
				}
			} );
		} );
	}
	
	/**
	 * Checks a node for validity as a Sizzle context
	 * @param {Element|Object=} context
	 * @returns {Element|Object|Boolean} The input node if acceptable, otherwise a falsy value
	 */
	function testContext( context ) {
		return context && typeof context.getElementsByTagName !== "undefined" && context;
	}
	
	// Expose support vars for convenience
	support = Sizzle.support = {};
	
	/**
	 * Detects XML nodes
	 * @param {Element|Object} elem An element or a document
	 * @returns {Boolean} True iff elem is a non-HTML XML node
	 */
	isXML = Sizzle.isXML = function( elem ) {
		var namespace = elem.namespaceURI,
			docElem = ( elem.ownerDocument || elem ).documentElement;
	
		// Support: IE <=8
		// Assume HTML when documentElement doesn't yet exist, such as inside loading iframes
		// https://bugs.jquery.com/ticket/4833
		return !rhtml.test( namespace || docElem && docElem.nodeName || "HTML" );
	};
	
	/**
	 * Sets document-related variables once based on the current document
	 * @param {Element|Object} [doc] An element or document object to use to set the document
	 * @returns {Object} Returns the current document
	 */
	setDocument = Sizzle.setDocument = function( node ) {
		var hasCompare, subWindow,
			doc = node ? node.ownerDocument || node : preferredDoc;
	
		// Return early if doc is invalid or already selected
		// Support: IE 11+, Edge 17 - 18+
		// IE/Edge sometimes throw a "Permission denied" error when strict-comparing
		// two documents; shallow comparisons work.
		// eslint-disable-next-line eqeqeq
		if ( doc == document || doc.nodeType !== 9 || !doc.documentElement ) {
			return document;
		}
	
		// Update global variables
		document = doc;
		docElem = document.documentElement;
		documentIsHTML = !isXML( document );
	
		// Support: IE 9 - 11+, Edge 12 - 18+
		// Accessing iframe documents after unload throws "permission denied" errors (jQuery #13936)
		// Support: IE 11+, Edge 17 - 18+
		// IE/Edge sometimes throw a "Permission denied" error when strict-comparing
		// two documents; shallow comparisons work.
		// eslint-disable-next-line eqeqeq
		if ( preferredDoc != document &&
			( subWindow = document.defaultView ) && subWindow.top !== subWindow ) {
	
			// Support: IE 11, Edge
			if ( subWindow.addEventListener ) {
				subWindow.addEventListener( "unload", unloadHandler, false );
	
			// Support: IE 9 - 10 only
			} else if ( subWindow.attachEvent ) {
				subWindow.attachEvent( "onunload", unloadHandler );
			}
		}
	
		// Support: IE 8 - 11+, Edge 12 - 18+, Chrome <=16 - 25 only, Firefox <=3.6 - 31 only,
		// Safari 4 - 5 only, Opera <=11.6 - 12.x only
		// IE/Edge & older browsers don't support the :scope pseudo-class.
		// Support: Safari 6.0 only
		// Safari 6.0 supports :scope but it's an alias of :root there.
		support.scope = assert( function( el ) {
			docElem.appendChild( el ).appendChild( document.createElement( "div" ) );
			return typeof el.querySelectorAll !== "undefined" &&
				!el.querySelectorAll( ":scope fieldset div" ).length;
		} );
	
		/* Attributes
		---------------------------------------------------------------------- */
	
		// Support: IE<8
		// Verify that getAttribute really returns attributes and not properties
		// (excepting IE8 booleans)
		support.attributes = assert( function( el ) {
			el.className = "i";
			return !el.getAttribute( "className" );
		} );
	
		/* getElement(s)By*
		---------------------------------------------------------------------- */
	
		// Check if getElementsByTagName("*") returns only elements
		support.getElementsByTagName = assert( function( el ) {
			el.appendChild( document.createComment( "" ) );
			return !el.getElementsByTagName( "*" ).length;
		} );
	
		// Support: IE<9
		support.getElementsByClassName = rnative.test( document.getElementsByClassName );
	
		// Support: IE<10
		// Check if getElementById returns elements by name
		// The broken getElementById methods don't pick up programmatically-set names,
		// so use a roundabout getElementsByName test
		support.getById = assert( function( el ) {
			docElem.appendChild( el ).id = expando;
			return !document.getElementsByName || !document.getElementsByName( expando ).length;
		} );
	
		// ID filter and find
		if ( support.getById ) {
			Expr.filter[ "ID" ] = function( id ) {
				var attrId = id.replace( runescape, funescape );
				return function( elem ) {
					return elem.getAttribute( "id" ) === attrId;
				};
			};
			Expr.find[ "ID" ] = function( id, context ) {
				if ( typeof context.getElementById !== "undefined" && documentIsHTML ) {
					var elem = context.getElementById( id );
					return elem ? [ elem ] : [];
				}
			};
		} else {
			Expr.filter[ "ID" ] =  function( id ) {
				var attrId = id.replace( runescape, funescape );
				return function( elem ) {
					var node = typeof elem.getAttributeNode !== "undefined" &&
						elem.getAttributeNode( "id" );
					return node && node.value === attrId;
				};
			};
	
			// Support: IE 6 - 7 only
			// getElementById is not reliable as a find shortcut
			Expr.find[ "ID" ] = function( id, context ) {
				if ( typeof context.getElementById !== "undefined" && documentIsHTML ) {
					var node, i, elems,
						elem = context.getElementById( id );
	
					if ( elem ) {
	
						// Verify the id attribute
						node = elem.getAttributeNode( "id" );
						if ( node && node.value === id ) {
							return [ elem ];
						}
	
						// Fall back on getElementsByName
						elems = context.getElementsByName( id );
						i = 0;
						while ( ( elem = elems[ i++ ] ) ) {
							node = elem.getAttributeNode( "id" );
							if ( node && node.value === id ) {
								return [ elem ];
							}
						}
					}
	
					return [];
				}
			};
		}
	
		// Tag
		Expr.find[ "TAG" ] = support.getElementsByTagName ?
			function( tag, context ) {
				if ( typeof context.getElementsByTagName !== "undefined" ) {
					return context.getElementsByTagName( tag );
	
				// DocumentFragment nodes don't have gEBTN
				} else if ( support.qsa ) {
					return context.querySelectorAll( tag );
				}
			} :
	
			function( tag, context ) {
				var elem,
					tmp = [],
					i = 0,
	
					// By happy coincidence, a (broken) gEBTN appears on DocumentFragment nodes too
					results = context.getElementsByTagName( tag );
	
				// Filter out possible comments
				if ( tag === "*" ) {
					while ( ( elem = results[ i++ ] ) ) {
						if ( elem.nodeType === 1 ) {
							tmp.push( elem );
						}
					}
	
					return tmp;
				}
				return results;
			};
	
		// Class
		Expr.find[ "CLASS" ] = support.getElementsByClassName && function( className, context ) {
			if ( typeof context.getElementsByClassName !== "undefined" && documentIsHTML ) {
				return context.getElementsByClassName( className );
			}
		};
	
		/* QSA/matchesSelector
		---------------------------------------------------------------------- */
	
		// QSA and matchesSelector support
	
		// matchesSelector(:active) reports false when true (IE9/Opera 11.5)
		rbuggyMatches = [];
	
		// qSa(:focus) reports false when true (Chrome 21)
		// We allow this because of a bug in IE8/9 that throws an error
		// whenever `document.activeElement` is accessed on an iframe
		// So, we allow :focus to pass through QSA all the time to avoid the IE error
		// See https://bugs.jquery.com/ticket/13378
		rbuggyQSA = [];
	
		if ( ( support.qsa = rnative.test( document.querySelectorAll ) ) ) {
	
			// Build QSA regex
			// Regex strategy adopted from Diego Perini
			assert( function( el ) {
	
				var input;
	
				// Select is set to empty string on purpose
				// This is to test IE's treatment of not explicitly
				// setting a boolean content attribute,
				// since its presence should be enough
				// https://bugs.jquery.com/ticket/12359
				docElem.appendChild( el ).innerHTML = "<a id='" + expando + "'></a>" +
					"<select id='" + expando + "-\r\\' msallowcapture=''>" +
					"<option selected=''></option></select>";
	
				// Support: IE8, Opera 11-12.16
				// Nothing should be selected when empty strings follow ^= or $= or *=
				// The test attribute must be unknown in Opera but "safe" for WinRT
				// https://msdn.microsoft.com/en-us/library/ie/hh465388.aspx#attribute_section
				if ( el.querySelectorAll( "[msallowcapture^='']" ).length ) {
					rbuggyQSA.push( "[*^$]=" + whitespace + "*(?:''|\"\")" );
				}
	
				// Support: IE8
				// Boolean attributes and "value" are not treated correctly
				if ( !el.querySelectorAll( "[selected]" ).length ) {
					rbuggyQSA.push( "\\[" + whitespace + "*(?:value|" + booleans + ")" );
				}
	
				// Support: Chrome<29, Android<4.4, Safari<7.0+, iOS<7.0+, PhantomJS<1.9.8+
				if ( !el.querySelectorAll( "[id~=" + expando + "-]" ).length ) {
					rbuggyQSA.push( "~=" );
				}
	
				// Support: IE 11+, Edge 15 - 18+
				// IE 11/Edge don't find elements on a `[name='']` query in some cases.
				// Adding a temporary attribute to the document before the selection works
				// around the issue.
				// Interestingly, IE 10 & older don't seem to have the issue.
				input = document.createElement( "input" );
				input.setAttribute( "name", "" );
				el.appendChild( input );
				if ( !el.querySelectorAll( "[name='']" ).length ) {
					rbuggyQSA.push( "\\[" + whitespace + "*name" + whitespace + "*=" +
						whitespace + "*(?:''|\"\")" );
				}
	
				// Webkit/Opera - :checked should return selected option elements
				// http://www.w3.org/TR/2011/REC-css3-selectors-20110929/#checked
				// IE8 throws error here and will not see later tests
				if ( !el.querySelectorAll( ":checked" ).length ) {
					rbuggyQSA.push( ":checked" );
				}
	
				// Support: Safari 8+, iOS 8+
				// https://bugs.webkit.org/show_bug.cgi?id=136851
				// In-page `selector#id sibling-combinator selector` fails
				if ( !el.querySelectorAll( "a#" + expando + "+*" ).length ) {
					rbuggyQSA.push( ".#.+[+~]" );
				}
	
				// Support: Firefox <=3.6 - 5 only
				// Old Firefox doesn't throw on a badly-escaped identifier.
				el.querySelectorAll( "\\\f" );
				rbuggyQSA.push( "[\\r\\n\\f]" );
			} );
	
			assert( function( el ) {
				el.innerHTML = "<a href='' disabled='disabled'></a>" +
					"<select disabled='disabled'><option/></select>";
	
				// Support: Windows 8 Native Apps
				// The type and name attributes are restricted during .innerHTML assignment
				var input = document.createElement( "input" );
				input.setAttribute( "type", "hidden" );
				el.appendChild( input ).setAttribute( "name", "D" );
	
				// Support: IE8
				// Enforce case-sensitivity of name attribute
				if ( el.querySelectorAll( "[name=d]" ).length ) {
					rbuggyQSA.push( "name" + whitespace + "*[*^$|!~]?=" );
				}
	
				// FF 3.5 - :enabled/:disabled and hidden elements (hidden elements are still enabled)
				// IE8 throws error here and will not see later tests
				if ( el.querySelectorAll( ":enabled" ).length !== 2 ) {
					rbuggyQSA.push( ":enabled", ":disabled" );
				}
	
				// Support: IE9-11+
				// IE's :disabled selector does not pick up the children of disabled fieldsets
				docElem.appendChild( el ).disabled = true;
				if ( el.querySelectorAll( ":disabled" ).length !== 2 ) {
					rbuggyQSA.push( ":enabled", ":disabled" );
				}
	
				// Support: Opera 10 - 11 only
				// Opera 10-11 does not throw on post-comma invalid pseudos
				el.querySelectorAll( "*,:x" );
				rbuggyQSA.push( ",.*:" );
			} );
		}
	
		if ( ( support.matchesSelector = rnative.test( ( matches = docElem.matches ||
			docElem.webkitMatchesSelector ||
			docElem.mozMatchesSelector ||
			docElem.oMatchesSelector ||
			docElem.msMatchesSelector ) ) ) ) {
	
			assert( function( el ) {
	
				// Check to see if it's possible to do matchesSelector
				// on a disconnected node (IE 9)
				support.disconnectedMatch = matches.call( el, "*" );
	
				// This should fail with an exception
				// Gecko does not error, returns false instead
				matches.call( el, "[s!='']:x" );
				rbuggyMatches.push( "!=", pseudos );
			} );
		}
	
		rbuggyQSA = rbuggyQSA.length && new RegExp( rbuggyQSA.join( "|" ) );
		rbuggyMatches = rbuggyMatches.length && new RegExp( rbuggyMatches.join( "|" ) );
	
		/* Contains
		---------------------------------------------------------------------- */
		hasCompare = rnative.test( docElem.compareDocumentPosition );
	
		// Element contains another
		// Purposefully self-exclusive
		// As in, an element does not contain itself
		contains = hasCompare || rnative.test( docElem.contains ) ?
			function( a, b ) {
				var adown = a.nodeType === 9 ? a.documentElement : a,
					bup = b && b.parentNode;
				return a === bup || !!( bup && bup.nodeType === 1 && (
					adown.contains ?
						adown.contains( bup ) :
						a.compareDocumentPosition && a.compareDocumentPosition( bup ) & 16
				) );
			} :
			function( a, b ) {
				if ( b ) {
					while ( ( b = b.parentNode ) ) {
						if ( b === a ) {
							return true;
						}
					}
				}
				return false;
			};
	
		/* Sorting
		---------------------------------------------------------------------- */
	
		// Document order sorting
		sortOrder = hasCompare ?
		function( a, b ) {
	
			// Flag for duplicate removal
			if ( a === b ) {
				hasDuplicate = true;
				return 0;
			}
	
			// Sort on method existence if only one input has compareDocumentPosition
			var compare = !a.compareDocumentPosition - !b.compareDocumentPosition;
			if ( compare ) {
				return compare;
			}
	
			// Calculate position if both inputs belong to the same document
			// Support: IE 11+, Edge 17 - 18+
			// IE/Edge sometimes throw a "Permission denied" error when strict-comparing
			// two documents; shallow comparisons work.
			// eslint-disable-next-line eqeqeq
			compare = ( a.ownerDocument || a ) == ( b.ownerDocument || b ) ?
				a.compareDocumentPosition( b ) :
	
				// Otherwise we know they are disconnected
				1;
	
			// Disconnected nodes
			if ( compare & 1 ||
				( !support.sortDetached && b.compareDocumentPosition( a ) === compare ) ) {
	
				// Choose the first element that is related to our preferred document
				// Support: IE 11+, Edge 17 - 18+
				// IE/Edge sometimes throw a "Permission denied" error when strict-comparing
				// two documents; shallow comparisons work.
				// eslint-disable-next-line eqeqeq
				if ( a == document || a.ownerDocument == preferredDoc &&
					contains( preferredDoc, a ) ) {
					return -1;
				}
	
				// Support: IE 11+, Edge 17 - 18+
				// IE/Edge sometimes throw a "Permission denied" error when strict-comparing
				// two documents; shallow comparisons work.
				// eslint-disable-next-line eqeqeq
				if ( b == document || b.ownerDocument == preferredDoc &&
					contains( preferredDoc, b ) ) {
					return 1;
				}
	
				// Maintain original order
				return sortInput ?
					( indexOf( sortInput, a ) - indexOf( sortInput, b ) ) :
					0;
			}
	
			return compare & 4 ? -1 : 1;
		} :
		function( a, b ) {
	
			// Exit early if the nodes are identical
			if ( a === b ) {
				hasDuplicate = true;
				return 0;
			}
	
			var cur,
				i = 0,
				aup = a.parentNode,
				bup = b.parentNode,
				ap = [ a ],
				bp = [ b ];
	
			// Parentless nodes are either documents or disconnected
			if ( !aup || !bup ) {
	
				// Support: IE 11+, Edge 17 - 18+
				// IE/Edge sometimes throw a "Permission denied" error when strict-comparing
				// two documents; shallow comparisons work.
				/* eslint-disable eqeqeq */
				return a == document ? -1 :
					b == document ? 1 :
					/* eslint-enable eqeqeq */
					aup ? -1 :
					bup ? 1 :
					sortInput ?
					( indexOf( sortInput, a ) - indexOf( sortInput, b ) ) :
					0;
	
			// If the nodes are siblings, we can do a quick check
			} else if ( aup === bup ) {
				return siblingCheck( a, b );
			}
	
			// Otherwise we need full lists of their ancestors for comparison
			cur = a;
			while ( ( cur = cur.parentNode ) ) {
				ap.unshift( cur );
			}
			cur = b;
			while ( ( cur = cur.parentNode ) ) {
				bp.unshift( cur );
			}
	
			// Walk down the tree looking for a discrepancy
			while ( ap[ i ] === bp[ i ] ) {
				i++;
			}
	
			return i ?
	
				// Do a sibling check if the nodes have a common ancestor
				siblingCheck( ap[ i ], bp[ i ] ) :
	
				// Otherwise nodes in our document sort first
				// Support: IE 11+, Edge 17 - 18+
				// IE/Edge sometimes throw a "Permission denied" error when strict-comparing
				// two documents; shallow comparisons work.
				/* eslint-disable eqeqeq */
				ap[ i ] == preferredDoc ? -1 :
				bp[ i ] == preferredDoc ? 1 :
				/* eslint-enable eqeqeq */
				0;
		};
	
		return document;
	};
	
	Sizzle.matches = function( expr, elements ) {
		return Sizzle( expr, null, null, elements );
	};
	
	Sizzle.matchesSelector = function( elem, expr ) {
		setDocument( elem );
	
		if ( support.matchesSelector && documentIsHTML &&
			!nonnativeSelectorCache[ expr + " " ] &&
			( !rbuggyMatches || !rbuggyMatches.test( expr ) ) &&
			( !rbuggyQSA     || !rbuggyQSA.test( expr ) ) ) {
	
			try {
				var ret = matches.call( elem, expr );
	
				// IE 9's matchesSelector returns false on disconnected nodes
				if ( ret || support.disconnectedMatch ||
	
					// As well, disconnected nodes are said to be in a document
					// fragment in IE 9
					elem.document && elem.document.nodeType !== 11 ) {
					return ret;
				}
			} catch ( e ) {
				nonnativeSelectorCache( expr, true );
			}
		}
	
		return Sizzle( expr, document, null, [ elem ] ).length > 0;
	};
	
	Sizzle.contains = function( context, elem ) {
	
		// Set document vars if needed
		// Support: IE 11+, Edge 17 - 18+
		// IE/Edge sometimes throw a "Permission denied" error when strict-comparing
		// two documents; shallow comparisons work.
		// eslint-disable-next-line eqeqeq
		if ( ( context.ownerDocument || context ) != document ) {
			setDocument( context );
		}
		return contains( context, elem );
	};
	
	Sizzle.attr = function( elem, name ) {
	
		// Set document vars if needed
		// Support: IE 11+, Edge 17 - 18+
		// IE/Edge sometimes throw a "Permission denied" error when strict-comparing
		// two documents; shallow comparisons work.
		// eslint-disable-next-line eqeqeq
		if ( ( elem.ownerDocument || elem ) != document ) {
			setDocument( elem );
		}
	
		var fn = Expr.attrHandle[ name.toLowerCase() ],
	
			// Don't get fooled by Object.prototype properties (jQuery #13807)
			val = fn && hasOwn.call( Expr.attrHandle, name.toLowerCase() ) ?
				fn( elem, name, !documentIsHTML ) :
				undefined;
	
		return val !== undefined ?
			val :
			support.attributes || !documentIsHTML ?
				elem.getAttribute( name ) :
				( val = elem.getAttributeNode( name ) ) && val.specified ?
					val.value :
					null;
	};
	
	Sizzle.escape = function( sel ) {
		return ( sel + "" ).replace( rcssescape, fcssescape );
	};
	
	Sizzle.error = function( msg ) {
		throw new Error( "Syntax error, unrecognized expression: " + msg );
	};
	
	/**
	 * Document sorting and removing duplicates
	 * @param {ArrayLike} results
	 */
	Sizzle.uniqueSort = function( results ) {
		var elem,
			duplicates = [],
			j = 0,
			i = 0;
	
		// Unless we *know* we can detect duplicates, assume their presence
		hasDuplicate = !support.detectDuplicates;
		sortInput = !support.sortStable && results.slice( 0 );
		results.sort( sortOrder );
	
		if ( hasDuplicate ) {
			while ( ( elem = results[ i++ ] ) ) {
				if ( elem === results[ i ] ) {
					j = duplicates.push( i );
				}
			}
			while ( j-- ) {
				results.splice( duplicates[ j ], 1 );
			}
		}
	
		// Clear input after sorting to release objects
		// See https://github.com/jquery/sizzle/pull/225
		sortInput = null;
	
		return results;
	};
	
	/**
	 * Utility function for retrieving the text value of an array of DOM nodes
	 * @param {Array|Element} elem
	 */
	getText = Sizzle.getText = function( elem ) {
		var node,
			ret = "",
			i = 0,
			nodeType = elem.nodeType;
	
		if ( !nodeType ) {
	
			// If no nodeType, this is expected to be an array
			while ( ( node = elem[ i++ ] ) ) {
	
				// Do not traverse comment nodes
				ret += getText( node );
			}
		} else if ( nodeType === 1 || nodeType === 9 || nodeType === 11 ) {
	
			// Use textContent for elements
			// innerText usage removed for consistency of new lines (jQuery #11153)
			if ( typeof elem.textContent === "string" ) {
				return elem.textContent;
			} else {
	
				// Traverse its children
				for ( elem = elem.firstChild; elem; elem = elem.nextSibling ) {
					ret += getText( elem );
				}
			}
		} else if ( nodeType === 3 || nodeType === 4 ) {
			return elem.nodeValue;
		}
	
		// Do not include comment or processing instruction nodes
	
		return ret;
	};
	
	Expr = Sizzle.selectors = {
	
		// Can be adjusted by the user
		cacheLength: 50,
	
		createPseudo: markFunction,
	
		match: matchExpr,
	
		attrHandle: {},
	
		find: {},
	
		relative: {
			">": { dir: "parentNode", first: true },
			" ": { dir: "parentNode" },
			"+": { dir: "previousSibling", first: true },
			"~": { dir: "previousSibling" }
		},
	
		preFilter: {
			"ATTR": function( match ) {
				match[ 1 ] = match[ 1 ].replace( runescape, funescape );
	
				// Move the given value to match[3] whether quoted or unquoted
				match[ 3 ] = ( match[ 3 ] || match[ 4 ] ||
					match[ 5 ] || "" ).replace( runescape, funescape );
	
				if ( match[ 2 ] === "~=" ) {
					match[ 3 ] = " " + match[ 3 ] + " ";
				}
	
				return match.slice( 0, 4 );
			},
	
			"CHILD": function( match ) {
	
				/* matches from matchExpr["CHILD"]
					1 type (only|nth|...)
					2 what (child|of-type)
					3 argument (even|odd|\d*|\d*n([+-]\d+)?|...)
					4 xn-component of xn+y argument ([+-]?\d*n|)
					5 sign of xn-component
					6 x of xn-component
					7 sign of y-component
					8 y of y-component
				*/
				match[ 1 ] = match[ 1 ].toLowerCase();
	
				if ( match[ 1 ].slice( 0, 3 ) === "nth" ) {
	
					// nth-* requires argument
					if ( !match[ 3 ] ) {
						Sizzle.error( match[ 0 ] );
					}
	
					// numeric x and y parameters for Expr.filter.CHILD
					// remember that false/true cast respectively to 0/1
					match[ 4 ] = +( match[ 4 ] ?
						match[ 5 ] + ( match[ 6 ] || 1 ) :
						2 * ( match[ 3 ] === "even" || match[ 3 ] === "odd" ) );
					match[ 5 ] = +( ( match[ 7 ] + match[ 8 ] ) || match[ 3 ] === "odd" );
	
					// other types prohibit arguments
				} else if ( match[ 3 ] ) {
					Sizzle.error( match[ 0 ] );
				}
	
				return match;
			},
	
			"PSEUDO": function( match ) {
				var excess,
					unquoted = !match[ 6 ] && match[ 2 ];
	
				if ( matchExpr[ "CHILD" ].test( match[ 0 ] ) ) {
					return null;
				}
	
				// Accept quoted arguments as-is
				if ( match[ 3 ] ) {
					match[ 2 ] = match[ 4 ] || match[ 5 ] || "";
	
				// Strip excess characters from unquoted arguments
				} else if ( unquoted && rpseudo.test( unquoted ) &&
	
					// Get excess from tokenize (recursively)
					( excess = tokenize( unquoted, true ) ) &&
	
					// advance to the next closing parenthesis
					( excess = unquoted.indexOf( ")", unquoted.length - excess ) - unquoted.length ) ) {
	
					// excess is a negative index
					match[ 0 ] = match[ 0 ].slice( 0, excess );
					match[ 2 ] = unquoted.slice( 0, excess );
				}
	
				// Return only captures needed by the pseudo filter method (type and argument)
				return match.slice( 0, 3 );
			}
		},
	
		filter: {
	
			"TAG": function( nodeNameSelector ) {
				var nodeName = nodeNameSelector.replace( runescape, funescape ).toLowerCase();
				return nodeNameSelector === "*" ?
					function() {
						return true;
					} :
					function( elem ) {
						return elem.nodeName && elem.nodeName.toLowerCase() === nodeName;
					};
			},
	
			"CLASS": function( className ) {
				var pattern = classCache[ className + " " ];
	
				return pattern ||
					( pattern = new RegExp( "(^|" + whitespace +
						")" + className + "(" + whitespace + "|$)" ) ) && classCache(
							className, function( elem ) {
								return pattern.test(
									typeof elem.className === "string" && elem.className ||
									typeof elem.getAttribute !== "undefined" &&
										elem.getAttribute( "class" ) ||
									""
								);
					} );
			},
	
			"ATTR": function( name, operator, check ) {
				return function( elem ) {
					var result = Sizzle.attr( elem, name );
	
					if ( result == null ) {
						return operator === "!=";
					}
					if ( !operator ) {
						return true;
					}
	
					result += "";
	
					/* eslint-disable max-len */
	
					return operator === "=" ? result === check :
						operator === "!=" ? result !== check :
						operator === "^=" ? check && result.indexOf( check ) === 0 :
						operator === "*=" ? check && result.indexOf( check ) > -1 :
						operator === "$=" ? check && result.slice( -check.length ) === check :
						operator === "~=" ? ( " " + result.replace( rwhitespace, " " ) + " " ).indexOf( check ) > -1 :
						operator === "|=" ? result === check || result.slice( 0, check.length + 1 ) === check + "-" :
						false;
					/* eslint-enable max-len */
	
				};
			},
	
			"CHILD": function( type, what, _argument, first, last ) {
				var simple = type.slice( 0, 3 ) !== "nth",
					forward = type.slice( -4 ) !== "last",
					ofType = what === "of-type";
	
				return first === 1 && last === 0 ?
	
					// Shortcut for :nth-*(n)
					function( elem ) {
						return !!elem.parentNode;
					} :
	
					function( elem, _context, xml ) {
						var cache, uniqueCache, outerCache, node, nodeIndex, start,
							dir = simple !== forward ? "nextSibling" : "previousSibling",
							parent = elem.parentNode,
							name = ofType && elem.nodeName.toLowerCase(),
							useCache = !xml && !ofType,
							diff = false;
	
						if ( parent ) {
	
							// :(first|last|only)-(child|of-type)
							if ( simple ) {
								while ( dir ) {
									node = elem;
									while ( ( node = node[ dir ] ) ) {
										if ( ofType ?
											node.nodeName.toLowerCase() === name :
											node.nodeType === 1 ) {
	
											return false;
										}
									}
	
									// Reverse direction for :only-* (if we haven't yet done so)
									start = dir = type === "only" && !start && "nextSibling";
								}
								return true;
							}
	
							start = [ forward ? parent.firstChild : parent.lastChild ];
	
							// non-xml :nth-child(...) stores cache data on `parent`
							if ( forward && useCache ) {
	
								// Seek `elem` from a previously-cached index
	
								// ...in a gzip-friendly way
								node = parent;
								outerCache = node[ expando ] || ( node[ expando ] = {} );
	
								// Support: IE <9 only
								// Defend against cloned attroperties (jQuery gh-1709)
								uniqueCache = outerCache[ node.uniqueID ] ||
									( outerCache[ node.uniqueID ] = {} );
	
								cache = uniqueCache[ type ] || [];
								nodeIndex = cache[ 0 ] === dirruns && cache[ 1 ];
								diff = nodeIndex && cache[ 2 ];
								node = nodeIndex && parent.childNodes[ nodeIndex ];
	
								while ( ( node = ++nodeIndex && node && node[ dir ] ||
	
									// Fallback to seeking `elem` from the start
									( diff = nodeIndex = 0 ) || start.pop() ) ) {
	
									// When found, cache indexes on `parent` and break
									if ( node.nodeType === 1 && ++diff && node === elem ) {
										uniqueCache[ type ] = [ dirruns, nodeIndex, diff ];
										break;
									}
								}
	
							} else {
	
								// Use previously-cached element index if available
								if ( useCache ) {
	
									// ...in a gzip-friendly way
									node = elem;
									outerCache = node[ expando ] || ( node[ expando ] = {} );
	
									// Support: IE <9 only
									// Defend against cloned attroperties (jQuery gh-1709)
									uniqueCache = outerCache[ node.uniqueID ] ||
										( outerCache[ node.uniqueID ] = {} );
	
									cache = uniqueCache[ type ] || [];
									nodeIndex = cache[ 0 ] === dirruns && cache[ 1 ];
									diff = nodeIndex;
								}
	
								// xml :nth-child(...)
								// or :nth-last-child(...) or :nth(-last)?-of-type(...)
								if ( diff === false ) {
	
									// Use the same loop as above to seek `elem` from the start
									while ( ( node = ++nodeIndex && node && node[ dir ] ||
										( diff = nodeIndex = 0 ) || start.pop() ) ) {
	
										if ( ( ofType ?
											node.nodeName.toLowerCase() === name :
											node.nodeType === 1 ) &&
											++diff ) {
	
											// Cache the index of each encountered element
											if ( useCache ) {
												outerCache = node[ expando ] ||
													( node[ expando ] = {} );
	
												// Support: IE <9 only
												// Defend against cloned attroperties (jQuery gh-1709)
												uniqueCache = outerCache[ node.uniqueID ] ||
													( outerCache[ node.uniqueID ] = {} );
	
												uniqueCache[ type ] = [ dirruns, diff ];
											}
	
											if ( node === elem ) {
												break;
											}
										}
									}
								}
							}
	
							// Incorporate the offset, then check against cycle size
							diff -= last;
							return diff === first || ( diff % first === 0 && diff / first >= 0 );
						}
					};
			},
	
			"PSEUDO": function( pseudo, argument ) {
	
				// pseudo-class names are case-insensitive
				// http://www.w3.org/TR/selectors/#pseudo-classes
				// Prioritize by case sensitivity in case custom pseudos are added with uppercase letters
				// Remember that setFilters inherits from pseudos
				var args,
					fn = Expr.pseudos[ pseudo ] || Expr.setFilters[ pseudo.toLowerCase() ] ||
						Sizzle.error( "unsupported pseudo: " + pseudo );
	
				// The user may use createPseudo to indicate that
				// arguments are needed to create the filter function
				// just as Sizzle does
				if ( fn[ expando ] ) {
					return fn( argument );
				}
	
				// But maintain support for old signatures
				if ( fn.length > 1 ) {
					args = [ pseudo, pseudo, "", argument ];
					return Expr.setFilters.hasOwnProperty( pseudo.toLowerCase() ) ?
						markFunction( function( seed, matches ) {
							var idx,
								matched = fn( seed, argument ),
								i = matched.length;
							while ( i-- ) {
								idx = indexOf( seed, matched[ i ] );
								seed[ idx ] = !( matches[ idx ] = matched[ i ] );
							}
						} ) :
						function( elem ) {
							return fn( elem, 0, args );
						};
				}
	
				return fn;
			}
		},
	
		pseudos: {
	
			// Potentially complex pseudos
			"not": markFunction( function( selector ) {
	
				// Trim the selector passed to compile
				// to avoid treating leading and trailing
				// spaces as combinators
				var input = [],
					results = [],
					matcher = compile( selector.replace( rtrim, "$1" ) );
	
				return matcher[ expando ] ?
					markFunction( function( seed, matches, _context, xml ) {
						var elem,
							unmatched = matcher( seed, null, xml, [] ),
							i = seed.length;
	
						// Match elements unmatched by `matcher`
						while ( i-- ) {
							if ( ( elem = unmatched[ i ] ) ) {
								seed[ i ] = !( matches[ i ] = elem );
							}
						}
					} ) :
					function( elem, _context, xml ) {
						input[ 0 ] = elem;
						matcher( input, null, xml, results );
	
						// Don't keep the element (issue #299)
						input[ 0 ] = null;
						return !results.pop();
					};
			} ),
	
			"has": markFunction( function( selector ) {
				return function( elem ) {
					return Sizzle( selector, elem ).length > 0;
				};
			} ),
	
			"contains": markFunction( function( text ) {
				text = text.replace( runescape, funescape );
				return function( elem ) {
					return ( elem.textContent || getText( elem ) ).indexOf( text ) > -1;
				};
			} ),
	
			// "Whether an element is represented by a :lang() selector
			// is based solely on the element's language value
			// being equal to the identifier C,
			// or beginning with the identifier C immediately followed by "-".
			// The matching of C against the element's language value is performed case-insensitively.
			// The identifier C does not have to be a valid language name."
			// http://www.w3.org/TR/selectors/#lang-pseudo
			"lang": markFunction( function( lang ) {
	
				// lang value must be a valid identifier
				if ( !ridentifier.test( lang || "" ) ) {
					Sizzle.error( "unsupported lang: " + lang );
				}
				lang = lang.replace( runescape, funescape ).toLowerCase();
				return function( elem ) {
					var elemLang;
					do {
						if ( ( elemLang = documentIsHTML ?
							elem.lang :
							elem.getAttribute( "xml:lang" ) || elem.getAttribute( "lang" ) ) ) {
	
							elemLang = elemLang.toLowerCase();
							return elemLang === lang || elemLang.indexOf( lang + "-" ) === 0;
						}
					} while ( ( elem = elem.parentNode ) && elem.nodeType === 1 );
					return false;
				};
			} ),
	
			// Miscellaneous
			"target": function( elem ) {
				var hash = window.location && window.location.hash;
				return hash && hash.slice( 1 ) === elem.id;
			},
	
			"root": function( elem ) {
				return elem === docElem;
			},
	
			"focus": function( elem ) {
				return elem === document.activeElement &&
					( !document.hasFocus || document.hasFocus() ) &&
					!!( elem.type || elem.href || ~elem.tabIndex );
			},
	
			// Boolean properties
			"enabled": createDisabledPseudo( false ),
			"disabled": createDisabledPseudo( true ),
	
			"checked": function( elem ) {
	
				// In CSS3, :checked should return both checked and selected elements
				// http://www.w3.org/TR/2011/REC-css3-selectors-20110929/#checked
				var nodeName = elem.nodeName.toLowerCase();
				return ( nodeName === "input" && !!elem.checked ) ||
					( nodeName === "option" && !!elem.selected );
			},
	
			"selected": function( elem ) {
	
				// Accessing this property makes selected-by-default
				// options in Safari work properly
				if ( elem.parentNode ) {
					// eslint-disable-next-line no-unused-expressions
					elem.parentNode.selectedIndex;
				}
	
				return elem.selected === true;
			},
	
			// Contents
			"empty": function( elem ) {
	
				// http://www.w3.org/TR/selectors/#empty-pseudo
				// :empty is negated by element (1) or content nodes (text: 3; cdata: 4; entity ref: 5),
				//   but not by others (comment: 8; processing instruction: 7; etc.)
				// nodeType < 6 works because attributes (2) do not appear as children
				for ( elem = elem.firstChild; elem; elem = elem.nextSibling ) {
					if ( elem.nodeType < 6 ) {
						return false;
					}
				}
				return true;
			},
	
			"parent": function( elem ) {
				return !Expr.pseudos[ "empty" ]( elem );
			},
	
			// Element/input types
			"header": function( elem ) {
				return rheader.test( elem.nodeName );
			},
	
			"input": function( elem ) {
				return rinputs.test( elem.nodeName );
			},
	
			"button": function( elem ) {
				var name = elem.nodeName.toLowerCase();
				return name === "input" && elem.type === "button" || name === "button";
			},
	
			"text": function( elem ) {
				var attr;
				return elem.nodeName.toLowerCase() === "input" &&
					elem.type === "text" &&
	
					// Support: IE<8
					// New HTML5 attribute values (e.g., "search") appear with elem.type === "text"
					( ( attr = elem.getAttribute( "type" ) ) == null ||
						attr.toLowerCase() === "text" );
			},
	
			// Position-in-collection
			"first": createPositionalPseudo( function() {
				return [ 0 ];
			} ),
	
			"last": createPositionalPseudo( function( _matchIndexes, length ) {
				return [ length - 1 ];
			} ),
	
			"eq": createPositionalPseudo( function( _matchIndexes, length, argument ) {
				return [ argument < 0 ? argument + length : argument ];
			} ),
	
			"even": createPositionalPseudo( function( matchIndexes, length ) {
				var i = 0;
				for ( ; i < length; i += 2 ) {
					matchIndexes.push( i );
				}
				return matchIndexes;
			} ),
	
			"odd": createPositionalPseudo( function( matchIndexes, length ) {
				var i = 1;
				for ( ; i < length; i += 2 ) {
					matchIndexes.push( i );
				}
				return matchIndexes;
			} ),
	
			"lt": createPositionalPseudo( function( matchIndexes, length, argument ) {
				var i = argument < 0 ?
					argument + length :
					argument > length ?
						length :
						argument;
				for ( ; --i >= 0; ) {
					matchIndexes.push( i );
				}
				return matchIndexes;
			} ),
	
			"gt": createPositionalPseudo( function( matchIndexes, length, argument ) {
				var i = argument < 0 ? argument + length : argument;
				for ( ; ++i < length; ) {
					matchIndexes.push( i );
				}
				return matchIndexes;
			} )
		}
	};
	
	Expr.pseudos[ "nth" ] = Expr.pseudos[ "eq" ];
	
	// Add button/input type pseudos
	for ( i in { radio: true, checkbox: true, file: true, password: true, image: true } ) {
		Expr.pseudos[ i ] = createInputPseudo( i );
	}
	for ( i in { submit: true, reset: true } ) {
		Expr.pseudos[ i ] = createButtonPseudo( i );
	}
	
	// Easy API for creating new setFilters
	function setFilters() {}
	setFilters.prototype = Expr.filters = Expr.pseudos;
	Expr.setFilters = new setFilters();
	
	tokenize = Sizzle.tokenize = function( selector, parseOnly ) {
		var matched, match, tokens, type,
			soFar, groups, preFilters,
			cached = tokenCache[ selector + " " ];
	
		if ( cached ) {
			return parseOnly ? 0 : cached.slice( 0 );
		}
	
		soFar = selector;
		groups = [];
		preFilters = Expr.preFilter;
	
		while ( soFar ) {
	
			// Comma and first run
			if ( !matched || ( match = rcomma.exec( soFar ) ) ) {
				if ( match ) {
	
					// Don't consume trailing commas as valid
					soFar = soFar.slice( match[ 0 ].length ) || soFar;
				}
				groups.push( ( tokens = [] ) );
			}
	
			matched = false;
	
			// Combinators
			if ( ( match = rcombinators.exec( soFar ) ) ) {
				matched = match.shift();
				tokens.push( {
					value: matched,
	
					// Cast descendant combinators to space
					type: match[ 0 ].replace( rtrim, " " )
				} );
				soFar = soFar.slice( matched.length );
			}
	
			// Filters
			for ( type in Expr.filter ) {
				if ( ( match = matchExpr[ type ].exec( soFar ) ) && ( !preFilters[ type ] ||
					( match = preFilters[ type ]( match ) ) ) ) {
					matched = match.shift();
					tokens.push( {
						value: matched,
						type: type,
						matches: match
					} );
					soFar = soFar.slice( matched.length );
				}
			}
	
			if ( !matched ) {
				break;
			}
		}
	
		// Return the length of the invalid excess
		// if we're just parsing
		// Otherwise, throw an error or return tokens
		return parseOnly ?
			soFar.length :
			soFar ?
				Sizzle.error( selector ) :
	
				// Cache the tokens
				tokenCache( selector, groups ).slice( 0 );
	};
	
	function toSelector( tokens ) {
		var i = 0,
			len = tokens.length,
			selector = "";
		for ( ; i < len; i++ ) {
			selector += tokens[ i ].value;
		}
		return selector;
	}
	
	function addCombinator( matcher, combinator, base ) {
		var dir = combinator.dir,
			skip = combinator.next,
			key = skip || dir,
			checkNonElements = base && key === "parentNode",
			doneName = done++;
	
		return combinator.first ?
	
			// Check against closest ancestor/preceding element
			function( elem, context, xml ) {
				while ( ( elem = elem[ dir ] ) ) {
					if ( elem.nodeType === 1 || checkNonElements ) {
						return matcher( elem, context, xml );
					}
				}
				return false;
			} :
	
			// Check against all ancestor/preceding elements
			function( elem, context, xml ) {
				var oldCache, uniqueCache, outerCache,
					newCache = [ dirruns, doneName ];
	
				// We can't set arbitrary data on XML nodes, so they don't benefit from combinator caching
				if ( xml ) {
					while ( ( elem = elem[ dir ] ) ) {
						if ( elem.nodeType === 1 || checkNonElements ) {
							if ( matcher( elem, context, xml ) ) {
								return true;
							}
						}
					}
				} else {
					while ( ( elem = elem[ dir ] ) ) {
						if ( elem.nodeType === 1 || checkNonElements ) {
							outerCache = elem[ expando ] || ( elem[ expando ] = {} );
	
							// Support: IE <9 only
							// Defend against cloned attroperties (jQuery gh-1709)
							uniqueCache = outerCache[ elem.uniqueID ] ||
								( outerCache[ elem.uniqueID ] = {} );
	
							if ( skip && skip === elem.nodeName.toLowerCase() ) {
								elem = elem[ dir ] || elem;
							} else if ( ( oldCache = uniqueCache[ key ] ) &&
								oldCache[ 0 ] === dirruns && oldCache[ 1 ] === doneName ) {
	
								// Assign to newCache so results back-propagate to previous elements
								return ( newCache[ 2 ] = oldCache[ 2 ] );
							} else {
	
								// Reuse newcache so results back-propagate to previous elements
								uniqueCache[ key ] = newCache;
	
								// A match means we're done; a fail means we have to keep checking
								if ( ( newCache[ 2 ] = matcher( elem, context, xml ) ) ) {
									return true;
								}
							}
						}
					}
				}
				return false;
			};
	}
	
	function elementMatcher( matchers ) {
		return matchers.length > 1 ?
			function( elem, context, xml ) {
				var i = matchers.length;
				while ( i-- ) {
					if ( !matchers[ i ]( elem, context, xml ) ) {
						return false;
					}
				}
				return true;
			} :
			matchers[ 0 ];
	}
	
	function multipleContexts( selector, contexts, results ) {
		var i = 0,
			len = contexts.length;
		for ( ; i < len; i++ ) {
			Sizzle( selector, contexts[ i ], results );
		}
		return results;
	}
	
	function condense( unmatched, map, filter, context, xml ) {
		var elem,
			newUnmatched = [],
			i = 0,
			len = unmatched.length,
			mapped = map != null;
	
		for ( ; i < len; i++ ) {
			if ( ( elem = unmatched[ i ] ) ) {
				if ( !filter || filter( elem, context, xml ) ) {
					newUnmatched.push( elem );
					if ( mapped ) {
						map.push( i );
					}
				}
			}
		}
	
		return newUnmatched;
	}
	
	function setMatcher( preFilter, selector, matcher, postFilter, postFinder, postSelector ) {
		if ( postFilter && !postFilter[ expando ] ) {
			postFilter = setMatcher( postFilter );
		}
		if ( postFinder && !postFinder[ expando ] ) {
			postFinder = setMatcher( postFinder, postSelector );
		}
		return markFunction( function( seed, results, context, xml ) {
			var temp, i, elem,
				preMap = [],
				postMap = [],
				preexisting = results.length,
	
				// Get initial elements from seed or context
				elems = seed || multipleContexts(
					selector || "*",
					context.nodeType ? [ context ] : context,
					[]
				),
	
				// Prefilter to get matcher input, preserving a map for seed-results synchronization
				matcherIn = preFilter && ( seed || !selector ) ?
					condense( elems, preMap, preFilter, context, xml ) :
					elems,
	
				matcherOut = matcher ?
	
					// If we have a postFinder, or filtered seed, or non-seed postFilter or preexisting results,
					postFinder || ( seed ? preFilter : preexisting || postFilter ) ?
	
						// ...intermediate processing is necessary
						[] :
	
						// ...otherwise use results directly
						results :
					matcherIn;
	
			// Find primary matches
			if ( matcher ) {
				matcher( matcherIn, matcherOut, context, xml );
			}
	
			// Apply postFilter
			if ( postFilter ) {
				temp = condense( matcherOut, postMap );
				postFilter( temp, [], context, xml );
	
				// Un-match failing elements by moving them back to matcherIn
				i = temp.length;
				while ( i-- ) {
					if ( ( elem = temp[ i ] ) ) {
						matcherOut[ postMap[ i ] ] = !( matcherIn[ postMap[ i ] ] = elem );
					}
				}
			}
	
			if ( seed ) {
				if ( postFinder || preFilter ) {
					if ( postFinder ) {
	
						// Get the final matcherOut by condensing this intermediate into postFinder contexts
						temp = [];
						i = matcherOut.length;
						while ( i-- ) {
							if ( ( elem = matcherOut[ i ] ) ) {
	
								// Restore matcherIn since elem is not yet a final match
								temp.push( ( matcherIn[ i ] = elem ) );
							}
						}
						postFinder( null, ( matcherOut = [] ), temp, xml );
					}
	
					// Move matched elements from seed to results to keep them synchronized
					i = matcherOut.length;
					while ( i-- ) {
						if ( ( elem = matcherOut[ i ] ) &&
							( temp = postFinder ? indexOf( seed, elem ) : preMap[ i ] ) > -1 ) {
	
							seed[ temp ] = !( results[ temp ] = elem );
						}
					}
				}
	
			// Add elements to results, through postFinder if defined
			} else {
				matcherOut = condense(
					matcherOut === results ?
						matcherOut.splice( preexisting, matcherOut.length ) :
						matcherOut
				);
				if ( postFinder ) {
					postFinder( null, results, matcherOut, xml );
				} else {
					push.apply( results, matcherOut );
				}
			}
		} );
	}
	
	function matcherFromTokens( tokens ) {
		var checkContext, matcher, j,
			len = tokens.length,
			leadingRelative = Expr.relative[ tokens[ 0 ].type ],
			implicitRelative = leadingRelative || Expr.relative[ " " ],
			i = leadingRelative ? 1 : 0,
	
			// The foundational matcher ensures that elements are reachable from top-level context(s)
			matchContext = addCombinator( function( elem ) {
				return elem === checkContext;
			}, implicitRelative, true ),
			matchAnyContext = addCombinator( function( elem ) {
				return indexOf( checkContext, elem ) > -1;
			}, implicitRelative, true ),
			matchers = [ function( elem, context, xml ) {
				var ret = ( !leadingRelative && ( xml || context !== outermostContext ) ) || (
					( checkContext = context ).nodeType ?
						matchContext( elem, context, xml ) :
						matchAnyContext( elem, context, xml ) );
	
				// Avoid hanging onto element (issue #299)
				checkContext = null;
				return ret;
			} ];
	
		for ( ; i < len; i++ ) {
			if ( ( matcher = Expr.relative[ tokens[ i ].type ] ) ) {
				matchers = [ addCombinator( elementMatcher( matchers ), matcher ) ];
			} else {
				matcher = Expr.filter[ tokens[ i ].type ].apply( null, tokens[ i ].matches );
	
				// Return special upon seeing a positional matcher
				if ( matcher[ expando ] ) {
	
					// Find the next relative operator (if any) for proper handling
					j = ++i;
					for ( ; j < len; j++ ) {
						if ( Expr.relative[ tokens[ j ].type ] ) {
							break;
						}
					}
					return setMatcher(
						i > 1 && elementMatcher( matchers ),
						i > 1 && toSelector(
	
						// If the preceding token was a descendant combinator, insert an implicit any-element `*`
						tokens
							.slice( 0, i - 1 )
							.concat( { value: tokens[ i - 2 ].type === " " ? "*" : "" } )
						).replace( rtrim, "$1" ),
						matcher,
						i < j && matcherFromTokens( tokens.slice( i, j ) ),
						j < len && matcherFromTokens( ( tokens = tokens.slice( j ) ) ),
						j < len && toSelector( tokens )
					);
				}
				matchers.push( matcher );
			}
		}
	
		return elementMatcher( matchers );
	}
	
	function matcherFromGroupMatchers( elementMatchers, setMatchers ) {
		var bySet = setMatchers.length > 0,
			byElement = elementMatchers.length > 0,
			superMatcher = function( seed, context, xml, results, outermost ) {
				var elem, j, matcher,
					matchedCount = 0,
					i = "0",
					unmatched = seed && [],
					setMatched = [],
					contextBackup = outermostContext,
	
					// We must always have either seed elements or outermost context
					elems = seed || byElement && Expr.find[ "TAG" ]( "*", outermost ),
	
					// Use integer dirruns iff this is the outermost matcher
					dirrunsUnique = ( dirruns += contextBackup == null ? 1 : Math.random() || 0.1 ),
					len = elems.length;
	
				if ( outermost ) {
	
					// Support: IE 11+, Edge 17 - 18+
					// IE/Edge sometimes throw a "Permission denied" error when strict-comparing
					// two documents; shallow comparisons work.
					// eslint-disable-next-line eqeqeq
					outermostContext = context == document || context || outermost;
				}
	
				// Add elements passing elementMatchers directly to results
				// Support: IE<9, Safari
				// Tolerate NodeList properties (IE: "length"; Safari: <number>) matching elements by id
				for ( ; i !== len && ( elem = elems[ i ] ) != null; i++ ) {
					if ( byElement && elem ) {
						j = 0;
	
						// Support: IE 11+, Edge 17 - 18+
						// IE/Edge sometimes throw a "Permission denied" error when strict-comparing
						// two documents; shallow comparisons work.
						// eslint-disable-next-line eqeqeq
						if ( !context && elem.ownerDocument != document ) {
							setDocument( elem );
							xml = !documentIsHTML;
						}
						while ( ( matcher = elementMatchers[ j++ ] ) ) {
							if ( matcher( elem, context || document, xml ) ) {
								results.push( elem );
								break;
							}
						}
						if ( outermost ) {
							dirruns = dirrunsUnique;
						}
					}
	
					// Track unmatched elements for set filters
					if ( bySet ) {
	
						// They will have gone through all possible matchers
						if ( ( elem = !matcher && elem ) ) {
							matchedCount--;
						}
	
						// Lengthen the array for every element, matched or not
						if ( seed ) {
							unmatched.push( elem );
						}
					}
				}
	
				// `i` is now the count of elements visited above, and adding it to `matchedCount`
				// makes the latter nonnegative.
				matchedCount += i;
	
				// Apply set filters to unmatched elements
				// NOTE: This can be skipped if there are no unmatched elements (i.e., `matchedCount`
				// equals `i`), unless we didn't visit _any_ elements in the above loop because we have
				// no element matchers and no seed.
				// Incrementing an initially-string "0" `i` allows `i` to remain a string only in that
				// case, which will result in a "00" `matchedCount` that differs from `i` but is also
				// numerically zero.
				if ( bySet && i !== matchedCount ) {
					j = 0;
					while ( ( matcher = setMatchers[ j++ ] ) ) {
						matcher( unmatched, setMatched, context, xml );
					}
	
					if ( seed ) {
	
						// Reintegrate element matches to eliminate the need for sorting
						if ( matchedCount > 0 ) {
							while ( i-- ) {
								if ( !( unmatched[ i ] || setMatched[ i ] ) ) {
									setMatched[ i ] = pop.call( results );
								}
							}
						}
	
						// Discard index placeholder values to get only actual matches
						setMatched = condense( setMatched );
					}
	
					// Add matches to results
					push.apply( results, setMatched );
	
					// Seedless set matches succeeding multiple successful matchers stipulate sorting
					if ( outermost && !seed && setMatched.length > 0 &&
						( matchedCount + setMatchers.length ) > 1 ) {
	
						Sizzle.uniqueSort( results );
					}
				}
	
				// Override manipulation of globals by nested matchers
				if ( outermost ) {
					dirruns = dirrunsUnique;
					outermostContext = contextBackup;
				}
	
				return unmatched;
			};
	
		return bySet ?
			markFunction( superMatcher ) :
			superMatcher;
	}
	
	compile = Sizzle.compile = function( selector, match /* Internal Use Only */ ) {
		var i,
			setMatchers = [],
			elementMatchers = [],
			cached = compilerCache[ selector + " " ];
	
		if ( !cached ) {
	
			// Generate a function of recursive functions that can be used to check each element
			if ( !match ) {
				match = tokenize( selector );
			}
			i = match.length;
			while ( i-- ) {
				cached = matcherFromTokens( match[ i ] );
				if ( cached[ expando ] ) {
					setMatchers.push( cached );
				} else {
					elementMatchers.push( cached );
				}
			}
	
			// Cache the compiled function
			cached = compilerCache(
				selector,
				matcherFromGroupMatchers( elementMatchers, setMatchers )
			);
	
			// Save selector and tokenization
			cached.selector = selector;
		}
		return cached;
	};
	
	/**
	 * A low-level selection function that works with Sizzle's compiled
	 *  selector functions
	 * @param {String|Function} selector A selector or a pre-compiled
	 *  selector function built with Sizzle.compile
	 * @param {Element} context
	 * @param {Array} [results]
	 * @param {Array} [seed] A set of elements to match against
	 */
	select = Sizzle.select = function( selector, context, results, seed ) {
		var i, tokens, token, type, find,
			compiled = typeof selector === "function" && selector,
			match = !seed && tokenize( ( selector = compiled.selector || selector ) );
	
		results = results || [];
	
		// Try to minimize operations if there is only one selector in the list and no seed
		// (the latter of which guarantees us context)
		if ( match.length === 1 ) {
	
			// Reduce context if the leading compound selector is an ID
			tokens = match[ 0 ] = match[ 0 ].slice( 0 );
			if ( tokens.length > 2 && ( token = tokens[ 0 ] ).type === "ID" &&
				context.nodeType === 9 && documentIsHTML && Expr.relative[ tokens[ 1 ].type ] ) {
	
				context = ( Expr.find[ "ID" ]( token.matches[ 0 ]
					.replace( runescape, funescape ), context ) || [] )[ 0 ];
				if ( !context ) {
					return results;
	
				// Precompiled matchers will still verify ancestry, so step up a level
				} else if ( compiled ) {
					context = context.parentNode;
				}
	
				selector = selector.slice( tokens.shift().value.length );
			}
	
			// Fetch a seed set for right-to-left matching
			i = matchExpr[ "needsContext" ].test( selector ) ? 0 : tokens.length;
			while ( i-- ) {
				token = tokens[ i ];
	
				// Abort if we hit a combinator
				if ( Expr.relative[ ( type = token.type ) ] ) {
					break;
				}
				if ( ( find = Expr.find[ type ] ) ) {
	
					// Search, expanding context for leading sibling combinators
					if ( ( seed = find(
						token.matches[ 0 ].replace( runescape, funescape ),
						rsibling.test( tokens[ 0 ].type ) && testContext( context.parentNode ) ||
							context
					) ) ) {
	
						// If seed is empty or no tokens remain, we can return early
						tokens.splice( i, 1 );
						selector = seed.length && toSelector( tokens );
						if ( !selector ) {
							push.apply( results, seed );
							return results;
						}
	
						break;
					}
				}
			}
		}
	
		// Compile and execute a filtering function if one is not provided
		// Provide `match` to avoid retokenization if we modified the selector above
		( compiled || compile( selector, match ) )(
			seed,
			context,
			!documentIsHTML,
			results,
			!context || rsibling.test( selector ) && testContext( context.parentNode ) || context
		);
		return results;
	};
	
	// One-time assignments
	
	// Sort stability
	support.sortStable = expando.split( "" ).sort( sortOrder ).join( "" ) === expando;
	
	// Support: Chrome 14-35+
	// Always assume duplicates if they aren't passed to the comparison function
	support.detectDuplicates = !!hasDuplicate;
	
	// Initialize against the default document
	setDocument();
	
	// Support: Webkit<537.32 - Safari 6.0.3/Chrome 25 (fixed in Chrome 27)
	// Detached nodes confoundingly follow *each other*
	support.sortDetached = assert( function( el ) {
	
		// Should return 1, but returns 4 (following)
		return el.compareDocumentPosition( document.createElement( "fieldset" ) ) & 1;
	} );
	
	// Support: IE<8
	// Prevent attribute/property "interpolation"
	// https://msdn.microsoft.com/en-us/library/ms536429%28VS.85%29.aspx
	if ( !assert( function( el ) {
		el.innerHTML = "<a href='#'></a>";
		return el.firstChild.getAttribute( "href" ) === "#";
	} ) ) {
		addHandle( "type|href|height|width", function( elem, name, isXML ) {
			if ( !isXML ) {
				return elem.getAttribute( name, name.toLowerCase() === "type" ? 1 : 2 );
			}
		} );
	}
	
	// Support: IE<9
	// Use defaultValue in place of getAttribute("value")
	if ( !support.attributes || !assert( function( el ) {
		el.innerHTML = "<input/>";
		el.firstChild.setAttribute( "value", "" );
		return el.firstChild.getAttribute( "value" ) === "";
	} ) ) {
		addHandle( "value", function( elem, _name, isXML ) {
			if ( !isXML && elem.nodeName.toLowerCase() === "input" ) {
				return elem.defaultValue;
			}
		} );
	}
	
	// Support: IE<9
	// Use getAttributeNode to fetch booleans when getAttribute lies
	if ( !assert( function( el ) {
		return el.getAttribute( "disabled" ) == null;
	} ) ) {
		addHandle( booleans, function( elem, name, isXML ) {
			var val;
			if ( !isXML ) {
				return elem[ name ] === true ? name.toLowerCase() :
					( val = elem.getAttributeNode( name ) ) && val.specified ?
						val.value :
						null;
			}
		} );
	}
	
	return Sizzle;
	
	} )( window );
	
	
	
	jQuery.find = Sizzle;
	jQuery.expr = Sizzle.selectors;
	
	// Deprecated
	jQuery.expr[ ":" ] = jQuery.expr.pseudos;
	jQuery.uniqueSort = jQuery.unique = Sizzle.uniqueSort;
	jQuery.text = Sizzle.getText;
	jQuery.isXMLDoc = Sizzle.isXML;
	jQuery.contains = Sizzle.contains;
	jQuery.escapeSelector = Sizzle.escape;
	
	
	
	
	var dir = function( elem, dir, until ) {
		var matched = [],
			truncate = until !== undefined;
	
		while ( ( elem = elem[ dir ] ) && elem.nodeType !== 9 ) {
			if ( elem.nodeType === 1 ) {
				if ( truncate && jQuery( elem ).is( until ) ) {
					break;
				}
				matched.push( elem );
			}
		}
		return matched;
	};
	
	
	var siblings = function( n, elem ) {
		var matched = [];
	
		for ( ; n; n = n.nextSibling ) {
			if ( n.nodeType === 1 && n !== elem ) {
				matched.push( n );
			}
		}
	
		return matched;
	};
	
	
	var rneedsContext = jQuery.expr.match.needsContext;
	
	
	
	function nodeName( elem, name ) {
	
	  return elem.nodeName && elem.nodeName.toLowerCase() === name.toLowerCase();
	
	};
	var rsingleTag = ( /^<([a-z][^\/\0>:\x20\t\r\n\f]*)[\x20\t\r\n\f]*\/?>(?:<\/\1>|)$/i );
	
	
	
	// Implement the identical functionality for filter and not
	function winnow( elements, qualifier, not ) {
		if ( isFunction( qualifier ) ) {
			return jQuery.grep( elements, function( elem, i ) {
				return !!qualifier.call( elem, i, elem ) !== not;
			} );
		}
	
		// Single element
		if ( qualifier.nodeType ) {
			return jQuery.grep( elements, function( elem ) {
				return ( elem === qualifier ) !== not;
			} );
		}
	
		// Arraylike of elements (jQuery, arguments, Array)
		if ( typeof qualifier !== "string" ) {
			return jQuery.grep( elements, function( elem ) {
				return ( indexOf.call( qualifier, elem ) > -1 ) !== not;
			} );
		}
	
		// Filtered directly for both simple and complex selectors
		return jQuery.filter( qualifier, elements, not );
	}
	
	jQuery.filter = function( expr, elems, not ) {
		var elem = elems[ 0 ];
	
		if ( not ) {
			expr = ":not(" + expr + ")";
		}
	
		if ( elems.length === 1 && elem.nodeType === 1 ) {
			return jQuery.find.matchesSelector( elem, expr ) ? [ elem ] : [];
		}
	
		return jQuery.find.matches( expr, jQuery.grep( elems, function( elem ) {
			return elem.nodeType === 1;
		} ) );
	};
	
	jQuery.fn.extend( {
		find: function( selector ) {
			var i, ret,
				len = this.length,
				self = this;
	
			if ( typeof selector !== "string" ) {
				return this.pushStack( jQuery( selector ).filter( function() {
					for ( i = 0; i < len; i++ ) {
						if ( jQuery.contains( self[ i ], this ) ) {
							return true;
						}
					}
				} ) );
			}
	
			ret = this.pushStack( [] );
	
			for ( i = 0; i < len; i++ ) {
				jQuery.find( selector, self[ i ], ret );
			}
	
			return len > 1 ? jQuery.uniqueSort( ret ) : ret;
		},
		filter: function( selector ) {
			return this.pushStack( winnow( this, selector || [], false ) );
		},
		not: function( selector ) {
			return this.pushStack( winnow( this, selector || [], true ) );
		},
		is: function( selector ) {
			return !!winnow(
				this,
	
				// If this is a positional/relative selector, check membership in the returned set
				// so $("p:first").is("p:last") won't return true for a doc with two "p".
				typeof selector === "string" && rneedsContext.test( selector ) ?
					jQuery( selector ) :
					selector || [],
				false
			).length;
		}
	} );
	
	
	// Initialize a jQuery object
	
	
	// A central reference to the root jQuery(document)
	var rootjQuery,
	
		// A simple way to check for HTML strings
		// Prioritize #id over <tag> to avoid XSS via location.hash (#9521)
		// Strict HTML recognition (#11290: must start with <)
		// Shortcut simple #id case for speed
		rquickExpr = /^(?:\s*(<[\w\W]+>)[^>]*|#([\w-]+))$/,
	
		init = jQuery.fn.init = function( selector, context, root ) {
			var match, elem;
	
			// HANDLE: $(""), $(null), $(undefined), $(false)
			if ( !selector ) {
				return this;
			}
	
			// Method init() accepts an alternate rootjQuery
			// so migrate can support jQuery.sub (gh-2101)
			root = root || rootjQuery;
	
			// Handle HTML strings
			if ( typeof selector === "string" ) {
				if ( selector[ 0 ] === "<" &&
					selector[ selector.length - 1 ] === ">" &&
					selector.length >= 3 ) {
	
					// Assume that strings that start and end with <> are HTML and skip the regex check
					match = [ null, selector, null ];
	
				} else {
					match = rquickExpr.exec( selector );
				}
	
				// Match html or make sure no context is specified for #id
				if ( match && ( match[ 1 ] || !context ) ) {
	
					// HANDLE: $(html) -> $(array)
					if ( match[ 1 ] ) {
						context = context instanceof jQuery ? context[ 0 ] : context;
	
						// Option to run scripts is true for back-compat
						// Intentionally let the error be thrown if parseHTML is not present
						jQuery.merge( this, jQuery.parseHTML(
							match[ 1 ],
							context && context.nodeType ? context.ownerDocument || context : document,
							true
						) );
	
						// HANDLE: $(html, props)
						if ( rsingleTag.test( match[ 1 ] ) && jQuery.isPlainObject( context ) ) {
							for ( match in context ) {
	
								// Properties of context are called as methods if possible
								if ( isFunction( this[ match ] ) ) {
									this[ match ]( context[ match ] );
	
								// ...and otherwise set as attributes
								} else {
									this.attr( match, context[ match ] );
								}
							}
						}
	
						return this;
	
					// HANDLE: $(#id)
					} else {
						elem = document.getElementById( match[ 2 ] );
	
						if ( elem ) {
	
							// Inject the element directly into the jQuery object
							this[ 0 ] = elem;
							this.length = 1;
						}
						return this;
					}
	
				// HANDLE: $(expr, $(...))
				} else if ( !context || context.jquery ) {
					return ( context || root ).find( selector );
	
				// HANDLE: $(expr, context)
				// (which is just equivalent to: $(context).find(expr)
				} else {
					return this.constructor( context ).find( selector );
				}
	
			// HANDLE: $(DOMElement)
			} else if ( selector.nodeType ) {
				this[ 0 ] = selector;
				this.length = 1;
				return this;
	
			// HANDLE: $(function)
			// Shortcut for document ready
			} else if ( isFunction( selector ) ) {
				return root.ready !== undefined ?
					root.ready( selector ) :
	
					// Execute immediately if ready is not present
					selector( jQuery );
			}
	
			return jQuery.makeArray( selector, this );
		};
	
	// Give the init function the jQuery prototype for later instantiation
	init.prototype = jQuery.fn;
	
	// Initialize central reference
	rootjQuery = jQuery( document );
	
	
	var rparentsprev = /^(?:parents|prev(?:Until|All))/,
	
		// Methods guaranteed to produce a unique set when starting from a unique set
		guaranteedUnique = {
			children: true,
			contents: true,
			next: true,
			prev: true
		};
	
	jQuery.fn.extend( {
		has: function( target ) {
			var targets = jQuery( target, this ),
				l = targets.length;
	
			return this.filter( function() {
				var i = 0;
				for ( ; i < l; i++ ) {
					if ( jQuery.contains( this, targets[ i ] ) ) {
						return true;
					}
				}
			} );
		},
	
		closest: function( selectors, context ) {
			var cur,
				i = 0,
				l = this.length,
				matched = [],
				targets = typeof selectors !== "string" && jQuery( selectors );
	
			// Positional selectors never match, since there's no _selection_ context
			if ( !rneedsContext.test( selectors ) ) {
				for ( ; i < l; i++ ) {
					for ( cur = this[ i ]; cur && cur !== context; cur = cur.parentNode ) {
	
						// Always skip document fragments
						if ( cur.nodeType < 11 && ( targets ?
							targets.index( cur ) > -1 :
	
							// Don't pass non-elements to Sizzle
							cur.nodeType === 1 &&
								jQuery.find.matchesSelector( cur, selectors ) ) ) {
	
							matched.push( cur );
							break;
						}
					}
				}
			}
	
			return this.pushStack( matched.length > 1 ? jQuery.uniqueSort( matched ) : matched );
		},
	
		// Determine the position of an element within the set
		index: function( elem ) {
	
			// No argument, return index in parent
			if ( !elem ) {
				return ( this[ 0 ] && this[ 0 ].parentNode ) ? this.first().prevAll().length : -1;
			}
	
			// Index in selector
			if ( typeof elem === "string" ) {
				return indexOf.call( jQuery( elem ), this[ 0 ] );
			}
	
			// Locate the position of the desired element
			return indexOf.call( this,
	
				// If it receives a jQuery object, the first element is used
				elem.jquery ? elem[ 0 ] : elem
			);
		},
	
		add: function( selector, context ) {
			return this.pushStack(
				jQuery.uniqueSort(
					jQuery.merge( this.get(), jQuery( selector, context ) )
				)
			);
		},
	
		addBack: function( selector ) {
			return this.add( selector == null ?
				this.prevObject : this.prevObject.filter( selector )
			);
		}
	} );
	
	function sibling( cur, dir ) {
		while ( ( cur = cur[ dir ] ) && cur.nodeType !== 1 ) {}
		return cur;
	}
	
	jQuery.each( {
		parent: function( elem ) {
			var parent = elem.parentNode;
			return parent && parent.nodeType !== 11 ? parent : null;
		},
		parents: function( elem ) {
			return dir( elem, "parentNode" );
		},
		parentsUntil: function( elem, _i, until ) {
			return dir( elem, "parentNode", until );
		},
		next: function( elem ) {
			return sibling( elem, "nextSibling" );
		},
		prev: function( elem ) {
			return sibling( elem, "previousSibling" );
		},
		nextAll: function( elem ) {
			return dir( elem, "nextSibling" );
		},
		prevAll: function( elem ) {
			return dir( elem, "previousSibling" );
		},
		nextUntil: function( elem, _i, until ) {
			return dir( elem, "nextSibling", until );
		},
		prevUntil: function( elem, _i, until ) {
			return dir( elem, "previousSibling", until );
		},
		siblings: function( elem ) {
			return siblings( ( elem.parentNode || {} ).firstChild, elem );
		},
		children: function( elem ) {
			return siblings( elem.firstChild );
		},
		contents: function( elem ) {
			if ( elem.contentDocument != null &&
	
				// Support: IE 11+
				// <object> elements with no `data` attribute has an object
				// `contentDocument` with a `null` prototype.
				getProto( elem.contentDocument ) ) {
	
				return elem.contentDocument;
			}
	
			// Support: IE 9 - 11 only, iOS 7 only, Android Browser <=4.3 only
			// Treat the template element as a regular one in browsers that
			// don't support it.
			if ( nodeName( elem, "template" ) ) {
				elem = elem.content || elem;
			}
	
			return jQuery.merge( [], elem.childNodes );
		}
	}, function( name, fn ) {
		jQuery.fn[ name ] = function( until, selector ) {
			var matched = jQuery.map( this, fn, until );
	
			if ( name.slice( -5 ) !== "Until" ) {
				selector = until;
			}
	
			if ( selector && typeof selector === "string" ) {
				matched = jQuery.filter( selector, matched );
			}
	
			if ( this.length > 1 ) {
	
				// Remove duplicates
				if ( !guaranteedUnique[ name ] ) {
					jQuery.uniqueSort( matched );
				}
	
				// Reverse order for parents* and prev-derivatives
				if ( rparentsprev.test( name ) ) {
					matched.reverse();
				}
			}
	
			return this.pushStack( matched );
		};
	} );
	var rnothtmlwhite = ( /[^\x20\t\r\n\f]+/g );
	
	
	
	// Convert String-formatted options into Object-formatted ones
	function createOptions( options ) {
		var object = {};
		jQuery.each( options.match( rnothtmlwhite ) || [], function( _, flag ) {
			object[ flag ] = true;
		} );
		return object;
	}
	
	/*
	 * Create a callback list using the following parameters:
	 *
	 *	options: an optional list of space-separated options that will change how
	 *			the callback list behaves or a more traditional option object
	 *
	 * By default a callback list will act like an event callback list and can be
	 * "fired" multiple times.
	 *
	 * Possible options:
	 *
	 *	once:			will ensure the callback list can only be fired once (like a Deferred)
	 *
	 *	memory:			will keep track of previous values and will call any callback added
	 *					after the list has been fired right away with the latest "memorized"
	 *					values (like a Deferred)
	 *
	 *	unique:			will ensure a callback can only be added once (no duplicate in the list)
	 *
	 *	stopOnFalse:	interrupt callings when a callback returns false
	 *
	 */
	jQuery.Callbacks = function( options ) {
	
		// Convert options from String-formatted to Object-formatted if needed
		// (we check in cache first)
		options = typeof options === "string" ?
			createOptions( options ) :
			jQuery.extend( {}, options );
	
		var // Flag to know if list is currently firing
			firing,
	
			// Last fire value for non-forgettable lists
			memory,
	
			// Flag to know if list was already fired
			fired,
	
			// Flag to prevent firing
			locked,
	
			// Actual callback list
			list = [],
	
			// Queue of execution data for repeatable lists
			queue = [],
	
			// Index of currently firing callback (modified by add/remove as needed)
			firingIndex = -1,
	
			// Fire callbacks
			fire = function() {
	
				// Enforce single-firing
				locked = locked || options.once;
	
				// Execute callbacks for all pending executions,
				// respecting firingIndex overrides and runtime changes
				fired = firing = true;
				for ( ; queue.length; firingIndex = -1 ) {
					memory = queue.shift();
					while ( ++firingIndex < list.length ) {
	
						// Run callback and check for early termination
						if ( list[ firingIndex ].apply( memory[ 0 ], memory[ 1 ] ) === false &&
							options.stopOnFalse ) {
	
							// Jump to end and forget the data so .add doesn't re-fire
							firingIndex = list.length;
							memory = false;
						}
					}
				}
	
				// Forget the data if we're done with it
				if ( !options.memory ) {
					memory = false;
				}
	
				firing = false;
	
				// Clean up if we're done firing for good
				if ( locked ) {
	
					// Keep an empty list if we have data for future add calls
					if ( memory ) {
						list = [];
	
					// Otherwise, this object is spent
					} else {
						list = "";
					}
				}
			},
	
			// Actual Callbacks object
			self = {
	
				// Add a callback or a collection of callbacks to the list
				add: function() {
					if ( list ) {
	
						// If we have memory from a past run, we should fire after adding
						if ( memory && !firing ) {
							firingIndex = list.length - 1;
							queue.push( memory );
						}
	
						( function add( args ) {
							jQuery.each( args, function( _, arg ) {
								if ( isFunction( arg ) ) {
									if ( !options.unique || !self.has( arg ) ) {
										list.push( arg );
									}
								} else if ( arg && arg.length && toType( arg ) !== "string" ) {
	
									// Inspect recursively
									add( arg );
								}
							} );
						} )( arguments );
	
						if ( memory && !firing ) {
							fire();
						}
					}
					return this;
				},
	
				// Remove a callback from the list
				remove: function() {
					jQuery.each( arguments, function( _, arg ) {
						var index;
						while ( ( index = jQuery.inArray( arg, list, index ) ) > -1 ) {
							list.splice( index, 1 );
	
							// Handle firing indexes
							if ( index <= firingIndex ) {
								firingIndex--;
							}
						}
					} );
					return this;
				},
	
				// Check if a given callback is in the list.
				// If no argument is given, return whether or not list has callbacks attached.
				has: function( fn ) {
					return fn ?
						jQuery.inArray( fn, list ) > -1 :
						list.length > 0;
				},
	
				// Remove all callbacks from the list
				empty: function() {
					if ( list ) {
						list = [];
					}
					return this;
				},
	
				// Disable .fire and .add
				// Abort any current/pending executions
				// Clear all callbacks and values
				disable: function() {
					locked = queue = [];
					list = memory = "";
					return this;
				},
				disabled: function() {
					return !list;
				},
	
				// Disable .fire
				// Also disable .add unless we have memory (since it would have no effect)
				// Abort any pending executions
				lock: function() {
					locked = queue = [];
					if ( !memory && !firing ) {
						list = memory = "";
					}
					return this;
				},
				locked: function() {
					return !!locked;
				},
	
				// Call all callbacks with the given context and arguments
				fireWith: function( context, args ) {
					if ( !locked ) {
						args = args || [];
						args = [ context, args.slice ? args.slice() : args ];
						queue.push( args );
						if ( !firing ) {
							fire();
						}
					}
					return this;
				},
	
				// Call all the callbacks with the given arguments
				fire: function() {
					self.fireWith( this, arguments );
					return this;
				},
	
				// To know if the callbacks have already been called at least once
				fired: function() {
					return !!fired;
				}
			};
	
		return self;
	};
	
	
	function Identity( v ) {
		return v;
	}
	function Thrower( ex ) {
		throw ex;
	}
	
	function adoptValue( value, resolve, reject, noValue ) {
		var method;
	
		try {
	
			// Check for promise aspect first to privilege synchronous behavior
			if ( value && isFunction( ( method = value.promise ) ) ) {
				method.call( value ).done( resolve ).fail( reject );
	
			// Other thenables
			} else if ( value && isFunction( ( method = value.then ) ) ) {
				method.call( value, resolve, reject );
	
			// Other non-thenables
			} else {
	
				// Control `resolve` arguments by letting Array#slice cast boolean `noValue` to integer:
				// * false: [ value ].slice( 0 ) => resolve( value )
				// * true: [ value ].slice( 1 ) => resolve()
				resolve.apply( undefined, [ value ].slice( noValue ) );
			}
	
		// For Promises/A+, convert exceptions into rejections
		// Since jQuery.when doesn't unwrap thenables, we can skip the extra checks appearing in
		// Deferred#then to conditionally suppress rejection.
		} catch ( value ) {
	
			// Support: Android 4.0 only
			// Strict mode functions invoked without .call/.apply get global-object context
			reject.apply( undefined, [ value ] );
		}
	}
	
	jQuery.extend( {
	
		Deferred: function( func ) {
			var tuples = [
	
					// action, add listener, callbacks,
					// ... .then handlers, argument index, [final state]
					[ "notify", "progress", jQuery.Callbacks( "memory" ),
						jQuery.Callbacks( "memory" ), 2 ],
					[ "resolve", "done", jQuery.Callbacks( "once memory" ),
						jQuery.Callbacks( "once memory" ), 0, "resolved" ],
					[ "reject", "fail", jQuery.Callbacks( "once memory" ),
						jQuery.Callbacks( "once memory" ), 1, "rejected" ]
				],
				state = "pending",
				promise = {
					state: function() {
						return state;
					},
					always: function() {
						deferred.done( arguments ).fail( arguments );
						return this;
					},
					"catch": function( fn ) {
						return promise.then( null, fn );
					},
	
					// Keep pipe for back-compat
					pipe: function( /* fnDone, fnFail, fnProgress */ ) {
						var fns = arguments;
	
						return jQuery.Deferred( function( newDefer ) {
							jQuery.each( tuples, function( _i, tuple ) {
	
								// Map tuples (progress, done, fail) to arguments (done, fail, progress)
								var fn = isFunction( fns[ tuple[ 4 ] ] ) && fns[ tuple[ 4 ] ];
	
								// deferred.progress(function() { bind to newDefer or newDefer.notify })
								// deferred.done(function() { bind to newDefer or newDefer.resolve })
								// deferred.fail(function() { bind to newDefer or newDefer.reject })
								deferred[ tuple[ 1 ] ]( function() {
									var returned = fn && fn.apply( this, arguments );
									if ( returned && isFunction( returned.promise ) ) {
										returned.promise()
											.progress( newDefer.notify )
											.done( newDefer.resolve )
											.fail( newDefer.reject );
									} else {
										newDefer[ tuple[ 0 ] + "With" ](
											this,
											fn ? [ returned ] : arguments
										);
									}
								} );
							} );
							fns = null;
						} ).promise();
					},
					then: function( onFulfilled, onRejected, onProgress ) {
						var maxDepth = 0;
						function resolve( depth, deferred, handler, special ) {
							return function() {
								var that = this,
									args = arguments,
									mightThrow = function() {
										var returned, then;
	
										// Support: Promises/A+ section 2.3.3.3.3
										// https://promisesaplus.com/#point-59
										// Ignore double-resolution attempts
										if ( depth < maxDepth ) {
											return;
										}
	
										returned = handler.apply( that, args );
	
										// Support: Promises/A+ section 2.3.1
										// https://promisesaplus.com/#point-48
										if ( returned === deferred.promise() ) {
											throw new TypeError( "Thenable self-resolution" );
										}
	
										// Support: Promises/A+ sections 2.3.3.1, 3.5
										// https://promisesaplus.com/#point-54
										// https://promisesaplus.com/#point-75
										// Retrieve `then` only once
										then = returned &&
	
											// Support: Promises/A+ section 2.3.4
											// https://promisesaplus.com/#point-64
											// Only check objects and functions for thenability
											( typeof returned === "object" ||
												typeof returned === "function" ) &&
											returned.then;
	
										// Handle a returned thenable
										if ( isFunction( then ) ) {
	
											// Special processors (notify) just wait for resolution
											if ( special ) {
												then.call(
													returned,
													resolve( maxDepth, deferred, Identity, special ),
													resolve( maxDepth, deferred, Thrower, special )
												);
	
											// Normal processors (resolve) also hook into progress
											} else {
	
												// ...and disregard older resolution values
												maxDepth++;
	
												then.call(
													returned,
													resolve( maxDepth, deferred, Identity, special ),
													resolve( maxDepth, deferred, Thrower, special ),
													resolve( maxDepth, deferred, Identity,
														deferred.notifyWith )
												);
											}
	
										// Handle all other returned values
										} else {
	
											// Only substitute handlers pass on context
											// and multiple values (non-spec behavior)
											if ( handler !== Identity ) {
												that = undefined;
												args = [ returned ];
											}
	
											// Process the value(s)
											// Default process is resolve
											( special || deferred.resolveWith )( that, args );
										}
									},
	
									// Only normal processors (resolve) catch and reject exceptions
									process = special ?
										mightThrow :
										function() {
											try {
												mightThrow();
											} catch ( e ) {
	
												if ( jQuery.Deferred.exceptionHook ) {
													jQuery.Deferred.exceptionHook( e,
														process.stackTrace );
												}
	
												// Support: Promises/A+ section 2.3.3.3.4.1
												// https://promisesaplus.com/#point-61
												// Ignore post-resolution exceptions
												if ( depth + 1 >= maxDepth ) {
	
													// Only substitute handlers pass on context
													// and multiple values (non-spec behavior)
													if ( handler !== Thrower ) {
														that = undefined;
														args = [ e ];
													}
	
													deferred.rejectWith( that, args );
												}
											}
										};
	
								// Support: Promises/A+ section 2.3.3.3.1
								// https://promisesaplus.com/#point-57
								// Re-resolve promises immediately to dodge false rejection from
								// subsequent errors
								if ( depth ) {
									process();
								} else {
	
									// Call an optional hook to record the stack, in case of exception
									// since it's otherwise lost when execution goes async
									if ( jQuery.Deferred.getStackHook ) {
										process.stackTrace = jQuery.Deferred.getStackHook();
									}
									window.setTimeout( process );
								}
							};
						}
	
						return jQuery.Deferred( function( newDefer ) {
	
							// progress_handlers.add( ... )
							tuples[ 0 ][ 3 ].add(
								resolve(
									0,
									newDefer,
									isFunction( onProgress ) ?
										onProgress :
										Identity,
									newDefer.notifyWith
								)
							);
	
							// fulfilled_handlers.add( ... )
							tuples[ 1 ][ 3 ].add(
								resolve(
									0,
									newDefer,
									isFunction( onFulfilled ) ?
										onFulfilled :
										Identity
								)
							);
	
							// rejected_handlers.add( ... )
							tuples[ 2 ][ 3 ].add(
								resolve(
									0,
									newDefer,
									isFunction( onRejected ) ?
										onRejected :
										Thrower
								)
							);
						} ).promise();
					},
	
					// Get a promise for this deferred
					// If obj is provided, the promise aspect is added to the object
					promise: function( obj ) {
						return obj != null ? jQuery.extend( obj, promise ) : promise;
					}
				},
				deferred = {};
	
			// Add list-specific methods
			jQuery.each( tuples, function( i, tuple ) {
				var list = tuple[ 2 ],
					stateString = tuple[ 5 ];
	
				// promise.progress = list.add
				// promise.done = list.add
				// promise.fail = list.add
				promise[ tuple[ 1 ] ] = list.add;
	
				// Handle state
				if ( stateString ) {
					list.add(
						function() {
	
							// state = "resolved" (i.e., fulfilled)
							// state = "rejected"
							state = stateString;
						},
	
						// rejected_callbacks.disable
						// fulfilled_callbacks.disable
						tuples[ 3 - i ][ 2 ].disable,
	
						// rejected_handlers.disable
						// fulfilled_handlers.disable
						tuples[ 3 - i ][ 3 ].disable,
	
						// progress_callbacks.lock
						tuples[ 0 ][ 2 ].lock,
	
						// progress_handlers.lock
						tuples[ 0 ][ 3 ].lock
					);
				}
	
				// progress_handlers.fire
				// fulfilled_handlers.fire
				// rejected_handlers.fire
				list.add( tuple[ 3 ].fire );
	
				// deferred.notify = function() { deferred.notifyWith(...) }
				// deferred.resolve = function() { deferred.resolveWith(...) }
				// deferred.reject = function() { deferred.rejectWith(...) }
				deferred[ tuple[ 0 ] ] = function() {
					deferred[ tuple[ 0 ] + "With" ]( this === deferred ? undefined : this, arguments );
					return this;
				};
	
				// deferred.notifyWith = list.fireWith
				// deferred.resolveWith = list.fireWith
				// deferred.rejectWith = list.fireWith
				deferred[ tuple[ 0 ] + "With" ] = list.fireWith;
			} );
	
			// Make the deferred a promise
			promise.promise( deferred );
	
			// Call given func if any
			if ( func ) {
				func.call( deferred, deferred );
			}
	
			// All done!
			return deferred;
		},
	
		// Deferred helper
		when: function( singleValue ) {
			var
	
				// count of uncompleted subordinates
				remaining = arguments.length,
	
				// count of unprocessed arguments
				i = remaining,
	
				// subordinate fulfillment data
				resolveContexts = Array( i ),
				resolveValues = slice.call( arguments ),
	
				// the master Deferred
				master = jQuery.Deferred(),
	
				// subordinate callback factory
				updateFunc = function( i ) {
					return function( value ) {
						resolveContexts[ i ] = this;
						resolveValues[ i ] = arguments.length > 1 ? slice.call( arguments ) : value;
						if ( !( --remaining ) ) {
							master.resolveWith( resolveContexts, resolveValues );
						}
					};
				};
	
			// Single- and empty arguments are adopted like Promise.resolve
			if ( remaining <= 1 ) {
				adoptValue( singleValue, master.done( updateFunc( i ) ).resolve, master.reject,
					!remaining );
	
				// Use .then() to unwrap secondary thenables (cf. gh-3000)
				if ( master.state() === "pending" ||
					isFunction( resolveValues[ i ] && resolveValues[ i ].then ) ) {
	
					return master.then();
				}
			}
	
			// Multiple arguments are aggregated like Promise.all array elements
			while ( i-- ) {
				adoptValue( resolveValues[ i ], updateFunc( i ), master.reject );
			}
	
			return master.promise();
		}
	} );
	
	
	// These usually indicate a programmer mistake during development,
	// warn about them ASAP rather than swallowing them by default.
	var rerrorNames = /^(Eval|Internal|Range|Reference|Syntax|Type|URI)Error$/;
	
	jQuery.Deferred.exceptionHook = function( error, stack ) {
	
		// Support: IE 8 - 9 only
		// Console exists when dev tools are open, which can happen at any time
		if ( window.console && window.console.warn && error && rerrorNames.test( error.name ) ) {
			window.console.warn( "jQuery.Deferred exception: " + error.message, error.stack, stack );
		}
	};
	
	
	
	
	jQuery.readyException = function( error ) {
		window.setTimeout( function() {
			throw error;
		} );
	};
	
	
	
	
	// The deferred used on DOM ready
	var readyList = jQuery.Deferred();
	
	jQuery.fn.ready = function( fn ) {
	
		readyList
			.then( fn )
	
			// Wrap jQuery.readyException in a function so that the lookup
			// happens at the time of error handling instead of callback
			// registration.
			.catch( function( error ) {
				jQuery.readyException( error );
			} );
	
		return this;
	};
	
	jQuery.extend( {
	
		// Is the DOM ready to be used? Set to true once it occurs.
		isReady: false,
	
		// A counter to track how many items to wait for before
		// the ready event fires. See #6781
		readyWait: 1,
	
		// Handle when the DOM is ready
		ready: function( wait ) {
	
			// Abort if there are pending holds or we're already ready
			if ( wait === true ? --jQuery.readyWait : jQuery.isReady ) {
				return;
			}
	
			// Remember that the DOM is ready
			jQuery.isReady = true;
	
			// If a normal DOM Ready event fired, decrement, and wait if need be
			if ( wait !== true && --jQuery.readyWait > 0 ) {
				return;
			}
	
			// If there are functions bound, to execute
			readyList.resolveWith( document, [ jQuery ] );
		}
	} );
	
	jQuery.ready.then = readyList.then;
	
	// The ready event handler and self cleanup method
	function completed() {
		document.removeEventListener( "DOMContentLoaded", completed );
		window.removeEventListener( "load", completed );
		jQuery.ready();
	}
	
	// Catch cases where $(document).ready() is called
	// after the browser event has already occurred.
	// Support: IE <=9 - 10 only
	// Older IE sometimes signals "interactive" too soon
	if ( document.readyState === "complete" ||
		( document.readyState !== "loading" && !document.documentElement.doScroll ) ) {
	
		// Handle it asynchronously to allow scripts the opportunity to delay ready
		window.setTimeout( jQuery.ready );
	
	} else {
	
		// Use the handy event callback
		document.addEventListener( "DOMContentLoaded", completed );
	
		// A fallback to window.onload, that will always work
		window.addEventListener( "load", completed );
	}
	
	
	
	
	// Multifunctional method to get and set values of a collection
	// The value/s can optionally be executed if it's a function
	var access = function( elems, fn, key, value, chainable, emptyGet, raw ) {
		var i = 0,
			len = elems.length,
			bulk = key == null;
	
		// Sets many values
		if ( toType( key ) === "object" ) {
			chainable = true;
			for ( i in key ) {
				access( elems, fn, i, key[ i ], true, emptyGet, raw );
			}
	
		// Sets one value
		} else if ( value !== undefined ) {
			chainable = true;
	
			if ( !isFunction( value ) ) {
				raw = true;
			}
	
			if ( bulk ) {
	
				// Bulk operations run against the entire set
				if ( raw ) {
					fn.call( elems, value );
					fn = null;
	
				// ...except when executing function values
				} else {
					bulk = fn;
					fn = function( elem, _key, value ) {
						return bulk.call( jQuery( elem ), value );
					};
				}
			}
	
			if ( fn ) {
				for ( ; i < len; i++ ) {
					fn(
						elems[ i ], key, raw ?
						value :
						value.call( elems[ i ], i, fn( elems[ i ], key ) )
					);
				}
			}
		}
	
		if ( chainable ) {
			return elems;
		}
	
		// Gets
		if ( bulk ) {
			return fn.call( elems );
		}
	
		return len ? fn( elems[ 0 ], key ) : emptyGet;
	};
	
	
	// Matches dashed string for camelizing
	var rmsPrefix = /^-ms-/,
		rdashAlpha = /-([a-z])/g;
	
	// Used by camelCase as callback to replace()
	function fcamelCase( _all, letter ) {
		return letter.toUpperCase();
	}
	
	// Convert dashed to camelCase; used by the css and data modules
	// Support: IE <=9 - 11, Edge 12 - 15
	// Microsoft forgot to hump their vendor prefix (#9572)
	function camelCase( string ) {
		return string.replace( rmsPrefix, "ms-" ).replace( rdashAlpha, fcamelCase );
	}
	var acceptData = function( owner ) {
	
		// Accepts only:
		//  - Node
		//    - Node.ELEMENT_NODE
		//    - Node.DOCUMENT_NODE
		//  - Object
		//    - Any
		return owner.nodeType === 1 || owner.nodeType === 9 || !( +owner.nodeType );
	};
	
	
	
	
	function Data() {
		this.expando = jQuery.expando + Data.uid++;
	}
	
	Data.uid = 1;
	
	Data.prototype = {
	
		cache: function( owner ) {
	
			// Check if the owner object already has a cache
			var value = owner[ this.expando ];
	
			// If not, create one
			if ( !value ) {
				value = {};
	
				// We can accept data for non-element nodes in modern browsers,
				// but we should not, see #8335.
				// Always return an empty object.
				if ( acceptData( owner ) ) {
	
					// If it is a node unlikely to be stringify-ed or looped over
					// use plain assignment
					if ( owner.nodeType ) {
						owner[ this.expando ] = value;
	
					// Otherwise secure it in a non-enumerable property
					// configurable must be true to allow the property to be
					// deleted when data is removed
					} else {
						Object.defineProperty( owner, this.expando, {
							value: value,
							configurable: true
						} );
					}
				}
			}
	
			return value;
		},
		set: function( owner, data, value ) {
			var prop,
				cache = this.cache( owner );
	
			// Handle: [ owner, key, value ] args
			// Always use camelCase key (gh-2257)
			if ( typeof data === "string" ) {
				cache[ camelCase( data ) ] = value;
	
			// Handle: [ owner, { properties } ] args
			} else {
	
				// Copy the properties one-by-one to the cache object
				for ( prop in data ) {
					cache[ camelCase( prop ) ] = data[ prop ];
				}
			}
			return cache;
		},
		get: function( owner, key ) {
			return key === undefined ?
				this.cache( owner ) :
	
				// Always use camelCase key (gh-2257)
				owner[ this.expando ] && owner[ this.expando ][ camelCase( key ) ];
		},
		access: function( owner, key, value ) {
	
			// In cases where either:
			//
			//   1. No key was specified
			//   2. A string key was specified, but no value provided
			//
			// Take the "read" path and allow the get method to determine
			// which value to return, respectively either:
			//
			//   1. The entire cache object
			//   2. The data stored at the key
			//
			if ( key === undefined ||
					( ( key && typeof key === "string" ) && value === undefined ) ) {
	
				return this.get( owner, key );
			}
	
			// When the key is not a string, or both a key and value
			// are specified, set or extend (existing objects) with either:
			//
			//   1. An object of properties
			//   2. A key and value
			//
			this.set( owner, key, value );
	
			// Since the "set" path can have two possible entry points
			// return the expected data based on which path was taken[*]
			return value !== undefined ? value : key;
		},
		remove: function( owner, key ) {
			var i,
				cache = owner[ this.expando ];
	
			if ( cache === undefined ) {
				return;
			}
	
			if ( key !== undefined ) {
	
				// Support array or space separated string of keys
				if ( Array.isArray( key ) ) {
	
					// If key is an array of keys...
					// We always set camelCase keys, so remove that.
					key = key.map( camelCase );
				} else {
					key = camelCase( key );
	
					// If a key with the spaces exists, use it.
					// Otherwise, create an array by matching non-whitespace
					key = key in cache ?
						[ key ] :
						( key.match( rnothtmlwhite ) || [] );
				}
	
				i = key.length;
	
				while ( i-- ) {
					delete cache[ key[ i ] ];
				}
			}
	
			// Remove the expando if there's no more data
			if ( key === undefined || jQuery.isEmptyObject( cache ) ) {
	
				// Support: Chrome <=35 - 45
				// Webkit & Blink performance suffers when deleting properties
				// from DOM nodes, so set to undefined instead
				// https://bugs.chromium.org/p/chromium/issues/detail?id=378607 (bug restricted)
				if ( owner.nodeType ) {
					owner[ this.expando ] = undefined;
				} else {
					delete owner[ this.expando ];
				}
			}
		},
		hasData: function( owner ) {
			var cache = owner[ this.expando ];
			return cache !== undefined && !jQuery.isEmptyObject( cache );
		}
	};
	var dataPriv = new Data();
	
	var dataUser = new Data();
	
	
	
	//	Implementation Summary
	//
	//	1. Enforce API surface and semantic compatibility with 1.9.x branch
	//	2. Improve the module's maintainability by reducing the storage
	//		paths to a single mechanism.
	//	3. Use the same single mechanism to support "private" and "user" data.
	//	4. _Never_ expose "private" data to user code (TODO: Drop _data, _removeData)
	//	5. Avoid exposing implementation details on user objects (eg. expando properties)
	//	6. Provide a clear path for implementation upgrade to WeakMap in 2014
	
	var rbrace = /^(?:\{[\w\W]*\}|\[[\w\W]*\])$/,
		rmultiDash = /[A-Z]/g;
	
	function getData( data ) {
		if ( data === "true" ) {
			return true;
		}
	
		if ( data === "false" ) {
			return false;
		}
	
		if ( data === "null" ) {
			return null;
		}
	
		// Only convert to a number if it doesn't change the string
		if ( data === +data + "" ) {
			return +data;
		}
	
		if ( rbrace.test( data ) ) {
			return JSON.parse( data );
		}
	
		return data;
	}
	
	function dataAttr( elem, key, data ) {
		var name;
	
		// If nothing was found internally, try to fetch any
		// data from the HTML5 data-* attribute
		if ( data === undefined && elem.nodeType === 1 ) {
			name = "data-" + key.replace( rmultiDash, "-$&" ).toLowerCase();
			data = elem.getAttribute( name );
	
			if ( typeof data === "string" ) {
				try {
					data = getData( data );
				} catch ( e ) {}
	
				// Make sure we set the data so it isn't changed later
				dataUser.set( elem, key, data );
			} else {
				data = undefined;
			}
		}
		return data;
	}
	
	jQuery.extend( {
		hasData: function( elem ) {
			return dataUser.hasData( elem ) || dataPriv.hasData( elem );
		},
	
		data: function( elem, name, data ) {
			return dataUser.access( elem, name, data );
		},
	
		removeData: function( elem, name ) {
			dataUser.remove( elem, name );
		},
	
		// TODO: Now that all calls to _data and _removeData have been replaced
		// with direct calls to dataPriv methods, these can be deprecated.
		_data: function( elem, name, data ) {
			return dataPriv.access( elem, name, data );
		},
	
		_removeData: function( elem, name ) {
			dataPriv.remove( elem, name );
		}
	} );
	
	jQuery.fn.extend( {
		data: function( key, value ) {
			var i, name, data,
				elem = this[ 0 ],
				attrs = elem && elem.attributes;
	
			// Gets all values
			if ( key === undefined ) {
				if ( this.length ) {
					data = dataUser.get( elem );
	
					if ( elem.nodeType === 1 && !dataPriv.get( elem, "hasDataAttrs" ) ) {
						i = attrs.length;
						while ( i-- ) {
	
							// Support: IE 11 only
							// The attrs elements can be null (#14894)
							if ( attrs[ i ] ) {
								name = attrs[ i ].name;
								if ( name.indexOf( "data-" ) === 0 ) {
									name = camelCase( name.slice( 5 ) );
									dataAttr( elem, name, data[ name ] );
								}
							}
						}
						dataPriv.set( elem, "hasDataAttrs", true );
					}
				}
	
				return data;
			}
	
			// Sets multiple values
			if ( typeof key === "object" ) {
				return this.each( function() {
					dataUser.set( this, key );
				} );
			}
	
			return access( this, function( value ) {
				var data;
	
				// The calling jQuery object (element matches) is not empty
				// (and therefore has an element appears at this[ 0 ]) and the
				// `value` parameter was not undefined. An empty jQuery object
				// will result in `undefined` for elem = this[ 0 ] which will
				// throw an exception if an attempt to read a data cache is made.
				if ( elem && value === undefined ) {
	
					// Attempt to get data from the cache
					// The key will always be camelCased in Data
					data = dataUser.get( elem, key );
					if ( data !== undefined ) {
						return data;
					}
	
					// Attempt to "discover" the data in
					// HTML5 custom data-* attrs
					data = dataAttr( elem, key );
					if ( data !== undefined ) {
						return data;
					}
	
					// We tried really hard, but the data doesn't exist.
					return;
				}
	
				// Set the data...
				this.each( function() {
	
					// We always store the camelCased key
					dataUser.set( this, key, value );
				} );
			}, null, value, arguments.length > 1, null, true );
		},
	
		removeData: function( key ) {
			return this.each( function() {
				dataUser.remove( this, key );
			} );
		}
	} );
	
	
	jQuery.extend( {
		queue: function( elem, type, data ) {
			var queue;
	
			if ( elem ) {
				type = ( type || "fx" ) + "queue";
				queue = dataPriv.get( elem, type );
	
				// Speed up dequeue by getting out quickly if this is just a lookup
				if ( data ) {
					if ( !queue || Array.isArray( data ) ) {
						queue = dataPriv.access( elem, type, jQuery.makeArray( data ) );
					} else {
						queue.push( data );
					}
				}
				return queue || [];
			}
		},
	
		dequeue: function( elem, type ) {
			type = type || "fx";
	
			var queue = jQuery.queue( elem, type ),
				startLength = queue.length,
				fn = queue.shift(),
				hooks = jQuery._queueHooks( elem, type ),
				next = function() {
					jQuery.dequeue( elem, type );
				};
	
			// If the fx queue is dequeued, always remove the progress sentinel
			if ( fn === "inprogress" ) {
				fn = queue.shift();
				startLength--;
			}
	
			if ( fn ) {
	
				// Add a progress sentinel to prevent the fx queue from being
				// automatically dequeued
				if ( type === "fx" ) {
					queue.unshift( "inprogress" );
				}
	
				// Clear up the last queue stop function
				delete hooks.stop;
				fn.call( elem, next, hooks );
			}
	
			if ( !startLength && hooks ) {
				hooks.empty.fire();
			}
		},
	
		// Not public - generate a queueHooks object, or return the current one
		_queueHooks: function( elem, type ) {
			var key = type + "queueHooks";
			return dataPriv.get( elem, key ) || dataPriv.access( elem, key, {
				empty: jQuery.Callbacks( "once memory" ).add( function() {
					dataPriv.remove( elem, [ type + "queue", key ] );
				} )
			} );
		}
	} );
	
	jQuery.fn.extend( {
		queue: function( type, data ) {
			var setter = 2;
	
			if ( typeof type !== "string" ) {
				data = type;
				type = "fx";
				setter--;
			}
	
			if ( arguments.length < setter ) {
				return jQuery.queue( this[ 0 ], type );
			}
	
			return data === undefined ?
				this :
				this.each( function() {
					var queue = jQuery.queue( this, type, data );
	
					// Ensure a hooks for this queue
					jQuery._queueHooks( this, type );
	
					if ( type === "fx" && queue[ 0 ] !== "inprogress" ) {
						jQuery.dequeue( this, type );
					}
				} );
		},
		dequeue: function( type ) {
			return this.each( function() {
				jQuery.dequeue( this, type );
			} );
		},
		clearQueue: function( type ) {
			return this.queue( type || "fx", [] );
		},
	
		// Get a promise resolved when queues of a certain type
		// are emptied (fx is the type by default)
		promise: function( type, obj ) {
			var tmp,
				count = 1,
				defer = jQuery.Deferred(),
				elements = this,
				i = this.length,
				resolve = function() {
					if ( !( --count ) ) {
						defer.resolveWith( elements, [ elements ] );
					}
				};
	
			if ( typeof type !== "string" ) {
				obj = type;
				type = undefined;
			}
			type = type || "fx";
	
			while ( i-- ) {
				tmp = dataPriv.get( elements[ i ], type + "queueHooks" );
				if ( tmp && tmp.empty ) {
					count++;
					tmp.empty.add( resolve );
				}
			}
			resolve();
			return defer.promise( obj );
		}
	} );
	var pnum = ( /[+-]?(?:\d*\.|)\d+(?:[eE][+-]?\d+|)/ ).source;
	
	var rcssNum = new RegExp( "^(?:([+-])=|)(" + pnum + ")([a-z%]*)$", "i" );
	
	
	var cssExpand = [ "Top", "Right", "Bottom", "Left" ];
	
	var documentElement = document.documentElement;
	
	
	
		var isAttached = function( elem ) {
				return jQuery.contains( elem.ownerDocument, elem );
			},
			composed = { composed: true };
	
		// Support: IE 9 - 11+, Edge 12 - 18+, iOS 10.0 - 10.2 only
		// Check attachment across shadow DOM boundaries when possible (gh-3504)
		// Support: iOS 10.0-10.2 only
		// Early iOS 10 versions support `attachShadow` but not `getRootNode`,
		// leading to errors. We need to check for `getRootNode`.
		if ( documentElement.getRootNode ) {
			isAttached = function( elem ) {
				return jQuery.contains( elem.ownerDocument, elem ) ||
					elem.getRootNode( composed ) === elem.ownerDocument;
			};
		}
	var isHiddenWithinTree = function( elem, el ) {
	
			// isHiddenWithinTree might be called from jQuery#filter function;
			// in that case, element will be second argument
			elem = el || elem;
	
			// Inline style trumps all
			return elem.style.display === "none" ||
				elem.style.display === "" &&
	
				// Otherwise, check computed style
				// Support: Firefox <=43 - 45
				// Disconnected elements can have computed display: none, so first confirm that elem is
				// in the document.
				isAttached( elem ) &&
	
				jQuery.css( elem, "display" ) === "none";
		};
	
	
	
	function adjustCSS( elem, prop, valueParts, tween ) {
		var adjusted, scale,
			maxIterations = 20,
			currentValue = tween ?
				function() {
					return tween.cur();
				} :
				function() {
					return jQuery.css( elem, prop, "" );
				},
			initial = currentValue(),
			unit = valueParts && valueParts[ 3 ] || ( jQuery.cssNumber[ prop ] ? "" : "px" ),
	
			// Starting value computation is required for potential unit mismatches
			initialInUnit = elem.nodeType &&
				( jQuery.cssNumber[ prop ] || unit !== "px" && +initial ) &&
				rcssNum.exec( jQuery.css( elem, prop ) );
	
		if ( initialInUnit && initialInUnit[ 3 ] !== unit ) {
	
			// Support: Firefox <=54
			// Halve the iteration target value to prevent interference from CSS upper bounds (gh-2144)
			initial = initial / 2;
	
			// Trust units reported by jQuery.css
			unit = unit || initialInUnit[ 3 ];
	
			// Iteratively approximate from a nonzero starting point
			initialInUnit = +initial || 1;
	
			while ( maxIterations-- ) {
	
				// Evaluate and update our best guess (doubling guesses that zero out).
				// Finish if the scale equals or crosses 1 (making the old*new product non-positive).
				jQuery.style( elem, prop, initialInUnit + unit );
				if ( ( 1 - scale ) * ( 1 - ( scale = currentValue() / initial || 0.5 ) ) <= 0 ) {
					maxIterations = 0;
				}
				initialInUnit = initialInUnit / scale;
	
			}
	
			initialInUnit = initialInUnit * 2;
			jQuery.style( elem, prop, initialInUnit + unit );
	
			// Make sure we update the tween properties later on
			valueParts = valueParts || [];
		}
	
		if ( valueParts ) {
			initialInUnit = +initialInUnit || +initial || 0;
	
			// Apply relative offset (+=/-=) if specified
			adjusted = valueParts[ 1 ] ?
				initialInUnit + ( valueParts[ 1 ] + 1 ) * valueParts[ 2 ] :
				+valueParts[ 2 ];
			if ( tween ) {
				tween.unit = unit;
				tween.start = initialInUnit;
				tween.end = adjusted;
			}
		}
		return adjusted;
	}
	
	
	var defaultDisplayMap = {};
	
	function getDefaultDisplay( elem ) {
		var temp,
			doc = elem.ownerDocument,
			nodeName = elem.nodeName,
			display = defaultDisplayMap[ nodeName ];
	
		if ( display ) {
			return display;
		}
	
		temp = doc.body.appendChild( doc.createElement( nodeName ) );
		display = jQuery.css( temp, "display" );
	
		temp.parentNode.removeChild( temp );
	
		if ( display === "none" ) {
			display = "block";
		}
		defaultDisplayMap[ nodeName ] = display;
	
		return display;
	}
	
	function showHide( elements, show ) {
		var display, elem,
			values = [],
			index = 0,
			length = elements.length;
	
		// Determine new display value for elements that need to change
		for ( ; index < length; index++ ) {
			elem = elements[ index ];
			if ( !elem.style ) {
				continue;
			}
	
			display = elem.style.display;
			if ( show ) {
	
				// Since we force visibility upon cascade-hidden elements, an immediate (and slow)
				// check is required in this first loop unless we have a nonempty display value (either
				// inline or about-to-be-restored)
				if ( display === "none" ) {
					values[ index ] = dataPriv.get( elem, "display" ) || null;
					if ( !values[ index ] ) {
						elem.style.display = "";
					}
				}
				if ( elem.style.display === "" && isHiddenWithinTree( elem ) ) {
					values[ index ] = getDefaultDisplay( elem );
				}
			} else {
				if ( display !== "none" ) {
					values[ index ] = "none";
	
					// Remember what we're overwriting
					dataPriv.set( elem, "display", display );
				}
			}
		}
	
		// Set the display of the elements in a second loop to avoid constant reflow
		for ( index = 0; index < length; index++ ) {
			if ( values[ index ] != null ) {
				elements[ index ].style.display = values[ index ];
			}
		}
	
		return elements;
	}
	
	jQuery.fn.extend( {
		show: function() {
			return showHide( this, true );
		},
		hide: function() {
			return showHide( this );
		},
		toggle: function( state ) {
			if ( typeof state === "boolean" ) {
				return state ? this.show() : this.hide();
			}
	
			return this.each( function() {
				if ( isHiddenWithinTree( this ) ) {
					jQuery( this ).show();
				} else {
					jQuery( this ).hide();
				}
			} );
		}
	} );
	var rcheckableType = ( /^(?:checkbox|radio)$/i );
	
	var rtagName = ( /<([a-z][^\/\0>\x20\t\r\n\f]*)/i );
	
	var rscriptType = ( /^$|^module$|\/(?:java|ecma)script/i );
	
	
	
	( function() {
		var fragment = document.createDocumentFragment(),
			div = fragment.appendChild( document.createElement( "div" ) ),
			input = document.createElement( "input" );
	
		// Support: Android 4.0 - 4.3 only
		// Check state lost if the name is set (#11217)
		// Support: Windows Web Apps (WWA)
		// `name` and `type` must use .setAttribute for WWA (#14901)
		input.setAttribute( "type", "radio" );
		input.setAttribute( "checked", "checked" );
		input.setAttribute( "name", "t" );
	
		div.appendChild( input );
	
		// Support: Android <=4.1 only
		// Older WebKit doesn't clone checked state correctly in fragments
		support.checkClone = div.cloneNode( true ).cloneNode( true ).lastChild.checked;
	
		// Support: IE <=11 only
		// Make sure textarea (and checkbox) defaultValue is properly cloned
		div.innerHTML = "<textarea>x</textarea>";
		support.noCloneChecked = !!div.cloneNode( true ).lastChild.defaultValue;
	
		// Support: IE <=9 only
		// IE <=9 replaces <option> tags with their contents when inserted outside of
		// the select element.
		div.innerHTML = "<option></option>";
		support.option = !!div.lastChild;
	} )();
	
	
	// We have to close these tags to support XHTML (#13200)
	var wrapMap = {
	
		// XHTML parsers do not magically insert elements in the
		// same way that tag soup parsers do. So we cannot shorten
		// this by omitting <tbody> or other required elements.
		thead: [ 1, "<table>", "</table>" ],
		col: [ 2, "<table><colgroup>", "</colgroup></table>" ],
		tr: [ 2, "<table><tbody>", "</tbody></table>" ],
		td: [ 3, "<table><tbody><tr>", "</tr></tbody></table>" ],
	
		_default: [ 0, "", "" ]
	};
	
	wrapMap.tbody = wrapMap.tfoot = wrapMap.colgroup = wrapMap.caption = wrapMap.thead;
	wrapMap.th = wrapMap.td;
	
	// Support: IE <=9 only
	if ( !support.option ) {
		wrapMap.optgroup = wrapMap.option = [ 1, "<select multiple='multiple'>", "</select>" ];
	}
	
	
	function getAll( context, tag ) {
	
		// Support: IE <=9 - 11 only
		// Use typeof to avoid zero-argument method invocation on host objects (#15151)
		var ret;
	
		if ( typeof context.getElementsByTagName !== "undefined" ) {
			ret = context.getElementsByTagName( tag || "*" );
	
		} else if ( typeof context.querySelectorAll !== "undefined" ) {
			ret = context.querySelectorAll( tag || "*" );
	
		} else {
			ret = [];
		}
	
		if ( tag === undefined || tag && nodeName( context, tag ) ) {
			return jQuery.merge( [ context ], ret );
		}
	
		return ret;
	}
	
	
	// Mark scripts as having already been evaluated
	function setGlobalEval( elems, refElements ) {
		var i = 0,
			l = elems.length;
	
		for ( ; i < l; i++ ) {
			dataPriv.set(
				elems[ i ],
				"globalEval",
				!refElements || dataPriv.get( refElements[ i ], "globalEval" )
			);
		}
	}
	
	
	var rhtml = /<|&#?\w+;/;
	
	function buildFragment( elems, context, scripts, selection, ignored ) {
		var elem, tmp, tag, wrap, attached, j,
			fragment = context.createDocumentFragment(),
			nodes = [],
			i = 0,
			l = elems.length;
	
		for ( ; i < l; i++ ) {
			elem = elems[ i ];
	
			if ( elem || elem === 0 ) {
	
				// Add nodes directly
				if ( toType( elem ) === "object" ) {
	
					// Support: Android <=4.0 only, PhantomJS 1 only
					// push.apply(_, arraylike) throws on ancient WebKit
					jQuery.merge( nodes, elem.nodeType ? [ elem ] : elem );
	
				// Convert non-html into a text node
				} else if ( !rhtml.test( elem ) ) {
					nodes.push( context.createTextNode( elem ) );
	
				// Convert html into DOM nodes
				} else {
					tmp = tmp || fragment.appendChild( context.createElement( "div" ) );
	
					// Deserialize a standard representation
					tag = ( rtagName.exec( elem ) || [ "", "" ] )[ 1 ].toLowerCase();
					wrap = wrapMap[ tag ] || wrapMap._default;
					tmp.innerHTML = wrap[ 1 ] + jQuery.htmlPrefilter( elem ) + wrap[ 2 ];
	
					// Descend through wrappers to the right content
					j = wrap[ 0 ];
					while ( j-- ) {
						tmp = tmp.lastChild;
					}
	
					// Support: Android <=4.0 only, PhantomJS 1 only
					// push.apply(_, arraylike) throws on ancient WebKit
					jQuery.merge( nodes, tmp.childNodes );
	
					// Remember the top-level container
					tmp = fragment.firstChild;
	
					// Ensure the created nodes are orphaned (#12392)
					tmp.textContent = "";
				}
			}
		}
	
		// Remove wrapper from fragment
		fragment.textContent = "";
	
		i = 0;
		while ( ( elem = nodes[ i++ ] ) ) {
	
			// Skip elements already in the context collection (trac-4087)
			if ( selection && jQuery.inArray( elem, selection ) > -1 ) {
				if ( ignored ) {
					ignored.push( elem );
				}
				continue;
			}
	
			attached = isAttached( elem );
	
			// Append to fragment
			tmp = getAll( fragment.appendChild( elem ), "script" );
	
			// Preserve script evaluation history
			if ( attached ) {
				setGlobalEval( tmp );
			}
	
			// Capture executables
			if ( scripts ) {
				j = 0;
				while ( ( elem = tmp[ j++ ] ) ) {
					if ( rscriptType.test( elem.type || "" ) ) {
						scripts.push( elem );
					}
				}
			}
		}
	
		return fragment;
	}
	
	
	var
		rkeyEvent = /^key/,
		rmouseEvent = /^(?:mouse|pointer|contextmenu|drag|drop)|click/,
		rtypenamespace = /^([^.]*)(?:\.(.+)|)/;
	
	function returnTrue() {
		return true;
	}
	
	function returnFalse() {
		return false;
	}
	
	// Support: IE <=9 - 11+
	// focus() and blur() are asynchronous, except when they are no-op.
	// So expect focus to be synchronous when the element is already active,
	// and blur to be synchronous when the element is not already active.
	// (focus and blur are always synchronous in other supported browsers,
	// this just defines when we can count on it).
	function expectSync( elem, type ) {
		return ( elem === safeActiveElement() ) === ( type === "focus" );
	}
	
	// Support: IE <=9 only
	// Accessing document.activeElement can throw unexpectedly
	// https://bugs.jquery.com/ticket/13393
	function safeActiveElement() {
		try {
			return document.activeElement;
		} catch ( err ) { }
	}
	
	function on( elem, types, selector, data, fn, one ) {
		var origFn, type;
	
		// Types can be a map of types/handlers
		if ( typeof types === "object" ) {
	
			// ( types-Object, selector, data )
			if ( typeof selector !== "string" ) {
	
				// ( types-Object, data )
				data = data || selector;
				selector = undefined;
			}
			for ( type in types ) {
				on( elem, type, selector, data, types[ type ], one );
			}
			return elem;
		}
	
		if ( data == null && fn == null ) {
	
			// ( types, fn )
			fn = selector;
			data = selector = undefined;
		} else if ( fn == null ) {
			if ( typeof selector === "string" ) {
	
				// ( types, selector, fn )
				fn = data;
				data = undefined;
			} else {
	
				// ( types, data, fn )
				fn = data;
				data = selector;
				selector = undefined;
			}
		}
		if ( fn === false ) {
			fn = returnFalse;
		} else if ( !fn ) {
			return elem;
		}
	
		if ( one === 1 ) {
			origFn = fn;
			fn = function( event ) {
	
				// Can use an empty set, since event contains the info
				jQuery().off( event );
				return origFn.apply( this, arguments );
			};
	
			// Use same guid so caller can remove using origFn
			fn.guid = origFn.guid || ( origFn.guid = jQuery.guid++ );
		}
		return elem.each( function() {
			jQuery.event.add( this, types, fn, data, selector );
		} );
	}
	
	/*
	 * Helper functions for managing events -- not part of the public interface.
	 * Props to Dean Edwards' addEvent library for many of the ideas.
	 */
	jQuery.event = {
	
		global: {},
	
		add: function( elem, types, handler, data, selector ) {
	
			var handleObjIn, eventHandle, tmp,
				events, t, handleObj,
				special, handlers, type, namespaces, origType,
				elemData = dataPriv.get( elem );
	
			// Only attach events to objects that accept data
			if ( !acceptData( elem ) ) {
				return;
			}
	
			// Caller can pass in an object of custom data in lieu of the handler
			if ( handler.handler ) {
				handleObjIn = handler;
				handler = handleObjIn.handler;
				selector = handleObjIn.selector;
			}
	
			// Ensure that invalid selectors throw exceptions at attach time
			// Evaluate against documentElement in case elem is a non-element node (e.g., document)
			if ( selector ) {
				jQuery.find.matchesSelector( documentElement, selector );
			}
	
			// Make sure that the handler has a unique ID, used to find/remove it later
			if ( !handler.guid ) {
				handler.guid = jQuery.guid++;
			}
	
			// Init the element's event structure and main handler, if this is the first
			if ( !( events = elemData.events ) ) {
				events = elemData.events = Object.create( null );
			}
			if ( !( eventHandle = elemData.handle ) ) {
				eventHandle = elemData.handle = function( e ) {
	
					// Discard the second event of a jQuery.event.trigger() and
					// when an event is called after a page has unloaded
					return typeof jQuery !== "undefined" && jQuery.event.triggered !== e.type ?
						jQuery.event.dispatch.apply( elem, arguments ) : undefined;
				};
			}
	
			// Handle multiple events separated by a space
			types = ( types || "" ).match( rnothtmlwhite ) || [ "" ];
			t = types.length;
			while ( t-- ) {
				tmp = rtypenamespace.exec( types[ t ] ) || [];
				type = origType = tmp[ 1 ];
				namespaces = ( tmp[ 2 ] || "" ).split( "." ).sort();
	
				// There *must* be a type, no attaching namespace-only handlers
				if ( !type ) {
					continue;
				}
	
				// If event changes its type, use the special event handlers for the changed type
				special = jQuery.event.special[ type ] || {};
	
				// If selector defined, determine special event api type, otherwise given type
				type = ( selector ? special.delegateType : special.bindType ) || type;
	
				// Update special based on newly reset type
				special = jQuery.event.special[ type ] || {};
	
				// handleObj is passed to all event handlers
				handleObj = jQuery.extend( {
					type: type,
					origType: origType,
					data: data,
					handler: handler,
					guid: handler.guid,
					selector: selector,
					needsContext: selector && jQuery.expr.match.needsContext.test( selector ),
					namespace: namespaces.join( "." )
				}, handleObjIn );
	
				// Init the event handler queue if we're the first
				if ( !( handlers = events[ type ] ) ) {
					handlers = events[ type ] = [];
					handlers.delegateCount = 0;
	
					// Only use addEventListener if the special events handler returns false
					if ( !special.setup ||
						special.setup.call( elem, data, namespaces, eventHandle ) === false ) {
	
						if ( elem.addEventListener ) {
							elem.addEventListener( type, eventHandle );
						}
					}
				}
	
				if ( special.add ) {
					special.add.call( elem, handleObj );
	
					if ( !handleObj.handler.guid ) {
						handleObj.handler.guid = handler.guid;
					}
				}
	
				// Add to the element's handler list, delegates in front
				if ( selector ) {
					handlers.splice( handlers.delegateCount++, 0, handleObj );
				} else {
					handlers.push( handleObj );
				}
	
				// Keep track of which events have ever been used, for event optimization
				jQuery.event.global[ type ] = true;
			}
	
		},
	
		// Detach an event or set of events from an element
		remove: function( elem, types, handler, selector, mappedTypes ) {
	
			var j, origCount, tmp,
				events, t, handleObj,
				special, handlers, type, namespaces, origType,
				elemData = dataPriv.hasData( elem ) && dataPriv.get( elem );
	
			if ( !elemData || !( events = elemData.events ) ) {
				return;
			}
	
			// Once for each type.namespace in types; type may be omitted
			types = ( types || "" ).match( rnothtmlwhite ) || [ "" ];
			t = types.length;
			while ( t-- ) {
				tmp = rtypenamespace.exec( types[ t ] ) || [];
				type = origType = tmp[ 1 ];
				namespaces = ( tmp[ 2 ] || "" ).split( "." ).sort();
	
				// Unbind all events (on this namespace, if provided) for the element
				if ( !type ) {
					for ( type in events ) {
						jQuery.event.remove( elem, type + types[ t ], handler, selector, true );
					}
					continue;
				}
	
				special = jQuery.event.special[ type ] || {};
				type = ( selector ? special.delegateType : special.bindType ) || type;
				handlers = events[ type ] || [];
				tmp = tmp[ 2 ] &&
					new RegExp( "(^|\\.)" + namespaces.join( "\\.(?:.*\\.|)" ) + "(\\.|$)" );
	
				// Remove matching events
				origCount = j = handlers.length;
				while ( j-- ) {
					handleObj = handlers[ j ];
	
					if ( ( mappedTypes || origType === handleObj.origType ) &&
						( !handler || handler.guid === handleObj.guid ) &&
						( !tmp || tmp.test( handleObj.namespace ) ) &&
						( !selector || selector === handleObj.selector ||
							selector === "**" && handleObj.selector ) ) {
						handlers.splice( j, 1 );
	
						if ( handleObj.selector ) {
							handlers.delegateCount--;
						}
						if ( special.remove ) {
							special.remove.call( elem, handleObj );
						}
					}
				}
	
				// Remove generic event handler if we removed something and no more handlers exist
				// (avoids potential for endless recursion during removal of special event handlers)
				if ( origCount && !handlers.length ) {
					if ( !special.teardown ||
						special.teardown.call( elem, namespaces, elemData.handle ) === false ) {
	
						jQuery.removeEvent( elem, type, elemData.handle );
					}
	
					delete events[ type ];
				}
			}
	
			// Remove data and the expando if it's no longer used
			if ( jQuery.isEmptyObject( events ) ) {
				dataPriv.remove( elem, "handle events" );
			}
		},
	
		dispatch: function( nativeEvent ) {
	
			var i, j, ret, matched, handleObj, handlerQueue,
				args = new Array( arguments.length ),
	
				// Make a writable jQuery.Event from the native event object
				event = jQuery.event.fix( nativeEvent ),
	
				handlers = (
						dataPriv.get( this, "events" ) || Object.create( null )
					)[ event.type ] || [],
				special = jQuery.event.special[ event.type ] || {};
	
			// Use the fix-ed jQuery.Event rather than the (read-only) native event
			args[ 0 ] = event;
	
			for ( i = 1; i < arguments.length; i++ ) {
				args[ i ] = arguments[ i ];
			}
	
			event.delegateTarget = this;
	
			// Call the preDispatch hook for the mapped type, and let it bail if desired
			if ( special.preDispatch && special.preDispatch.call( this, event ) === false ) {
				return;
			}
	
			// Determine handlers
			handlerQueue = jQuery.event.handlers.call( this, event, handlers );
	
			// Run delegates first; they may want to stop propagation beneath us
			i = 0;
			while ( ( matched = handlerQueue[ i++ ] ) && !event.isPropagationStopped() ) {
				event.currentTarget = matched.elem;
	
				j = 0;
				while ( ( handleObj = matched.handlers[ j++ ] ) &&
					!event.isImmediatePropagationStopped() ) {
	
					// If the event is namespaced, then each handler is only invoked if it is
					// specially universal or its namespaces are a superset of the event's.
					if ( !event.rnamespace || handleObj.namespace === false ||
						event.rnamespace.test( handleObj.namespace ) ) {
	
						event.handleObj = handleObj;
						event.data = handleObj.data;
	
						ret = ( ( jQuery.event.special[ handleObj.origType ] || {} ).handle ||
							handleObj.handler ).apply( matched.elem, args );
	
						if ( ret !== undefined ) {
							if ( ( event.result = ret ) === false ) {
								event.preventDefault();
								event.stopPropagation();
							}
						}
					}
				}
			}
	
			// Call the postDispatch hook for the mapped type
			if ( special.postDispatch ) {
				special.postDispatch.call( this, event );
			}
	
			return event.result;
		},
	
		handlers: function( event, handlers ) {
			var i, handleObj, sel, matchedHandlers, matchedSelectors,
				handlerQueue = [],
				delegateCount = handlers.delegateCount,
				cur = event.target;
	
			// Find delegate handlers
			if ( delegateCount &&
	
				// Support: IE <=9
				// Black-hole SVG <use> instance trees (trac-13180)
				cur.nodeType &&
	
				// Support: Firefox <=42
				// Suppress spec-violating clicks indicating a non-primary pointer button (trac-3861)
				// https://www.w3.org/TR/DOM-Level-3-Events/#event-type-click
				// Support: IE 11 only
				// ...but not arrow key "clicks" of radio inputs, which can have `button` -1 (gh-2343)
				!( event.type === "click" && event.button >= 1 ) ) {
	
				for ( ; cur !== this; cur = cur.parentNode || this ) {
	
					// Don't check non-elements (#13208)
					// Don't process clicks on disabled elements (#6911, #8165, #11382, #11764)
					if ( cur.nodeType === 1 && !( event.type === "click" && cur.disabled === true ) ) {
						matchedHandlers = [];
						matchedSelectors = {};
						for ( i = 0; i < delegateCount; i++ ) {
							handleObj = handlers[ i ];
	
							// Don't conflict with Object.prototype properties (#13203)
							sel = handleObj.selector + " ";
	
							if ( matchedSelectors[ sel ] === undefined ) {
								matchedSelectors[ sel ] = handleObj.needsContext ?
									jQuery( sel, this ).index( cur ) > -1 :
									jQuery.find( sel, this, null, [ cur ] ).length;
							}
							if ( matchedSelectors[ sel ] ) {
								matchedHandlers.push( handleObj );
							}
						}
						if ( matchedHandlers.length ) {
							handlerQueue.push( { elem: cur, handlers: matchedHandlers } );
						}
					}
				}
			}
	
			// Add the remaining (directly-bound) handlers
			cur = this;
			if ( delegateCount < handlers.length ) {
				handlerQueue.push( { elem: cur, handlers: handlers.slice( delegateCount ) } );
			}
	
			return handlerQueue;
		},
	
		addProp: function( name, hook ) {
			Object.defineProperty( jQuery.Event.prototype, name, {
				enumerable: true,
				configurable: true,
	
				get: isFunction( hook ) ?
					function() {
						if ( this.originalEvent ) {
								return hook( this.originalEvent );
						}
					} :
					function() {
						if ( this.originalEvent ) {
								return this.originalEvent[ name ];
						}
					},
	
				set: function( value ) {
					Object.defineProperty( this, name, {
						enumerable: true,
						configurable: true,
						writable: true,
						value: value
					} );
				}
			} );
		},
	
		fix: function( originalEvent ) {
			return originalEvent[ jQuery.expando ] ?
				originalEvent :
				new jQuery.Event( originalEvent );
		},
	
		special: {
			load: {
	
				// Prevent triggered image.load events from bubbling to window.load
				noBubble: true
			},
			click: {
	
				// Utilize native event to ensure correct state for checkable inputs
				setup: function( data ) {
	
					// For mutual compressibility with _default, replace `this` access with a local var.
					// `|| data` is dead code meant only to preserve the variable through minification.
					var el = this || data;
	
					// Claim the first handler
					if ( rcheckableType.test( el.type ) &&
						el.click && nodeName( el, "input" ) ) {
	
						// dataPriv.set( el, "click", ... )
						leverageNative( el, "click", returnTrue );
					}
	
					// Return false to allow normal processing in the caller
					return false;
				},
				trigger: function( data ) {
	
					// For mutual compressibility with _default, replace `this` access with a local var.
					// `|| data` is dead code meant only to preserve the variable through minification.
					var el = this || data;
	
					// Force setup before triggering a click
					if ( rcheckableType.test( el.type ) &&
						el.click && nodeName( el, "input" ) ) {
	
						leverageNative( el, "click" );
					}
	
					// Return non-false to allow normal event-path propagation
					return true;
				},
	
				// For cross-browser consistency, suppress native .click() on links
				// Also prevent it if we're currently inside a leveraged native-event stack
				_default: function( event ) {
					var target = event.target;
					return rcheckableType.test( target.type ) &&
						target.click && nodeName( target, "input" ) &&
						dataPriv.get( target, "click" ) ||
						nodeName( target, "a" );
				}
			},
	
			beforeunload: {
				postDispatch: function( event ) {
	
					// Support: Firefox 20+
					// Firefox doesn't alert if the returnValue field is not set.
					if ( event.result !== undefined && event.originalEvent ) {
						event.originalEvent.returnValue = event.result;
					}
				}
			}
		}
	};
	
	// Ensure the presence of an event listener that handles manually-triggered
	// synthetic events by interrupting progress until reinvoked in response to
	// *native* events that it fires directly, ensuring that state changes have
	// already occurred before other listeners are invoked.
	function leverageNative( el, type, expectSync ) {
	
		// Missing expectSync indicates a trigger call, which must force setup through jQuery.event.add
		if ( !expectSync ) {
			if ( dataPriv.get( el, type ) === undefined ) {
				jQuery.event.add( el, type, returnTrue );
			}
			return;
		}
	
		// Register the controller as a special universal handler for all event namespaces
		dataPriv.set( el, type, false );
		jQuery.event.add( el, type, {
			namespace: false,
			handler: function( event ) {
				var notAsync, result,
					saved = dataPriv.get( this, type );
	
				if ( ( event.isTrigger & 1 ) && this[ type ] ) {
	
					// Interrupt processing of the outer synthetic .trigger()ed event
					// Saved data should be false in such cases, but might be a leftover capture object
					// from an async native handler (gh-4350)
					if ( !saved.length ) {
	
						// Store arguments for use when handling the inner native event
						// There will always be at least one argument (an event object), so this array
						// will not be confused with a leftover capture object.
						saved = slice.call( arguments );
						dataPriv.set( this, type, saved );
	
						// Trigger the native event and capture its result
						// Support: IE <=9 - 11+
						// focus() and blur() are asynchronous
						notAsync = expectSync( this, type );
						this[ type ]();
						result = dataPriv.get( this, type );
						if ( saved !== result || notAsync ) {
							dataPriv.set( this, type, false );
						} else {
							result = {};
						}
						if ( saved !== result ) {
	
							// Cancel the outer synthetic event
							event.stopImmediatePropagation();
							event.preventDefault();
							return result.value;
						}
	
					// If this is an inner synthetic event for an event with a bubbling surrogate
					// (focus or blur), assume that the surrogate already propagated from triggering the
					// native event and prevent that from happening again here.
					// This technically gets the ordering wrong w.r.t. to `.trigger()` (in which the
					// bubbling surrogate propagates *after* the non-bubbling base), but that seems
					// less bad than duplication.
					} else if ( ( jQuery.event.special[ type ] || {} ).delegateType ) {
						event.stopPropagation();
					}
	
				// If this is a native event triggered above, everything is now in order
				// Fire an inner synthetic event with the original arguments
				} else if ( saved.length ) {
	
					// ...and capture the result
					dataPriv.set( this, type, {
						value: jQuery.event.trigger(
	
							// Support: IE <=9 - 11+
							// Extend with the prototype to reset the above stopImmediatePropagation()
							jQuery.extend( saved[ 0 ], jQuery.Event.prototype ),
							saved.slice( 1 ),
							this
						)
					} );
	
					// Abort handling of the native event
					event.stopImmediatePropagation();
				}
			}
		} );
	}
	
	jQuery.removeEvent = function( elem, type, handle ) {
	
		// This "if" is needed for plain objects
		if ( elem.removeEventListener ) {
			elem.removeEventListener( type, handle );
		}
	};
	
	jQuery.Event = function( src, props ) {
	
		// Allow instantiation without the 'new' keyword
		if ( !( this instanceof jQuery.Event ) ) {
			return new jQuery.Event( src, props );
		}
	
		// Event object
		if ( src && src.type ) {
			this.originalEvent = src;
			this.type = src.type;
	
			// Events bubbling up the document may have been marked as prevented
			// by a handler lower down the tree; reflect the correct value.
			this.isDefaultPrevented = src.defaultPrevented ||
					src.defaultPrevented === undefined &&
	
					// Support: Android <=2.3 only
					src.returnValue === false ?
				returnTrue :
				returnFalse;
	
			// Create target properties
			// Support: Safari <=6 - 7 only
			// Target should not be a text node (#504, #13143)
			this.target = ( src.target && src.target.nodeType === 3 ) ?
				src.target.parentNode :
				src.target;
	
			this.currentTarget = src.currentTarget;
			this.relatedTarget = src.relatedTarget;
	
		// Event type
		} else {
			this.type = src;
		}
	
		// Put explicitly provided properties onto the event object
		if ( props ) {
			jQuery.extend( this, props );
		}
	
		// Create a timestamp if incoming event doesn't have one
		this.timeStamp = src && src.timeStamp || Date.now();
	
		// Mark it as fixed
		this[ jQuery.expando ] = true;
	};
	
	// jQuery.Event is based on DOM3 Events as specified by the ECMAScript Language Binding
	// https://www.w3.org/TR/2003/WD-DOM-Level-3-Events-20030331/ecma-script-binding.html
	jQuery.Event.prototype = {
		constructor: jQuery.Event,
		isDefaultPrevented: returnFalse,
		isPropagationStopped: returnFalse,
		isImmediatePropagationStopped: returnFalse,
		isSimulated: false,
	
		preventDefault: function() {
			var e = this.originalEvent;
	
			this.isDefaultPrevented = returnTrue;
	
			if ( e && !this.isSimulated ) {
				e.preventDefault();
			}
		},
		stopPropagation: function() {
			var e = this.originalEvent;
	
			this.isPropagationStopped = returnTrue;
	
			if ( e && !this.isSimulated ) {
				e.stopPropagation();
			}
		},
		stopImmediatePropagation: function() {
			var e = this.originalEvent;
	
			this.isImmediatePropagationStopped = returnTrue;
	
			if ( e && !this.isSimulated ) {
				e.stopImmediatePropagation();
			}
	
			this.stopPropagation();
		}
	};
	
	// Includes all common event props including KeyEvent and MouseEvent specific props
	jQuery.each( {
		altKey: true,
		bubbles: true,
		cancelable: true,
		changedTouches: true,
		ctrlKey: true,
		detail: true,
		eventPhase: true,
		metaKey: true,
		pageX: true,
		pageY: true,
		shiftKey: true,
		view: true,
		"char": true,
		code: true,
		charCode: true,
		key: true,
		keyCode: true,
		button: true,
		buttons: true,
		clientX: true,
		clientY: true,
		offsetX: true,
		offsetY: true,
		pointerId: true,
		pointerType: true,
		screenX: true,
		screenY: true,
		targetTouches: true,
		toElement: true,
		touches: true,
	
		which: function( event ) {
			var button = event.button;
	
			// Add which for key events
			if ( event.which == null && rkeyEvent.test( event.type ) ) {
				return event.charCode != null ? event.charCode : event.keyCode;
			}
	
			// Add which for click: 1 === left; 2 === middle; 3 === right
			if ( !event.which && button !== undefined && rmouseEvent.test( event.type ) ) {
				if ( button & 1 ) {
					return 1;
				}
	
				if ( button & 2 ) {
					return 3;
				}
	
				if ( button & 4 ) {
					return 2;
				}
	
				return 0;
			}
	
			return event.which;
		}
	}, jQuery.event.addProp );
	
	jQuery.each( { focus: "focusin", blur: "focusout" }, function( type, delegateType ) {
		jQuery.event.special[ type ] = {
	
			// Utilize native event if possible so blur/focus sequence is correct
			setup: function() {
	
				// Claim the first handler
				// dataPriv.set( this, "focus", ... )
				// dataPriv.set( this, "blur", ... )
				leverageNative( this, type, expectSync );
	
				// Return false to allow normal processing in the caller
				return false;
			},
			trigger: function() {
	
				// Force setup before trigger
				leverageNative( this, type );
	
				// Return non-false to allow normal event-path propagation
				return true;
			},
	
			delegateType: delegateType
		};
	} );
	
	// Create mouseenter/leave events using mouseover/out and event-time checks
	// so that event delegation works in jQuery.
	// Do the same for pointerenter/pointerleave and pointerover/pointerout
	//
	// Support: Safari 7 only
	// Safari sends mouseenter too often; see:
	// https://bugs.chromium.org/p/chromium/issues/detail?id=470258
	// for the description of the bug (it existed in older Chrome versions as well).
	jQuery.each( {
		mouseenter: "mouseover",
		mouseleave: "mouseout",
		pointerenter: "pointerover",
		pointerleave: "pointerout"
	}, function( orig, fix ) {
		jQuery.event.special[ orig ] = {
			delegateType: fix,
			bindType: fix,
	
			handle: function( event ) {
				var ret,
					target = this,
					related = event.relatedTarget,
					handleObj = event.handleObj;
	
				// For mouseenter/leave call the handler if related is outside the target.
				// NB: No relatedTarget if the mouse left/entered the browser window
				if ( !related || ( related !== target && !jQuery.contains( target, related ) ) ) {
					event.type = handleObj.origType;
					ret = handleObj.handler.apply( this, arguments );
					event.type = fix;
				}
				return ret;
			}
		};
	} );
	
	jQuery.fn.extend( {
	
		on: function( types, selector, data, fn ) {
			return on( this, types, selector, data, fn );
		},
		one: function( types, selector, data, fn ) {
			return on( this, types, selector, data, fn, 1 );
		},
		off: function( types, selector, fn ) {
			var handleObj, type;
			if ( types && types.preventDefault && types.handleObj ) {
	
				// ( event )  dispatched jQuery.Event
				handleObj = types.handleObj;
				jQuery( types.delegateTarget ).off(
					handleObj.namespace ?
						handleObj.origType + "." + handleObj.namespace :
						handleObj.origType,
					handleObj.selector,
					handleObj.handler
				);
				return this;
			}
			if ( typeof types === "object" ) {
	
				// ( types-object [, selector] )
				for ( type in types ) {
					this.off( type, selector, types[ type ] );
				}
				return this;
			}
			if ( selector === false || typeof selector === "function" ) {
	
				// ( types [, fn] )
				fn = selector;
				selector = undefined;
			}
			if ( fn === false ) {
				fn = returnFalse;
			}
			return this.each( function() {
				jQuery.event.remove( this, types, fn, selector );
			} );
		}
	} );
	
	
	var
	
		// Support: IE <=10 - 11, Edge 12 - 13 only
		// In IE/Edge using regex groups here causes severe slowdowns.
		// See https://connect.microsoft.com/IE/feedback/details/1736512/
		rnoInnerhtml = /<script|<style|<link/i,
	
		// checked="checked" or checked
		rchecked = /checked\s*(?:[^=]|=\s*.checked.)/i,
		rcleanScript = /^\s*<!(?:\[CDATA\[|--)|(?:\]\]|--)>\s*$/g;
	
	// Prefer a tbody over its parent table for containing new rows
	function manipulationTarget( elem, content ) {
		if ( nodeName( elem, "table" ) &&
			nodeName( content.nodeType !== 11 ? content : content.firstChild, "tr" ) ) {
	
			return jQuery( elem ).children( "tbody" )[ 0 ] || elem;
		}
	
		return elem;
	}
	
	// Replace/restore the type attribute of script elements for safe DOM manipulation
	function disableScript( elem ) {
		elem.type = ( elem.getAttribute( "type" ) !== null ) + "/" + elem.type;
		return elem;
	}
	function restoreScript( elem ) {
		if ( ( elem.type || "" ).slice( 0, 5 ) === "true/" ) {
			elem.type = elem.type.slice( 5 );
		} else {
			elem.removeAttribute( "type" );
		}
	
		return elem;
	}
	
	function cloneCopyEvent( src, dest ) {
		var i, l, type, pdataOld, udataOld, udataCur, events;
	
		if ( dest.nodeType !== 1 ) {
			return;
		}
	
		// 1. Copy private data: events, handlers, etc.
		if ( dataPriv.hasData( src ) ) {
			pdataOld = dataPriv.get( src );
			events = pdataOld.events;
	
			if ( events ) {
				dataPriv.remove( dest, "handle events" );
	
				for ( type in events ) {
					for ( i = 0, l = events[ type ].length; i < l; i++ ) {
						jQuery.event.add( dest, type, events[ type ][ i ] );
					}
				}
			}
		}
	
		// 2. Copy user data
		if ( dataUser.hasData( src ) ) {
			udataOld = dataUser.access( src );
			udataCur = jQuery.extend( {}, udataOld );
	
			dataUser.set( dest, udataCur );
		}
	}
	
	// Fix IE bugs, see support tests
	function fixInput( src, dest ) {
		var nodeName = dest.nodeName.toLowerCase();
	
		// Fails to persist the checked state of a cloned checkbox or radio button.
		if ( nodeName === "input" && rcheckableType.test( src.type ) ) {
			dest.checked = src.checked;
	
		// Fails to return the selected option to the default selected state when cloning options
		} else if ( nodeName === "input" || nodeName === "textarea" ) {
			dest.defaultValue = src.defaultValue;
		}
	}
	
	function domManip( collection, args, callback, ignored ) {
	
		// Flatten any nested arrays
		args = flat( args );
	
		var fragment, first, scripts, hasScripts, node, doc,
			i = 0,
			l = collection.length,
			iNoClone = l - 1,
			value = args[ 0 ],
			valueIsFunction = isFunction( value );
	
		// We can't cloneNode fragments that contain checked, in WebKit
		if ( valueIsFunction ||
				( l > 1 && typeof value === "string" &&
					!support.checkClone && rchecked.test( value ) ) ) {
			return collection.each( function( index ) {
				var self = collection.eq( index );
				if ( valueIsFunction ) {
					args[ 0 ] = value.call( this, index, self.html() );
				}
				domManip( self, args, callback, ignored );
			} );
		}
	
		if ( l ) {
			fragment = buildFragment( args, collection[ 0 ].ownerDocument, false, collection, ignored );
			first = fragment.firstChild;
	
			if ( fragment.childNodes.length === 1 ) {
				fragment = first;
			}
	
			// Require either new content or an interest in ignored elements to invoke the callback
			if ( first || ignored ) {
				scripts = jQuery.map( getAll( fragment, "script" ), disableScript );
				hasScripts = scripts.length;
	
				// Use the original fragment for the last item
				// instead of the first because it can end up
				// being emptied incorrectly in certain situations (#8070).
				for ( ; i < l; i++ ) {
					node = fragment;
	
					if ( i !== iNoClone ) {
						node = jQuery.clone( node, true, true );
	
						// Keep references to cloned scripts for later restoration
						if ( hasScripts ) {
	
							// Support: Android <=4.0 only, PhantomJS 1 only
							// push.apply(_, arraylike) throws on ancient WebKit
							jQuery.merge( scripts, getAll( node, "script" ) );
						}
					}
	
					callback.call( collection[ i ], node, i );
				}
	
				if ( hasScripts ) {
					doc = scripts[ scripts.length - 1 ].ownerDocument;
	
					// Reenable scripts
					jQuery.map( scripts, restoreScript );
	
					// Evaluate executable scripts on first document insertion
					for ( i = 0; i < hasScripts; i++ ) {
						node = scripts[ i ];
						if ( rscriptType.test( node.type || "" ) &&
							!dataPriv.access( node, "globalEval" ) &&
							jQuery.contains( doc, node ) ) {
	
							if ( node.src && ( node.type || "" ).toLowerCase()  !== "module" ) {
	
								// Optional AJAX dependency, but won't run scripts if not present
								if ( jQuery._evalUrl && !node.noModule ) {
									jQuery._evalUrl( node.src, {
										nonce: node.nonce || node.getAttribute( "nonce" )
									}, doc );
								}
							} else {
								DOMEval( node.textContent.replace( rcleanScript, "" ), node, doc );
							}
						}
					}
				}
			}
		}
	
		return collection;
	}
	
	function remove( elem, selector, keepData ) {
		var node,
			nodes = selector ? jQuery.filter( selector, elem ) : elem,
			i = 0;
	
		for ( ; ( node = nodes[ i ] ) != null; i++ ) {
			if ( !keepData && node.nodeType === 1 ) {
				jQuery.cleanData( getAll( node ) );
			}
	
			if ( node.parentNode ) {
				if ( keepData && isAttached( node ) ) {
					setGlobalEval( getAll( node, "script" ) );
				}
				node.parentNode.removeChild( node );
			}
		}
	
		return elem;
	}
	
	jQuery.extend( {
		htmlPrefilter: function( html ) {
			return html;
		},
	
		clone: function( elem, dataAndEvents, deepDataAndEvents ) {
			var i, l, srcElements, destElements,
				clone = elem.cloneNode( true ),
				inPage = isAttached( elem );
	
			// Fix IE cloning issues
			if ( !support.noCloneChecked && ( elem.nodeType === 1 || elem.nodeType === 11 ) &&
					!jQuery.isXMLDoc( elem ) ) {
	
				// We eschew Sizzle here for performance reasons: https://jsperf.com/getall-vs-sizzle/2
				destElements = getAll( clone );
				srcElements = getAll( elem );
	
				for ( i = 0, l = srcElements.length; i < l; i++ ) {
					fixInput( srcElements[ i ], destElements[ i ] );
				}
			}
	
			// Copy the events from the original to the clone
			if ( dataAndEvents ) {
				if ( deepDataAndEvents ) {
					srcElements = srcElements || getAll( elem );
					destElements = destElements || getAll( clone );
	
					for ( i = 0, l = srcElements.length; i < l; i++ ) {
						cloneCopyEvent( srcElements[ i ], destElements[ i ] );
					}
				} else {
					cloneCopyEvent( elem, clone );
				}
			}
	
			// Preserve script evaluation history
			destElements = getAll( clone, "script" );
			if ( destElements.length > 0 ) {
				setGlobalEval( destElements, !inPage && getAll( elem, "script" ) );
			}
	
			// Return the cloned set
			return clone;
		},
	
		cleanData: function( elems ) {
			var data, elem, type,
				special = jQuery.event.special,
				i = 0;
	
			for ( ; ( elem = elems[ i ] ) !== undefined; i++ ) {
				if ( acceptData( elem ) ) {
					if ( ( data = elem[ dataPriv.expando ] ) ) {
						if ( data.events ) {
							for ( type in data.events ) {
								if ( special[ type ] ) {
									jQuery.event.remove( elem, type );
	
								// This is a shortcut to avoid jQuery.event.remove's overhead
								} else {
									jQuery.removeEvent( elem, type, data.handle );
								}
							}
						}
	
						// Support: Chrome <=35 - 45+
						// Assign undefined instead of using delete, see Data#remove
						elem[ dataPriv.expando ] = undefined;
					}
					if ( elem[ dataUser.expando ] ) {
	
						// Support: Chrome <=35 - 45+
						// Assign undefined instead of using delete, see Data#remove
						elem[ dataUser.expando ] = undefined;
					}
				}
			}
		}
	} );
	
	jQuery.fn.extend( {
		detach: function( selector ) {
			return remove( this, selector, true );
		},
	
		remove: function( selector ) {
			return remove( this, selector );
		},
	
		text: function( value ) {
			return access( this, function( value ) {
				return value === undefined ?
					jQuery.text( this ) :
					this.empty().each( function() {
						if ( this.nodeType === 1 || this.nodeType === 11 || this.nodeType === 9 ) {
							this.textContent = value;
						}
					} );
			}, null, value, arguments.length );
		},
	
		append: function() {
			return domManip( this, arguments, function( elem ) {
				if ( this.nodeType === 1 || this.nodeType === 11 || this.nodeType === 9 ) {
					var target = manipulationTarget( this, elem );
					target.appendChild( elem );
				}
			} );
		},
	
		prepend: function() {
			return domManip( this, arguments, function( elem ) {
				if ( this.nodeType === 1 || this.nodeType === 11 || this.nodeType === 9 ) {
					var target = manipulationTarget( this, elem );
					target.insertBefore( elem, target.firstChild );
				}
			} );
		},
	
		before: function() {
			return domManip( this, arguments, function( elem ) {
				if ( this.parentNode ) {
					this.parentNode.insertBefore( elem, this );
				}
			} );
		},
	
		after: function() {
			return domManip( this, arguments, function( elem ) {
				if ( this.parentNode ) {
					this.parentNode.insertBefore( elem, this.nextSibling );
				}
			} );
		},
	
		empty: function() {
			var elem,
				i = 0;
	
			for ( ; ( elem = this[ i ] ) != null; i++ ) {
				if ( elem.nodeType === 1 ) {
	
					// Prevent memory leaks
					jQuery.cleanData( getAll( elem, false ) );
	
					// Remove any remaining nodes
					elem.textContent = "";
				}
			}
	
			return this;
		},
	
		clone: function( dataAndEvents, deepDataAndEvents ) {
			dataAndEvents = dataAndEvents == null ? false : dataAndEvents;
			deepDataAndEvents = deepDataAndEvents == null ? dataAndEvents : deepDataAndEvents;
	
			return this.map( function() {
				return jQuery.clone( this, dataAndEvents, deepDataAndEvents );
			} );
		},
	
		html: function( value ) {
			return access( this, function( value ) {
				var elem = this[ 0 ] || {},
					i = 0,
					l = this.length;
	
				if ( value === undefined && elem.nodeType === 1 ) {
					return elem.innerHTML;
				}
	
				// See if we can take a shortcut and just use innerHTML
				if ( typeof value === "string" && !rnoInnerhtml.test( value ) &&
					!wrapMap[ ( rtagName.exec( value ) || [ "", "" ] )[ 1 ].toLowerCase() ] ) {
	
					value = jQuery.htmlPrefilter( value );
	
					try {
						for ( ; i < l; i++ ) {
							elem = this[ i ] || {};
	
							// Remove element nodes and prevent memory leaks
							if ( elem.nodeType === 1 ) {
								jQuery.cleanData( getAll( elem, false ) );
								elem.innerHTML = value;
							}
						}
	
						elem = 0;
	
					// If using innerHTML throws an exception, use the fallback method
					} catch ( e ) {}
				}
	
				if ( elem ) {
					this.empty().append( value );
				}
			}, null, value, arguments.length );
		},
	
		replaceWith: function() {
			var ignored = [];
	
			// Make the changes, replacing each non-ignored context element with the new content
			return domManip( this, arguments, function( elem ) {
				var parent = this.parentNode;
	
				if ( jQuery.inArray( this, ignored ) < 0 ) {
					jQuery.cleanData( getAll( this ) );
					if ( parent ) {
						parent.replaceChild( elem, this );
					}
				}
	
			// Force callback invocation
			}, ignored );
		}
	} );
	
	jQuery.each( {
		appendTo: "append",
		prependTo: "prepend",
		insertBefore: "before",
		insertAfter: "after",
		replaceAll: "replaceWith"
	}, function( name, original ) {
		jQuery.fn[ name ] = function( selector ) {
			var elems,
				ret = [],
				insert = jQuery( selector ),
				last = insert.length - 1,
				i = 0;
	
			for ( ; i <= last; i++ ) {
				elems = i === last ? this : this.clone( true );
				jQuery( insert[ i ] )[ original ]( elems );
	
				// Support: Android <=4.0 only, PhantomJS 1 only
				// .get() because push.apply(_, arraylike) throws on ancient WebKit
				push.apply( ret, elems.get() );
			}
	
			return this.pushStack( ret );
		};
	} );
	var rnumnonpx = new RegExp( "^(" + pnum + ")(?!px)[a-z%]+$", "i" );
	
	var getStyles = function( elem ) {
	
			// Support: IE <=11 only, Firefox <=30 (#15098, #14150)
			// IE throws on elements created in popups
			// FF meanwhile throws on frame elements through "defaultView.getComputedStyle"
			var view = elem.ownerDocument.defaultView;
	
			if ( !view || !view.opener ) {
				view = window;
			}
	
			return view.getComputedStyle( elem );
		};
	
	var swap = function( elem, options, callback ) {
		var ret, name,
			old = {};
	
		// Remember the old values, and insert the new ones
		for ( name in options ) {
			old[ name ] = elem.style[ name ];
			elem.style[ name ] = options[ name ];
		}
	
		ret = callback.call( elem );
	
		// Revert the old values
		for ( name in options ) {
			elem.style[ name ] = old[ name ];
		}
	
		return ret;
	};
	
	
	var rboxStyle = new RegExp( cssExpand.join( "|" ), "i" );
	
	
	
	( function() {
	
		// Executing both pixelPosition & boxSizingReliable tests require only one layout
		// so they're executed at the same time to save the second computation.
		function computeStyleTests() {
	
			// This is a singleton, we need to execute it only once
			if ( !div ) {
				return;
			}
	
			container.style.cssText = "position:absolute;left:-11111px;width:60px;" +
				"margin-top:1px;padding:0;border:0";
			div.style.cssText =
				"position:relative;display:block;box-sizing:border-box;overflow:scroll;" +
				"margin:auto;border:1px;padding:1px;" +
				"width:60%;top:1%";
			documentElement.appendChild( container ).appendChild( div );
	
			var divStyle = window.getComputedStyle( div );
			pixelPositionVal = divStyle.top !== "1%";
	
			// Support: Android 4.0 - 4.3 only, Firefox <=3 - 44
			reliableMarginLeftVal = roundPixelMeasures( divStyle.marginLeft ) === 12;
	
			// Support: Android 4.0 - 4.3 only, Safari <=9.1 - 10.1, iOS <=7.0 - 9.3
			// Some styles come back with percentage values, even though they shouldn't
			div.style.right = "60%";
			pixelBoxStylesVal = roundPixelMeasures( divStyle.right ) === 36;
	
			// Support: IE 9 - 11 only
			// Detect misreporting of content dimensions for box-sizing:border-box elements
			boxSizingReliableVal = roundPixelMeasures( divStyle.width ) === 36;
	
			// Support: IE 9 only
			// Detect overflow:scroll screwiness (gh-3699)
			// Support: Chrome <=64
			// Don't get tricked when zoom affects offsetWidth (gh-4029)
			div.style.position = "absolute";
			scrollboxSizeVal = roundPixelMeasures( div.offsetWidth / 3 ) === 12;
	
			documentElement.removeChild( container );
	
			// Nullify the div so it wouldn't be stored in the memory and
			// it will also be a sign that checks already performed
			div = null;
		}
	
		function roundPixelMeasures( measure ) {
			return Math.round( parseFloat( measure ) );
		}
	
		var pixelPositionVal, boxSizingReliableVal, scrollboxSizeVal, pixelBoxStylesVal,
			reliableTrDimensionsVal, reliableMarginLeftVal,
			container = document.createElement( "div" ),
			div = document.createElement( "div" );
	
		// Finish early in limited (non-browser) environments
		if ( !div.style ) {
			return;
		}
	
		// Support: IE <=9 - 11 only
		// Style of cloned element affects source element cloned (#8908)
		div.style.backgroundClip = "content-box";
		div.cloneNode( true ).style.backgroundClip = "";
		support.clearCloneStyle = div.style.backgroundClip === "content-box";
	
		jQuery.extend( support, {
			boxSizingReliable: function() {
				computeStyleTests();
				return boxSizingReliableVal;
			},
			pixelBoxStyles: function() {
				computeStyleTests();
				return pixelBoxStylesVal;
			},
			pixelPosition: function() {
				computeStyleTests();
				return pixelPositionVal;
			},
			reliableMarginLeft: function() {
				computeStyleTests();
				return reliableMarginLeftVal;
			},
			scrollboxSize: function() {
				computeStyleTests();
				return scrollboxSizeVal;
			},
	
			// Support: IE 9 - 11+, Edge 15 - 18+
			// IE/Edge misreport `getComputedStyle` of table rows with width/height
			// set in CSS while `offset*` properties report correct values.
			// Behavior in IE 9 is more subtle than in newer versions & it passes
			// some versions of this test; make sure not to make it pass there!
			reliableTrDimensions: function() {
				var table, tr, trChild, trStyle;
				if ( reliableTrDimensionsVal == null ) {
					table = document.createElement( "table" );
					tr = document.createElement( "tr" );
					trChild = document.createElement( "div" );
	
					table.style.cssText = "position:absolute;left:-11111px";
					tr.style.height = "1px";
					trChild.style.height = "9px";
	
					documentElement
						.appendChild( table )
						.appendChild( tr )
						.appendChild( trChild );
	
					trStyle = window.getComputedStyle( tr );
					reliableTrDimensionsVal = parseInt( trStyle.height ) > 3;
	
					documentElement.removeChild( table );
				}
				return reliableTrDimensionsVal;
			}
		} );
	} )();
	
	
	function curCSS( elem, name, computed ) {
		var width, minWidth, maxWidth, ret,
	
			// Support: Firefox 51+
			// Retrieving style before computed somehow
			// fixes an issue with getting wrong values
			// on detached elements
			style = elem.style;
	
		computed = computed || getStyles( elem );
	
		// getPropertyValue is needed for:
		//   .css('filter') (IE 9 only, #12537)
		//   .css('--customProperty) (#3144)
		if ( computed ) {
			ret = computed.getPropertyValue( name ) || computed[ name ];
	
			if ( ret === "" && !isAttached( elem ) ) {
				ret = jQuery.style( elem, name );
			}
	
			// A tribute to the "awesome hack by Dean Edwards"
			// Android Browser returns percentage for some values,
			// but width seems to be reliably pixels.
			// This is against the CSSOM draft spec:
			// https://drafts.csswg.org/cssom/#resolved-values
			if ( !support.pixelBoxStyles() && rnumnonpx.test( ret ) && rboxStyle.test( name ) ) {
	
				// Remember the original values
				width = style.width;
				minWidth = style.minWidth;
				maxWidth = style.maxWidth;
	
				// Put in the new values to get a computed value out
				style.minWidth = style.maxWidth = style.width = ret;
				ret = computed.width;
	
				// Revert the changed values
				style.width = width;
				style.minWidth = minWidth;
				style.maxWidth = maxWidth;
			}
		}
	
		return ret !== undefined ?
	
			// Support: IE <=9 - 11 only
			// IE returns zIndex value as an integer.
			ret + "" :
			ret;
	}
	
	
	function addGetHookIf( conditionFn, hookFn ) {
	
		// Define the hook, we'll check on the first run if it's really needed.
		return {
			get: function() {
				if ( conditionFn() ) {
	
					// Hook not needed (or it's not possible to use it due
					// to missing dependency), remove it.
					delete this.get;
					return;
				}
	
				// Hook needed; redefine it so that the support test is not executed again.
				return ( this.get = hookFn ).apply( this, arguments );
			}
		};
	}
	
	
	var cssPrefixes = [ "Webkit", "Moz", "ms" ],
		emptyStyle = document.createElement( "div" ).style,
		vendorProps = {};
	
	// Return a vendor-prefixed property or undefined
	function vendorPropName( name ) {
	
		// Check for vendor prefixed names
		var capName = name[ 0 ].toUpperCase() + name.slice( 1 ),
			i = cssPrefixes.length;
	
		while ( i-- ) {
			name = cssPrefixes[ i ] + capName;
			if ( name in emptyStyle ) {
				return name;
			}
		}
	}
	
	// Return a potentially-mapped jQuery.cssProps or vendor prefixed property
	function finalPropName( name ) {
		var final = jQuery.cssProps[ name ] || vendorProps[ name ];
	
		if ( final ) {
			return final;
		}
		if ( name in emptyStyle ) {
			return name;
		}
		return vendorProps[ name ] = vendorPropName( name ) || name;
	}
	
	
	var
	
		// Swappable if display is none or starts with table
		// except "table", "table-cell", or "table-caption"
		// See here for display values: https://developer.mozilla.org/en-US/docs/CSS/display
		rdisplayswap = /^(none|table(?!-c[ea]).+)/,
		rcustomProp = /^--/,
		cssShow = { position: "absolute", visibility: "hidden", display: "block" },
		cssNormalTransform = {
			letterSpacing: "0",
			fontWeight: "400"
		};
	
	function setPositiveNumber( _elem, value, subtract ) {
	
		// Any relative (+/-) values have already been
		// normalized at this point
		var matches = rcssNum.exec( value );
		return matches ?
	
			// Guard against undefined "subtract", e.g., when used as in cssHooks
			Math.max( 0, matches[ 2 ] - ( subtract || 0 ) ) + ( matches[ 3 ] || "px" ) :
			value;
	}
	
	function boxModelAdjustment( elem, dimension, box, isBorderBox, styles, computedVal ) {
		var i = dimension === "width" ? 1 : 0,
			extra = 0,
			delta = 0;
	
		// Adjustment may not be necessary
		if ( box === ( isBorderBox ? "border" : "content" ) ) {
			return 0;
		}
	
		for ( ; i < 4; i += 2 ) {
	
			// Both box models exclude margin
			if ( box === "margin" ) {
				delta += jQuery.css( elem, box + cssExpand[ i ], true, styles );
			}
	
			// If we get here with a content-box, we're seeking "padding" or "border" or "margin"
			if ( !isBorderBox ) {
	
				// Add padding
				delta += jQuery.css( elem, "padding" + cssExpand[ i ], true, styles );
	
				// For "border" or "margin", add border
				if ( box !== "padding" ) {
					delta += jQuery.css( elem, "border" + cssExpand[ i ] + "Width", true, styles );
	
				// But still keep track of it otherwise
				} else {
					extra += jQuery.css( elem, "border" + cssExpand[ i ] + "Width", true, styles );
				}
	
			// If we get here with a border-box (content + padding + border), we're seeking "content" or
			// "padding" or "margin"
			} else {
	
				// For "content", subtract padding
				if ( box === "content" ) {
					delta -= jQuery.css( elem, "padding" + cssExpand[ i ], true, styles );
				}
	
				// For "content" or "padding", subtract border
				if ( box !== "margin" ) {
					delta -= jQuery.css( elem, "border" + cssExpand[ i ] + "Width", true, styles );
				}
			}
		}
	
		// Account for positive content-box scroll gutter when requested by providing computedVal
		if ( !isBorderBox && computedVal >= 0 ) {
	
			// offsetWidth/offsetHeight is a rounded sum of content, padding, scroll gutter, and border
			// Assuming integer scroll gutter, subtract the rest and round down
			delta += Math.max( 0, Math.ceil(
				elem[ "offset" + dimension[ 0 ].toUpperCase() + dimension.slice( 1 ) ] -
				computedVal -
				delta -
				extra -
				0.5
	
			// If offsetWidth/offsetHeight is unknown, then we can't determine content-box scroll gutter
			// Use an explicit zero to avoid NaN (gh-3964)
			) ) || 0;
		}
	
		return delta;
	}
	
	function getWidthOrHeight( elem, dimension, extra ) {
	
		// Start with computed style
		var styles = getStyles( elem ),
	
			// To avoid forcing a reflow, only fetch boxSizing if we need it (gh-4322).
			// Fake content-box until we know it's needed to know the true value.
			boxSizingNeeded = !support.boxSizingReliable() || extra,
			isBorderBox = boxSizingNeeded &&
				jQuery.css( elem, "boxSizing", false, styles ) === "border-box",
			valueIsBorderBox = isBorderBox,
	
			val = curCSS( elem, dimension, styles ),
			offsetProp = "offset" + dimension[ 0 ].toUpperCase() + dimension.slice( 1 );
	
		// Support: Firefox <=54
		// Return a confounding non-pixel value or feign ignorance, as appropriate.
		if ( rnumnonpx.test( val ) ) {
			if ( !extra ) {
				return val;
			}
			val = "auto";
		}
	
	
		// Support: IE 9 - 11 only
		// Use offsetWidth/offsetHeight for when box sizing is unreliable.
		// In those cases, the computed value can be trusted to be border-box.
		if ( ( !support.boxSizingReliable() && isBorderBox ||
	
			// Support: IE 10 - 11+, Edge 15 - 18+
			// IE/Edge misreport `getComputedStyle` of table rows with width/height
			// set in CSS while `offset*` properties report correct values.
			// Interestingly, in some cases IE 9 doesn't suffer from this issue.
			!support.reliableTrDimensions() && nodeName( elem, "tr" ) ||
	
			// Fall back to offsetWidth/offsetHeight when value is "auto"
			// This happens for inline elements with no explicit setting (gh-3571)
			val === "auto" ||
	
			// Support: Android <=4.1 - 4.3 only
			// Also use offsetWidth/offsetHeight for misreported inline dimensions (gh-3602)
			!parseFloat( val ) && jQuery.css( elem, "display", false, styles ) === "inline" ) &&
	
			// Make sure the element is visible & connected
			elem.getClientRects().length ) {
	
			isBorderBox = jQuery.css( elem, "boxSizing", false, styles ) === "border-box";
	
			// Where available, offsetWidth/offsetHeight approximate border box dimensions.
			// Where not available (e.g., SVG), assume unreliable box-sizing and interpret the
			// retrieved value as a content box dimension.
			valueIsBorderBox = offsetProp in elem;
			if ( valueIsBorderBox ) {
				val = elem[ offsetProp ];
			}
		}
	
		// Normalize "" and auto
		val = parseFloat( val ) || 0;
	
		// Adjust for the element's box model
		return ( val +
			boxModelAdjustment(
				elem,
				dimension,
				extra || ( isBorderBox ? "border" : "content" ),
				valueIsBorderBox,
				styles,
	
				// Provide the current computed size to request scroll gutter calculation (gh-3589)
				val
			)
		) + "px";
	}
	
	jQuery.extend( {
	
		// Add in style property hooks for overriding the default
		// behavior of getting and setting a style property
		cssHooks: {
			opacity: {
				get: function( elem, computed ) {
					if ( computed ) {
	
						// We should always get a number back from opacity
						var ret = curCSS( elem, "opacity" );
						return ret === "" ? "1" : ret;
					}
				}
			}
		},
	
		// Don't automatically add "px" to these possibly-unitless properties
		cssNumber: {
			"animationIterationCount": true,
			"columnCount": true,
			"fillOpacity": true,
			"flexGrow": true,
			"flexShrink": true,
			"fontWeight": true,
			"gridArea": true,
			"gridColumn": true,
			"gridColumnEnd": true,
			"gridColumnStart": true,
			"gridRow": true,
			"gridRowEnd": true,
			"gridRowStart": true,
			"lineHeight": true,
			"opacity": true,
			"order": true,
			"orphans": true,
			"widows": true,
			"zIndex": true,
			"zoom": true
		},
	
		// Add in properties whose names you wish to fix before
		// setting or getting the value
		cssProps: {},
	
		// Get and set the style property on a DOM Node
		style: function( elem, name, value, extra ) {
	
			// Don't set styles on text and comment nodes
			if ( !elem || elem.nodeType === 3 || elem.nodeType === 8 || !elem.style ) {
				return;
			}
	
			// Make sure that we're working with the right name
			var ret, type, hooks,
				origName = camelCase( name ),
				isCustomProp = rcustomProp.test( name ),
				style = elem.style;
	
			// Make sure that we're working with the right name. We don't
			// want to query the value if it is a CSS custom property
			// since they are user-defined.
			if ( !isCustomProp ) {
				name = finalPropName( origName );
			}
	
			// Gets hook for the prefixed version, then unprefixed version
			hooks = jQuery.cssHooks[ name ] || jQuery.cssHooks[ origName ];
	
			// Check if we're setting a value
			if ( value !== undefined ) {
				type = typeof value;
	
				// Convert "+=" or "-=" to relative numbers (#7345)
				if ( type === "string" && ( ret = rcssNum.exec( value ) ) && ret[ 1 ] ) {
					value = adjustCSS( elem, name, ret );
	
					// Fixes bug #9237
					type = "number";
				}
	
				// Make sure that null and NaN values aren't set (#7116)
				if ( value == null || value !== value ) {
					return;
				}
	
				// If a number was passed in, add the unit (except for certain CSS properties)
				// The isCustomProp check can be removed in jQuery 4.0 when we only auto-append
				// "px" to a few hardcoded values.
				if ( type === "number" && !isCustomProp ) {
					value += ret && ret[ 3 ] || ( jQuery.cssNumber[ origName ] ? "" : "px" );
				}
	
				// background-* props affect original clone's values
				if ( !support.clearCloneStyle && value === "" && name.indexOf( "background" ) === 0 ) {
					style[ name ] = "inherit";
				}
	
				// If a hook was provided, use that value, otherwise just set the specified value
				if ( !hooks || !( "set" in hooks ) ||
					( value = hooks.set( elem, value, extra ) ) !== undefined ) {
	
					if ( isCustomProp ) {
						style.setProperty( name, value );
					} else {
						style[ name ] = value;
					}
				}
	
			} else {
	
				// If a hook was provided get the non-computed value from there
				if ( hooks && "get" in hooks &&
					( ret = hooks.get( elem, false, extra ) ) !== undefined ) {
	
					return ret;
				}
	
				// Otherwise just get the value from the style object
				return style[ name ];
			}
		},
	
		css: function( elem, name, extra, styles ) {
			var val, num, hooks,
				origName = camelCase( name ),
				isCustomProp = rcustomProp.test( name );
	
			// Make sure that we're working with the right name. We don't
			// want to modify the value if it is a CSS custom property
			// since they are user-defined.
			if ( !isCustomProp ) {
				name = finalPropName( origName );
			}
	
			// Try prefixed name followed by the unprefixed name
			hooks = jQuery.cssHooks[ name ] || jQuery.cssHooks[ origName ];
	
			// If a hook was provided get the computed value from there
			if ( hooks && "get" in hooks ) {
				val = hooks.get( elem, true, extra );
			}
	
			// Otherwise, if a way to get the computed value exists, use that
			if ( val === undefined ) {
				val = curCSS( elem, name, styles );
			}
	
			// Convert "normal" to computed value
			if ( val === "normal" && name in cssNormalTransform ) {
				val = cssNormalTransform[ name ];
			}
	
			// Make numeric if forced or a qualifier was provided and val looks numeric
			if ( extra === "" || extra ) {
				num = parseFloat( val );
				return extra === true || isFinite( num ) ? num || 0 : val;
			}
	
			return val;
		}
	} );
	
	jQuery.each( [ "height", "width" ], function( _i, dimension ) {
		jQuery.cssHooks[ dimension ] = {
			get: function( elem, computed, extra ) {
				if ( computed ) {
	
					// Certain elements can have dimension info if we invisibly show them
					// but it must have a current display style that would benefit
					return rdisplayswap.test( jQuery.css( elem, "display" ) ) &&
	
						// Support: Safari 8+
						// Table columns in Safari have non-zero offsetWidth & zero
						// getBoundingClientRect().width unless display is changed.
						// Support: IE <=11 only
						// Running getBoundingClientRect on a disconnected node
						// in IE throws an error.
						( !elem.getClientRects().length || !elem.getBoundingClientRect().width ) ?
							swap( elem, cssShow, function() {
								return getWidthOrHeight( elem, dimension, extra );
							} ) :
							getWidthOrHeight( elem, dimension, extra );
				}
			},
	
			set: function( elem, value, extra ) {
				var matches,
					styles = getStyles( elem ),
	
					// Only read styles.position if the test has a chance to fail
					// to avoid forcing a reflow.
					scrollboxSizeBuggy = !support.scrollboxSize() &&
						styles.position === "absolute",
	
					// To avoid forcing a reflow, only fetch boxSizing if we need it (gh-3991)
					boxSizingNeeded = scrollboxSizeBuggy || extra,
					isBorderBox = boxSizingNeeded &&
						jQuery.css( elem, "boxSizing", false, styles ) === "border-box",
					subtract = extra ?
						boxModelAdjustment(
							elem,
							dimension,
							extra,
							isBorderBox,
							styles
						) :
						0;
	
				// Account for unreliable border-box dimensions by comparing offset* to computed and
				// faking a content-box to get border and padding (gh-3699)
				if ( isBorderBox && scrollboxSizeBuggy ) {
					subtract -= Math.ceil(
						elem[ "offset" + dimension[ 0 ].toUpperCase() + dimension.slice( 1 ) ] -
						parseFloat( styles[ dimension ] ) -
						boxModelAdjustment( elem, dimension, "border", false, styles ) -
						0.5
					);
				}
	
				// Convert to pixels if value adjustment is needed
				if ( subtract && ( matches = rcssNum.exec( value ) ) &&
					( matches[ 3 ] || "px" ) !== "px" ) {
	
					elem.style[ dimension ] = value;
					value = jQuery.css( elem, dimension );
				}
	
				return setPositiveNumber( elem, value, subtract );
			}
		};
	} );
	
	jQuery.cssHooks.marginLeft = addGetHookIf( support.reliableMarginLeft,
		function( elem, computed ) {
			if ( computed ) {
				return ( parseFloat( curCSS( elem, "marginLeft" ) ) ||
					elem.getBoundingClientRect().left -
						swap( elem, { marginLeft: 0 }, function() {
							return elem.getBoundingClientRect().left;
						} )
					) + "px";
			}
		}
	);
	
	// These hooks are used by animate to expand properties
	jQuery.each( {
		margin: "",
		padding: "",
		border: "Width"
	}, function( prefix, suffix ) {
		jQuery.cssHooks[ prefix + suffix ] = {
			expand: function( value ) {
				var i = 0,
					expanded = {},
	
					// Assumes a single number if not a string
					parts = typeof value === "string" ? value.split( " " ) : [ value ];
	
				for ( ; i < 4; i++ ) {
					expanded[ prefix + cssExpand[ i ] + suffix ] =
						parts[ i ] || parts[ i - 2 ] || parts[ 0 ];
				}
	
				return expanded;
			}
		};
	
		if ( prefix !== "margin" ) {
			jQuery.cssHooks[ prefix + suffix ].set = setPositiveNumber;
		}
	} );
	
	jQuery.fn.extend( {
		css: function( name, value ) {
			return access( this, function( elem, name, value ) {
				var styles, len,
					map = {},
					i = 0;
	
				if ( Array.isArray( name ) ) {
					styles = getStyles( elem );
					len = name.length;
	
					for ( ; i < len; i++ ) {
						map[ name[ i ] ] = jQuery.css( elem, name[ i ], false, styles );
					}
	
					return map;
				}
	
				return value !== undefined ?
					jQuery.style( elem, name, value ) :
					jQuery.css( elem, name );
			}, name, value, arguments.length > 1 );
		}
	} );
	
	
	function Tween( elem, options, prop, end, easing ) {
		return new Tween.prototype.init( elem, options, prop, end, easing );
	}
	jQuery.Tween = Tween;
	
	Tween.prototype = {
		constructor: Tween,
		init: function( elem, options, prop, end, easing, unit ) {
			this.elem = elem;
			this.prop = prop;
			this.easing = easing || jQuery.easing._default;
			this.options = options;
			this.start = this.now = this.cur();
			this.end = end;
			this.unit = unit || ( jQuery.cssNumber[ prop ] ? "" : "px" );
		},
		cur: function() {
			var hooks = Tween.propHooks[ this.prop ];
	
			return hooks && hooks.get ?
				hooks.get( this ) :
				Tween.propHooks._default.get( this );
		},
		run: function( percent ) {
			var eased,
				hooks = Tween.propHooks[ this.prop ];
	
			if ( this.options.duration ) {
				this.pos = eased = jQuery.easing[ this.easing ](
					percent, this.options.duration * percent, 0, 1, this.options.duration
				);
			} else {
				this.pos = eased = percent;
			}
			this.now = ( this.end - this.start ) * eased + this.start;
	
			if ( this.options.step ) {
				this.options.step.call( this.elem, this.now, this );
			}
	
			if ( hooks && hooks.set ) {
				hooks.set( this );
			} else {
				Tween.propHooks._default.set( this );
			}
			return this;
		}
	};
	
	Tween.prototype.init.prototype = Tween.prototype;
	
	Tween.propHooks = {
		_default: {
			get: function( tween ) {
				var result;
	
				// Use a property on the element directly when it is not a DOM element,
				// or when there is no matching style property that exists.
				if ( tween.elem.nodeType !== 1 ||
					tween.elem[ tween.prop ] != null && tween.elem.style[ tween.prop ] == null ) {
					return tween.elem[ tween.prop ];
				}
	
				// Passing an empty string as a 3rd parameter to .css will automatically
				// attempt a parseFloat and fallback to a string if the parse fails.
				// Simple values such as "10px" are parsed to Float;
				// complex values such as "rotate(1rad)" are returned as-is.
				result = jQuery.css( tween.elem, tween.prop, "" );
	
				// Empty strings, null, undefined and "auto" are converted to 0.
				return !result || result === "auto" ? 0 : result;
			},
			set: function( tween ) {
	
				// Use step hook for back compat.
				// Use cssHook if its there.
				// Use .style if available and use plain properties where available.
				if ( jQuery.fx.step[ tween.prop ] ) {
					jQuery.fx.step[ tween.prop ]( tween );
				} else if ( tween.elem.nodeType === 1 && (
						jQuery.cssHooks[ tween.prop ] ||
						tween.elem.style[ finalPropName( tween.prop ) ] != null ) ) {
					jQuery.style( tween.elem, tween.prop, tween.now + tween.unit );
				} else {
					tween.elem[ tween.prop ] = tween.now;
				}
			}
		}
	};
	
	// Support: IE <=9 only
	// Panic based approach to setting things on disconnected nodes
	Tween.propHooks.scrollTop = Tween.propHooks.scrollLeft = {
		set: function( tween ) {
			if ( tween.elem.nodeType && tween.elem.parentNode ) {
				tween.elem[ tween.prop ] = tween.now;
			}
		}
	};
	
	jQuery.easing = {
		linear: function( p ) {
			return p;
		},
		swing: function( p ) {
			return 0.5 - Math.cos( p * Math.PI ) / 2;
		},
		_default: "swing"
	};
	
	jQuery.fx = Tween.prototype.init;
	
	// Back compat <1.8 extension point
	jQuery.fx.step = {};
	
	
	
	
	var
		fxNow, inProgress,
		rfxtypes = /^(?:toggle|show|hide)$/,
		rrun = /queueHooks$/;
	
	function schedule() {
		if ( inProgress ) {
			if ( document.hidden === false && window.requestAnimationFrame ) {
				window.requestAnimationFrame( schedule );
			} else {
				window.setTimeout( schedule, jQuery.fx.interval );
			}
	
			jQuery.fx.tick();
		}
	}
	
	// Animations created synchronously will run synchronously
	function createFxNow() {
		window.setTimeout( function() {
			fxNow = undefined;
		} );
		return ( fxNow = Date.now() );
	}
	
	// Generate parameters to create a standard animation
	function genFx( type, includeWidth ) {
		var which,
			i = 0,
			attrs = { height: type };
	
		// If we include width, step value is 1 to do all cssExpand values,
		// otherwise step value is 2 to skip over Left and Right
		includeWidth = includeWidth ? 1 : 0;
		for ( ; i < 4; i += 2 - includeWidth ) {
			which = cssExpand[ i ];
			attrs[ "margin" + which ] = attrs[ "padding" + which ] = type;
		}
	
		if ( includeWidth ) {
			attrs.opacity = attrs.width = type;
		}
	
		return attrs;
	}
	
	function createTween( value, prop, animation ) {
		var tween,
			collection = ( Animation.tweeners[ prop ] || [] ).concat( Animation.tweeners[ "*" ] ),
			index = 0,
			length = collection.length;
		for ( ; index < length; index++ ) {
			if ( ( tween = collection[ index ].call( animation, prop, value ) ) ) {
	
				// We're done with this property
				return tween;
			}
		}
	}
	
	function defaultPrefilter( elem, props, opts ) {
		var prop, value, toggle, hooks, oldfire, propTween, restoreDisplay, display,
			isBox = "width" in props || "height" in props,
			anim = this,
			orig = {},
			style = elem.style,
			hidden = elem.nodeType && isHiddenWithinTree( elem ),
			dataShow = dataPriv.get( elem, "fxshow" );
	
		// Queue-skipping animations hijack the fx hooks
		if ( !opts.queue ) {
			hooks = jQuery._queueHooks( elem, "fx" );
			if ( hooks.unqueued == null ) {
				hooks.unqueued = 0;
				oldfire = hooks.empty.fire;
				hooks.empty.fire = function() {
					if ( !hooks.unqueued ) {
						oldfire();
					}
				};
			}
			hooks.unqueued++;
	
			anim.always( function() {
	
				// Ensure the complete handler is called before this completes
				anim.always( function() {
					hooks.unqueued--;
					if ( !jQuery.queue( elem, "fx" ).length ) {
						hooks.empty.fire();
					}
				} );
			} );
		}
	
		// Detect show/hide animations
		for ( prop in props ) {
			value = props[ prop ];
			if ( rfxtypes.test( value ) ) {
				delete props[ prop ];
				toggle = toggle || value === "toggle";
				if ( value === ( hidden ? "hide" : "show" ) ) {
	
					// Pretend to be hidden if this is a "show" and
					// there is still data from a stopped show/hide
					if ( value === "show" && dataShow && dataShow[ prop ] !== undefined ) {
						hidden = true;
	
					// Ignore all other no-op show/hide data
					} else {
						continue;
					}
				}
				orig[ prop ] = dataShow && dataShow[ prop ] || jQuery.style( elem, prop );
			}
		}
	
		// Bail out if this is a no-op like .hide().hide()
		propTween = !jQuery.isEmptyObject( props );
		if ( !propTween && jQuery.isEmptyObject( orig ) ) {
			return;
		}
	
		// Restrict "overflow" and "display" styles during box animations
		if ( isBox && elem.nodeType === 1 ) {
	
			// Support: IE <=9 - 11, Edge 12 - 15
			// Record all 3 overflow attributes because IE does not infer the shorthand
			// from identically-valued overflowX and overflowY and Edge just mirrors
			// the overflowX value there.
			opts.overflow = [ style.overflow, style.overflowX, style.overflowY ];
	
			// Identify a display type, preferring old show/hide data over the CSS cascade
			restoreDisplay = dataShow && dataShow.display;
			if ( restoreDisplay == null ) {
				restoreDisplay = dataPriv.get( elem, "display" );
			}
			display = jQuery.css( elem, "display" );
			if ( display === "none" ) {
				if ( restoreDisplay ) {
					display = restoreDisplay;
				} else {
	
					// Get nonempty value(s) by temporarily forcing visibility
					showHide( [ elem ], true );
					restoreDisplay = elem.style.display || restoreDisplay;
					display = jQuery.css( elem, "display" );
					showHide( [ elem ] );
				}
			}
	
			// Animate inline elements as inline-block
			if ( display === "inline" || display === "inline-block" && restoreDisplay != null ) {
				if ( jQuery.css( elem, "float" ) === "none" ) {
	
					// Restore the original display value at the end of pure show/hide animations
					if ( !propTween ) {
						anim.done( function() {
							style.display = restoreDisplay;
						} );
						if ( restoreDisplay == null ) {
							display = style.display;
							restoreDisplay = display === "none" ? "" : display;
						}
					}
					style.display = "inline-block";
				}
			}
		}
	
		if ( opts.overflow ) {
			style.overflow = "hidden";
			anim.always( function() {
				style.overflow = opts.overflow[ 0 ];
				style.overflowX = opts.overflow[ 1 ];
				style.overflowY = opts.overflow[ 2 ];
			} );
		}
	
		// Implement show/hide animations
		propTween = false;
		for ( prop in orig ) {
	
			// General show/hide setup for this element animation
			if ( !propTween ) {
				if ( dataShow ) {
					if ( "hidden" in dataShow ) {
						hidden = dataShow.hidden;
					}
				} else {
					dataShow = dataPriv.access( elem, "fxshow", { display: restoreDisplay } );
				}
	
				// Store hidden/visible for toggle so `.stop().toggle()` "reverses"
				if ( toggle ) {
					dataShow.hidden = !hidden;
				}
	
				// Show elements before animating them
				if ( hidden ) {
					showHide( [ elem ], true );
				}
	
				/* eslint-disable no-loop-func */
	
				anim.done( function() {
	
				/* eslint-enable no-loop-func */
	
					// The final step of a "hide" animation is actually hiding the element
					if ( !hidden ) {
						showHide( [ elem ] );
					}
					dataPriv.remove( elem, "fxshow" );
					for ( prop in orig ) {
						jQuery.style( elem, prop, orig[ prop ] );
					}
				} );
			}
	
			// Per-property setup
			propTween = createTween( hidden ? dataShow[ prop ] : 0, prop, anim );
			if ( !( prop in dataShow ) ) {
				dataShow[ prop ] = propTween.start;
				if ( hidden ) {
					propTween.end = propTween.start;
					propTween.start = 0;
				}
			}
		}
	}
	
	function propFilter( props, specialEasing ) {
		var index, name, easing, value, hooks;
	
		// camelCase, specialEasing and expand cssHook pass
		for ( index in props ) {
			name = camelCase( index );
			easing = specialEasing[ name ];
			value = props[ index ];
			if ( Array.isArray( value ) ) {
				easing = value[ 1 ];
				value = props[ index ] = value[ 0 ];
			}
	
			if ( index !== name ) {
				props[ name ] = value;
				delete props[ index ];
			}
	
			hooks = jQuery.cssHooks[ name ];
			if ( hooks && "expand" in hooks ) {
				value = hooks.expand( value );
				delete props[ name ];
	
				// Not quite $.extend, this won't overwrite existing keys.
				// Reusing 'index' because we have the correct "name"
				for ( index in value ) {
					if ( !( index in props ) ) {
						props[ index ] = value[ index ];
						specialEasing[ index ] = easing;
					}
				}
			} else {
				specialEasing[ name ] = easing;
			}
		}
	}
	
	function Animation( elem, properties, options ) {
		var result,
			stopped,
			index = 0,
			length = Animation.prefilters.length,
			deferred = jQuery.Deferred().always( function() {
	
				// Don't match elem in the :animated selector
				delete tick.elem;
			} ),
			tick = function() {
				if ( stopped ) {
					return false;
				}
				var currentTime = fxNow || createFxNow(),
					remaining = Math.max( 0, animation.startTime + animation.duration - currentTime ),
	
					// Support: Android 2.3 only
					// Archaic crash bug won't allow us to use `1 - ( 0.5 || 0 )` (#12497)
					temp = remaining / animation.duration || 0,
					percent = 1 - temp,
					index = 0,
					length = animation.tweens.length;
	
				for ( ; index < length; index++ ) {
					animation.tweens[ index ].run( percent );
				}
	
				deferred.notifyWith( elem, [ animation, percent, remaining ] );
	
				// If there's more to do, yield
				if ( percent < 1 && length ) {
					return remaining;
				}
	
				// If this was an empty animation, synthesize a final progress notification
				if ( !length ) {
					deferred.notifyWith( elem, [ animation, 1, 0 ] );
				}
	
				// Resolve the animation and report its conclusion
				deferred.resolveWith( elem, [ animation ] );
				return false;
			},
			animation = deferred.promise( {
				elem: elem,
				props: jQuery.extend( {}, properties ),
				opts: jQuery.extend( true, {
					specialEasing: {},
					easing: jQuery.easing._default
				}, options ),
				originalProperties: properties,
				originalOptions: options,
				startTime: fxNow || createFxNow(),
				duration: options.duration,
				tweens: [],
				createTween: function( prop, end ) {
					var tween = jQuery.Tween( elem, animation.opts, prop, end,
							animation.opts.specialEasing[ prop ] || animation.opts.easing );
					animation.tweens.push( tween );
					return tween;
				},
				stop: function( gotoEnd ) {
					var index = 0,
	
						// If we are going to the end, we want to run all the tweens
						// otherwise we skip this part
						length = gotoEnd ? animation.tweens.length : 0;
					if ( stopped ) {
						return this;
					}
					stopped = true;
					for ( ; index < length; index++ ) {
						animation.tweens[ index ].run( 1 );
					}
	
					// Resolve when we played the last frame; otherwise, reject
					if ( gotoEnd ) {
						deferred.notifyWith( elem, [ animation, 1, 0 ] );
						deferred.resolveWith( elem, [ animation, gotoEnd ] );
					} else {
						deferred.rejectWith( elem, [ animation, gotoEnd ] );
					}
					return this;
				}
			} ),
			props = animation.props;
	
		propFilter( props, animation.opts.specialEasing );
	
		for ( ; index < length; index++ ) {
			result = Animation.prefilters[ index ].call( animation, elem, props, animation.opts );
			if ( result ) {
				if ( isFunction( result.stop ) ) {
					jQuery._queueHooks( animation.elem, animation.opts.queue ).stop =
						result.stop.bind( result );
				}
				return result;
			}
		}
	
		jQuery.map( props, createTween, animation );
	
		if ( isFunction( animation.opts.start ) ) {
			animation.opts.start.call( elem, animation );
		}
	
		// Attach callbacks from options
		animation
			.progress( animation.opts.progress )
			.done( animation.opts.done, animation.opts.complete )
			.fail( animation.opts.fail )
			.always( animation.opts.always );
	
		jQuery.fx.timer(
			jQuery.extend( tick, {
				elem: elem,
				anim: animation,
				queue: animation.opts.queue
			} )
		);
	
		return animation;
	}
	
	jQuery.Animation = jQuery.extend( Animation, {
	
		tweeners: {
			"*": [ function( prop, value ) {
				var tween = this.createTween( prop, value );
				adjustCSS( tween.elem, prop, rcssNum.exec( value ), tween );
				return tween;
			} ]
		},
	
		tweener: function( props, callback ) {
			if ( isFunction( props ) ) {
				callback = props;
				props = [ "*" ];
			} else {
				props = props.match( rnothtmlwhite );
			}
	
			var prop,
				index = 0,
				length = props.length;
	
			for ( ; index < length; index++ ) {
				prop = props[ index ];
				Animation.tweeners[ prop ] = Animation.tweeners[ prop ] || [];
				Animation.tweeners[ prop ].unshift( callback );
			}
		},
	
		prefilters: [ defaultPrefilter ],
	
		prefilter: function( callback, prepend ) {
			if ( prepend ) {
				Animation.prefilters.unshift( callback );
			} else {
				Animation.prefilters.push( callback );
			}
		}
	} );
	
	jQuery.speed = function( speed, easing, fn ) {
		var opt = speed && typeof speed === "object" ? jQuery.extend( {}, speed ) : {
			complete: fn || !fn && easing ||
				isFunction( speed ) && speed,
			duration: speed,
			easing: fn && easing || easing && !isFunction( easing ) && easing
		};
	
		// Go to the end state if fx are off
		if ( jQuery.fx.off ) {
			opt.duration = 0;
	
		} else {
			if ( typeof opt.duration !== "number" ) {
				if ( opt.duration in jQuery.fx.speeds ) {
					opt.duration = jQuery.fx.speeds[ opt.duration ];
	
				} else {
					opt.duration = jQuery.fx.speeds._default;
				}
			}
		}
	
		// Normalize opt.queue - true/undefined/null -> "fx"
		if ( opt.queue == null || opt.queue === true ) {
			opt.queue = "fx";
		}
	
		// Queueing
		opt.old = opt.complete;
	
		opt.complete = function() {
			if ( isFunction( opt.old ) ) {
				opt.old.call( this );
			}
	
			if ( opt.queue ) {
				jQuery.dequeue( this, opt.queue );
			}
		};
	
		return opt;
	};
	
	jQuery.fn.extend( {
		fadeTo: function( speed, to, easing, callback ) {
	
			// Show any hidden elements after setting opacity to 0
			return this.filter( isHiddenWithinTree ).css( "opacity", 0 ).show()
	
				// Animate to the value specified
				.end().animate( { opacity: to }, speed, easing, callback );
		},
		animate: function( prop, speed, easing, callback ) {
			var empty = jQuery.isEmptyObject( prop ),
				optall = jQuery.speed( speed, easing, callback ),
				doAnimation = function() {
	
					// Operate on a copy of prop so per-property easing won't be lost
					var anim = Animation( this, jQuery.extend( {}, prop ), optall );
	
					// Empty animations, or finishing resolves immediately
					if ( empty || dataPriv.get( this, "finish" ) ) {
						anim.stop( true );
					}
				};
				doAnimation.finish = doAnimation;
	
			return empty || optall.queue === false ?
				this.each( doAnimation ) :
				this.queue( optall.queue, doAnimation );
		},
		stop: function( type, clearQueue, gotoEnd ) {
			var stopQueue = function( hooks ) {
				var stop = hooks.stop;
				delete hooks.stop;
				stop( gotoEnd );
			};
	
			if ( typeof type !== "string" ) {
				gotoEnd = clearQueue;
				clearQueue = type;
				type = undefined;
			}
			if ( clearQueue ) {
				this.queue( type || "fx", [] );
			}
	
			return this.each( function() {
				var dequeue = true,
					index = type != null && type + "queueHooks",
					timers = jQuery.timers,
					data = dataPriv.get( this );
	
				if ( index ) {
					if ( data[ index ] && data[ index ].stop ) {
						stopQueue( data[ index ] );
					}
				} else {
					for ( index in data ) {
						if ( data[ index ] && data[ index ].stop && rrun.test( index ) ) {
							stopQueue( data[ index ] );
						}
					}
				}
	
				for ( index = timers.length; index--; ) {
					if ( timers[ index ].elem === this &&
						( type == null || timers[ index ].queue === type ) ) {
	
						timers[ index ].anim.stop( gotoEnd );
						dequeue = false;
						timers.splice( index, 1 );
					}
				}
	
				// Start the next in the queue if the last step wasn't forced.
				// Timers currently will call their complete callbacks, which
				// will dequeue but only if they were gotoEnd.
				if ( dequeue || !gotoEnd ) {
					jQuery.dequeue( this, type );
				}
			} );
		},
		finish: function( type ) {
			if ( type !== false ) {
				type = type || "fx";
			}
			return this.each( function() {
				var index,
					data = dataPriv.get( this ),
					queue = data[ type + "queue" ],
					hooks = data[ type + "queueHooks" ],
					timers = jQuery.timers,
					length = queue ? queue.length : 0;
	
				// Enable finishing flag on private data
				data.finish = true;
	
				// Empty the queue first
				jQuery.queue( this, type, [] );
	
				if ( hooks && hooks.stop ) {
					hooks.stop.call( this, true );
				}
	
				// Look for any active animations, and finish them
				for ( index = timers.length; index--; ) {
					if ( timers[ index ].elem === this && timers[ index ].queue === type ) {
						timers[ index ].anim.stop( true );
						timers.splice( index, 1 );
					}
				}
	
				// Look for any animations in the old queue and finish them
				for ( index = 0; index < length; index++ ) {
					if ( queue[ index ] && queue[ index ].finish ) {
						queue[ index ].finish.call( this );
					}
				}
	
				// Turn off finishing flag
				delete data.finish;
			} );
		}
	} );
	
	jQuery.each( [ "toggle", "show", "hide" ], function( _i, name ) {
		var cssFn = jQuery.fn[ name ];
		jQuery.fn[ name ] = function( speed, easing, callback ) {
			return speed == null || typeof speed === "boolean" ?
				cssFn.apply( this, arguments ) :
				this.animate( genFx( name, true ), speed, easing, callback );
		};
	} );
	
	// Generate shortcuts for custom animations
	jQuery.each( {
		slideDown: genFx( "show" ),
		slideUp: genFx( "hide" ),
		slideToggle: genFx( "toggle" ),
		fadeIn: { opacity: "show" },
		fadeOut: { opacity: "hide" },
		fadeToggle: { opacity: "toggle" }
	}, function( name, props ) {
		jQuery.fn[ name ] = function( speed, easing, callback ) {
			return this.animate( props, speed, easing, callback );
		};
	} );
	
	jQuery.timers = [];
	jQuery.fx.tick = function() {
		var timer,
			i = 0,
			timers = jQuery.timers;
	
		fxNow = Date.now();
	
		for ( ; i < timers.length; i++ ) {
			timer = timers[ i ];
	
			// Run the timer and safely remove it when done (allowing for external removal)
			if ( !timer() && timers[ i ] === timer ) {
				timers.splice( i--, 1 );
			}
		}
	
		if ( !timers.length ) {
			jQuery.fx.stop();
		}
		fxNow = undefined;
	};
	
	jQuery.fx.timer = function( timer ) {
		jQuery.timers.push( timer );
		jQuery.fx.start();
	};
	
	jQuery.fx.interval = 13;
	jQuery.fx.start = function() {
		if ( inProgress ) {
			return;
		}
	
		inProgress = true;
		schedule();
	};
	
	jQuery.fx.stop = function() {
		inProgress = null;
	};
	
	jQuery.fx.speeds = {
		slow: 600,
		fast: 200,
	
		// Default speed
		_default: 400
	};
	
	
	// Based off of the plugin by Clint Helfers, with permission.
	// https://web.archive.org/web/20100324014747/http://blindsignals.com/index.php/2009/07/jquery-delay/
	jQuery.fn.delay = function( time, type ) {
		time = jQuery.fx ? jQuery.fx.speeds[ time ] || time : time;
		type = type || "fx";
	
		return this.queue( type, function( next, hooks ) {
			var timeout = window.setTimeout( next, time );
			hooks.stop = function() {
				window.clearTimeout( timeout );
			};
		} );
	};
	
	
	( function() {
		var input = document.createElement( "input" ),
			select = document.createElement( "select" ),
			opt = select.appendChild( document.createElement( "option" ) );
	
		input.type = "checkbox";
	
		// Support: Android <=4.3 only
		// Default value for a checkbox should be "on"
		support.checkOn = input.value !== "";
	
		// Support: IE <=11 only
		// Must access selectedIndex to make default options select
		support.optSelected = opt.selected;
	
		// Support: IE <=11 only
		// An input loses its value after becoming a radio
		input = document.createElement( "input" );
		input.value = "t";
		input.type = "radio";
		support.radioValue = input.value === "t";
	} )();
	
	
	var boolHook,
		attrHandle = jQuery.expr.attrHandle;
	
	jQuery.fn.extend( {
		attr: function( name, value ) {
			return access( this, jQuery.attr, name, value, arguments.length > 1 );
		},
	
		removeAttr: function( name ) {
			return this.each( function() {
				jQuery.removeAttr( this, name );
			} );
		}
	} );
	
	jQuery.extend( {
		attr: function( elem, name, value ) {
			var ret, hooks,
				nType = elem.nodeType;
	
			// Don't get/set attributes on text, comment and attribute nodes
			if ( nType === 3 || nType === 8 || nType === 2 ) {
				return;
			}
	
			// Fallback to prop when attributes are not supported
			if ( typeof elem.getAttribute === "undefined" ) {
				return jQuery.prop( elem, name, value );
			}
	
			// Attribute hooks are determined by the lowercase version
			// Grab necessary hook if one is defined
			if ( nType !== 1 || !jQuery.isXMLDoc( elem ) ) {
				hooks = jQuery.attrHooks[ name.toLowerCase() ] ||
					( jQuery.expr.match.bool.test( name ) ? boolHook : undefined );
			}
	
			if ( value !== undefined ) {
				if ( value === null ) {
					jQuery.removeAttr( elem, name );
					return;
				}
	
				if ( hooks && "set" in hooks &&
					( ret = hooks.set( elem, value, name ) ) !== undefined ) {
					return ret;
				}
	
				elem.setAttribute( name, value + "" );
				return value;
			}
	
			if ( hooks && "get" in hooks && ( ret = hooks.get( elem, name ) ) !== null ) {
				return ret;
			}
	
			ret = jQuery.find.attr( elem, name );
	
			// Non-existent attributes return null, we normalize to undefined
			return ret == null ? undefined : ret;
		},
	
		attrHooks: {
			type: {
				set: function( elem, value ) {
					if ( !support.radioValue && value === "radio" &&
						nodeName( elem, "input" ) ) {
						var val = elem.value;
						elem.setAttribute( "type", value );
						if ( val ) {
							elem.value = val;
						}
						return value;
					}
				}
			}
		},
	
		removeAttr: function( elem, value ) {
			var name,
				i = 0,
	
				// Attribute names can contain non-HTML whitespace characters
				// https://html.spec.whatwg.org/multipage/syntax.html#attributes-2
				attrNames = value && value.match( rnothtmlwhite );
	
			if ( attrNames && elem.nodeType === 1 ) {
				while ( ( name = attrNames[ i++ ] ) ) {
					elem.removeAttribute( name );
				}
			}
		}
	} );
	
	// Hooks for boolean attributes
	boolHook = {
		set: function( elem, value, name ) {
			if ( value === false ) {
	
				// Remove boolean attributes when set to false
				jQuery.removeAttr( elem, name );
			} else {
				elem.setAttribute( name, name );
			}
			return name;
		}
	};
	
	jQuery.each( jQuery.expr.match.bool.source.match( /\w+/g ), function( _i, name ) {
		var getter = attrHandle[ name ] || jQuery.find.attr;
	
		attrHandle[ name ] = function( elem, name, isXML ) {
			var ret, handle,
				lowercaseName = name.toLowerCase();
	
			if ( !isXML ) {
	
				// Avoid an infinite loop by temporarily removing this function from the getter
				handle = attrHandle[ lowercaseName ];
				attrHandle[ lowercaseName ] = ret;
				ret = getter( elem, name, isXML ) != null ?
					lowercaseName :
					null;
				attrHandle[ lowercaseName ] = handle;
			}
			return ret;
		};
	} );
	
	
	
	
	var rfocusable = /^(?:input|select|textarea|button)$/i,
		rclickable = /^(?:a|area)$/i;
	
	jQuery.fn.extend( {
		prop: function( name, value ) {
			return access( this, jQuery.prop, name, value, arguments.length > 1 );
		},
	
		removeProp: function( name ) {
			return this.each( function() {
				delete this[ jQuery.propFix[ name ] || name ];
			} );
		}
	} );
	
	jQuery.extend( {
		prop: function( elem, name, value ) {
			var ret, hooks,
				nType = elem.nodeType;
	
			// Don't get/set properties on text, comment and attribute nodes
			if ( nType === 3 || nType === 8 || nType === 2 ) {
				return;
			}
	
			if ( nType !== 1 || !jQuery.isXMLDoc( elem ) ) {
	
				// Fix name and attach hooks
				name = jQuery.propFix[ name ] || name;
				hooks = jQuery.propHooks[ name ];
			}
	
			if ( value !== undefined ) {
				if ( hooks && "set" in hooks &&
					( ret = hooks.set( elem, value, name ) ) !== undefined ) {
					return ret;
				}
	
				return ( elem[ name ] = value );
			}
	
			if ( hooks && "get" in hooks && ( ret = hooks.get( elem, name ) ) !== null ) {
				return ret;
			}
	
			return elem[ name ];
		},
	
		propHooks: {
			tabIndex: {
				get: function( elem ) {
	
					// Support: IE <=9 - 11 only
					// elem.tabIndex doesn't always return the
					// correct value when it hasn't been explicitly set
					// https://web.archive.org/web/20141116233347/http://fluidproject.org/blog/2008/01/09/getting-setting-and-removing-tabindex-values-with-javascript/
					// Use proper attribute retrieval(#12072)
					var tabindex = jQuery.find.attr( elem, "tabindex" );
	
					if ( tabindex ) {
						return parseInt( tabindex, 10 );
					}
	
					if (
						rfocusable.test( elem.nodeName ) ||
						rclickable.test( elem.nodeName ) &&
						elem.href
					) {
						return 0;
					}
	
					return -1;
				}
			}
		},
	
		propFix: {
			"for": "htmlFor",
			"class": "className"
		}
	} );
	
	// Support: IE <=11 only
	// Accessing the selectedIndex property
	// forces the browser to respect setting selected
	// on the option
	// The getter ensures a default option is selected
	// when in an optgroup
	// eslint rule "no-unused-expressions" is disabled for this code
	// since it considers such accessions noop
	if ( !support.optSelected ) {
		jQuery.propHooks.selected = {
			get: function( elem ) {
	
				/* eslint no-unused-expressions: "off" */
	
				var parent = elem.parentNode;
				if ( parent && parent.parentNode ) {
					parent.parentNode.selectedIndex;
				}
				return null;
			},
			set: function( elem ) {
	
				/* eslint no-unused-expressions: "off" */
	
				var parent = elem.parentNode;
				if ( parent ) {
					parent.selectedIndex;
	
					if ( parent.parentNode ) {
						parent.parentNode.selectedIndex;
					}
				}
			}
		};
	}
	
	jQuery.each( [
		"tabIndex",
		"readOnly",
		"maxLength",
		"cellSpacing",
		"cellPadding",
		"rowSpan",
		"colSpan",
		"useMap",
		"frameBorder",
		"contentEditable"
	], function() {
		jQuery.propFix[ this.toLowerCase() ] = this;
	} );
	
	
	
	
		// Strip and collapse whitespace according to HTML spec
		// https://infra.spec.whatwg.org/#strip-and-collapse-ascii-whitespace
		function stripAndCollapse( value ) {
			var tokens = value.match( rnothtmlwhite ) || [];
			return tokens.join( " " );
		}
	
	
	function getClass( elem ) {
		return elem.getAttribute && elem.getAttribute( "class" ) || "";
	}
	
	function classesToArray( value ) {
		if ( Array.isArray( value ) ) {
			return value;
		}
		if ( typeof value === "string" ) {
			return value.match( rnothtmlwhite ) || [];
		}
		return [];
	}
	
	jQuery.fn.extend( {
		addClass: function( value ) {
			var classes, elem, cur, curValue, clazz, j, finalValue,
				i = 0;
	
			if ( isFunction( value ) ) {
				return this.each( function( j ) {
					jQuery( this ).addClass( value.call( this, j, getClass( this ) ) );
				} );
			}
	
			classes = classesToArray( value );
	
			if ( classes.length ) {
				while ( ( elem = this[ i++ ] ) ) {
					curValue = getClass( elem );
					cur = elem.nodeType === 1 && ( " " + stripAndCollapse( curValue ) + " " );
	
					if ( cur ) {
						j = 0;
						while ( ( clazz = classes[ j++ ] ) ) {
							if ( cur.indexOf( " " + clazz + " " ) < 0 ) {
								cur += clazz + " ";
							}
						}
	
						// Only assign if different to avoid unneeded rendering.
						finalValue = stripAndCollapse( cur );
						if ( curValue !== finalValue ) {
							elem.setAttribute( "class", finalValue );
						}
					}
				}
			}
	
			return this;
		},
	
		removeClass: function( value ) {
			var classes, elem, cur, curValue, clazz, j, finalValue,
				i = 0;
	
			if ( isFunction( value ) ) {
				return this.each( function( j ) {
					jQuery( this ).removeClass( value.call( this, j, getClass( this ) ) );
				} );
			}
	
			if ( !arguments.length ) {
				return this.attr( "class", "" );
			}
	
			classes = classesToArray( value );
	
			if ( classes.length ) {
				while ( ( elem = this[ i++ ] ) ) {
					curValue = getClass( elem );
	
					// This expression is here for better compressibility (see addClass)
					cur = elem.nodeType === 1 && ( " " + stripAndCollapse( curValue ) + " " );
	
					if ( cur ) {
						j = 0;
						while ( ( clazz = classes[ j++ ] ) ) {
	
							// Remove *all* instances
							while ( cur.indexOf( " " + clazz + " " ) > -1 ) {
								cur = cur.replace( " " + clazz + " ", " " );
							}
						}
	
						// Only assign if different to avoid unneeded rendering.
						finalValue = stripAndCollapse( cur );
						if ( curValue !== finalValue ) {
							elem.setAttribute( "class", finalValue );
						}
					}
				}
			}
	
			return this;
		},
	
		toggleClass: function( value, stateVal ) {
			var type = typeof value,
				isValidValue = type === "string" || Array.isArray( value );
	
			if ( typeof stateVal === "boolean" && isValidValue ) {
				return stateVal ? this.addClass( value ) : this.removeClass( value );
			}
	
			if ( isFunction( value ) ) {
				return this.each( function( i ) {
					jQuery( this ).toggleClass(
						value.call( this, i, getClass( this ), stateVal ),
						stateVal
					);
				} );
			}
	
			return this.each( function() {
				var className, i, self, classNames;
	
				if ( isValidValue ) {
	
					// Toggle individual class names
					i = 0;
					self = jQuery( this );
					classNames = classesToArray( value );
	
					while ( ( className = classNames[ i++ ] ) ) {
	
						// Check each className given, space separated list
						if ( self.hasClass( className ) ) {
							self.removeClass( className );
						} else {
							self.addClass( className );
						}
					}
	
				// Toggle whole class name
				} else if ( value === undefined || type === "boolean" ) {
					className = getClass( this );
					if ( className ) {
	
						// Store className if set
						dataPriv.set( this, "__className__", className );
					}
	
					// If the element has a class name or if we're passed `false`,
					// then remove the whole classname (if there was one, the above saved it).
					// Otherwise bring back whatever was previously saved (if anything),
					// falling back to the empty string if nothing was stored.
					if ( this.setAttribute ) {
						this.setAttribute( "class",
							className || value === false ?
							"" :
							dataPriv.get( this, "__className__" ) || ""
						);
					}
				}
			} );
		},
	
		hasClass: function( selector ) {
			var className, elem,
				i = 0;
	
			className = " " + selector + " ";
			while ( ( elem = this[ i++ ] ) ) {
				if ( elem.nodeType === 1 &&
					( " " + stripAndCollapse( getClass( elem ) ) + " " ).indexOf( className ) > -1 ) {
						return true;
				}
			}
	
			return false;
		}
	} );
	
	
	
	
	var rreturn = /\r/g;
	
	jQuery.fn.extend( {
		val: function( value ) {
			var hooks, ret, valueIsFunction,
				elem = this[ 0 ];
	
			if ( !arguments.length ) {
				if ( elem ) {
					hooks = jQuery.valHooks[ elem.type ] ||
						jQuery.valHooks[ elem.nodeName.toLowerCase() ];
	
					if ( hooks &&
						"get" in hooks &&
						( ret = hooks.get( elem, "value" ) ) !== undefined
					) {
						return ret;
					}
	
					ret = elem.value;
	
					// Handle most common string cases
					if ( typeof ret === "string" ) {
						return ret.replace( rreturn, "" );
					}
	
					// Handle cases where value is null/undef or number
					return ret == null ? "" : ret;
				}
	
				return;
			}
	
			valueIsFunction = isFunction( value );
	
			return this.each( function( i ) {
				var val;
	
				if ( this.nodeType !== 1 ) {
					return;
				}
	
				if ( valueIsFunction ) {
					val = value.call( this, i, jQuery( this ).val() );
				} else {
					val = value;
				}
	
				// Treat null/undefined as ""; convert numbers to string
				if ( val == null ) {
					val = "";
	
				} else if ( typeof val === "number" ) {
					val += "";
	
				} else if ( Array.isArray( val ) ) {
					val = jQuery.map( val, function( value ) {
						return value == null ? "" : value + "";
					} );
				}
	
				hooks = jQuery.valHooks[ this.type ] || jQuery.valHooks[ this.nodeName.toLowerCase() ];
	
				// If set returns undefined, fall back to normal setting
				if ( !hooks || !( "set" in hooks ) || hooks.set( this, val, "value" ) === undefined ) {
					this.value = val;
				}
			} );
		}
	} );
	
	jQuery.extend( {
		valHooks: {
			option: {
				get: function( elem ) {
	
					var val = jQuery.find.attr( elem, "value" );
					return val != null ?
						val :
	
						// Support: IE <=10 - 11 only
						// option.text throws exceptions (#14686, #14858)
						// Strip and collapse whitespace
						// https://html.spec.whatwg.org/#strip-and-collapse-whitespace
						stripAndCollapse( jQuery.text( elem ) );
				}
			},
			select: {
				get: function( elem ) {
					var value, option, i,
						options = elem.options,
						index = elem.selectedIndex,
						one = elem.type === "select-one",
						values = one ? null : [],
						max = one ? index + 1 : options.length;
	
					if ( index < 0 ) {
						i = max;
	
					} else {
						i = one ? index : 0;
					}
	
					// Loop through all the selected options
					for ( ; i < max; i++ ) {
						option = options[ i ];
	
						// Support: IE <=9 only
						// IE8-9 doesn't update selected after form reset (#2551)
						if ( ( option.selected || i === index ) &&
	
								// Don't return options that are disabled or in a disabled optgroup
								!option.disabled &&
								( !option.parentNode.disabled ||
									!nodeName( option.parentNode, "optgroup" ) ) ) {
	
							// Get the specific value for the option
							value = jQuery( option ).val();
	
							// We don't need an array for one selects
							if ( one ) {
								return value;
							}
	
							// Multi-Selects return an array
							values.push( value );
						}
					}
	
					return values;
				},
	
				set: function( elem, value ) {
					var optionSet, option,
						options = elem.options,
						values = jQuery.makeArray( value ),
						i = options.length;
	
					while ( i-- ) {
						option = options[ i ];
	
						/* eslint-disable no-cond-assign */
	
						if ( option.selected =
							jQuery.inArray( jQuery.valHooks.option.get( option ), values ) > -1
						) {
							optionSet = true;
						}
	
						/* eslint-enable no-cond-assign */
					}
	
					// Force browsers to behave consistently when non-matching value is set
					if ( !optionSet ) {
						elem.selectedIndex = -1;
					}
					return values;
				}
			}
		}
	} );
	
	// Radios and checkboxes getter/setter
	jQuery.each( [ "radio", "checkbox" ], function() {
		jQuery.valHooks[ this ] = {
			set: function( elem, value ) {
				if ( Array.isArray( value ) ) {
					return ( elem.checked = jQuery.inArray( jQuery( elem ).val(), value ) > -1 );
				}
			}
		};
		if ( !support.checkOn ) {
			jQuery.valHooks[ this ].get = function( elem ) {
				return elem.getAttribute( "value" ) === null ? "on" : elem.value;
			};
		}
	} );
	
	
	
	
	// Return jQuery for attributes-only inclusion
	
	
	support.focusin = "onfocusin" in window;
	
	
	var rfocusMorph = /^(?:focusinfocus|focusoutblur)$/,
		stopPropagationCallback = function( e ) {
			e.stopPropagation();
		};
	
	jQuery.extend( jQuery.event, {
	
		trigger: function( event, data, elem, onlyHandlers ) {
	
			var i, cur, tmp, bubbleType, ontype, handle, special, lastElement,
				eventPath = [ elem || document ],
				type = hasOwn.call( event, "type" ) ? event.type : event,
				namespaces = hasOwn.call( event, "namespace" ) ? event.namespace.split( "." ) : [];
	
			cur = lastElement = tmp = elem = elem || document;
	
			// Don't do events on text and comment nodes
			if ( elem.nodeType === 3 || elem.nodeType === 8 ) {
				return;
			}
	
			// focus/blur morphs to focusin/out; ensure we're not firing them right now
			if ( rfocusMorph.test( type + jQuery.event.triggered ) ) {
				return;
			}
	
			if ( type.indexOf( "." ) > -1 ) {
	
				// Namespaced trigger; create a regexp to match event type in handle()
				namespaces = type.split( "." );
				type = namespaces.shift();
				namespaces.sort();
			}
			ontype = type.indexOf( ":" ) < 0 && "on" + type;
	
			// Caller can pass in a jQuery.Event object, Object, or just an event type string
			event = event[ jQuery.expando ] ?
				event :
				new jQuery.Event( type, typeof event === "object" && event );
	
			// Trigger bitmask: & 1 for native handlers; & 2 for jQuery (always true)
			event.isTrigger = onlyHandlers ? 2 : 3;
			event.namespace = namespaces.join( "." );
			event.rnamespace = event.namespace ?
				new RegExp( "(^|\\.)" + namespaces.join( "\\.(?:.*\\.|)" ) + "(\\.|$)" ) :
				null;
	
			// Clean up the event in case it is being reused
			event.result = undefined;
			if ( !event.target ) {
				event.target = elem;
			}
	
			// Clone any incoming data and prepend the event, creating the handler arg list
			data = data == null ?
				[ event ] :
				jQuery.makeArray( data, [ event ] );
	
			// Allow special events to draw outside the lines
			special = jQuery.event.special[ type ] || {};
			if ( !onlyHandlers && special.trigger && special.trigger.apply( elem, data ) === false ) {
				return;
			}
	
			// Determine event propagation path in advance, per W3C events spec (#9951)
			// Bubble up to document, then to window; watch for a global ownerDocument var (#9724)
			if ( !onlyHandlers && !special.noBubble && !isWindow( elem ) ) {
	
				bubbleType = special.delegateType || type;
				if ( !rfocusMorph.test( bubbleType + type ) ) {
					cur = cur.parentNode;
				}
				for ( ; cur; cur = cur.parentNode ) {
					eventPath.push( cur );
					tmp = cur;
				}
	
				// Only add window if we got to document (e.g., not plain obj or detached DOM)
				if ( tmp === ( elem.ownerDocument || document ) ) {
					eventPath.push( tmp.defaultView || tmp.parentWindow || window );
				}
			}
	
			// Fire handlers on the event path
			i = 0;
			while ( ( cur = eventPath[ i++ ] ) && !event.isPropagationStopped() ) {
				lastElement = cur;
				event.type = i > 1 ?
					bubbleType :
					special.bindType || type;
	
				// jQuery handler
				handle = (
						dataPriv.get( cur, "events" ) || Object.create( null )
					)[ event.type ] &&
					dataPriv.get( cur, "handle" );
				if ( handle ) {
					handle.apply( cur, data );
				}
	
				// Native handler
				handle = ontype && cur[ ontype ];
				if ( handle && handle.apply && acceptData( cur ) ) {
					event.result = handle.apply( cur, data );
					if ( event.result === false ) {
						event.preventDefault();
					}
				}
			}
			event.type = type;
	
			// If nobody prevented the default action, do it now
			if ( !onlyHandlers && !event.isDefaultPrevented() ) {
	
				if ( ( !special._default ||
					special._default.apply( eventPath.pop(), data ) === false ) &&
					acceptData( elem ) ) {
	
					// Call a native DOM method on the target with the same name as the event.
					// Don't do default actions on window, that's where global variables be (#6170)
					if ( ontype && isFunction( elem[ type ] ) && !isWindow( elem ) ) {
	
						// Don't re-trigger an onFOO event when we call its FOO() method
						tmp = elem[ ontype ];
	
						if ( tmp ) {
							elem[ ontype ] = null;
						}
	
						// Prevent re-triggering of the same event, since we already bubbled it above
						jQuery.event.triggered = type;
	
						if ( event.isPropagationStopped() ) {
							lastElement.addEventListener( type, stopPropagationCallback );
						}
	
						elem[ type ]();
	
						if ( event.isPropagationStopped() ) {
							lastElement.removeEventListener( type, stopPropagationCallback );
						}
	
						jQuery.event.triggered = undefined;
	
						if ( tmp ) {
							elem[ ontype ] = tmp;
						}
					}
				}
			}
	
			return event.result;
		},
	
		// Piggyback on a donor event to simulate a different one
		// Used only for `focus(in | out)` events
		simulate: function( type, elem, event ) {
			var e = jQuery.extend(
				new jQuery.Event(),
				event,
				{
					type: type,
					isSimulated: true
				}
			);
	
			jQuery.event.trigger( e, null, elem );
		}
	
	} );
	
	jQuery.fn.extend( {
	
		trigger: function( type, data ) {
			return this.each( function() {
				jQuery.event.trigger( type, data, this );
			} );
		},
		triggerHandler: function( type, data ) {
			var elem = this[ 0 ];
			if ( elem ) {
				return jQuery.event.trigger( type, data, elem, true );
			}
		}
	} );
	
	
	// Support: Firefox <=44
	// Firefox doesn't have focus(in | out) events
	// Related ticket - https://bugzilla.mozilla.org/show_bug.cgi?id=687787
	//
	// Support: Chrome <=48 - 49, Safari <=9.0 - 9.1
	// focus(in | out) events fire after focus & blur events,
	// which is spec violation - http://www.w3.org/TR/DOM-Level-3-Events/#events-focusevent-event-order
	// Related ticket - https://bugs.chromium.org/p/chromium/issues/detail?id=449857
	if ( !support.focusin ) {
		jQuery.each( { focus: "focusin", blur: "focusout" }, function( orig, fix ) {
	
			// Attach a single capturing handler on the document while someone wants focusin/focusout
			var handler = function( event ) {
				jQuery.event.simulate( fix, event.target, jQuery.event.fix( event ) );
			};
	
			jQuery.event.special[ fix ] = {
				setup: function() {
	
					// Handle: regular nodes (via `this.ownerDocument`), window
					// (via `this.document`) & document (via `this`).
					var doc = this.ownerDocument || this.document || this,
						attaches = dataPriv.access( doc, fix );
	
					if ( !attaches ) {
						doc.addEventListener( orig, handler, true );
					}
					dataPriv.access( doc, fix, ( attaches || 0 ) + 1 );
				},
				teardown: function() {
					var doc = this.ownerDocument || this.document || this,
						attaches = dataPriv.access( doc, fix ) - 1;
	
					if ( !attaches ) {
						doc.removeEventListener( orig, handler, true );
						dataPriv.remove( doc, fix );
	
					} else {
						dataPriv.access( doc, fix, attaches );
					}
				}
			};
		} );
	}
	var location = window.location;
	
	var nonce = { guid: Date.now() };
	
	var rquery = ( /\?/ );
	
	
	
	// Cross-browser xml parsing
	jQuery.parseXML = function( data ) {
		var xml;
		if ( !data || typeof data !== "string" ) {
			return null;
		}
	
		// Support: IE 9 - 11 only
		// IE throws on parseFromString with invalid input.
		try {
			xml = ( new window.DOMParser() ).parseFromString( data, "text/xml" );
		} catch ( e ) {
			xml = undefined;
		}
	
		if ( !xml || xml.getElementsByTagName( "parsererror" ).length ) {
			jQuery.error( "Invalid XML: " + data );
		}
		return xml;
	};
	
	
	var
		rbracket = /\[\]$/,
		rCRLF = /\r?\n/g,
		rsubmitterTypes = /^(?:submit|button|image|reset|file)$/i,
		rsubmittable = /^(?:input|select|textarea|keygen)/i;
	
	function buildParams( prefix, obj, traditional, add ) {
		var name;
	
		if ( Array.isArray( obj ) ) {
	
			// Serialize array item.
			jQuery.each( obj, function( i, v ) {
				if ( traditional || rbracket.test( prefix ) ) {
	
					// Treat each array item as a scalar.
					add( prefix, v );
	
				} else {
	
					// Item is non-scalar (array or object), encode its numeric index.
					buildParams(
						prefix + "[" + ( typeof v === "object" && v != null ? i : "" ) + "]",
						v,
						traditional,
						add
					);
				}
			} );
	
		} else if ( !traditional && toType( obj ) === "object" ) {
	
			// Serialize object item.
			for ( name in obj ) {
				buildParams( prefix + "[" + name + "]", obj[ name ], traditional, add );
			}
	
		} else {
	
			// Serialize scalar item.
			add( prefix, obj );
		}
	}
	
	// Serialize an array of form elements or a set of
	// key/values into a query string
	jQuery.param = function( a, traditional ) {
		var prefix,
			s = [],
			add = function( key, valueOrFunction ) {
	
				// If value is a function, invoke it and use its return value
				var value = isFunction( valueOrFunction ) ?
					valueOrFunction() :
					valueOrFunction;
	
				s[ s.length ] = encodeURIComponent( key ) + "=" +
					encodeURIComponent( value == null ? "" : value );
			};
	
		if ( a == null ) {
			return "";
		}
	
		// If an array was passed in, assume that it is an array of form elements.
		if ( Array.isArray( a ) || ( a.jquery && !jQuery.isPlainObject( a ) ) ) {
	
			// Serialize the form elements
			jQuery.each( a, function() {
				add( this.name, this.value );
			} );
	
		} else {
	
			// If traditional, encode the "old" way (the way 1.3.2 or older
			// did it), otherwise encode params recursively.
			for ( prefix in a ) {
				buildParams( prefix, a[ prefix ], traditional, add );
			}
		}
	
		// Return the resulting serialization
		return s.join( "&" );
	};
	
	jQuery.fn.extend( {
		serialize: function() {
			return jQuery.param( this.serializeArray() );
		},
		serializeArray: function() {
			return this.map( function() {
	
				// Can add propHook for "elements" to filter or add form elements
				var elements = jQuery.prop( this, "elements" );
				return elements ? jQuery.makeArray( elements ) : this;
			} )
			.filter( function() {
				var type = this.type;
	
				// Use .is( ":disabled" ) so that fieldset[disabled] works
				return this.name && !jQuery( this ).is( ":disabled" ) &&
					rsubmittable.test( this.nodeName ) && !rsubmitterTypes.test( type ) &&
					( this.checked || !rcheckableType.test( type ) );
			} )
			.map( function( _i, elem ) {
				var val = jQuery( this ).val();
	
				if ( val == null ) {
					return null;
				}
	
				if ( Array.isArray( val ) ) {
					return jQuery.map( val, function( val ) {
						return { name: elem.name, value: val.replace( rCRLF, "\r\n" ) };
					} );
				}
	
				return { name: elem.name, value: val.replace( rCRLF, "\r\n" ) };
			} ).get();
		}
	} );
	
	
	var
		r20 = /%20/g,
		rhash = /#.*$/,
		rantiCache = /([?&])_=[^&]*/,
		rheaders = /^(.*?):[ \t]*([^\r\n]*)$/mg,
	
		// #7653, #8125, #8152: local protocol detection
		rlocalProtocol = /^(?:about|app|app-storage|.+-extension|file|res|widget):$/,
		rnoContent = /^(?:GET|HEAD)$/,
		rprotocol = /^\/\//,
	
		/* Prefilters
		 * 1) They are useful to introduce custom dataTypes (see ajax/jsonp.js for an example)
		 * 2) These are called:
		 *    - BEFORE asking for a transport
		 *    - AFTER param serialization (s.data is a string if s.processData is true)
		 * 3) key is the dataType
		 * 4) the catchall symbol "*" can be used
		 * 5) execution will start with transport dataType and THEN continue down to "*" if needed
		 */
		prefilters = {},
	
		/* Transports bindings
		 * 1) key is the dataType
		 * 2) the catchall symbol "*" can be used
		 * 3) selection will start with transport dataType and THEN go to "*" if needed
		 */
		transports = {},
	
		// Avoid comment-prolog char sequence (#10098); must appease lint and evade compression
		allTypes = "*/".concat( "*" ),
	
		// Anchor tag for parsing the document origin
		originAnchor = document.createElement( "a" );
		originAnchor.href = location.href;
	
	// Base "constructor" for jQuery.ajaxPrefilter and jQuery.ajaxTransport
	function addToPrefiltersOrTransports( structure ) {
	
		// dataTypeExpression is optional and defaults to "*"
		return function( dataTypeExpression, func ) {
	
			if ( typeof dataTypeExpression !== "string" ) {
				func = dataTypeExpression;
				dataTypeExpression = "*";
			}
	
			var dataType,
				i = 0,
				dataTypes = dataTypeExpression.toLowerCase().match( rnothtmlwhite ) || [];
	
			if ( isFunction( func ) ) {
	
				// For each dataType in the dataTypeExpression
				while ( ( dataType = dataTypes[ i++ ] ) ) {
	
					// Prepend if requested
					if ( dataType[ 0 ] === "+" ) {
						dataType = dataType.slice( 1 ) || "*";
						( structure[ dataType ] = structure[ dataType ] || [] ).unshift( func );
	
					// Otherwise append
					} else {
						( structure[ dataType ] = structure[ dataType ] || [] ).push( func );
					}
				}
			}
		};
	}
	
	// Base inspection function for prefilters and transports
	function inspectPrefiltersOrTransports( structure, options, originalOptions, jqXHR ) {
	
		var inspected = {},
			seekingTransport = ( structure === transports );
	
		function inspect( dataType ) {
			var selected;
			inspected[ dataType ] = true;
			jQuery.each( structure[ dataType ] || [], function( _, prefilterOrFactory ) {
				var dataTypeOrTransport = prefilterOrFactory( options, originalOptions, jqXHR );
				if ( typeof dataTypeOrTransport === "string" &&
					!seekingTransport && !inspected[ dataTypeOrTransport ] ) {
	
					options.dataTypes.unshift( dataTypeOrTransport );
					inspect( dataTypeOrTransport );
					return false;
				} else if ( seekingTransport ) {
					return !( selected = dataTypeOrTransport );
				}
			} );
			return selected;
		}
	
		return inspect( options.dataTypes[ 0 ] ) || !inspected[ "*" ] && inspect( "*" );
	}
	
	// A special extend for ajax options
	// that takes "flat" options (not to be deep extended)
	// Fixes #9887
	function ajaxExtend( target, src ) {
		var key, deep,
			flatOptions = jQuery.ajaxSettings.flatOptions || {};
	
		for ( key in src ) {
			if ( src[ key ] !== undefined ) {
				( flatOptions[ key ] ? target : ( deep || ( deep = {} ) ) )[ key ] = src[ key ];
			}
		}
		if ( deep ) {
			jQuery.extend( true, target, deep );
		}
	
		return target;
	}
	
	/* Handles responses to an ajax request:
	 * - finds the right dataType (mediates between content-type and expected dataType)
	 * - returns the corresponding response
	 */
	function ajaxHandleResponses( s, jqXHR, responses ) {
	
		var ct, type, finalDataType, firstDataType,
			contents = s.contents,
			dataTypes = s.dataTypes;
	
		// Remove auto dataType and get content-type in the process
		while ( dataTypes[ 0 ] === "*" ) {
			dataTypes.shift();
			if ( ct === undefined ) {
				ct = s.mimeType || jqXHR.getResponseHeader( "Content-Type" );
			}
		}
	
		// Check if we're dealing with a known content-type
		if ( ct ) {
			for ( type in contents ) {
				if ( contents[ type ] && contents[ type ].test( ct ) ) {
					dataTypes.unshift( type );
					break;
				}
			}
		}
	
		// Check to see if we have a response for the expected dataType
		if ( dataTypes[ 0 ] in responses ) {
			finalDataType = dataTypes[ 0 ];
		} else {
	
			// Try convertible dataTypes
			for ( type in responses ) {
				if ( !dataTypes[ 0 ] || s.converters[ type + " " + dataTypes[ 0 ] ] ) {
					finalDataType = type;
					break;
				}
				if ( !firstDataType ) {
					firstDataType = type;
				}
			}
	
			// Or just use first one
			finalDataType = finalDataType || firstDataType;
		}
	
		// If we found a dataType
		// We add the dataType to the list if needed
		// and return the corresponding response
		if ( finalDataType ) {
			if ( finalDataType !== dataTypes[ 0 ] ) {
				dataTypes.unshift( finalDataType );
			}
			return responses[ finalDataType ];
		}
	}
	
	/* Chain conversions given the request and the original response
	 * Also sets the responseXXX fields on the jqXHR instance
	 */
	function ajaxConvert( s, response, jqXHR, isSuccess ) {
		var conv2, current, conv, tmp, prev,
			converters = {},
	
			// Work with a copy of dataTypes in case we need to modify it for conversion
			dataTypes = s.dataTypes.slice();
	
		// Create converters map with lowercased keys
		if ( dataTypes[ 1 ] ) {
			for ( conv in s.converters ) {
				converters[ conv.toLowerCase() ] = s.converters[ conv ];
			}
		}
	
		current = dataTypes.shift();
	
		// Convert to each sequential dataType
		while ( current ) {
	
			if ( s.responseFields[ current ] ) {
				jqXHR[ s.responseFields[ current ] ] = response;
			}
	
			// Apply the dataFilter if provided
			if ( !prev && isSuccess && s.dataFilter ) {
				response = s.dataFilter( response, s.dataType );
			}
	
			prev = current;
			current = dataTypes.shift();
	
			if ( current ) {
	
				// There's only work to do if current dataType is non-auto
				if ( current === "*" ) {
	
					current = prev;
	
				// Convert response if prev dataType is non-auto and differs from current
				} else if ( prev !== "*" && prev !== current ) {
	
					// Seek a direct converter
					conv = converters[ prev + " " + current ] || converters[ "* " + current ];
	
					// If none found, seek a pair
					if ( !conv ) {
						for ( conv2 in converters ) {
	
							// If conv2 outputs current
							tmp = conv2.split( " " );
							if ( tmp[ 1 ] === current ) {
	
								// If prev can be converted to accepted input
								conv = converters[ prev + " " + tmp[ 0 ] ] ||
									converters[ "* " + tmp[ 0 ] ];
								if ( conv ) {
	
									// Condense equivalence converters
									if ( conv === true ) {
										conv = converters[ conv2 ];
	
									// Otherwise, insert the intermediate dataType
									} else if ( converters[ conv2 ] !== true ) {
										current = tmp[ 0 ];
										dataTypes.unshift( tmp[ 1 ] );
									}
									break;
								}
							}
						}
					}
	
					// Apply converter (if not an equivalence)
					if ( conv !== true ) {
	
						// Unless errors are allowed to bubble, catch and return them
						if ( conv && s.throws ) {
							response = conv( response );
						} else {
							try {
								response = conv( response );
							} catch ( e ) {
								return {
									state: "parsererror",
									error: conv ? e : "No conversion from " + prev + " to " + current
								};
							}
						}
					}
				}
			}
		}
	
		return { state: "success", data: response };
	}
	
	jQuery.extend( {
	
		// Counter for holding the number of active queries
		active: 0,
	
		// Last-Modified header cache for next request
		lastModified: {},
		etag: {},
	
		ajaxSettings: {
			url: location.href,
			type: "GET",
			isLocal: rlocalProtocol.test( location.protocol ),
			global: true,
			processData: true,
			async: true,
			contentType: "application/x-www-form-urlencoded; charset=UTF-8",
	
			/*
			timeout: 0,
			data: null,
			dataType: null,
			username: null,
			password: null,
			cache: null,
			throws: false,
			traditional: false,
			headers: {},
			*/
	
			accepts: {
				"*": allTypes,
				text: "text/plain",
				html: "text/html",
				xml: "application/xml, text/xml",
				json: "application/json, text/javascript"
			},
	
			contents: {
				xml: /\bxml\b/,
				html: /\bhtml/,
				json: /\bjson\b/
			},
	
			responseFields: {
				xml: "responseXML",
				text: "responseText",
				json: "responseJSON"
			},
	
			// Data converters
			// Keys separate source (or catchall "*") and destination types with a single space
			converters: {
	
				// Convert anything to text
				"* text": String,
	
				// Text to html (true = no transformation)
				"text html": true,
	
				// Evaluate text as a json expression
				"text json": JSON.parse,
	
				// Parse text as xml
				"text xml": jQuery.parseXML
			},
	
			// For options that shouldn't be deep extended:
			// you can add your own custom options here if
			// and when you create one that shouldn't be
			// deep extended (see ajaxExtend)
			flatOptions: {
				url: true,
				context: true
			}
		},
	
		// Creates a full fledged settings object into target
		// with both ajaxSettings and settings fields.
		// If target is omitted, writes into ajaxSettings.
		ajaxSetup: function( target, settings ) {
			return settings ?
	
				// Building a settings object
				ajaxExtend( ajaxExtend( target, jQuery.ajaxSettings ), settings ) :
	
				// Extending ajaxSettings
				ajaxExtend( jQuery.ajaxSettings, target );
		},
	
		ajaxPrefilter: addToPrefiltersOrTransports( prefilters ),
		ajaxTransport: addToPrefiltersOrTransports( transports ),
	
		// Main method
		ajax: function( url, options ) {
	
			// If url is an object, simulate pre-1.5 signature
			if ( typeof url === "object" ) {
				options = url;
				url = undefined;
			}
	
			// Force options to be an object
			options = options || {};
	
			var transport,
	
				// URL without anti-cache param
				cacheURL,
	
				// Response headers
				responseHeadersString,
				responseHeaders,
	
				// timeout handle
				timeoutTimer,
	
				// Url cleanup var
				urlAnchor,
	
				// Request state (becomes false upon send and true upon completion)
				completed,
	
				// To know if global events are to be dispatched
				fireGlobals,
	
				// Loop variable
				i,
	
				// uncached part of the url
				uncached,
	
				// Create the final options object
				s = jQuery.ajaxSetup( {}, options ),
	
				// Callbacks context
				callbackContext = s.context || s,
	
				// Context for global events is callbackContext if it is a DOM node or jQuery collection
				globalEventContext = s.context &&
					( callbackContext.nodeType || callbackContext.jquery ) ?
						jQuery( callbackContext ) :
						jQuery.event,
	
				// Deferreds
				deferred = jQuery.Deferred(),
				completeDeferred = jQuery.Callbacks( "once memory" ),
	
				// Status-dependent callbacks
				statusCode = s.statusCode || {},
	
				// Headers (they are sent all at once)
				requestHeaders = {},
				requestHeadersNames = {},
	
				// Default abort message
				strAbort = "canceled",
	
				// Fake xhr
				jqXHR = {
					readyState: 0,
	
					// Builds headers hashtable if needed
					getResponseHeader: function( key ) {
						var match;
						if ( completed ) {
							if ( !responseHeaders ) {
								responseHeaders = {};
								while ( ( match = rheaders.exec( responseHeadersString ) ) ) {
									responseHeaders[ match[ 1 ].toLowerCase() + " " ] =
										( responseHeaders[ match[ 1 ].toLowerCase() + " " ] || [] )
											.concat( match[ 2 ] );
								}
							}
							match = responseHeaders[ key.toLowerCase() + " " ];
						}
						return match == null ? null : match.join( ", " );
					},
	
					// Raw string
					getAllResponseHeaders: function() {
						return completed ? responseHeadersString : null;
					},
	
					// Caches the header
					setRequestHeader: function( name, value ) {
						if ( completed == null ) {
							name = requestHeadersNames[ name.toLowerCase() ] =
								requestHeadersNames[ name.toLowerCase() ] || name;
							requestHeaders[ name ] = value;
						}
						return this;
					},
	
					// Overrides response content-type header
					overrideMimeType: function( type ) {
						if ( completed == null ) {
							s.mimeType = type;
						}
						return this;
					},
	
					// Status-dependent callbacks
					statusCode: function( map ) {
						var code;
						if ( map ) {
							if ( completed ) {
	
								// Execute the appropriate callbacks
								jqXHR.always( map[ jqXHR.status ] );
							} else {
	
								// Lazy-add the new callbacks in a way that preserves old ones
								for ( code in map ) {
									statusCode[ code ] = [ statusCode[ code ], map[ code ] ];
								}
							}
						}
						return this;
					},
	
					// Cancel the request
					abort: function( statusText ) {
						var finalText = statusText || strAbort;
						if ( transport ) {
							transport.abort( finalText );
						}
						done( 0, finalText );
						return this;
					}
				};
	
			// Attach deferreds
			deferred.promise( jqXHR );
	
			// Add protocol if not provided (prefilters might expect it)
			// Handle falsy url in the settings object (#10093: consistency with old signature)
			// We also use the url parameter if available
			s.url = ( ( url || s.url || location.href ) + "" )
				.replace( rprotocol, location.protocol + "//" );
	
			// Alias method option to type as per ticket #12004
			s.type = options.method || options.type || s.method || s.type;
	
			// Extract dataTypes list
			s.dataTypes = ( s.dataType || "*" ).toLowerCase().match( rnothtmlwhite ) || [ "" ];
	
			// A cross-domain request is in order when the origin doesn't match the current origin.
			if ( s.crossDomain == null ) {
				urlAnchor = document.createElement( "a" );
	
				// Support: IE <=8 - 11, Edge 12 - 15
				// IE throws exception on accessing the href property if url is malformed,
				// e.g. http://example.com:80x/
				try {
					urlAnchor.href = s.url;
	
					// Support: IE <=8 - 11 only
					// Anchor's host property isn't correctly set when s.url is relative
					urlAnchor.href = urlAnchor.href;
					s.crossDomain = originAnchor.protocol + "//" + originAnchor.host !==
						urlAnchor.protocol + "//" + urlAnchor.host;
				} catch ( e ) {
	
					// If there is an error parsing the URL, assume it is crossDomain,
					// it can be rejected by the transport if it is invalid
					s.crossDomain = true;
				}
			}
	
			// Convert data if not already a string
			if ( s.data && s.processData && typeof s.data !== "string" ) {
				s.data = jQuery.param( s.data, s.traditional );
			}
	
			// Apply prefilters
			inspectPrefiltersOrTransports( prefilters, s, options, jqXHR );
	
			// If request was aborted inside a prefilter, stop there
			if ( completed ) {
				return jqXHR;
			}
	
			// We can fire global events as of now if asked to
			// Don't fire events if jQuery.event is undefined in an AMD-usage scenario (#15118)
			fireGlobals = jQuery.event && s.global;
	
			// Watch for a new set of requests
			if ( fireGlobals && jQuery.active++ === 0 ) {
				jQuery.event.trigger( "ajaxStart" );
			}
	
			// Uppercase the type
			s.type = s.type.toUpperCase();
	
			// Determine if request has content
			s.hasContent = !rnoContent.test( s.type );
	
			// Save the URL in case we're toying with the If-Modified-Since
			// and/or If-None-Match header later on
			// Remove hash to simplify url manipulation
			cacheURL = s.url.replace( rhash, "" );
	
			// More options handling for requests with no content
			if ( !s.hasContent ) {
	
				// Remember the hash so we can put it back
				uncached = s.url.slice( cacheURL.length );
	
				// If data is available and should be processed, append data to url
				if ( s.data && ( s.processData || typeof s.data === "string" ) ) {
					cacheURL += ( rquery.test( cacheURL ) ? "&" : "?" ) + s.data;
	
					// #9682: remove data so that it's not used in an eventual retry
					delete s.data;
				}
	
				// Add or update anti-cache param if needed
				if ( s.cache === false ) {
					cacheURL = cacheURL.replace( rantiCache, "$1" );
					uncached = ( rquery.test( cacheURL ) ? "&" : "?" ) + "_=" + ( nonce.guid++ ) +
						uncached;
				}
	
				// Put hash and anti-cache on the URL that will be requested (gh-1732)
				s.url = cacheURL + uncached;
	
			// Change '%20' to '+' if this is encoded form body content (gh-2658)
			} else if ( s.data && s.processData &&
				( s.contentType || "" ).indexOf( "application/x-www-form-urlencoded" ) === 0 ) {
				s.data = s.data.replace( r20, "+" );
			}
	
			// Set the If-Modified-Since and/or If-None-Match header, if in ifModified mode.
			if ( s.ifModified ) {
				if ( jQuery.lastModified[ cacheURL ] ) {
					jqXHR.setRequestHeader( "If-Modified-Since", jQuery.lastModified[ cacheURL ] );
				}
				if ( jQuery.etag[ cacheURL ] ) {
					jqXHR.setRequestHeader( "If-None-Match", jQuery.etag[ cacheURL ] );
				}
			}
	
			// Set the correct header, if data is being sent
			if ( s.data && s.hasContent && s.contentType !== false || options.contentType ) {
				jqXHR.setRequestHeader( "Content-Type", s.contentType );
			}
	
			// Set the Accepts header for the server, depending on the dataType
			jqXHR.setRequestHeader(
				"Accept",
				s.dataTypes[ 0 ] && s.accepts[ s.dataTypes[ 0 ] ] ?
					s.accepts[ s.dataTypes[ 0 ] ] +
						( s.dataTypes[ 0 ] !== "*" ? ", " + allTypes + "; q=0.01" : "" ) :
					s.accepts[ "*" ]
			);
	
			// Check for headers option
			for ( i in s.headers ) {
				jqXHR.setRequestHeader( i, s.headers[ i ] );
			}
	
			// Allow custom headers/mimetypes and early abort
			if ( s.beforeSend &&
				( s.beforeSend.call( callbackContext, jqXHR, s ) === false || completed ) ) {
	
				// Abort if not done already and return
				return jqXHR.abort();
			}
	
			// Aborting is no longer a cancellation
			strAbort = "abort";
	
			// Install callbacks on deferreds
			completeDeferred.add( s.complete );
			jqXHR.done( s.success );
			jqXHR.fail( s.error );
	
			// Get transport
			transport = inspectPrefiltersOrTransports( transports, s, options, jqXHR );
	
			// If no transport, we auto-abort
			if ( !transport ) {
				done( -1, "No Transport" );
			} else {
				jqXHR.readyState = 1;
	
				// Send global event
				if ( fireGlobals ) {
					globalEventContext.trigger( "ajaxSend", [ jqXHR, s ] );
				}
	
				// If request was aborted inside ajaxSend, stop there
				if ( completed ) {
					return jqXHR;
				}
	
				// Timeout
				if ( s.async && s.timeout > 0 ) {
					timeoutTimer = window.setTimeout( function() {
						jqXHR.abort( "timeout" );
					}, s.timeout );
				}
	
				try {
					completed = false;
					transport.send( requestHeaders, done );
				} catch ( e ) {
	
					// Rethrow post-completion exceptions
					if ( completed ) {
						throw e;
					}
	
					// Propagate others as results
					done( -1, e );
				}
			}
	
			// Callback for when everything is done
			function done( status, nativeStatusText, responses, headers ) {
				var isSuccess, success, error, response, modified,
					statusText = nativeStatusText;
	
				// Ignore repeat invocations
				if ( completed ) {
					return;
				}
	
				completed = true;
	
				// Clear timeout if it exists
				if ( timeoutTimer ) {
					window.clearTimeout( timeoutTimer );
				}
	
				// Dereference transport for early garbage collection
				// (no matter how long the jqXHR object will be used)
				transport = undefined;
	
				// Cache response headers
				responseHeadersString = headers || "";
	
				// Set readyState
				jqXHR.readyState = status > 0 ? 4 : 0;
	
				// Determine if successful
				isSuccess = status >= 200 && status < 300 || status === 304;
	
				// Get response data
				if ( responses ) {
					response = ajaxHandleResponses( s, jqXHR, responses );
				}
	
				// Use a noop converter for missing script
				if ( !isSuccess && jQuery.inArray( "script", s.dataTypes ) > -1 ) {
					s.converters[ "text script" ] = function() {};
				}
	
				// Convert no matter what (that way responseXXX fields are always set)
				response = ajaxConvert( s, response, jqXHR, isSuccess );
	
				// If successful, handle type chaining
				if ( isSuccess ) {
	
					// Set the If-Modified-Since and/or If-None-Match header, if in ifModified mode.
					if ( s.ifModified ) {
						modified = jqXHR.getResponseHeader( "Last-Modified" );
						if ( modified ) {
							jQuery.lastModified[ cacheURL ] = modified;
						}
						modified = jqXHR.getResponseHeader( "etag" );
						if ( modified ) {
							jQuery.etag[ cacheURL ] = modified;
						}
					}
	
					// if no content
					if ( status === 204 || s.type === "HEAD" ) {
						statusText = "nocontent";
	
					// if not modified
					} else if ( status === 304 ) {
						statusText = "notmodified";
	
					// If we have data, let's convert it
					} else {
						statusText = response.state;
						success = response.data;
						error = response.error;
						isSuccess = !error;
					}
				} else {
	
					// Extract error from statusText and normalize for non-aborts
					error = statusText;
					if ( status || !statusText ) {
						statusText = "error";
						if ( status < 0 ) {
							status = 0;
						}
					}
				}
	
				// Set data for the fake xhr object
				jqXHR.status = status;
				jqXHR.statusText = ( nativeStatusText || statusText ) + "";
	
				// Success/Error
				if ( isSuccess ) {
					deferred.resolveWith( callbackContext, [ success, statusText, jqXHR ] );
				} else {
					deferred.rejectWith( callbackContext, [ jqXHR, statusText, error ] );
				}
	
				// Status-dependent callbacks
				jqXHR.statusCode( statusCode );
				statusCode = undefined;
	
				if ( fireGlobals ) {
					globalEventContext.trigger( isSuccess ? "ajaxSuccess" : "ajaxError",
						[ jqXHR, s, isSuccess ? success : error ] );
				}
	
				// Complete
				completeDeferred.fireWith( callbackContext, [ jqXHR, statusText ] );
	
				if ( fireGlobals ) {
					globalEventContext.trigger( "ajaxComplete", [ jqXHR, s ] );
	
					// Handle the global AJAX counter
					if ( !( --jQuery.active ) ) {
						jQuery.event.trigger( "ajaxStop" );
					}
				}
			}
	
			return jqXHR;
		},
	
		getJSON: function( url, data, callback ) {
			return jQuery.get( url, data, callback, "json" );
		},
	
		getScript: function( url, callback ) {
			return jQuery.get( url, undefined, callback, "script" );
		}
	} );
	
	jQuery.each( [ "get", "post" ], function( _i, method ) {
		jQuery[ method ] = function( url, data, callback, type ) {
	
			// Shift arguments if data argument was omitted
			if ( isFunction( data ) ) {
				type = type || callback;
				callback = data;
				data = undefined;
			}
	
			// The url can be an options object (which then must have .url)
			return jQuery.ajax( jQuery.extend( {
				url: url,
				type: method,
				dataType: type,
				data: data,
				success: callback
			}, jQuery.isPlainObject( url ) && url ) );
		};
	} );
	
	jQuery.ajaxPrefilter( function( s ) {
		var i;
		for ( i in s.headers ) {
			if ( i.toLowerCase() === "content-type" ) {
				s.contentType = s.headers[ i ] || "";
			}
		}
	} );
	
	
	jQuery._evalUrl = function( url, options, doc ) {
		return jQuery.ajax( {
			url: url,
	
			// Make this explicit, since user can override this through ajaxSetup (#11264)
			type: "GET",
			dataType: "script",
			cache: true,
			async: false,
			global: false,
	
			// Only evaluate the response if it is successful (gh-4126)
			// dataFilter is not invoked for failure responses, so using it instead
			// of the default converter is kludgy but it works.
			converters: {
				"text script": function() {}
			},
			dataFilter: function( response ) {
				jQuery.globalEval( response, options, doc );
			}
		} );
	};
	
	
	jQuery.fn.extend( {
		wrapAll: function( html ) {
			var wrap;
	
			if ( this[ 0 ] ) {
				if ( isFunction( html ) ) {
					html = html.call( this[ 0 ] );
				}
	
				// The elements to wrap the target around
				wrap = jQuery( html, this[ 0 ].ownerDocument ).eq( 0 ).clone( true );
	
				if ( this[ 0 ].parentNode ) {
					wrap.insertBefore( this[ 0 ] );
				}
	
				wrap.map( function() {
					var elem = this;
	
					while ( elem.firstElementChild ) {
						elem = elem.firstElementChild;
					}
	
					return elem;
				} ).append( this );
			}
	
			return this;
		},
	
		wrapInner: function( html ) {
			if ( isFunction( html ) ) {
				return this.each( function( i ) {
					jQuery( this ).wrapInner( html.call( this, i ) );
				} );
			}
	
			return this.each( function() {
				var self = jQuery( this ),
					contents = self.contents();
	
				if ( contents.length ) {
					contents.wrapAll( html );
	
				} else {
					self.append( html );
				}
			} );
		},
	
		wrap: function( html ) {
			var htmlIsFunction = isFunction( html );
	
			return this.each( function( i ) {
				jQuery( this ).wrapAll( htmlIsFunction ? html.call( this, i ) : html );
			} );
		},
	
		unwrap: function( selector ) {
			this.parent( selector ).not( "body" ).each( function() {
				jQuery( this ).replaceWith( this.childNodes );
			} );
			return this;
		}
	} );
	
	
	jQuery.expr.pseudos.hidden = function( elem ) {
		return !jQuery.expr.pseudos.visible( elem );
	};
	jQuery.expr.pseudos.visible = function( elem ) {
		return !!( elem.offsetWidth || elem.offsetHeight || elem.getClientRects().length );
	};
	
	
	
	
	jQuery.ajaxSettings.xhr = function() {
		try {
			return new window.XMLHttpRequest();
		} catch ( e ) {}
	};
	
	var xhrSuccessStatus = {
	
			// File protocol always yields status code 0, assume 200
			0: 200,
	
			// Support: IE <=9 only
			// #1450: sometimes IE returns 1223 when it should be 204
			1223: 204
		},
		xhrSupported = jQuery.ajaxSettings.xhr();
	
	support.cors = !!xhrSupported && ( "withCredentials" in xhrSupported );
	support.ajax = xhrSupported = !!xhrSupported;
	
	jQuery.ajaxTransport( function( options ) {
		var callback, errorCallback;
	
		// Cross domain only allowed if supported through XMLHttpRequest
		if ( support.cors || xhrSupported && !options.crossDomain ) {
			return {
				send: function( headers, complete ) {
					var i,
						xhr = options.xhr();
	
					xhr.open(
						options.type,
						options.url,
						options.async,
						options.username,
						options.password
					);
	
					// Apply custom fields if provided
					if ( options.xhrFields ) {
						for ( i in options.xhrFields ) {
							xhr[ i ] = options.xhrFields[ i ];
						}
					}
	
					// Override mime type if needed
					if ( options.mimeType && xhr.overrideMimeType ) {
						xhr.overrideMimeType( options.mimeType );
					}
	
					// X-Requested-With header
					// For cross-domain requests, seeing as conditions for a preflight are
					// akin to a jigsaw puzzle, we simply never set it to be sure.
					// (it can always be set on a per-request basis or even using ajaxSetup)
					// For same-domain requests, won't change header if already provided.
					if ( !options.crossDomain && !headers[ "X-Requested-With" ] ) {
						headers[ "X-Requested-With" ] = "XMLHttpRequest";
					}
	
					// Set headers
					for ( i in headers ) {
						xhr.setRequestHeader( i, headers[ i ] );
					}
	
					// Callback
					callback = function( type ) {
						return function() {
							if ( callback ) {
								callback = errorCallback = xhr.onload =
									xhr.onerror = xhr.onabort = xhr.ontimeout =
										xhr.onreadystatechange = null;
	
								if ( type === "abort" ) {
									xhr.abort();
								} else if ( type === "error" ) {
	
									// Support: IE <=9 only
									// On a manual native abort, IE9 throws
									// errors on any property access that is not readyState
									if ( typeof xhr.status !== "number" ) {
										complete( 0, "error" );
									} else {
										complete(
	
											// File: protocol always yields status 0; see #8605, #14207
											xhr.status,
											xhr.statusText
										);
									}
								} else {
									complete(
										xhrSuccessStatus[ xhr.status ] || xhr.status,
										xhr.statusText,
	
										// Support: IE <=9 only
										// IE9 has no XHR2 but throws on binary (trac-11426)
										// For XHR2 non-text, let the caller handle it (gh-2498)
										( xhr.responseType || "text" ) !== "text"  ||
										typeof xhr.responseText !== "string" ?
											{ binary: xhr.response } :
											{ text: xhr.responseText },
										xhr.getAllResponseHeaders()
									);
								}
							}
						};
					};
	
					// Listen to events
					xhr.onload = callback();
					errorCallback = xhr.onerror = xhr.ontimeout = callback( "error" );
	
					// Support: IE 9 only
					// Use onreadystatechange to replace onabort
					// to handle uncaught aborts
					if ( xhr.onabort !== undefined ) {
						xhr.onabort = errorCallback;
					} else {
						xhr.onreadystatechange = function() {
	
							// Check readyState before timeout as it changes
							if ( xhr.readyState === 4 ) {
	
								// Allow onerror to be called first,
								// but that will not handle a native abort
								// Also, save errorCallback to a variable
								// as xhr.onerror cannot be accessed
								window.setTimeout( function() {
									if ( callback ) {
										errorCallback();
									}
								} );
							}
						};
					}
	
					// Create the abort callback
					callback = callback( "abort" );
	
					try {
	
						// Do send the request (this may raise an exception)
						xhr.send( options.hasContent && options.data || null );
					} catch ( e ) {
	
						// #14683: Only rethrow if this hasn't been notified as an error yet
						if ( callback ) {
							throw e;
						}
					}
				},
	
				abort: function() {
					if ( callback ) {
						callback();
					}
				}
			};
		}
	} );
	
	
	
	
	// Prevent auto-execution of scripts when no explicit dataType was provided (See gh-2432)
	jQuery.ajaxPrefilter( function( s ) {
		if ( s.crossDomain ) {
			s.contents.script = false;
		}
	} );
	
	// Install script dataType
	jQuery.ajaxSetup( {
		accepts: {
			script: "text/javascript, application/javascript, " +
				"application/ecmascript, application/x-ecmascript"
		},
		contents: {
			script: /\b(?:java|ecma)script\b/
		},
		converters: {
			"text script": function( text ) {
				jQuery.globalEval( text );
				return text;
			}
		}
	} );
	
	// Handle cache's special case and crossDomain
	jQuery.ajaxPrefilter( "script", function( s ) {
		if ( s.cache === undefined ) {
			s.cache = false;
		}
		if ( s.crossDomain ) {
			s.type = "GET";
		}
	} );
	
	// Bind script tag hack transport
	jQuery.ajaxTransport( "script", function( s ) {
	
		// This transport only deals with cross domain or forced-by-attrs requests
		if ( s.crossDomain || s.scriptAttrs ) {
			var script, callback;
			return {
				send: function( _, complete ) {
					script = jQuery( "<script>" )
						.attr( s.scriptAttrs || {} )
						.prop( { charset: s.scriptCharset, src: s.url } )
						.on( "load error", callback = function( evt ) {
							script.remove();
							callback = null;
							if ( evt ) {
								complete( evt.type === "error" ? 404 : 200, evt.type );
							}
						} );
	
					// Use native DOM manipulation to avoid our domManip AJAX trickery
					document.head.appendChild( script[ 0 ] );
				},
				abort: function() {
					if ( callback ) {
						callback();
					}
				}
			};
		}
	} );
	
	
	
	
	var oldCallbacks = [],
		rjsonp = /(=)\?(?=&|$)|\?\?/;
	
	// Default jsonp settings
	jQuery.ajaxSetup( {
		jsonp: "callback",
		jsonpCallback: function() {
			var callback = oldCallbacks.pop() || ( jQuery.expando + "_" + ( nonce.guid++ ) );
			this[ callback ] = true;
			return callback;
		}
	} );
	
	// Detect, normalize options and install callbacks for jsonp requests
	jQuery.ajaxPrefilter( "json jsonp", function( s, originalSettings, jqXHR ) {
	
		var callbackName, overwritten, responseContainer,
			jsonProp = s.jsonp !== false && ( rjsonp.test( s.url ) ?
				"url" :
				typeof s.data === "string" &&
					( s.contentType || "" )
						.indexOf( "application/x-www-form-urlencoded" ) === 0 &&
					rjsonp.test( s.data ) && "data"
			);
	
		// Handle iff the expected data type is "jsonp" or we have a parameter to set
		if ( jsonProp || s.dataTypes[ 0 ] === "jsonp" ) {
	
			// Get callback name, remembering preexisting value associated with it
			callbackName = s.jsonpCallback = isFunction( s.jsonpCallback ) ?
				s.jsonpCallback() :
				s.jsonpCallback;
	
			// Insert callback into url or form data
			if ( jsonProp ) {
				s[ jsonProp ] = s[ jsonProp ].replace( rjsonp, "$1" + callbackName );
			} else if ( s.jsonp !== false ) {
				s.url += ( rquery.test( s.url ) ? "&" : "?" ) + s.jsonp + "=" + callbackName;
			}
	
			// Use data converter to retrieve json after script execution
			s.converters[ "script json" ] = function() {
				if ( !responseContainer ) {
					jQuery.error( callbackName + " was not called" );
				}
				return responseContainer[ 0 ];
			};
	
			// Force json dataType
			s.dataTypes[ 0 ] = "json";
	
			// Install callback
			overwritten = window[ callbackName ];
			window[ callbackName ] = function() {
				responseContainer = arguments;
			};
	
			// Clean-up function (fires after converters)
			jqXHR.always( function() {
	
				// If previous value didn't exist - remove it
				if ( overwritten === undefined ) {
					jQuery( window ).removeProp( callbackName );
	
				// Otherwise restore preexisting value
				} else {
					window[ callbackName ] = overwritten;
				}
	
				// Save back as free
				if ( s[ callbackName ] ) {
	
					// Make sure that re-using the options doesn't screw things around
					s.jsonpCallback = originalSettings.jsonpCallback;
	
					// Save the callback name for future use
					oldCallbacks.push( callbackName );
				}
	
				// Call if it was a function and we have a response
				if ( responseContainer && isFunction( overwritten ) ) {
					overwritten( responseContainer[ 0 ] );
				}
	
				responseContainer = overwritten = undefined;
			} );
	
			// Delegate to script
			return "script";
		}
	} );
	
	
	
	
	// Support: Safari 8 only
	// In Safari 8 documents created via document.implementation.createHTMLDocument
	// collapse sibling forms: the second one becomes a child of the first one.
	// Because of that, this security measure has to be disabled in Safari 8.
	// https://bugs.webkit.org/show_bug.cgi?id=137337
	support.createHTMLDocument = ( function() {
		var body = document.implementation.createHTMLDocument( "" ).body;
		body.innerHTML = "<form></form><form></form>";
		return body.childNodes.length === 2;
	} )();
	
	
	// Argument "data" should be string of html
	// context (optional): If specified, the fragment will be created in this context,
	// defaults to document
	// keepScripts (optional): If true, will include scripts passed in the html string
	jQuery.parseHTML = function( data, context, keepScripts ) {
		if ( typeof data !== "string" ) {
			return [];
		}
		if ( typeof context === "boolean" ) {
			keepScripts = context;
			context = false;
		}
	
		var base, parsed, scripts;
	
		if ( !context ) {
	
			// Stop scripts or inline event handlers from being executed immediately
			// by using document.implementation
			if ( support.createHTMLDocument ) {
				context = document.implementation.createHTMLDocument( "" );
	
				// Set the base href for the created document
				// so any parsed elements with URLs
				// are based on the document's URL (gh-2965)
				base = context.createElement( "base" );
				base.href = document.location.href;
				context.head.appendChild( base );
			} else {
				context = document;
			}
		}
	
		parsed = rsingleTag.exec( data );
		scripts = !keepScripts && [];
	
		// Single tag
		if ( parsed ) {
			return [ context.createElement( parsed[ 1 ] ) ];
		}
	
		parsed = buildFragment( [ data ], context, scripts );
	
		if ( scripts && scripts.length ) {
			jQuery( scripts ).remove();
		}
	
		return jQuery.merge( [], parsed.childNodes );
	};
	
	
	/**
	 * Load a url into a page
	 */
	jQuery.fn.load = function( url, params, callback ) {
		var selector, type, response,
			self = this,
			off = url.indexOf( " " );
	
		if ( off > -1 ) {
			selector = stripAndCollapse( url.slice( off ) );
			url = url.slice( 0, off );
		}
	
		// If it's a function
		if ( isFunction( params ) ) {
	
			// We assume that it's the callback
			callback = params;
			params = undefined;
	
		// Otherwise, build a param string
		} else if ( params && typeof params === "object" ) {
			type = "POST";
		}
	
		// If we have elements to modify, make the request
		if ( self.length > 0 ) {
			jQuery.ajax( {
				url: url,
	
				// If "type" variable is undefined, then "GET" method will be used.
				// Make value of this field explicit since
				// user can override it through ajaxSetup method
				type: type || "GET",
				dataType: "html",
				data: params
			} ).done( function( responseText ) {
	
				// Save response for use in complete callback
				response = arguments;
	
				self.html( selector ?
	
					// If a selector was specified, locate the right elements in a dummy div
					// Exclude scripts to avoid IE 'Permission Denied' errors
					jQuery( "<div>" ).append( jQuery.parseHTML( responseText ) ).find( selector ) :
	
					// Otherwise use the full result
					responseText );
	
			// If the request succeeds, this function gets "data", "status", "jqXHR"
			// but they are ignored because response was set above.
			// If it fails, this function gets "jqXHR", "status", "error"
			} ).always( callback && function( jqXHR, status ) {
				self.each( function() {
					callback.apply( this, response || [ jqXHR.responseText, status, jqXHR ] );
				} );
			} );
		}
	
		return this;
	};
	
	
	
	
	jQuery.expr.pseudos.animated = function( elem ) {
		return jQuery.grep( jQuery.timers, function( fn ) {
			return elem === fn.elem;
		} ).length;
	};
	
	
	
	
	jQuery.offset = {
		setOffset: function( elem, options, i ) {
			var curPosition, curLeft, curCSSTop, curTop, curOffset, curCSSLeft, calculatePosition,
				position = jQuery.css( elem, "position" ),
				curElem = jQuery( elem ),
				props = {};
	
			// Set position first, in-case top/left are set even on static elem
			if ( position === "static" ) {
				elem.style.position = "relative";
			}
	
			curOffset = curElem.offset();
			curCSSTop = jQuery.css( elem, "top" );
			curCSSLeft = jQuery.css( elem, "left" );
			calculatePosition = ( position === "absolute" || position === "fixed" ) &&
				( curCSSTop + curCSSLeft ).indexOf( "auto" ) > -1;
	
			// Need to be able to calculate position if either
			// top or left is auto and position is either absolute or fixed
			if ( calculatePosition ) {
				curPosition = curElem.position();
				curTop = curPosition.top;
				curLeft = curPosition.left;
	
			} else {
				curTop = parseFloat( curCSSTop ) || 0;
				curLeft = parseFloat( curCSSLeft ) || 0;
			}
	
			if ( isFunction( options ) ) {
	
				// Use jQuery.extend here to allow modification of coordinates argument (gh-1848)
				options = options.call( elem, i, jQuery.extend( {}, curOffset ) );
			}
	
			if ( options.top != null ) {
				props.top = ( options.top - curOffset.top ) + curTop;
			}
			if ( options.left != null ) {
				props.left = ( options.left - curOffset.left ) + curLeft;
			}
	
			if ( "using" in options ) {
				options.using.call( elem, props );
	
			} else {
				if ( typeof props.top === "number" ) {
					props.top += "px";
				}
				if ( typeof props.left === "number" ) {
					props.left += "px";
				}
				curElem.css( props );
			}
		}
	};
	
	jQuery.fn.extend( {
	
		// offset() relates an element's border box to the document origin
		offset: function( options ) {
	
			// Preserve chaining for setter
			if ( arguments.length ) {
				return options === undefined ?
					this :
					this.each( function( i ) {
						jQuery.offset.setOffset( this, options, i );
					} );
			}
	
			var rect, win,
				elem = this[ 0 ];
	
			if ( !elem ) {
				return;
			}
	
			// Return zeros for disconnected and hidden (display: none) elements (gh-2310)
			// Support: IE <=11 only
			// Running getBoundingClientRect on a
			// disconnected node in IE throws an error
			if ( !elem.getClientRects().length ) {
				return { top: 0, left: 0 };
			}
	
			// Get document-relative position by adding viewport scroll to viewport-relative gBCR
			rect = elem.getBoundingClientRect();
			win = elem.ownerDocument.defaultView;
			return {
				top: rect.top + win.pageYOffset,
				left: rect.left + win.pageXOffset
			};
		},
	
		// position() relates an element's margin box to its offset parent's padding box
		// This corresponds to the behavior of CSS absolute positioning
		position: function() {
			if ( !this[ 0 ] ) {
				return;
			}
	
			var offsetParent, offset, doc,
				elem = this[ 0 ],
				parentOffset = { top: 0, left: 0 };
	
			// position:fixed elements are offset from the viewport, which itself always has zero offset
			if ( jQuery.css( elem, "position" ) === "fixed" ) {
	
				// Assume position:fixed implies availability of getBoundingClientRect
				offset = elem.getBoundingClientRect();
	
			} else {
				offset = this.offset();
	
				// Account for the *real* offset parent, which can be the document or its root element
				// when a statically positioned element is identified
				doc = elem.ownerDocument;
				offsetParent = elem.offsetParent || doc.documentElement;
				while ( offsetParent &&
					( offsetParent === doc.body || offsetParent === doc.documentElement ) &&
					jQuery.css( offsetParent, "position" ) === "static" ) {
	
					offsetParent = offsetParent.parentNode;
				}
				if ( offsetParent && offsetParent !== elem && offsetParent.nodeType === 1 ) {
	
					// Incorporate borders into its offset, since they are outside its content origin
					parentOffset = jQuery( offsetParent ).offset();
					parentOffset.top += jQuery.css( offsetParent, "borderTopWidth", true );
					parentOffset.left += jQuery.css( offsetParent, "borderLeftWidth", true );
				}
			}
	
			// Subtract parent offsets and element margins
			return {
				top: offset.top - parentOffset.top - jQuery.css( elem, "marginTop", true ),
				left: offset.left - parentOffset.left - jQuery.css( elem, "marginLeft", true )
			};
		},
	
		// This method will return documentElement in the following cases:
		// 1) For the element inside the iframe without offsetParent, this method will return
		//    documentElement of the parent window
		// 2) For the hidden or detached element
		// 3) For body or html element, i.e. in case of the html node - it will return itself
		//
		// but those exceptions were never presented as a real life use-cases
		// and might be considered as more preferable results.
		//
		// This logic, however, is not guaranteed and can change at any point in the future
		offsetParent: function() {
			return this.map( function() {
				var offsetParent = this.offsetParent;
	
				while ( offsetParent && jQuery.css( offsetParent, "position" ) === "static" ) {
					offsetParent = offsetParent.offsetParent;
				}
	
				return offsetParent || documentElement;
			} );
		}
	} );
	
	// Create scrollLeft and scrollTop methods
	jQuery.each( { scrollLeft: "pageXOffset", scrollTop: "pageYOffset" }, function( method, prop ) {
		var top = "pageYOffset" === prop;
	
		jQuery.fn[ method ] = function( val ) {
			return access( this, function( elem, method, val ) {
	
				// Coalesce documents and windows
				var win;
				if ( isWindow( elem ) ) {
					win = elem;
				} else if ( elem.nodeType === 9 ) {
					win = elem.defaultView;
				}
	
				if ( val === undefined ) {
					return win ? win[ prop ] : elem[ method ];
				}
	
				if ( win ) {
					win.scrollTo(
						!top ? val : win.pageXOffset,
						top ? val : win.pageYOffset
					);
	
				} else {
					elem[ method ] = val;
				}
			}, method, val, arguments.length );
		};
	} );
	
	// Support: Safari <=7 - 9.1, Chrome <=37 - 49
	// Add the top/left cssHooks using jQuery.fn.position
	// Webkit bug: https://bugs.webkit.org/show_bug.cgi?id=29084
	// Blink bug: https://bugs.chromium.org/p/chromium/issues/detail?id=589347
	// getComputedStyle returns percent when specified for top/left/bottom/right;
	// rather than make the css module depend on the offset module, just check for it here
	jQuery.each( [ "top", "left" ], function( _i, prop ) {
		jQuery.cssHooks[ prop ] = addGetHookIf( support.pixelPosition,
			function( elem, computed ) {
				if ( computed ) {
					computed = curCSS( elem, prop );
	
					// If curCSS returns percentage, fallback to offset
					return rnumnonpx.test( computed ) ?
						jQuery( elem ).position()[ prop ] + "px" :
						computed;
				}
			}
		);
	} );
	
	
	// Create innerHeight, innerWidth, height, width, outerHeight and outerWidth methods
	jQuery.each( { Height: "height", Width: "width" }, function( name, type ) {
		jQuery.each( { padding: "inner" + name, content: type, "": "outer" + name },
			function( defaultExtra, funcName ) {
	
			// Margin is only for outerHeight, outerWidth
			jQuery.fn[ funcName ] = function( margin, value ) {
				var chainable = arguments.length && ( defaultExtra || typeof margin !== "boolean" ),
					extra = defaultExtra || ( margin === true || value === true ? "margin" : "border" );
	
				return access( this, function( elem, type, value ) {
					var doc;
	
					if ( isWindow( elem ) ) {
	
						// $( window ).outerWidth/Height return w/h including scrollbars (gh-1729)
						return funcName.indexOf( "outer" ) === 0 ?
							elem[ "inner" + name ] :
							elem.document.documentElement[ "client" + name ];
					}
	
					// Get document width or height
					if ( elem.nodeType === 9 ) {
						doc = elem.documentElement;
	
						// Either scroll[Width/Height] or offset[Width/Height] or client[Width/Height],
						// whichever is greatest
						return Math.max(
							elem.body[ "scroll" + name ], doc[ "scroll" + name ],
							elem.body[ "offset" + name ], doc[ "offset" + name ],
							doc[ "client" + name ]
						);
					}
	
					return value === undefined ?
	
						// Get width or height on the element, requesting but not forcing parseFloat
						jQuery.css( elem, type, extra ) :
	
						// Set width or height on the element
						jQuery.style( elem, type, value, extra );
				}, type, chainable ? margin : undefined, chainable );
			};
		} );
	} );
	
	
	jQuery.each( [
		"ajaxStart",
		"ajaxStop",
		"ajaxComplete",
		"ajaxError",
		"ajaxSuccess",
		"ajaxSend"
	], function( _i, type ) {
		jQuery.fn[ type ] = function( fn ) {
			return this.on( type, fn );
		};
	} );
	
	
	
	
	jQuery.fn.extend( {
	
		bind: function( types, data, fn ) {
			return this.on( types, null, data, fn );
		},
		unbind: function( types, fn ) {
			return this.off( types, null, fn );
		},
	
		delegate: function( selector, types, data, fn ) {
			return this.on( types, selector, data, fn );
		},
		undelegate: function( selector, types, fn ) {
	
			// ( namespace ) or ( selector, types [, fn] )
			return arguments.length === 1 ?
				this.off( selector, "**" ) :
				this.off( types, selector || "**", fn );
		},
	
		hover: function( fnOver, fnOut ) {
			return this.mouseenter( fnOver ).mouseleave( fnOut || fnOver );
		}
	} );
	
	jQuery.each( ( "blur focus focusin focusout resize scroll click dblclick " +
		"mousedown mouseup mousemove mouseover mouseout mouseenter mouseleave " +
		"change select submit keydown keypress keyup contextmenu" ).split( " " ),
		function( _i, name ) {
	
			// Handle event binding
			jQuery.fn[ name ] = function( data, fn ) {
				return arguments.length > 0 ?
					this.on( name, null, data, fn ) :
					this.trigger( name );
			};
		} );
	
	
	
	
	// Support: Android <=4.0 only
	// Make sure we trim BOM and NBSP
	var rtrim = /^[\s\uFEFF\xA0]+|[\s\uFEFF\xA0]+$/g;
	
	// Bind a function to a context, optionally partially applying any
	// arguments.
	// jQuery.proxy is deprecated to promote standards (specifically Function#bind)
	// However, it is not slated for removal any time soon
	jQuery.proxy = function( fn, context ) {
		var tmp, args, proxy;
	
		if ( typeof context === "string" ) {
			tmp = fn[ context ];
			context = fn;
			fn = tmp;
		}
	
		// Quick check to determine if target is callable, in the spec
		// this throws a TypeError, but we will just return undefined.
		if ( !isFunction( fn ) ) {
			return undefined;
		}
	
		// Simulated bind
		args = slice.call( arguments, 2 );
		proxy = function() {
			return fn.apply( context || this, args.concat( slice.call( arguments ) ) );
		};
	
		// Set the guid of unique handler to the same of original handler, so it can be removed
		proxy.guid = fn.guid = fn.guid || jQuery.guid++;
	
		return proxy;
	};
	
	jQuery.holdReady = function( hold ) {
		if ( hold ) {
			jQuery.readyWait++;
		} else {
			jQuery.ready( true );
		}
	};
	jQuery.isArray = Array.isArray;
	jQuery.parseJSON = JSON.parse;
	jQuery.nodeName = nodeName;
	jQuery.isFunction = isFunction;
	jQuery.isWindow = isWindow;
	jQuery.camelCase = camelCase;
	jQuery.type = toType;
	
	jQuery.now = Date.now;
	
	jQuery.isNumeric = function( obj ) {
	
		// As of jQuery 3.0, isNumeric is limited to
		// strings and numbers (primitives or objects)
		// that can be coerced to finite numbers (gh-2662)
		var type = jQuery.type( obj );
		return ( type === "number" || type === "string" ) &&
	
			// parseFloat NaNs numeric-cast false positives ("")
			// ...but misinterprets leading-number strings, particularly hex literals ("0x...")
			// subtraction forces infinities to NaN
			!isNaN( obj - parseFloat( obj ) );
	};
	
	jQuery.trim = function( text ) {
		return text == null ?
			"" :
			( text + "" ).replace( rtrim, "" );
	};
	
	
	
	// Register as a named AMD module, since jQuery can be concatenated with other
	// files that may use define, but not via a proper concatenation script that
	// understands anonymous AMD modules. A named AMD is safest and most robust
	// way to register. Lowercase jquery is used because AMD module names are
	// derived from file names, and jQuery is normally delivered in a lowercase
	// file name. Do this after creating the global so that if an AMD module wants
	// to call noConflict to hide this version of jQuery, it will work.
	
	// Note that for maximum portability, libraries that are not jQuery should
	// declare themselves as anonymous modules, and avoid setting a global if an
	// AMD loader is present. jQuery is a special case. For more information, see
	// https://github.com/jrburke/requirejs/wiki/Updating-existing-libraries#wiki-anon
	
	if ( true ) {
		!(__WEBPACK_AMD_DEFINE_ARRAY__ = [], __WEBPACK_AMD_DEFINE_RESULT__ = function() {
			return jQuery;
		}.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
	}
	
	
	
	
	var
	
		// Map over jQuery in case of overwrite
		_jQuery = window.jQuery,
	
		// Map over the $ in case of overwrite
		_$ = window.$;
	
	jQuery.noConflict = function( deep ) {
		if ( window.$ === jQuery ) {
			window.$ = _$;
		}
	
		if ( deep && window.jQuery === jQuery ) {
			window.jQuery = _jQuery;
		}
	
		return jQuery;
	};
	
	// Expose jQuery and $ identifiers, even in AMD
	// (#7102#comment:10, https://github.com/jquery/jquery/pull/557)
	// and CommonJS for browser emulators (#13566)
	if ( typeof noGlobal === "undefined" ) {
		window.jQuery = window.$ = jQuery;
	}
	
	
	
	
	return jQuery;
	} );


/***/ },
/* 17 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	exports.__esModule = true;
	var matrix = __webpack_require__(27);
	var Point_1 = __webpack_require__(79);
	var mathMin = Math.min;
	var mathMax = Math.max;
	var lt = new Point_1["default"]();
	var rb = new Point_1["default"]();
	var lb = new Point_1["default"]();
	var rt = new Point_1["default"]();
	var minTv = new Point_1["default"]();
	var maxTv = new Point_1["default"]();
	var BoundingRect = (function () {
	    function BoundingRect(x, y, width, height) {
	        if (width < 0 && isFinite(width)) {
	            x = x + width;
	            width = -width;
	        }
	        if (height < 0 && isFinite(height)) {
	            y = y + height;
	            height = -height;
	        }
	        this.x = x;
	        this.y = y;
	        this.width = width;
	        this.height = height;
	    }
	    BoundingRect.prototype.union = function (other) {
	        var x = mathMin(other.x, this.x);
	        var y = mathMin(other.y, this.y);
	        if (isFinite(this.x) && isFinite(this.width)) {
	            this.width = mathMax(other.x + other.width, this.x + this.width) - x;
	        }
	        else {
	            this.width = other.width;
	        }
	        if (isFinite(this.y) && isFinite(this.height)) {
	            this.height = mathMax(other.y + other.height, this.y + this.height) - y;
	        }
	        else {
	            this.height = other.height;
	        }
	        this.x = x;
	        this.y = y;
	    };
	    BoundingRect.prototype.applyTransform = function (m) {
	        BoundingRect.applyTransform(this, this, m);
	    };
	    BoundingRect.prototype.calculateTransform = function (b) {
	        var a = this;
	        var sx = b.width / a.width;
	        var sy = b.height / a.height;
	        var m = matrix.create();
	        matrix.translate(m, m, [-a.x, -a.y]);
	        matrix.scale(m, m, [sx, sy]);
	        matrix.translate(m, m, [b.x, b.y]);
	        return m;
	    };
	    BoundingRect.prototype.intersect = function (b, mtv) {
	        if (!b) {
	            return false;
	        }
	        if (!(b instanceof BoundingRect)) {
	            b = BoundingRect.create(b);
	        }
	        var a = this;
	        var ax0 = a.x;
	        var ax1 = a.x + a.width;
	        var ay0 = a.y;
	        var ay1 = a.y + a.height;
	        var bx0 = b.x;
	        var bx1 = b.x + b.width;
	        var by0 = b.y;
	        var by1 = b.y + b.height;
	        var overlap = !(ax1 < bx0 || bx1 < ax0 || ay1 < by0 || by1 < ay0);
	        if (mtv) {
	            var dMin = Infinity;
	            var dMax = 0;
	            var d0 = Math.abs(ax1 - bx0);
	            var d1 = Math.abs(bx1 - ax0);
	            var d2 = Math.abs(ay1 - by0);
	            var d3 = Math.abs(by1 - ay0);
	            var dx = Math.min(d0, d1);
	            var dy = Math.min(d2, d3);
	            if (ax1 < bx0 || bx1 < ax0) {
	                if (dx > dMax) {
	                    dMax = dx;
	                    if (d0 < d1) {
	                        Point_1["default"].set(maxTv, -d0, 0);
	                    }
	                    else {
	                        Point_1["default"].set(maxTv, d1, 0);
	                    }
	                }
	            }
	            else {
	                if (dx < dMin) {
	                    dMin = dx;
	                    if (d0 < d1) {
	                        Point_1["default"].set(minTv, d0, 0);
	                    }
	                    else {
	                        Point_1["default"].set(minTv, -d1, 0);
	                    }
	                }
	            }
	            if (ay1 < by0 || by1 < ay0) {
	                if (dy > dMax) {
	                    dMax = dy;
	                    if (d2 < d3) {
	                        Point_1["default"].set(maxTv, 0, -d2);
	                    }
	                    else {
	                        Point_1["default"].set(maxTv, 0, d3);
	                    }
	                }
	            }
	            else {
	                if (dx < dMin) {
	                    dMin = dx;
	                    if (d2 < d3) {
	                        Point_1["default"].set(minTv, 0, d2);
	                    }
	                    else {
	                        Point_1["default"].set(minTv, 0, -d3);
	                    }
	                }
	            }
	        }
	        if (mtv) {
	            Point_1["default"].copy(mtv, overlap ? minTv : maxTv);
	        }
	        return overlap;
	    };
	    BoundingRect.prototype.contain = function (x, y) {
	        var rect = this;
	        return x >= rect.x
	            && x <= (rect.x + rect.width)
	            && y >= rect.y
	            && y <= (rect.y + rect.height);
	    };
	    BoundingRect.prototype.clone = function () {
	        return new BoundingRect(this.x, this.y, this.width, this.height);
	    };
	    BoundingRect.prototype.copy = function (other) {
	        BoundingRect.copy(this, other);
	    };
	    BoundingRect.prototype.plain = function () {
	        return {
	            x: this.x,
	            y: this.y,
	            width: this.width,
	            height: this.height
	        };
	    };
	    BoundingRect.prototype.isFinite = function () {
	        return isFinite(this.x)
	            && isFinite(this.y)
	            && isFinite(this.width)
	            && isFinite(this.height);
	    };
	    BoundingRect.prototype.isZero = function () {
	        return this.width === 0 || this.height === 0;
	    };
	    BoundingRect.create = function (rect) {
	        return new BoundingRect(rect.x, rect.y, rect.width, rect.height);
	    };
	    BoundingRect.copy = function (target, source) {
	        target.x = source.x;
	        target.y = source.y;
	        target.width = source.width;
	        target.height = source.height;
	    };
	    BoundingRect.applyTransform = function (target, source, m) {
	        if (!m) {
	            if (target !== source) {
	                BoundingRect.copy(target, source);
	            }
	            return;
	        }
	        if (m[1] < 1e-5 && m[1] > -1e-5 && m[2] < 1e-5 && m[2] > -1e-5) {
	            var sx = m[0];
	            var sy = m[3];
	            var tx = m[4];
	            var ty = m[5];
	            target.x = source.x * sx + tx;
	            target.y = source.y * sy + ty;
	            target.width = source.width * sx;
	            target.height = source.height * sy;
	            if (target.width < 0) {
	                target.x += target.width;
	                target.width = -target.width;
	            }
	            if (target.height < 0) {
	                target.y += target.height;
	                target.height = -target.height;
	            }
	            return;
	        }
	        lt.x = lb.x = source.x;
	        lt.y = rt.y = source.y;
	        rb.x = rt.x = source.x + source.width;
	        rb.y = lb.y = source.y + source.height;
	        lt.transform(m);
	        rt.transform(m);
	        rb.transform(m);
	        lb.transform(m);
	        target.x = mathMin(lt.x, rb.x, lb.x, rt.x);
	        target.y = mathMin(lt.y, rb.y, lb.y, rt.y);
	        var maxX = mathMax(lt.x, rb.x, lb.x, rt.x);
	        var maxY = mathMax(lt.y, rb.y, lb.y, rt.y);
	        target.width = maxX - target.x;
	        target.height = maxY - target.y;
	    };
	    return BoundingRect;
	}());
	exports["default"] = BoundingRect;


/***/ },
/* 18 */
/***/ function(module, exports, __webpack_require__) {

	
	/*
	* Licensed to the Apache Software Foundation (ASF) under one
	* or more contributor license agreements.  See the NOTICE file
	* distributed with this work for additional information
	* regarding copyright ownership.  The ASF licenses this file
	* to you under the Apache License, Version 2.0 (the
	* "License"); you may not use this file except in compliance
	* with the License.  You may obtain a copy of the License at
	*
	*   http://www.apache.org/licenses/LICENSE-2.0
	*
	* Unless required by applicable law or agreed to in writing,
	* software distributed under the License is distributed on an
	* "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
	* KIND, either express or implied.  See the License for the
	* specific language governing permissions and limitations
	* under the License.
	*/
	
	
	
	/**
	 * AUTO-GENERATED FILE. DO NOT MODIFY.
	 */
	
	"use strict";
	
	exports.__esModule = true;
	
	var Group_1 = __webpack_require__(51);
	
	var componentUtil = __webpack_require__(41);
	
	var clazzUtil = __webpack_require__(28);
	
	var ComponentView = function () {
	  function ComponentView() {
	    this.group = new Group_1["default"]();
	    this.uid = componentUtil.getUID('viewComponent');
	  }
	
	  ComponentView.prototype.init = function (ecModel, api) {};
	
	  ComponentView.prototype.render = function (model, ecModel, api, payload) {};
	
	  ComponentView.prototype.dispose = function (ecModel, api) {};
	
	  ComponentView.prototype.updateView = function (model, ecModel, api, payload) {};
	
	  ComponentView.prototype.updateLayout = function (model, ecModel, api, payload) {};
	
	  ComponentView.prototype.updateVisual = function (model, ecModel, api, payload) {};
	
	  ComponentView.prototype.blurSeries = function (seriesModels, ecModel) {};
	
	  return ComponentView;
	}();
	
	;
	clazzUtil.enableClassExtend(ComponentView);
	clazzUtil.enableClassManagement(ComponentView, {
	  registerWhenExtend: true
	});
	exports["default"] = ComponentView;

/***/ },
/* 19 */
/***/ function(module, exports, __webpack_require__) {

	
	/*
	* Licensed to the Apache Software Foundation (ASF) under one
	* or more contributor license agreements.  See the NOTICE file
	* distributed with this work for additional information
	* regarding copyright ownership.  The ASF licenses this file
	* to you under the Apache License, Version 2.0 (the
	* "License"); you may not use this file except in compliance
	* with the License.  You may obtain a copy of the License at
	*
	*   http://www.apache.org/licenses/LICENSE-2.0
	*
	* Unless required by applicable law or agreed to in writing,
	* software distributed under the License is distributed on an
	* "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
	* KIND, either express or implied.  See the License for the
	* specific language governing permissions and limitations
	* under the License.
	*/
	
	
	
	/**
	 * AUTO-GENERATED FILE. DO NOT MODIFY.
	 */
	
	"use strict";
	
	exports.__esModule = true;
	
	var echarts = __webpack_require__(6);
	
	__webpack_require__(133);
	
	__webpack_require__(329);
	
	__webpack_require__(331);
	
	echarts.registerAction({
	  type: 'showTip',
	  event: 'showTip',
	  update: 'tooltip:manuallyShowTip'
	}, function () {});
	echarts.registerAction({
	  type: 'hideTip',
	  event: 'hideTip',
	  update: 'tooltip:manuallyHideTip'
	}, function () {});

/***/ },
/* 20 */
/***/ function(module, exports, __webpack_require__) {

	
	/*
	* Licensed to the Apache Software Foundation (ASF) under one
	* or more contributor license agreements.  See the NOTICE file
	* distributed with this work for additional information
	* regarding copyright ownership.  The ASF licenses this file
	* to you under the Apache License, Version 2.0 (the
	* "License"); you may not use this file except in compliance
	* with the License.  You may obtain a copy of the License at
	*
	*   http://www.apache.org/licenses/LICENSE-2.0
	*
	* Unless required by applicable law or agreed to in writing,
	* software distributed under the License is distributed on an
	* "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
	* KIND, either express or implied.  See the License for the
	* specific language governing permissions and limitations
	* under the License.
	*/
	
	
	
	/**
	 * AUTO-GENERATED FILE. DO NOT MODIFY.
	 */
	
	"use strict";
	
	exports.__esModule = true;
	
	var Text_1 = __webpack_require__(60);
	
	var util_1 = __webpack_require__(1);
	
	var states_1 = __webpack_require__(22);
	
	var log_1 = __webpack_require__(12);
	
	var model_1 = __webpack_require__(4);
	
	var graphic_1 = __webpack_require__(7);
	
	var EMPTY_OBJ = {};
	
	function setLabelText(label, labelTexts) {
	  for (var i = 0; i < states_1.SPECIAL_STATES.length; i++) {
	    var stateName = states_1.SPECIAL_STATES[i];
	    var text = labelTexts[stateName];
	    var state = label.ensureState(stateName);
	    state.style = state.style || {};
	    state.style.text = text;
	  }
	
	  var oldStates = label.currentStates.slice();
	  label.clearStates(true);
	  label.setStyle({
	    text: labelTexts.normal
	  });
	  label.useStates(oldStates, true);
	}
	
	exports.setLabelText = setLabelText;
	
	function getLabelText(opt, stateModels, overrideValue) {
	  var labelFetcher = opt.labelFetcher;
	  var labelDataIndex = opt.labelDataIndex;
	  var labelDimIndex = opt.labelDimIndex;
	  var normalModel = stateModels.normal;
	  var baseText;
	
	  if (labelFetcher) {
	    baseText = labelFetcher.getFormattedLabel(labelDataIndex, 'normal', null, labelDimIndex, normalModel && normalModel.get('formatter'), overrideValue != null ? {
	      value: overrideValue
	    } : null);
	  }
	
	  if (baseText == null) {
	    baseText = util_1.isFunction(opt.defaultText) ? opt.defaultText(labelDataIndex, opt, overrideValue) : opt.defaultText;
	  }
	
	  var statesText = {
	    normal: baseText
	  };
	
	  for (var i = 0; i < states_1.SPECIAL_STATES.length; i++) {
	    var stateName = states_1.SPECIAL_STATES[i];
	    var stateModel = stateModels[stateName];
	    statesText[stateName] = util_1.retrieve2(labelFetcher ? labelFetcher.getFormattedLabel(labelDataIndex, stateName, null, labelDimIndex, stateModel && stateModel.get('formatter')) : null, baseText);
	  }
	
	  return statesText;
	}
	
	exports.getLabelText = getLabelText;
	
	function setLabelStyle(targetEl, labelStatesModels, opt, stateSpecified) {
	  opt = opt || EMPTY_OBJ;
	  var isSetOnText = targetEl instanceof Text_1["default"];
	  var needsCreateText = false;
	
	  for (var i = 0; i < states_1.DISPLAY_STATES.length; i++) {
	    var stateModel = labelStatesModels[states_1.DISPLAY_STATES[i]];
	
	    if (stateModel && stateModel.getShallow('show')) {
	      needsCreateText = true;
	      break;
	    }
	  }
	
	  var textContent = isSetOnText ? targetEl : targetEl.getTextContent();
	
	  if (needsCreateText) {
	    if (!isSetOnText) {
	      if (!textContent) {
	        textContent = new Text_1["default"]();
	        targetEl.setTextContent(textContent);
	      }
	
	      if (targetEl.stateProxy) {
	        textContent.stateProxy = targetEl.stateProxy;
	      }
	    }
	
	    var labelStatesTexts = getLabelText(opt, labelStatesModels);
	    var normalModel = labelStatesModels.normal;
	    var showNormal = !!normalModel.getShallow('show');
	    var normalStyle = createTextStyle(normalModel, stateSpecified && stateSpecified.normal, opt, false, !isSetOnText);
	    normalStyle.text = labelStatesTexts.normal;
	
	    if (!isSetOnText) {
	      targetEl.setTextConfig(createTextConfig(normalModel, opt, false));
	    }
	
	    for (var i = 0; i < states_1.SPECIAL_STATES.length; i++) {
	      var stateName = states_1.SPECIAL_STATES[i];
	      var stateModel = labelStatesModels[stateName];
	
	      if (stateModel) {
	        var stateObj = textContent.ensureState(stateName);
	        var stateShow = !!util_1.retrieve2(stateModel.getShallow('show'), showNormal);
	
	        if (stateShow !== showNormal) {
	          stateObj.ignore = !stateShow;
	        }
	
	        stateObj.style = createTextStyle(stateModel, stateSpecified && stateSpecified[stateName], opt, true, !isSetOnText);
	        stateObj.style.text = labelStatesTexts[stateName];
	
	        if (!isSetOnText) {
	          var targetElEmphasisState = targetEl.ensureState(stateName);
	          targetElEmphasisState.textConfig = createTextConfig(stateModel, opt, true);
	        }
	      }
	    }
	
	    textContent.silent = !!normalModel.getShallow('silent');
	
	    if (textContent.style.x != null) {
	      normalStyle.x = textContent.style.x;
	    }
	
	    if (textContent.style.y != null) {
	      normalStyle.y = textContent.style.y;
	    }
	
	    textContent.ignore = !showNormal;
	    textContent.useStyle(normalStyle);
	    textContent.dirty();
	
	    if (opt.enableTextSetter) {
	      exports.labelInner(textContent).setLabelText = function (overrideValue) {
	        var labelStatesTexts = getLabelText(opt, labelStatesModels, overrideValue);
	        setLabelText(textContent, labelStatesTexts);
	      };
	    }
	  } else if (textContent) {
	    textContent.ignore = true;
	  }
	
	  targetEl.dirty();
	}
	
	exports.setLabelStyle = setLabelStyle;
	
	function getLabelStatesModels(itemModel, labelName) {
	  labelName = labelName || 'label';
	  var statesModels = {
	    normal: itemModel.getModel(labelName)
	  };
	
	  for (var i = 0; i < states_1.SPECIAL_STATES.length; i++) {
	    var stateName = states_1.SPECIAL_STATES[i];
	    statesModels[stateName] = itemModel.getModel([stateName, labelName]);
	  }
	
	  return statesModels;
	}
	
	exports.getLabelStatesModels = getLabelStatesModels;
	
	function createTextStyle(textStyleModel, specifiedTextStyle, opt, isNotNormal, isAttached) {
	  var textStyle = {};
	  setTextStyleCommon(textStyle, textStyleModel, opt, isNotNormal, isAttached);
	  specifiedTextStyle && util_1.extend(textStyle, specifiedTextStyle);
	  return textStyle;
	}
	
	exports.createTextStyle = createTextStyle;
	
	function createTextConfig(textStyleModel, opt, isNotNormal) {
	  opt = opt || {};
	  var textConfig = {};
	  var labelPosition;
	  var labelRotate = textStyleModel.getShallow('rotate');
	  var labelDistance = util_1.retrieve2(textStyleModel.getShallow('distance'), isNotNormal ? null : 5);
	  var labelOffset = textStyleModel.getShallow('offset');
	  labelPosition = textStyleModel.getShallow('position') || (isNotNormal ? null : 'inside');
	  labelPosition === 'outside' && (labelPosition = opt.defaultOutsidePosition || 'top');
	
	  if (labelPosition != null) {
	    textConfig.position = labelPosition;
	  }
	
	  if (labelOffset != null) {
	    textConfig.offset = labelOffset;
	  }
	
	  if (labelRotate != null) {
	    labelRotate *= Math.PI / 180;
	    textConfig.rotation = labelRotate;
	  }
	
	  if (labelDistance != null) {
	    textConfig.distance = labelDistance;
	  }
	
	  textConfig.outsideFill = textStyleModel.get('color') === 'inherit' ? opt.inheritColor || null : 'auto';
	  return textConfig;
	}
	
	exports.createTextConfig = createTextConfig;
	
	function setTextStyleCommon(textStyle, textStyleModel, opt, isNotNormal, isAttached) {
	  opt = opt || EMPTY_OBJ;
	  var ecModel = textStyleModel.ecModel;
	  var globalTextStyle = ecModel && ecModel.option.textStyle;
	  var richItemNames = getRichItemNames(textStyleModel);
	  var richResult;
	
	  if (richItemNames) {
	    richResult = {};
	
	    for (var name_1 in richItemNames) {
	      if (richItemNames.hasOwnProperty(name_1)) {
	        var richTextStyle = textStyleModel.getModel(['rich', name_1]);
	        setTokenTextStyle(richResult[name_1] = {}, richTextStyle, globalTextStyle, opt, isNotNormal, isAttached, false, true);
	      }
	    }
	  }
	
	  if (richResult) {
	    textStyle.rich = richResult;
	  }
	
	  var overflow = textStyleModel.get('overflow');
	
	  if (overflow) {
	    textStyle.overflow = overflow;
	  }
	
	  var margin = textStyleModel.get('minMargin');
	
	  if (margin != null) {
	    textStyle.margin = margin;
	  }
	
	  setTokenTextStyle(textStyle, textStyleModel, globalTextStyle, opt, isNotNormal, isAttached, true, false);
	}
	
	function getRichItemNames(textStyleModel) {
	  var richItemNameMap;
	
	  while (textStyleModel && textStyleModel !== textStyleModel.ecModel) {
	    var rich = (textStyleModel.option || EMPTY_OBJ).rich;
	
	    if (rich) {
	      richItemNameMap = richItemNameMap || {};
	      var richKeys = util_1.keys(rich);
	
	      for (var i = 0; i < richKeys.length; i++) {
	        var richKey = richKeys[i];
	        richItemNameMap[richKey] = 1;
	      }
	    }
	
	    textStyleModel = textStyleModel.parentModel;
	  }
	
	  return richItemNameMap;
	}
	
	var TEXT_PROPS_WITH_GLOBAL = ['fontStyle', 'fontWeight', 'fontSize', 'fontFamily', 'textShadowColor', 'textShadowBlur', 'textShadowOffsetX', 'textShadowOffsetY'];
	var TEXT_PROPS_SELF = ['align', 'lineHeight', 'width', 'height', 'tag', 'verticalAlign'];
	var TEXT_PROPS_BOX = ['padding', 'borderWidth', 'borderRadius', 'borderDashOffset', 'backgroundColor', 'borderColor', 'shadowColor', 'shadowBlur', 'shadowOffsetX', 'shadowOffsetY'];
	
	function setTokenTextStyle(textStyle, textStyleModel, globalTextStyle, opt, isNotNormal, isAttached, isBlock, inRich) {
	  globalTextStyle = !isNotNormal && globalTextStyle || EMPTY_OBJ;
	  var inheritColor = opt && opt.inheritColor;
	  var fillColor = textStyleModel.getShallow('color');
	  var strokeColor = textStyleModel.getShallow('textBorderColor');
	  var opacity = util_1.retrieve2(textStyleModel.getShallow('opacity'), globalTextStyle.opacity);
	
	  if (fillColor === 'inherit' || fillColor === 'auto') {
	    if (false) {
	      if (fillColor === 'auto') {
	        log_1.deprecateReplaceLog('color: \'auto\'', 'color: \'inherit\'');
	      }
	    }
	
	    if (inheritColor) {
	      fillColor = inheritColor;
	    } else {
	      fillColor = null;
	    }
	  }
	
	  if (strokeColor === 'inherit' || strokeColor === 'auto') {
	    if (false) {
	      if (strokeColor === 'auto') {
	        log_1.deprecateReplaceLog('color: \'auto\'', 'color: \'inherit\'');
	      }
	    }
	
	    if (inheritColor) {
	      strokeColor = inheritColor;
	    } else {
	      strokeColor = null;
	    }
	  }
	
	  if (!isAttached) {
	    fillColor = fillColor || globalTextStyle.color;
	    strokeColor = strokeColor || globalTextStyle.textBorderColor;
	  }
	
	  if (fillColor != null) {
	    textStyle.fill = fillColor;
	  }
	
	  if (strokeColor != null) {
	    textStyle.stroke = strokeColor;
	  }
	
	  var textBorderWidth = util_1.retrieve2(textStyleModel.getShallow('textBorderWidth'), globalTextStyle.textBorderWidth);
	
	  if (textBorderWidth != null) {
	    textStyle.lineWidth = textBorderWidth;
	  }
	
	  var textBorderType = util_1.retrieve2(textStyleModel.getShallow('textBorderType'), globalTextStyle.textBorderType);
	
	  if (textBorderType != null) {
	    textStyle.lineDash = textBorderType;
	  }
	
	  var textBorderDashOffset = util_1.retrieve2(textStyleModel.getShallow('textBorderDashOffset'), globalTextStyle.textBorderDashOffset);
	
	  if (textBorderDashOffset != null) {
	    textStyle.lineDashOffset = textBorderDashOffset;
	  }
	
	  if (!isNotNormal && opacity == null && !inRich) {
	    opacity = opt && opt.defaultOpacity;
	  }
	
	  if (opacity != null) {
	    textStyle.opacity = opacity;
	  }
	
	  if (!isNotNormal && !isAttached) {
	    if (textStyle.fill == null && opt.inheritColor) {
	      textStyle.fill = opt.inheritColor;
	    }
	  }
	
	  for (var i = 0; i < TEXT_PROPS_WITH_GLOBAL.length; i++) {
	    var key = TEXT_PROPS_WITH_GLOBAL[i];
	    var val = util_1.retrieve2(textStyleModel.getShallow(key), globalTextStyle[key]);
	
	    if (val != null) {
	      textStyle[key] = val;
	    }
	  }
	
	  for (var i = 0; i < TEXT_PROPS_SELF.length; i++) {
	    var key = TEXT_PROPS_SELF[i];
	    var val = textStyleModel.getShallow(key);
	
	    if (val != null) {
	      textStyle[key] = val;
	    }
	  }
	
	  if (textStyle.verticalAlign == null) {
	    var baseline = textStyleModel.getShallow('baseline');
	
	    if (baseline != null) {
	      textStyle.verticalAlign = baseline;
	    }
	  }
	
	  if (!isBlock || !opt.disableBox) {
	    for (var i = 0; i < TEXT_PROPS_BOX.length; i++) {
	      var key = TEXT_PROPS_BOX[i];
	      var val = textStyleModel.getShallow(key);
	
	      if (val != null) {
	        textStyle[key] = val;
	      }
	    }
	
	    var borderType = textStyleModel.getShallow('borderType');
	
	    if (borderType != null) {
	      textStyle.borderDash = borderType;
	    }
	
	    if ((textStyle.backgroundColor === 'auto' || textStyle.backgroundColor === 'inherit') && inheritColor) {
	      if (false) {
	        if (textStyle.backgroundColor === 'auto') {
	          log_1.deprecateReplaceLog('backgroundColor: \'auto\'', 'backgroundColor: \'inherit\'');
	        }
	      }
	
	      textStyle.backgroundColor = inheritColor;
	    }
	
	    if ((textStyle.borderColor === 'auto' || textStyle.borderColor === 'inherit') && inheritColor) {
	      if (false) {
	        if (textStyle.borderColor === 'auto') {
	          log_1.deprecateReplaceLog('borderColor: \'auto\'', 'borderColor: \'inherit\'');
	        }
	      }
	
	      textStyle.borderColor = inheritColor;
	    }
	  }
	}
	
	function getFont(opt, ecModel) {
	  var gTextStyleModel = ecModel && ecModel.getModel('textStyle');
	  return util_1.trim([opt.fontStyle || gTextStyleModel && gTextStyleModel.getShallow('fontStyle') || '', opt.fontWeight || gTextStyleModel && gTextStyleModel.getShallow('fontWeight') || '', (opt.fontSize || gTextStyleModel && gTextStyleModel.getShallow('fontSize') || 12) + 'px', opt.fontFamily || gTextStyleModel && gTextStyleModel.getShallow('fontFamily') || 'sans-serif'].join(' '));
	}
	
	exports.getFont = getFont;
	exports.labelInner = model_1.makeInner();
	
	function setLabelValueAnimation(label, labelStatesModels, value, getDefaultText) {
	  if (!label) {
	    return;
	  }
	
	  var obj = exports.labelInner(label);
	  obj.prevValue = obj.value;
	  obj.value = value;
	  var normalLabelModel = labelStatesModels.normal;
	  obj.valueAnimation = normalLabelModel.get('valueAnimation');
	
	  if (obj.valueAnimation) {
	    obj.precision = normalLabelModel.get('precision');
	    obj.defaultInterpolatedText = getDefaultText;
	    obj.statesModels = labelStatesModels;
	  }
	}
	
	exports.setLabelValueAnimation = setLabelValueAnimation;
	
	function animateLabelValue(textEl, dataIndex, data, seriesModel) {
	  var labelInnerStore = exports.labelInner(textEl);
	
	  if (!labelInnerStore.valueAnimation) {
	    return;
	  }
	
	  var defaultInterpolatedText = labelInnerStore.defaultInterpolatedText;
	  var prevValue = labelInnerStore.prevValue;
	  var currentValue = labelInnerStore.value;
	
	  function during(percent) {
	    var interpolated = model_1.interpolateRawValues(data, labelInnerStore.precision, prevValue, currentValue, percent);
	    var labelText = getLabelText({
	      labelDataIndex: dataIndex,
	      defaultText: defaultInterpolatedText ? defaultInterpolatedText(interpolated) : interpolated + ''
	    }, labelInnerStore.statesModels, interpolated);
	    setLabelText(textEl, labelText);
	  }
	
	  (prevValue == null ? graphic_1.initProps : graphic_1.updateProps)(textEl, {}, seriesModel, dataIndex, null, during);
	}
	
	exports.animateLabelValue = animateLabelValue;

/***/ },
/* 21 */
/***/ function(module, exports, __webpack_require__) {

	
	/*
	* Licensed to the Apache Software Foundation (ASF) under one
	* or more contributor license agreements.  See the NOTICE file
	* distributed with this work for additional information
	* regarding copyright ownership.  The ASF licenses this file
	* to you under the Apache License, Version 2.0 (the
	* "License"); you may not use this file except in compliance
	* with the License.  You may obtain a copy of the License at
	*
	*   http://www.apache.org/licenses/LICENSE-2.0
	*
	* Unless required by applicable law or agreed to in writing,
	* software distributed under the License is distributed on an
	* "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
	* KIND, either express or implied.  See the License for the
	* specific language governing permissions and limitations
	* under the License.
	*/
	
	
	
	/**
	 * AUTO-GENERATED FILE. DO NOT MODIFY.
	 */
	
	"use strict";
	
	exports.__esModule = true;
	
	var model_1 = __webpack_require__(4);
	
	exports.getECData = model_1.makeInner();

/***/ },
/* 22 */
/***/ function(module, exports, __webpack_require__) {

	
	/*
	* Licensed to the Apache Software Foundation (ASF) under one
	* or more contributor license agreements.  See the NOTICE file
	* distributed with this work for additional information
	* regarding copyright ownership.  The ASF licenses this file
	* to you under the Apache License, Version 2.0 (the
	* "License"); you may not use this file except in compliance
	* with the License.  You may obtain a copy of the License at
	*
	*   http://www.apache.org/licenses/LICENSE-2.0
	*
	* Unless required by applicable law or agreed to in writing,
	* software distributed under the License is distributed on an
	* "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
	* KIND, either express or implied.  See the License for the
	* specific language governing permissions and limitations
	* under the License.
	*/
	
	
	
	/**
	 * AUTO-GENERATED FILE. DO NOT MODIFY.
	 */
	
	"use strict";
	
	exports.__esModule = true;
	
	var LRU_1 = __webpack_require__(59);
	
	var util_1 = __webpack_require__(1);
	
	var innerStore_1 = __webpack_require__(21);
	
	var colorTool = __webpack_require__(34);
	
	var model_1 = __webpack_require__(4);
	
	var Path_1 = __webpack_require__(8);
	
	var _highlightNextDigit = 1;
	var _highlightKeyMap = {};
	var getSavedStates = model_1.makeInner();
	exports.HOVER_STATE_NORMAL = 0;
	exports.HOVER_STATE_BLUR = 1;
	exports.HOVER_STATE_EMPHASIS = 2;
	exports.SPECIAL_STATES = ['emphasis', 'blur', 'select'];
	exports.DISPLAY_STATES = ['normal', 'emphasis', 'blur', 'select'];
	exports.Z2_EMPHASIS_LIFT = 10;
	exports.Z2_SELECT_LIFT = 9;
	exports.HIGHLIGHT_ACTION_TYPE = 'highlight';
	exports.DOWNPLAY_ACTION_TYPE = 'downplay';
	exports.SELECT_ACTION_TYPE = 'select';
	exports.UNSELECT_ACTION_TYPE = 'unselect';
	exports.TOGGLE_SELECT_ACTION_TYPE = 'toggleSelect';
	
	function hasFillOrStroke(fillOrStroke) {
	  return fillOrStroke != null && fillOrStroke !== 'none';
	}
	
	var liftedColorCache = new LRU_1["default"](100);
	
	function liftColor(color) {
	  if (typeof color !== 'string') {
	    return color;
	  }
	
	  var liftedColor = liftedColorCache.get(color);
	
	  if (!liftedColor) {
	    liftedColor = colorTool.lift(color, -0.1);
	    liftedColorCache.put(color, liftedColor);
	  }
	
	  return liftedColor;
	}
	
	function doChangeHoverState(el, stateName, hoverStateEnum) {
	  if (el.onHoverStateChange && (el.hoverState || 0) !== hoverStateEnum) {
	    el.onHoverStateChange(stateName);
	  }
	
	  el.hoverState = hoverStateEnum;
	}
	
	function singleEnterEmphasis(el) {
	  doChangeHoverState(el, 'emphasis', exports.HOVER_STATE_EMPHASIS);
	}
	
	function singleLeaveEmphasis(el) {
	  if (el.hoverState === exports.HOVER_STATE_EMPHASIS) {
	    doChangeHoverState(el, 'normal', exports.HOVER_STATE_NORMAL);
	  }
	}
	
	function singleEnterBlur(el) {
	  doChangeHoverState(el, 'blur', exports.HOVER_STATE_BLUR);
	}
	
	function singleLeaveBlur(el) {
	  if (el.hoverState === exports.HOVER_STATE_BLUR) {
	    doChangeHoverState(el, 'normal', exports.HOVER_STATE_NORMAL);
	  }
	}
	
	function singleEnterSelect(el) {
	  el.selected = true;
	}
	
	function singleLeaveSelect(el) {
	  el.selected = false;
	}
	
	function updateElementState(el, updater, commonParam) {
	  updater(el, commonParam);
	}
	
	function traverseUpdateState(el, updater, commonParam) {
	  updateElementState(el, updater, commonParam);
	  el.isGroup && el.traverse(function (child) {
	    updateElementState(child, updater, commonParam);
	  });
	}
	
	function setStatesFlag(el, stateName) {
	  switch (stateName) {
	    case 'emphasis':
	      el.hoverState = exports.HOVER_STATE_EMPHASIS;
	      break;
	
	    case 'normal':
	      el.hoverState = exports.HOVER_STATE_NORMAL;
	      break;
	
	    case 'blur':
	      el.hoverState = exports.HOVER_STATE_BLUR;
	      break;
	
	    case 'select':
	      el.selected = true;
	  }
	}
	
	exports.setStatesFlag = setStatesFlag;
	
	function clearStates(el) {
	  if (el.isGroup) {
	    el.traverse(function (child) {
	      child.clearStates();
	    });
	  } else {
	    el.clearStates();
	  }
	}
	
	exports.clearStates = clearStates;
	
	function getFromStateStyle(el, props, toStateName, defaultValue) {
	  var style = el.style;
	  var fromState = {};
	
	  for (var i = 0; i < props.length; i++) {
	    var propName = props[i];
	    var val = style[propName];
	    fromState[propName] = val == null ? defaultValue && defaultValue[propName] : val;
	  }
	
	  for (var i = 0; i < el.animators.length; i++) {
	    var animator = el.animators[i];
	
	    if (animator.__fromStateTransition && animator.__fromStateTransition.indexOf(toStateName) < 0 && animator.targetName === 'style') {
	      animator.saveFinalToTarget(fromState, props);
	    }
	  }
	
	  return fromState;
	}
	
	function createEmphasisDefaultState(el, stateName, targetStates, state) {
	  var hasSelect = targetStates && util_1.indexOf(targetStates, 'select') >= 0;
	  var cloned = false;
	
	  if (el instanceof Path_1["default"]) {
	    var store = getSavedStates(el);
	    var fromFill = hasSelect ? store.selectFill || store.normalFill : store.normalFill;
	    var fromStroke = hasSelect ? store.selectStroke || store.normalStroke : store.normalStroke;
	
	    if (hasFillOrStroke(fromFill) || hasFillOrStroke(fromStroke)) {
	      state = state || {};
	      var emphasisStyle = state.style || {};
	
	      if (!hasFillOrStroke(emphasisStyle.fill) && hasFillOrStroke(fromFill)) {
	        cloned = true;
	        state = util_1.extend({}, state);
	        emphasisStyle = util_1.extend({}, emphasisStyle);
	        emphasisStyle.fill = liftColor(fromFill);
	      } else if (!hasFillOrStroke(emphasisStyle.stroke) && hasFillOrStroke(fromStroke)) {
	        if (!cloned) {
	          state = util_1.extend({}, state);
	          emphasisStyle = util_1.extend({}, emphasisStyle);
	        }
	
	        emphasisStyle.stroke = liftColor(fromStroke);
	      }
	
	      state.style = emphasisStyle;
	    }
	  }
	
	  if (state) {
	    if (state.z2 == null) {
	      if (!cloned) {
	        state = util_1.extend({}, state);
	      }
	
	      var z2EmphasisLift = el.z2EmphasisLift;
	      state.z2 = el.z2 + (z2EmphasisLift != null ? z2EmphasisLift : exports.Z2_EMPHASIS_LIFT);
	    }
	  }
	
	  return state;
	}
	
	function createSelectDefaultState(el, stateName, state) {
	  if (state) {
	    if (state.z2 == null) {
	      state = util_1.extend({}, state);
	      var z2SelectLift = el.z2SelectLift;
	      state.z2 = el.z2 + (z2SelectLift != null ? z2SelectLift : exports.Z2_SELECT_LIFT);
	    }
	  }
	
	  return state;
	}
	
	function createBlurDefaultState(el, stateName, state) {
	  var hasBlur = util_1.indexOf(el.currentStates, stateName) >= 0;
	  var currentOpacity = el.style.opacity;
	  var fromState = !hasBlur ? getFromStateStyle(el, ['opacity'], stateName, {
	    opacity: 1
	  }) : null;
	  state = state || {};
	  var blurStyle = state.style || {};
	
	  if (blurStyle.opacity == null) {
	    state = util_1.extend({}, state);
	    blurStyle = util_1.extend({
	      opacity: hasBlur ? currentOpacity : fromState.opacity * 0.1
	    }, blurStyle);
	    state.style = blurStyle;
	  }
	
	  return state;
	}
	
	function elementStateProxy(stateName, targetStates) {
	  var state = this.states[stateName];
	
	  if (this.style) {
	    if (stateName === 'emphasis') {
	      return createEmphasisDefaultState(this, stateName, targetStates, state);
	    } else if (stateName === 'blur') {
	      return createBlurDefaultState(this, stateName, state);
	    } else if (stateName === 'select') {
	      return createSelectDefaultState(this, stateName, state);
	    }
	  }
	
	  return state;
	}
	
	function setDefaultStateProxy(el) {
	  el.stateProxy = elementStateProxy;
	  var textContent = el.getTextContent();
	  var textGuide = el.getTextGuideLine();
	
	  if (textContent) {
	    textContent.stateProxy = elementStateProxy;
	  }
	
	  if (textGuide) {
	    textGuide.stateProxy = elementStateProxy;
	  }
	}
	
	exports.setDefaultStateProxy = setDefaultStateProxy;
	
	function enterEmphasisWhenMouseOver(el, e) {
	  !shouldSilent(el, e) && !el.__highByOuter && traverseUpdateState(el, singleEnterEmphasis);
	}
	
	exports.enterEmphasisWhenMouseOver = enterEmphasisWhenMouseOver;
	
	function leaveEmphasisWhenMouseOut(el, e) {
	  !shouldSilent(el, e) && !el.__highByOuter && traverseUpdateState(el, singleLeaveEmphasis);
	}
	
	exports.leaveEmphasisWhenMouseOut = leaveEmphasisWhenMouseOut;
	
	function enterEmphasis(el, highlightDigit) {
	  el.__highByOuter |= 1 << (highlightDigit || 0);
	  traverseUpdateState(el, singleEnterEmphasis);
	}
	
	exports.enterEmphasis = enterEmphasis;
	
	function leaveEmphasis(el, highlightDigit) {
	  !(el.__highByOuter &= ~(1 << (highlightDigit || 0))) && traverseUpdateState(el, singleLeaveEmphasis);
	}
	
	exports.leaveEmphasis = leaveEmphasis;
	
	function enterBlur(el) {
	  traverseUpdateState(el, singleEnterBlur);
	}
	
	exports.enterBlur = enterBlur;
	
	function leaveBlur(el) {
	  traverseUpdateState(el, singleLeaveBlur);
	}
	
	exports.leaveBlur = leaveBlur;
	
	function enterSelect(el) {
	  traverseUpdateState(el, singleEnterSelect);
	}
	
	exports.enterSelect = enterSelect;
	
	function leaveSelect(el) {
	  traverseUpdateState(el, singleLeaveSelect);
	}
	
	exports.leaveSelect = leaveSelect;
	
	function shouldSilent(el, e) {
	  return el.__highDownSilentOnTouch && e.zrByTouch;
	}
	
	function allLeaveBlur(api) {
	  var model = api.getModel();
	  model.eachComponent(function (componentType, componentModel) {
	    var view = componentType === 'series' ? api.getViewOfSeriesModel(componentModel) : api.getViewOfComponentModel(componentModel);
	    view.group.traverse(function (child) {
	      singleLeaveBlur(child);
	    });
	  });
	}
	
	function toggleSeriesBlurState(targetSeriesIndex, focus, blurScope, api, isBlur) {
	  var ecModel = api.getModel();
	  blurScope = blurScope || 'coordinateSystem';
	
	  function leaveBlurOfIndices(data, dataIndices) {
	    for (var i = 0; i < dataIndices.length; i++) {
	      var itemEl = data.getItemGraphicEl(dataIndices[i]);
	      itemEl && leaveBlur(itemEl);
	    }
	  }
	
	  if (!isBlur) {
	    allLeaveBlur(api);
	    return;
	  }
	
	  if (targetSeriesIndex == null) {
	    return;
	  }
	
	  if (!focus || focus === 'none') {
	    return;
	  }
	
	  var targetSeriesModel = ecModel.getSeriesByIndex(targetSeriesIndex);
	  var targetCoordSys = targetSeriesModel.coordinateSystem;
	
	  if (targetCoordSys && targetCoordSys.master) {
	    targetCoordSys = targetCoordSys.master;
	  }
	
	  var blurredSeries = [];
	  ecModel.eachSeries(function (seriesModel) {
	    var sameSeries = targetSeriesModel === seriesModel;
	    var coordSys = seriesModel.coordinateSystem;
	
	    if (coordSys && coordSys.master) {
	      coordSys = coordSys.master;
	    }
	
	    var sameCoordSys = coordSys && targetCoordSys ? coordSys === targetCoordSys : sameSeries;
	
	    if (!(blurScope === 'series' && !sameSeries || blurScope === 'coordinateSystem' && !sameCoordSys || focus === 'series' && sameSeries)) {
	      var view = api.getViewOfSeriesModel(seriesModel);
	      view.group.traverse(function (child) {
	        singleEnterBlur(child);
	      });
	
	      if (util_1.isArrayLike(focus)) {
	        leaveBlurOfIndices(seriesModel.getData(), focus);
	      } else if (util_1.isObject(focus)) {
	        var dataTypes = util_1.keys(focus);
	
	        for (var d = 0; d < dataTypes.length; d++) {
	          leaveBlurOfIndices(seriesModel.getData(dataTypes[d]), focus[dataTypes[d]]);
	        }
	      }
	
	      blurredSeries.push(seriesModel);
	    }
	  });
	  ecModel.eachComponent(function (componentType, componentModel) {
	    if (componentType === 'series') {
	      return;
	    }
	
	    var view = api.getViewOfComponentModel(componentModel);
	
	    if (view && view.blurSeries) {
	      view.blurSeries(blurredSeries, ecModel);
	    }
	  });
	}
	
	exports.toggleSeriesBlurState = toggleSeriesBlurState;
	
	function toggleSeriesBlurStateFromPayload(seriesModel, payload, api) {
	  if (!isHighDownPayload(payload)) {
	    return;
	  }
	
	  var isHighlight = payload.type === exports.HIGHLIGHT_ACTION_TYPE;
	  var seriesIndex = seriesModel.seriesIndex;
	  var data = seriesModel.getData(payload.dataType);
	  var dataIndex = model_1.queryDataIndex(data, payload);
	  dataIndex = (util_1.isArray(dataIndex) ? dataIndex[0] : dataIndex) || 0;
	  var el = data.getItemGraphicEl(dataIndex);
	
	  if (!el) {
	    var count = data.count();
	    var current = 0;
	
	    while (!el && current < count) {
	      el = data.getItemGraphicEl(current++);
	    }
	  }
	
	  if (el) {
	    var ecData = innerStore_1.getECData(el);
	    toggleSeriesBlurState(seriesIndex, ecData.focus, ecData.blurScope, api, isHighlight);
	  } else {
	    var focus_1 = seriesModel.get(['emphasis', 'focus']);
	    var blurScope = seriesModel.get(['emphasis', 'blurScope']);
	
	    if (focus_1 != null) {
	      toggleSeriesBlurState(seriesIndex, focus_1, blurScope, api, isHighlight);
	    }
	  }
	}
	
	exports.toggleSeriesBlurStateFromPayload = toggleSeriesBlurStateFromPayload;
	
	function toggleSelectionFromPayload(seriesModel, payload, api) {
	  if (!isSelectChangePayload(payload)) {
	    return;
	  }
	
	  var dataType = payload.dataType;
	  var data = seriesModel.getData(dataType);
	  var dataIndex = model_1.queryDataIndex(data, payload);
	
	  if (!util_1.isArray(dataIndex)) {
	    dataIndex = [dataIndex];
	  }
	
	  seriesModel[payload.type === exports.TOGGLE_SELECT_ACTION_TYPE ? 'toggleSelect' : payload.type === exports.SELECT_ACTION_TYPE ? 'select' : 'unselect'](dataIndex, dataType);
	}
	
	exports.toggleSelectionFromPayload = toggleSelectionFromPayload;
	
	function updateSeriesElementSelection(seriesModel) {
	  var allData = seriesModel.getAllData();
	  util_1.each(allData, function (_a) {
	    var data = _a.data,
	        type = _a.type;
	    data.eachItemGraphicEl(function (el, idx) {
	      seriesModel.isSelected(idx, type) ? enterSelect(el) : leaveSelect(el);
	    });
	  });
	}
	
	exports.updateSeriesElementSelection = updateSeriesElementSelection;
	
	function getAllSelectedIndices(ecModel) {
	  var ret = [];
	  ecModel.eachSeries(function (seriesModel) {
	    var allData = seriesModel.getAllData();
	    util_1.each(allData, function (_a) {
	      var data = _a.data,
	          type = _a.type;
	      var dataIndices = seriesModel.getSelectedDataIndices();
	
	      if (dataIndices.length > 0) {
	        var item = {
	          dataIndex: dataIndices,
	          seriesIndex: seriesModel.seriesIndex
	        };
	
	        if (type != null) {
	          item.dataType = type;
	        }
	
	        ret.push(item);
	      }
	    });
	  });
	  return ret;
	}
	
	exports.getAllSelectedIndices = getAllSelectedIndices;
	
	function enableHoverEmphasis(el, focus, blurScope) {
	  setAsHighDownDispatcher(el, true);
	  traverseUpdateState(el, setDefaultStateProxy);
	  enableHoverFocus(el, focus, blurScope);
	}
	
	exports.enableHoverEmphasis = enableHoverEmphasis;
	
	function enableHoverFocus(el, focus, blurScope) {
	  var ecData = innerStore_1.getECData(el);
	
	  if (focus != null) {
	    ecData.focus = focus;
	    ecData.blurScope = blurScope;
	  } else if (ecData.focus) {
	    ecData.focus = null;
	  }
	}
	
	exports.enableHoverFocus = enableHoverFocus;
	var OTHER_STATES = ['emphasis', 'blur', 'select'];
	var defaultStyleGetterMap = {
	  itemStyle: 'getItemStyle',
	  lineStyle: 'getLineStyle',
	  areaStyle: 'getAreaStyle'
	};
	
	function setStatesStylesFromModel(el, itemModel, styleType, getter) {
	  styleType = styleType || 'itemStyle';
	
	  for (var i = 0; i < OTHER_STATES.length; i++) {
	    var stateName = OTHER_STATES[i];
	    var model = itemModel.getModel([stateName, styleType]);
	    var state = el.ensureState(stateName);
	    state.style = getter ? getter(model) : model[defaultStyleGetterMap[styleType]]();
	  }
	}
	
	exports.setStatesStylesFromModel = setStatesStylesFromModel;
	
	function setAsHighDownDispatcher(el, asDispatcher) {
	  var disable = asDispatcher === false;
	  var extendedEl = el;
	
	  if (el.highDownSilentOnTouch) {
	    extendedEl.__highDownSilentOnTouch = el.highDownSilentOnTouch;
	  }
	
	  if (!disable || extendedEl.__highDownDispatcher) {
	    extendedEl.__highByOuter = extendedEl.__highByOuter || 0;
	    extendedEl.__highDownDispatcher = !disable;
	  }
	}
	
	exports.setAsHighDownDispatcher = setAsHighDownDispatcher;
	
	function isHighDownDispatcher(el) {
	  return !!(el && el.__highDownDispatcher);
	}
	
	exports.isHighDownDispatcher = isHighDownDispatcher;
	
	function getHighlightDigit(highlightKey) {
	  var highlightDigit = _highlightKeyMap[highlightKey];
	
	  if (highlightDigit == null && _highlightNextDigit <= 32) {
	    highlightDigit = _highlightKeyMap[highlightKey] = _highlightNextDigit++;
	  }
	
	  return highlightDigit;
	}
	
	exports.getHighlightDigit = getHighlightDigit;
	
	function isSelectChangePayload(payload) {
	  var payloadType = payload.type;
	  return payloadType === exports.SELECT_ACTION_TYPE || payloadType === exports.UNSELECT_ACTION_TYPE || payloadType === exports.TOGGLE_SELECT_ACTION_TYPE;
	}
	
	exports.isSelectChangePayload = isSelectChangePayload;
	
	function isHighDownPayload(payload) {
	  var payloadType = payload.type;
	  return payloadType === exports.HIGHLIGHT_ACTION_TYPE || payloadType === exports.DOWNPLAY_ACTION_TYPE;
	}
	
	exports.isHighDownPayload = isHighDownPayload;
	
	function savePathStates(el) {
	  var store = getSavedStates(el);
	  store.normalFill = el.style.fill;
	  store.normalStroke = el.style.stroke;
	  var selectState = el.states.select || {};
	  store.selectFill = selectState.style && selectState.style.fill || null;
	  store.selectStroke = selectState.style && selectState.style.stroke || null;
	}
	
	exports.savePathStates = savePathStates;

/***/ },
/* 23 */
/***/ function(module, exports, __webpack_require__) {

	
	/*
	* Licensed to the Apache Software Foundation (ASF) under one
	* or more contributor license agreements.  See the NOTICE file
	* distributed with this work for additional information
	* regarding copyright ownership.  The ASF licenses this file
	* to you under the Apache License, Version 2.0 (the
	* "License"); you may not use this file except in compliance
	* with the License.  You may obtain a copy of the License at
	*
	*   http://www.apache.org/licenses/LICENSE-2.0
	*
	* Unless required by applicable law or agreed to in writing,
	* software distributed under the License is distributed on an
	* "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
	* KIND, either express or implied.  See the License for the
	* specific language governing permissions and limitations
	* under the License.
	*/
	
	
	
	/**
	 * AUTO-GENERATED FILE. DO NOT MODIFY.
	 */
	
	"use strict";
	
	exports.__esModule = true;
	
	var echarts = __webpack_require__(6);
	
	__webpack_require__(320);
	
	__webpack_require__(322);
	
	__webpack_require__(321);
	
	var legendFilter_1 = __webpack_require__(323);
	
	var Component_1 = __webpack_require__(10);
	
	echarts.registerProcessor(echarts.PRIORITY.PROCESSOR.SERIES_FILTER, legendFilter_1["default"]);
	Component_1["default"].registerSubTypeDefaulter('legend', function () {
	  return 'plain';
	});

/***/ },
/* 24 */
/***/ function(module, exports, __webpack_require__) {

	
	/*
	* Licensed to the Apache Software Foundation (ASF) under one
	* or more contributor license agreements.  See the NOTICE file
	* distributed with this work for additional information
	* regarding copyright ownership.  The ASF licenses this file
	* to you under the Apache License, Version 2.0 (the
	* "License"); you may not use this file except in compliance
	* with the License.  You may obtain a copy of the License at
	*
	*   http://www.apache.org/licenses/LICENSE-2.0
	*
	* Unless required by applicable law or agreed to in writing,
	* software distributed under the License is distributed on an
	* "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
	* KIND, either express or implied.  See the License for the
	* specific language governing permissions and limitations
	* under the License.
	*/
	
	
	
	/**
	 * AUTO-GENERATED FILE. DO NOT MODIFY.
	 */
	
	"use strict";
	
	exports.__esModule = true;
	
	var env_1 = __webpack_require__(13);
	
	var clazz_1 = __webpack_require__(28);
	
	var areaStyle_1 = __webpack_require__(361);
	
	var textStyle_1 = __webpack_require__(362);
	
	var lineStyle_1 = __webpack_require__(152);
	
	var itemStyle_1 = __webpack_require__(151);
	
	var util_1 = __webpack_require__(1);
	
	var Model = function () {
	  function Model(option, parentModel, ecModel) {
	    this.parentModel = parentModel;
	    this.ecModel = ecModel;
	    this.option = option;
	  }
	
	  Model.prototype.init = function (option, parentModel, ecModel) {
	    var rest = [];
	
	    for (var _i = 3; _i < arguments.length; _i++) {
	      rest[_i - 3] = arguments[_i];
	    }
	  };
	
	  Model.prototype.mergeOption = function (option, ecModel) {
	    util_1.merge(this.option, option, true);
	  };
	
	  Model.prototype.get = function (path, ignoreParent) {
	    if (path == null) {
	      return this.option;
	    }
	
	    return this._doGet(this.parsePath(path), !ignoreParent && this.parentModel);
	  };
	
	  Model.prototype.getShallow = function (key, ignoreParent) {
	    var option = this.option;
	    var val = option == null ? option : option[key];
	
	    if (val == null && !ignoreParent) {
	      var parentModel = this.parentModel;
	
	      if (parentModel) {
	        val = parentModel.getShallow(key);
	      }
	    }
	
	    return val;
	  };
	
	  Model.prototype.getModel = function (path, parentModel) {
	    var hasPath = path != null;
	    var pathFinal = hasPath ? this.parsePath(path) : null;
	    var obj = hasPath ? this._doGet(pathFinal) : this.option;
	    parentModel = parentModel || this.parentModel && this.parentModel.getModel(this.resolveParentPath(pathFinal));
	    return new Model(obj, parentModel, this.ecModel);
	  };
	
	  Model.prototype.isEmpty = function () {
	    return this.option == null;
	  };
	
	  Model.prototype.restoreData = function () {};
	
	  Model.prototype.clone = function () {
	    var Ctor = this.constructor;
	    return new Ctor(util_1.clone(this.option));
	  };
	
	  Model.prototype.parsePath = function (path) {
	    if (typeof path === 'string') {
	      return path.split('.');
	    }
	
	    return path;
	  };
	
	  Model.prototype.resolveParentPath = function (path) {
	    return path;
	  };
	
	  Model.prototype.isAnimationEnabled = function () {
	    if (!env_1["default"].node && this.option) {
	      if (this.option.animation != null) {
	        return !!this.option.animation;
	      } else if (this.parentModel) {
	        return this.parentModel.isAnimationEnabled();
	      }
	    }
	  };
	
	  Model.prototype._doGet = function (pathArr, parentModel) {
	    var obj = this.option;
	
	    if (!pathArr) {
	      return obj;
	    }
	
	    for (var i = 0; i < pathArr.length; i++) {
	      if (!pathArr[i]) {
	        continue;
	      }
	
	      obj = obj && typeof obj === 'object' ? obj[pathArr[i]] : null;
	
	      if (obj == null) {
	        break;
	      }
	    }
	
	    if (obj == null && parentModel) {
	      obj = parentModel._doGet(this.resolveParentPath(pathArr), parentModel.parentModel);
	    }
	
	    return obj;
	  };
	
	  return Model;
	}();
	
	;
	clazz_1.enableClassExtend(Model);
	clazz_1.enableClassCheck(Model);
	util_1.mixin(Model, lineStyle_1.LineStyleMixin);
	util_1.mixin(Model, itemStyle_1.ItemStyleMixin);
	util_1.mixin(Model, areaStyle_1.AreaStyleMixin);
	util_1.mixin(Model, textStyle_1["default"]);
	exports["default"] = Model;

/***/ },
/* 25 */
/***/ function(module, exports, __webpack_require__) {

	
	/*
	* Licensed to the Apache Software Foundation (ASF) under one
	* or more contributor license agreements.  See the NOTICE file
	* distributed with this work for additional information
	* regarding copyright ownership.  The ASF licenses this file
	* to you under the Apache License, Version 2.0 (the
	* "License"); you may not use this file except in compliance
	* with the License.  You may obtain a copy of the License at
	*
	*   http://www.apache.org/licenses/LICENSE-2.0
	*
	* Unless required by applicable law or agreed to in writing,
	* software distributed under the License is distributed on an
	* "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
	* KIND, either express or implied.  See the License for the
	* specific language governing permissions and limitations
	* under the License.
	*/
	
	
	
	/**
	 * AUTO-GENERATED FILE. DO NOT MODIFY.
	 */
	
	"use strict";
	
	exports.__esModule = true;
	
	var util_1 = __webpack_require__(1);
	
	;
	;
	;
	exports.VISUAL_DIMENSIONS = util_1.createHashMap(['tooltip', 'label', 'itemName', 'itemId', 'seriesName']);
	exports.SOURCE_FORMAT_ORIGINAL = 'original';
	exports.SOURCE_FORMAT_ARRAY_ROWS = 'arrayRows';
	exports.SOURCE_FORMAT_OBJECT_ROWS = 'objectRows';
	exports.SOURCE_FORMAT_KEYED_COLUMNS = 'keyedColumns';
	exports.SOURCE_FORMAT_TYPED_ARRAY = 'typedArray';
	exports.SOURCE_FORMAT_UNKNOWN = 'unknown';
	exports.SERIES_LAYOUT_BY_COLUMN = 'column';
	exports.SERIES_LAYOUT_BY_ROW = 'row';
	;
	;
	;
	;

/***/ },
/* 26 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	exports.__esModule = true;
	var BoundingRect_1 = __webpack_require__(17);
	var util_1 = __webpack_require__(1);
	var LRU_1 = __webpack_require__(59);
	var textWidthCache = {};
	exports.DEFAULT_FONT = '12px sans-serif';
	var _ctx;
	var _cachedFont;
	function defaultMeasureText(text, font) {
	    if (!_ctx) {
	        _ctx = util_1.createCanvas().getContext('2d');
	    }
	    if (_cachedFont !== font) {
	        _cachedFont = _ctx.font = font || exports.DEFAULT_FONT;
	    }
	    return _ctx.measureText(text);
	}
	var methods = {
	    measureText: defaultMeasureText
	};
	function $override(name, fn) {
	    methods[name] = fn;
	}
	exports.$override = $override;
	function getWidth(text, font) {
	    font = font || exports.DEFAULT_FONT;
	    var cacheOfFont = textWidthCache[font];
	    if (!cacheOfFont) {
	        cacheOfFont = textWidthCache[font] = new LRU_1["default"](500);
	    }
	    var width = cacheOfFont.get(text);
	    if (width == null) {
	        width = methods.measureText(text, font).width;
	        cacheOfFont.put(text, width);
	    }
	    return width;
	}
	exports.getWidth = getWidth;
	function innerGetBoundingRect(text, font, textAlign, textBaseline) {
	    var width = getWidth(text, font);
	    var height = getLineHeight(font);
	    var x = adjustTextX(0, width, textAlign);
	    var y = adjustTextY(0, height, textBaseline);
	    var rect = new BoundingRect_1["default"](x, y, width, height);
	    return rect;
	}
	exports.innerGetBoundingRect = innerGetBoundingRect;
	function getBoundingRect(text, font, textAlign, textBaseline) {
	    var textLines = ((text || '') + '').split('\n');
	    var len = textLines.length;
	    if (len === 1) {
	        return innerGetBoundingRect(textLines[0], font, textAlign, textBaseline);
	    }
	    else {
	        var uniondRect = new BoundingRect_1["default"](0, 0, 0, 0);
	        for (var i = 0; i < textLines.length; i++) {
	            var rect = innerGetBoundingRect(textLines[i], font, textAlign, textBaseline);
	            i === 0 ? uniondRect.copy(rect) : uniondRect.union(rect);
	        }
	        return uniondRect;
	    }
	}
	exports.getBoundingRect = getBoundingRect;
	function adjustTextX(x, width, textAlign) {
	    if (textAlign === 'right') {
	        x -= width;
	    }
	    else if (textAlign === 'center') {
	        x -= width / 2;
	    }
	    return x;
	}
	exports.adjustTextX = adjustTextX;
	function adjustTextY(y, height, verticalAlign) {
	    if (verticalAlign === 'middle') {
	        y -= height / 2;
	    }
	    else if (verticalAlign === 'bottom') {
	        y -= height;
	    }
	    return y;
	}
	exports.adjustTextY = adjustTextY;
	function getLineHeight(font) {
	    return getWidth('国', font);
	}
	exports.getLineHeight = getLineHeight;
	function measureText(text, font) {
	    return methods.measureText(text, font);
	}
	exports.measureText = measureText;
	function parsePercent(value, maxValue) {
	    if (typeof value === 'string') {
	        if (value.lastIndexOf('%') >= 0) {
	            return parseFloat(value) / 100 * maxValue;
	        }
	        return parseFloat(value);
	    }
	    return value;
	}
	exports.parsePercent = parsePercent;
	function calculateTextPosition(out, opts, rect) {
	    var textPosition = opts.position || 'inside';
	    var distance = opts.distance != null ? opts.distance : 5;
	    var height = rect.height;
	    var width = rect.width;
	    var halfHeight = height / 2;
	    var x = rect.x;
	    var y = rect.y;
	    var textAlign = 'left';
	    var textVerticalAlign = 'top';
	    if (textPosition instanceof Array) {
	        x += parsePercent(textPosition[0], rect.width);
	        y += parsePercent(textPosition[1], rect.height);
	        textAlign = null;
	        textVerticalAlign = null;
	    }
	    else {
	        switch (textPosition) {
	            case 'left':
	                x -= distance;
	                y += halfHeight;
	                textAlign = 'right';
	                textVerticalAlign = 'middle';
	                break;
	            case 'right':
	                x += distance + width;
	                y += halfHeight;
	                textVerticalAlign = 'middle';
	                break;
	            case 'top':
	                x += width / 2;
	                y -= distance;
	                textAlign = 'center';
	                textVerticalAlign = 'bottom';
	                break;
	            case 'bottom':
	                x += width / 2;
	                y += height + distance;
	                textAlign = 'center';
	                break;
	            case 'inside':
	                x += width / 2;
	                y += halfHeight;
	                textAlign = 'center';
	                textVerticalAlign = 'middle';
	                break;
	            case 'insideLeft':
	                x += distance;
	                y += halfHeight;
	                textVerticalAlign = 'middle';
	                break;
	            case 'insideRight':
	                x += width - distance;
	                y += halfHeight;
	                textAlign = 'right';
	                textVerticalAlign = 'middle';
	                break;
	            case 'insideTop':
	                x += width / 2;
	                y += distance;
	                textAlign = 'center';
	                break;
	            case 'insideBottom':
	                x += width / 2;
	                y += height - distance;
	                textAlign = 'center';
	                textVerticalAlign = 'bottom';
	                break;
	            case 'insideTopLeft':
	                x += distance;
	                y += distance;
	                break;
	            case 'insideTopRight':
	                x += width - distance;
	                y += distance;
	                textAlign = 'right';
	                break;
	            case 'insideBottomLeft':
	                x += distance;
	                y += height - distance;
	                textVerticalAlign = 'bottom';
	                break;
	            case 'insideBottomRight':
	                x += width - distance;
	                y += height - distance;
	                textAlign = 'right';
	                textVerticalAlign = 'bottom';
	                break;
	        }
	    }
	    out = out || {};
	    out.x = x;
	    out.y = y;
	    out.align = textAlign;
	    out.verticalAlign = textVerticalAlign;
	    return out;
	}
	exports.calculateTextPosition = calculateTextPosition;


/***/ },
/* 27 */
/***/ function(module, exports) {

	"use strict";
	exports.__esModule = true;
	function create() {
	    return [1, 0, 0, 1, 0, 0];
	}
	exports.create = create;
	function identity(out) {
	    out[0] = 1;
	    out[1] = 0;
	    out[2] = 0;
	    out[3] = 1;
	    out[4] = 0;
	    out[5] = 0;
	    return out;
	}
	exports.identity = identity;
	function copy(out, m) {
	    out[0] = m[0];
	    out[1] = m[1];
	    out[2] = m[2];
	    out[3] = m[3];
	    out[4] = m[4];
	    out[5] = m[5];
	    return out;
	}
	exports.copy = copy;
	function mul(out, m1, m2) {
	    var out0 = m1[0] * m2[0] + m1[2] * m2[1];
	    var out1 = m1[1] * m2[0] + m1[3] * m2[1];
	    var out2 = m1[0] * m2[2] + m1[2] * m2[3];
	    var out3 = m1[1] * m2[2] + m1[3] * m2[3];
	    var out4 = m1[0] * m2[4] + m1[2] * m2[5] + m1[4];
	    var out5 = m1[1] * m2[4] + m1[3] * m2[5] + m1[5];
	    out[0] = out0;
	    out[1] = out1;
	    out[2] = out2;
	    out[3] = out3;
	    out[4] = out4;
	    out[5] = out5;
	    return out;
	}
	exports.mul = mul;
	function translate(out, a, v) {
	    out[0] = a[0];
	    out[1] = a[1];
	    out[2] = a[2];
	    out[3] = a[3];
	    out[4] = a[4] + v[0];
	    out[5] = a[5] + v[1];
	    return out;
	}
	exports.translate = translate;
	function rotate(out, a, rad) {
	    var aa = a[0];
	    var ac = a[2];
	    var atx = a[4];
	    var ab = a[1];
	    var ad = a[3];
	    var aty = a[5];
	    var st = Math.sin(rad);
	    var ct = Math.cos(rad);
	    out[0] = aa * ct + ab * st;
	    out[1] = -aa * st + ab * ct;
	    out[2] = ac * ct + ad * st;
	    out[3] = -ac * st + ct * ad;
	    out[4] = ct * atx + st * aty;
	    out[5] = ct * aty - st * atx;
	    return out;
	}
	exports.rotate = rotate;
	function scale(out, a, v) {
	    var vx = v[0];
	    var vy = v[1];
	    out[0] = a[0] * vx;
	    out[1] = a[1] * vy;
	    out[2] = a[2] * vx;
	    out[3] = a[3] * vy;
	    out[4] = a[4] * vx;
	    out[5] = a[5] * vy;
	    return out;
	}
	exports.scale = scale;
	function invert(out, a) {
	    var aa = a[0];
	    var ac = a[2];
	    var atx = a[4];
	    var ab = a[1];
	    var ad = a[3];
	    var aty = a[5];
	    var det = aa * ad - ab * ac;
	    if (!det) {
	        return null;
	    }
	    det = 1.0 / det;
	    out[0] = ad * det;
	    out[1] = -ab * det;
	    out[2] = -ac * det;
	    out[3] = aa * det;
	    out[4] = (ac * aty - ad * atx) * det;
	    out[5] = (ab * atx - aa * aty) * det;
	    return out;
	}
	exports.invert = invert;
	function clone(a) {
	    var b = create();
	    copy(b, a);
	    return b;
	}
	exports.clone = clone;


/***/ },
/* 28 */
/***/ function(module, exports, __webpack_require__) {

	
	/*
	* Licensed to the Apache Software Foundation (ASF) under one
	* or more contributor license agreements.  See the NOTICE file
	* distributed with this work for additional information
	* regarding copyright ownership.  The ASF licenses this file
	* to you under the Apache License, Version 2.0 (the
	* "License"); you may not use this file except in compliance
	* with the License.  You may obtain a copy of the License at
	*
	*   http://www.apache.org/licenses/LICENSE-2.0
	*
	* Unless required by applicable law or agreed to in writing,
	* software distributed under the License is distributed on an
	* "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
	* KIND, either express or implied.  See the License for the
	* specific language governing permissions and limitations
	* under the License.
	*/
	
	
	
	/**
	 * AUTO-GENERATED FILE. DO NOT MODIFY.
	 */
	
	"use strict";
	
	exports.__esModule = true;
	
	var tslib_1 = __webpack_require__(3);
	
	var zrUtil = __webpack_require__(1);
	
	var TYPE_DELIMITER = '.';
	var IS_CONTAINER = '___EC__COMPONENT__CONTAINER___';
	var IS_EXTENDED_CLASS = '___EC__EXTENDED_CLASS___';
	
	function parseClassType(componentType) {
	  var ret = {
	    main: '',
	    sub: ''
	  };
	
	  if (componentType) {
	    var typeArr = componentType.split(TYPE_DELIMITER);
	    ret.main = typeArr[0] || '';
	    ret.sub = typeArr[1] || '';
	  }
	
	  return ret;
	}
	
	exports.parseClassType = parseClassType;
	
	function checkClassType(componentType) {
	  zrUtil.assert(/^[a-zA-Z0-9_]+([.][a-zA-Z0-9_]+)?$/.test(componentType), 'componentType "' + componentType + '" illegal');
	}
	
	function isExtendedClass(clz) {
	  return !!(clz && clz[IS_EXTENDED_CLASS]);
	}
	
	exports.isExtendedClass = isExtendedClass;
	
	function enableClassExtend(rootClz, mandatoryMethods) {
	  rootClz.$constructor = rootClz;
	
	  rootClz.extend = function (proto) {
	    if (false) {
	      zrUtil.each(mandatoryMethods, function (method) {
	        if (!proto[method]) {
	          console.warn('Method `' + method + '` should be implemented' + (proto.type ? ' in ' + proto.type : '') + '.');
	        }
	      });
	    }
	
	    var superClass = this;
	
	    function ExtendedClass() {
	      var args = [];
	
	      for (var _i = 0; _i < arguments.length; _i++) {
	        args[_i] = arguments[_i];
	      }
	
	      if (!proto.$constructor) {
	        if (!isESClass(superClass)) {
	          superClass.apply(this, arguments);
	        } else {
	          var ins = zrUtil.createObject(ExtendedClass.prototype, new (superClass.bind.apply(superClass, tslib_1.__spreadArrays([void 0], args)))());
	          return ins;
	        }
	      } else {
	        proto.$constructor.apply(this, arguments);
	      }
	    }
	
	    ExtendedClass[IS_EXTENDED_CLASS] = true;
	    zrUtil.extend(ExtendedClass.prototype, proto);
	    ExtendedClass.extend = this.extend;
	    ExtendedClass.superCall = superCall;
	    ExtendedClass.superApply = superApply;
	    zrUtil.inherits(ExtendedClass, this);
	    ExtendedClass.superClass = superClass;
	    return ExtendedClass;
	  };
	}
	
	exports.enableClassExtend = enableClassExtend;
	
	function isESClass(fn) {
	  return typeof fn === 'function' && /^class\s/.test(Function.prototype.toString.call(fn));
	}
	
	function mountExtend(SubClz, SupperClz) {
	  SubClz.extend = SupperClz.extend;
	}
	
	exports.mountExtend = mountExtend;
	var classBase = Math.round(Math.random() * 10);
	
	function enableClassCheck(target) {
	  var classAttr = ['__\0is_clz', classBase++].join('_');
	  target.prototype[classAttr] = true;
	
	  if (false) {
	    zrUtil.assert(!target.isInstance, 'The method "is" can not be defined.');
	  }
	
	  target.isInstance = function (obj) {
	    return !!(obj && obj[classAttr]);
	  };
	}
	
	exports.enableClassCheck = enableClassCheck;
	
	function superCall(context, methodName) {
	  var args = [];
	
	  for (var _i = 2; _i < arguments.length; _i++) {
	    args[_i - 2] = arguments[_i];
	  }
	
	  return this.superClass.prototype[methodName].apply(context, args);
	}
	
	function superApply(context, methodName, args) {
	  return this.superClass.prototype[methodName].apply(context, args);
	}
	
	function enableClassManagement(target, options) {
	  options = options || {};
	  var storage = {};
	
	  target.registerClass = function (clz) {
	    var componentFullType = clz.type || clz.prototype.type;
	
	    if (componentFullType) {
	      checkClassType(componentFullType);
	      clz.prototype.type = componentFullType;
	      var componentTypeInfo = parseClassType(componentFullType);
	
	      if (!componentTypeInfo.sub) {
	        if (false) {
	          if (storage[componentTypeInfo.main]) {
	            console.warn(componentTypeInfo.main + ' exists.');
	          }
	        }
	
	        storage[componentTypeInfo.main] = clz;
	      } else if (componentTypeInfo.sub !== IS_CONTAINER) {
	        var container = makeContainer(componentTypeInfo);
	        container[componentTypeInfo.sub] = clz;
	      }
	    }
	
	    return clz;
	  };
	
	  target.getClass = function (mainType, subType, throwWhenNotFound) {
	    var clz = storage[mainType];
	
	    if (clz && clz[IS_CONTAINER]) {
	      clz = subType ? clz[subType] : null;
	    }
	
	    if (throwWhenNotFound && !clz) {
	      throw new Error(!subType ? mainType + '.' + 'type should be specified.' : 'Component ' + mainType + '.' + (subType || '') + ' not exists. Load it first.');
	    }
	
	    return clz;
	  };
	
	  target.getClassesByMainType = function (componentType) {
	    var componentTypeInfo = parseClassType(componentType);
	    var result = [];
	    var obj = storage[componentTypeInfo.main];
	
	    if (obj && obj[IS_CONTAINER]) {
	      zrUtil.each(obj, function (o, type) {
	        type !== IS_CONTAINER && result.push(o);
	      });
	    } else {
	      result.push(obj);
	    }
	
	    return result;
	  };
	
	  target.hasClass = function (componentType) {
	    var componentTypeInfo = parseClassType(componentType);
	    return !!storage[componentTypeInfo.main];
	  };
	
	  target.getAllClassMainTypes = function () {
	    var types = [];
	    zrUtil.each(storage, function (obj, type) {
	      types.push(type);
	    });
	    return types;
	  };
	
	  target.hasSubTypes = function (componentType) {
	    var componentTypeInfo = parseClassType(componentType);
	    var obj = storage[componentTypeInfo.main];
	    return obj && obj[IS_CONTAINER];
	  };
	
	  function makeContainer(componentTypeInfo) {
	    var container = storage[componentTypeInfo.main];
	
	    if (!container || !container[IS_CONTAINER]) {
	      container = storage[componentTypeInfo.main] = {};
	      container[IS_CONTAINER] = true;
	    }
	
	    return container;
	  }
	
	  if (options.registerWhenExtend) {
	    var originalExtend_1 = target.extend;
	
	    if (originalExtend_1) {
	      target.extend = function (proto) {
	        var ExtendedClass = originalExtend_1.call(this, proto);
	        return target.registerClass(ExtendedClass);
	      };
	    }
	  }
	}
	
	exports.enableClassManagement = enableClassManagement;

/***/ },
/* 29 */
/***/ function(module, exports, __webpack_require__) {

	
	/*
	* Licensed to the Apache Software Foundation (ASF) under one
	* or more contributor license agreements.  See the NOTICE file
	* distributed with this work for additional information
	* regarding copyright ownership.  The ASF licenses this file
	* to you under the Apache License, Version 2.0 (the
	* "License"); you may not use this file except in compliance
	* with the License.  You may obtain a copy of the License at
	*
	*   http://www.apache.org/licenses/LICENSE-2.0
	*
	* Unless required by applicable law or agreed to in writing,
	* software distributed under the License is distributed on an
	* "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
	* KIND, either express or implied.  See the License for the
	* specific language governing permissions and limitations
	* under the License.
	*/
	
	
	
	/**
	 * AUTO-GENERATED FILE. DO NOT MODIFY.
	 */
	
	"use strict";
	
	exports.__esModule = true;
	
	var zrUtil = __webpack_require__(1);
	
	var number_1 = __webpack_require__(9);
	
	var time_1 = __webpack_require__(94);
	
	var log_1 = __webpack_require__(12);
	
	function addCommas(x) {
	  if (!number_1.isNumeric(x)) {
	    return zrUtil.isString(x) ? x : '-';
	  }
	
	  var parts = (x + '').split('.');
	  return parts[0].replace(/(\d{1,3})(?=(?:\d{3})+(?!\d))/g, '$1,') + (parts.length > 1 ? '.' + parts[1] : '');
	}
	
	exports.addCommas = addCommas;
	
	function toCamelCase(str, upperCaseFirst) {
	  str = (str || '').toLowerCase().replace(/-(.)/g, function (match, group1) {
	    return group1.toUpperCase();
	  });
	
	  if (upperCaseFirst && str) {
	    str = str.charAt(0).toUpperCase() + str.slice(1);
	  }
	
	  return str;
	}
	
	exports.toCamelCase = toCamelCase;
	exports.normalizeCssArray = zrUtil.normalizeCssArray;
	var replaceReg = /([&<>"'])/g;
	var replaceMap = {
	  '&': '&amp;',
	  '<': '&lt;',
	  '>': '&gt;',
	  '"': '&quot;',
	  '\'': '&#39;'
	};
	
	function encodeHTML(source) {
	  return source == null ? '' : (source + '').replace(replaceReg, function (str, c) {
	    return replaceMap[c];
	  });
	}
	
	exports.encodeHTML = encodeHTML;
	
	function makeValueReadable(value, valueType, useUTC) {
	  var USER_READABLE_DEFUALT_TIME_PATTERN = 'yyyy-MM-dd hh:mm:ss';
	
	  function stringToUserReadable(str) {
	    return str && zrUtil.trim(str) ? str : '-';
	  }
	
	  function isNumberUserReadable(num) {
	    return !!(num != null && !isNaN(num) && isFinite(num));
	  }
	
	  var isTypeTime = valueType === 'time';
	  var isValueDate = value instanceof Date;
	
	  if (isTypeTime || isValueDate) {
	    var date = isTypeTime ? number_1.parseDate(value) : value;
	
	    if (!isNaN(+date)) {
	      return time_1.format(date, USER_READABLE_DEFUALT_TIME_PATTERN, useUTC);
	    } else if (isValueDate) {
	      return '-';
	    }
	  }
	
	  if (valueType === 'ordinal') {
	    return zrUtil.isStringSafe(value) ? stringToUserReadable(value) : zrUtil.isNumber(value) ? isNumberUserReadable(value) ? value + '' : '-' : '-';
	  }
	
	  var numericResult = number_1.numericToNumber(value);
	  return isNumberUserReadable(numericResult) ? addCommas(numericResult) : zrUtil.isStringSafe(value) ? stringToUserReadable(value) : '-';
	}
	
	exports.makeValueReadable = makeValueReadable;
	var TPL_VAR_ALIAS = ['a', 'b', 'c', 'd', 'e', 'f', 'g'];
	
	var wrapVar = function (varName, seriesIdx) {
	  return '{' + varName + (seriesIdx == null ? '' : seriesIdx) + '}';
	};
	
	function formatTpl(tpl, paramsList, encode) {
	  if (!zrUtil.isArray(paramsList)) {
	    paramsList = [paramsList];
	  }
	
	  var seriesLen = paramsList.length;
	
	  if (!seriesLen) {
	    return '';
	  }
	
	  var $vars = paramsList[0].$vars || [];
	
	  for (var i = 0; i < $vars.length; i++) {
	    var alias = TPL_VAR_ALIAS[i];
	    tpl = tpl.replace(wrapVar(alias), wrapVar(alias, 0));
	  }
	
	  for (var seriesIdx = 0; seriesIdx < seriesLen; seriesIdx++) {
	    for (var k = 0; k < $vars.length; k++) {
	      var val = paramsList[seriesIdx][$vars[k]];
	      tpl = tpl.replace(wrapVar(TPL_VAR_ALIAS[k], seriesIdx), encode ? encodeHTML(val) : val);
	    }
	  }
	
	  return tpl;
	}
	
	exports.formatTpl = formatTpl;
	
	function formatTplSimple(tpl, param, encode) {
	  zrUtil.each(param, function (value, key) {
	    tpl = tpl.replace('{' + key + '}', encode ? encodeHTML(value) : value);
	  });
	  return tpl;
	}
	
	exports.formatTplSimple = formatTplSimple;
	
	function getTooltipMarker(inOpt, extraCssText) {
	  var opt = zrUtil.isString(inOpt) ? {
	    color: inOpt,
	    extraCssText: extraCssText
	  } : inOpt || {};
	  var color = opt.color;
	  var type = opt.type;
	  extraCssText = opt.extraCssText;
	  var renderMode = opt.renderMode || 'html';
	
	  if (!color) {
	    return '';
	  }
	
	  if (renderMode === 'html') {
	    return type === 'subItem' ? '<span style="display:inline-block;vertical-align:middle;margin-right:8px;margin-left:3px;' + 'border-radius:4px;width:4px;height:4px;background-color:' + encodeHTML(color) + ';' + (extraCssText || '') + '"></span>' : '<span style="display:inline-block;margin-right:4px;' + 'border-radius:10px;width:10px;height:10px;background-color:' + encodeHTML(color) + ';' + (extraCssText || '') + '"></span>';
	  } else {
	    var markerId = opt.markerId || 'markerX';
	    return {
	      renderMode: renderMode,
	      content: '{' + markerId + '|}  ',
	      style: type === 'subItem' ? {
	        width: 4,
	        height: 4,
	        borderRadius: 2,
	        backgroundColor: color
	      } : {
	        width: 10,
	        height: 10,
	        borderRadius: 5,
	        backgroundColor: color
	      }
	    };
	  }
	}
	
	exports.getTooltipMarker = getTooltipMarker;
	
	function formatTime(tpl, value, isUTC) {
	  if (false) {
	    log_1.deprecateReplaceLog('echarts.format.formatTime', 'echarts.time.format');
	  }
	
	  if (tpl === 'week' || tpl === 'month' || tpl === 'quarter' || tpl === 'half-year' || tpl === 'year') {
	    tpl = 'MM-dd\nyyyy';
	  }
	
	  var date = number_1.parseDate(value);
	  var utc = isUTC ? 'UTC' : '';
	  var y = date['get' + utc + 'FullYear']();
	  var M = date['get' + utc + 'Month']() + 1;
	  var d = date['get' + utc + 'Date']();
	  var h = date['get' + utc + 'Hours']();
	  var m = date['get' + utc + 'Minutes']();
	  var s = date['get' + utc + 'Seconds']();
	  var S = date['get' + utc + 'Milliseconds']();
	  tpl = tpl.replace('MM', time_1.pad(M, 2)).replace('M', M).replace('yyyy', y).replace('yy', y % 100 + '').replace('dd', time_1.pad(d, 2)).replace('d', d).replace('hh', time_1.pad(h, 2)).replace('h', h).replace('mm', time_1.pad(m, 2)).replace('m', m).replace('ss', time_1.pad(s, 2)).replace('s', s).replace('SSS', time_1.pad(S, 3));
	  return tpl;
	}
	
	exports.formatTime = formatTime;
	
	function capitalFirst(str) {
	  return str ? str.charAt(0).toUpperCase() + str.substr(1) : str;
	}
	
	exports.capitalFirst = capitalFirst;
	
	function convertToColorString(color, defaultColor) {
	  defaultColor = defaultColor || 'transparent';
	  return zrUtil.isString(color) ? color : zrUtil.isObject(color) ? color.colorStops && (color.colorStops[0] || {}).color || defaultColor : defaultColor;
	}
	
	exports.convertToColorString = convertToColorString;
	
	var parseText_1 = __webpack_require__(189);
	
	exports.truncateText = parseText_1.truncateText;
	
	function windowOpen(link, target) {
	  if (target === '_blank' || target === 'blank') {
	    var blank = window.open();
	    blank.opener = null;
	    blank.location.href = link;
	  } else {
	    window.open(link, target);
	  }
	}
	
	exports.windowOpen = windowOpen;
	
	var getTextRect_1 = __webpack_require__(356);
	
	exports.getTextRect = getTextRect_1.getTextRect;

/***/ },
/* 30 */
/***/ function(module, exports, __webpack_require__) {

	
	/*
	* Licensed to the Apache Software Foundation (ASF) under one
	* or more contributor license agreements.  See the NOTICE file
	* distributed with this work for additional information
	* regarding copyright ownership.  The ASF licenses this file
	* to you under the Apache License, Version 2.0 (the
	* "License"); you may not use this file except in compliance
	* with the License.  You may obtain a copy of the License at
	*
	*   http://www.apache.org/licenses/LICENSE-2.0
	*
	* Unless required by applicable law or agreed to in writing,
	* software distributed under the License is distributed on an
	* "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
	* KIND, either express or implied.  See the License for the
	* specific language governing permissions and limitations
	* under the License.
	*/
	
	
	
	/**
	 * AUTO-GENERATED FILE. DO NOT MODIFY.
	 */
	
	"use strict";
	
	exports.__esModule = true;
	
	var zrUtil = __webpack_require__(1);
	
	var BoundingRect_1 = __webpack_require__(17);
	
	var number_1 = __webpack_require__(9);
	
	var formatUtil = __webpack_require__(29);
	
	var each = zrUtil.each;
	exports.LOCATION_PARAMS = ['left', 'right', 'top', 'bottom', 'width', 'height'];
	exports.HV_NAMES = [['width', 'left', 'right'], ['height', 'top', 'bottom']];
	
	function boxLayout(orient, group, gap, maxWidth, maxHeight) {
	  var x = 0;
	  var y = 0;
	
	  if (maxWidth == null) {
	    maxWidth = Infinity;
	  }
	
	  if (maxHeight == null) {
	    maxHeight = Infinity;
	  }
	
	  var currentLineMaxSize = 0;
	  group.eachChild(function (child, idx) {
	    var rect = child.getBoundingRect();
	    var nextChild = group.childAt(idx + 1);
	    var nextChildRect = nextChild && nextChild.getBoundingRect();
	    var nextX;
	    var nextY;
	
	    if (orient === 'horizontal') {
	      var moveX = rect.width + (nextChildRect ? -nextChildRect.x + rect.x : 0);
	      nextX = x + moveX;
	
	      if (nextX > maxWidth || child.newline) {
	        x = 0;
	        nextX = moveX;
	        y += currentLineMaxSize + gap;
	        currentLineMaxSize = rect.height;
	      } else {
	        currentLineMaxSize = Math.max(currentLineMaxSize, rect.height);
	      }
	    } else {
	      var moveY = rect.height + (nextChildRect ? -nextChildRect.y + rect.y : 0);
	      nextY = y + moveY;
	
	      if (nextY > maxHeight || child.newline) {
	        x += currentLineMaxSize + gap;
	        y = 0;
	        nextY = moveY;
	        currentLineMaxSize = rect.width;
	      } else {
	        currentLineMaxSize = Math.max(currentLineMaxSize, rect.width);
	      }
	    }
	
	    if (child.newline) {
	      return;
	    }
	
	    child.x = x;
	    child.y = y;
	    child.markRedraw();
	    orient === 'horizontal' ? x = nextX + gap : y = nextY + gap;
	  });
	}
	
	exports.box = boxLayout;
	exports.vbox = zrUtil.curry(boxLayout, 'vertical');
	exports.hbox = zrUtil.curry(boxLayout, 'horizontal');
	
	function getAvailableSize(positionInfo, containerRect, margin) {
	  var containerWidth = containerRect.width;
	  var containerHeight = containerRect.height;
	  var x = number_1.parsePercent(positionInfo.left, containerWidth);
	  var y = number_1.parsePercent(positionInfo.top, containerHeight);
	  var x2 = number_1.parsePercent(positionInfo.right, containerWidth);
	  var y2 = number_1.parsePercent(positionInfo.bottom, containerHeight);
	  (isNaN(x) || isNaN(parseFloat(positionInfo.left))) && (x = 0);
	  (isNaN(x2) || isNaN(parseFloat(positionInfo.right))) && (x2 = containerWidth);
	  (isNaN(y) || isNaN(parseFloat(positionInfo.top))) && (y = 0);
	  (isNaN(y2) || isNaN(parseFloat(positionInfo.bottom))) && (y2 = containerHeight);
	  margin = formatUtil.normalizeCssArray(margin || 0);
	  return {
	    width: Math.max(x2 - x - margin[1] - margin[3], 0),
	    height: Math.max(y2 - y - margin[0] - margin[2], 0)
	  };
	}
	
	exports.getAvailableSize = getAvailableSize;
	
	function getLayoutRect(positionInfo, containerRect, margin) {
	  margin = formatUtil.normalizeCssArray(margin || 0);
	  var containerWidth = containerRect.width;
	  var containerHeight = containerRect.height;
	  var left = number_1.parsePercent(positionInfo.left, containerWidth);
	  var top = number_1.parsePercent(positionInfo.top, containerHeight);
	  var right = number_1.parsePercent(positionInfo.right, containerWidth);
	  var bottom = number_1.parsePercent(positionInfo.bottom, containerHeight);
	  var width = number_1.parsePercent(positionInfo.width, containerWidth);
	  var height = number_1.parsePercent(positionInfo.height, containerHeight);
	  var verticalMargin = margin[2] + margin[0];
	  var horizontalMargin = margin[1] + margin[3];
	  var aspect = positionInfo.aspect;
	
	  if (isNaN(width)) {
	    width = containerWidth - right - horizontalMargin - left;
	  }
	
	  if (isNaN(height)) {
	    height = containerHeight - bottom - verticalMargin - top;
	  }
	
	  if (aspect != null) {
	    if (isNaN(width) && isNaN(height)) {
	      if (aspect > containerWidth / containerHeight) {
	        width = containerWidth * 0.8;
	      } else {
	        height = containerHeight * 0.8;
	      }
	    }
	
	    if (isNaN(width)) {
	      width = aspect * height;
	    }
	
	    if (isNaN(height)) {
	      height = width / aspect;
	    }
	  }
	
	  if (isNaN(left)) {
	    left = containerWidth - right - width - horizontalMargin;
	  }
	
	  if (isNaN(top)) {
	    top = containerHeight - bottom - height - verticalMargin;
	  }
	
	  switch (positionInfo.left || positionInfo.right) {
	    case 'center':
	      left = containerWidth / 2 - width / 2 - margin[3];
	      break;
	
	    case 'right':
	      left = containerWidth - width - horizontalMargin;
	      break;
	  }
	
	  switch (positionInfo.top || positionInfo.bottom) {
	    case 'middle':
	    case 'center':
	      top = containerHeight / 2 - height / 2 - margin[0];
	      break;
	
	    case 'bottom':
	      top = containerHeight - height - verticalMargin;
	      break;
	  }
	
	  left = left || 0;
	  top = top || 0;
	
	  if (isNaN(width)) {
	    width = containerWidth - horizontalMargin - left - (right || 0);
	  }
	
	  if (isNaN(height)) {
	    height = containerHeight - verticalMargin - top - (bottom || 0);
	  }
	
	  var rect = new BoundingRect_1["default"](left + margin[3], top + margin[0], width, height);
	  rect.margin = margin;
	  return rect;
	}
	
	exports.getLayoutRect = getLayoutRect;
	
	function positionElement(el, positionInfo, containerRect, margin, opt) {
	  var h = !opt || !opt.hv || opt.hv[0];
	  var v = !opt || !opt.hv || opt.hv[1];
	  var boundingMode = opt && opt.boundingMode || 'all';
	
	  if (!h && !v) {
	    return;
	  }
	
	  var rect;
	
	  if (boundingMode === 'raw') {
	    rect = el.type === 'group' ? new BoundingRect_1["default"](0, 0, +positionInfo.width || 0, +positionInfo.height || 0) : el.getBoundingRect();
	  } else {
	    rect = el.getBoundingRect();
	
	    if (el.needLocalTransform()) {
	      var transform = el.getLocalTransform();
	      rect = rect.clone();
	      rect.applyTransform(transform);
	    }
	  }
	
	  var layoutRect = getLayoutRect(zrUtil.defaults({
	    width: rect.width,
	    height: rect.height
	  }, positionInfo), containerRect, margin);
	  var dx = h ? layoutRect.x - rect.x : 0;
	  var dy = v ? layoutRect.y - rect.y : 0;
	
	  if (boundingMode === 'raw') {
	    el.x = dx;
	    el.y = dy;
	  } else {
	    el.x += dx;
	    el.y += dy;
	  }
	
	  el.markRedraw();
	}
	
	exports.positionElement = positionElement;
	
	function sizeCalculable(option, hvIdx) {
	  return option[exports.HV_NAMES[hvIdx][0]] != null || option[exports.HV_NAMES[hvIdx][1]] != null && option[exports.HV_NAMES[hvIdx][2]] != null;
	}
	
	exports.sizeCalculable = sizeCalculable;
	
	function fetchLayoutMode(ins) {
	  var layoutMode = ins.layoutMode || ins.constructor.layoutMode;
	  return zrUtil.isObject(layoutMode) ? layoutMode : layoutMode ? {
	    type: layoutMode
	  } : null;
	}
	
	exports.fetchLayoutMode = fetchLayoutMode;
	
	function mergeLayoutParam(targetOption, newOption, opt) {
	  var ignoreSize = opt && opt.ignoreSize;
	  !zrUtil.isArray(ignoreSize) && (ignoreSize = [ignoreSize, ignoreSize]);
	  var hResult = merge(exports.HV_NAMES[0], 0);
	  var vResult = merge(exports.HV_NAMES[1], 1);
	  copy(exports.HV_NAMES[0], targetOption, hResult);
	  copy(exports.HV_NAMES[1], targetOption, vResult);
	
	  function merge(names, hvIdx) {
	    var newParams = {};
	    var newValueCount = 0;
	    var merged = {};
	    var mergedValueCount = 0;
	    var enoughParamNumber = 2;
	    each(names, function (name) {
	      merged[name] = targetOption[name];
	    });
	    each(names, function (name) {
	      hasProp(newOption, name) && (newParams[name] = merged[name] = newOption[name]);
	      hasValue(newParams, name) && newValueCount++;
	      hasValue(merged, name) && mergedValueCount++;
	    });
	
	    if (ignoreSize[hvIdx]) {
	      if (hasValue(newOption, names[1])) {
	        merged[names[2]] = null;
	      } else if (hasValue(newOption, names[2])) {
	        merged[names[1]] = null;
	      }
	
	      return merged;
	    }
	
	    if (mergedValueCount === enoughParamNumber || !newValueCount) {
	      return merged;
	    } else if (newValueCount >= enoughParamNumber) {
	      return newParams;
	    } else {
	      for (var i = 0; i < names.length; i++) {
	        var name_1 = names[i];
	
	        if (!hasProp(newParams, name_1) && hasProp(targetOption, name_1)) {
	          newParams[name_1] = targetOption[name_1];
	          break;
	        }
	      }
	
	      return newParams;
	    }
	  }
	
	  function hasProp(obj, name) {
	    return obj.hasOwnProperty(name);
	  }
	
	  function hasValue(obj, name) {
	    return obj[name] != null && obj[name] !== 'auto';
	  }
	
	  function copy(names, target, source) {
	    each(names, function (name) {
	      target[name] = source[name];
	    });
	  }
	}
	
	exports.mergeLayoutParam = mergeLayoutParam;
	
	function getLayoutParams(source) {
	  return copyLayoutParams({}, source);
	}
	
	exports.getLayoutParams = getLayoutParams;
	
	function copyLayoutParams(target, source) {
	  source && target && each(exports.LOCATION_PARAMS, function (name) {
	    source.hasOwnProperty(name) && (target[name] = source[name]);
	  });
	  return target;
	}
	
	exports.copyLayoutParams = copyLayoutParams;

/***/ },
/* 31 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * Copyright (c) 2013-present, Facebook, Inc.
	 *
	 * This source code is licensed under the MIT license found in the
	 * LICENSE file in the root directory of this source tree.
	 */
	
	if (false) {
	  var ReactIs = require('react-is');
	
	  // By explicitly using `prop-types` you are opting into new development behavior.
	  // http://fb.me/prop-types-in-prod
	  var throwOnDirectAccess = true;
	  module.exports = require('./factoryWithTypeCheckers')(ReactIs.isElement, throwOnDirectAccess);
	} else {
	  // By explicitly using `prop-types` you are opting into new production behavior.
	  // http://fb.me/prop-types-in-prod
	  module.exports = __webpack_require__(404)();
	}


/***/ },
/* 32 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	exports.__esModule = true;
	var vec2 = __webpack_require__(11);
	var BoundingRect_1 = __webpack_require__(17);
	var config_1 = __webpack_require__(49);
	var bbox_1 = __webpack_require__(458);
	var curve_1 = __webpack_require__(33);
	var CMD = {
	    M: 1,
	    L: 2,
	    C: 3,
	    Q: 4,
	    A: 5,
	    Z: 6,
	    R: 7
	};
	var tmpOutX = [];
	var tmpOutY = [];
	var min = [];
	var max = [];
	var min2 = [];
	var max2 = [];
	var mathMin = Math.min;
	var mathMax = Math.max;
	var mathCos = Math.cos;
	var mathSin = Math.sin;
	var mathSqrt = Math.sqrt;
	var mathAbs = Math.abs;
	var PI = Math.PI;
	var PI2 = PI * 2;
	var hasTypedArray = typeof Float32Array !== 'undefined';
	var tmpAngles = [];
	function modPI2(radian) {
	    var n = Math.round(radian / PI * 1e8) / 1e8;
	    return (n % 2) * PI;
	}
	function normalizeArcAngles(angles, anticlockwise) {
	    var newStartAngle = modPI2(angles[0]);
	    if (newStartAngle < 0) {
	        newStartAngle += PI2;
	    }
	    var delta = newStartAngle - angles[0];
	    var newEndAngle = angles[1];
	    newEndAngle += delta;
	    if (!anticlockwise && newEndAngle - newStartAngle >= PI2) {
	        newEndAngle = newStartAngle + PI2;
	    }
	    else if (anticlockwise && newStartAngle - newEndAngle >= PI2) {
	        newEndAngle = newStartAngle - PI2;
	    }
	    else if (!anticlockwise && newStartAngle > newEndAngle) {
	        newEndAngle = newStartAngle +
	            (PI2 - modPI2(newStartAngle - newEndAngle));
	    }
	    else if (anticlockwise && newStartAngle < newEndAngle) {
	        newEndAngle = newStartAngle -
	            (PI2 - modPI2(newEndAngle - newStartAngle));
	    }
	    angles[0] = newStartAngle;
	    angles[1] = newEndAngle;
	}
	exports.normalizeArcAngles = normalizeArcAngles;
	var PathProxy = (function () {
	    function PathProxy(notSaveData) {
	        this.dpr = 1;
	        this._version = 0;
	        this._xi = 0;
	        this._yi = 0;
	        this._x0 = 0;
	        this._y0 = 0;
	        this._len = 0;
	        if (notSaveData) {
	            this._saveData = false;
	        }
	        if (this._saveData) {
	            this.data = [];
	        }
	    }
	    PathProxy.prototype.increaseVersion = function () {
	        this._version++;
	    };
	    PathProxy.prototype.getVersion = function () {
	        return this._version;
	    };
	    PathProxy.prototype.setScale = function (sx, sy, segmentIgnoreThreshold) {
	        segmentIgnoreThreshold = segmentIgnoreThreshold || 0;
	        if (segmentIgnoreThreshold > 0) {
	            this._ux = mathAbs(segmentIgnoreThreshold / config_1.devicePixelRatio / sx) || 0;
	            this._uy = mathAbs(segmentIgnoreThreshold / config_1.devicePixelRatio / sy) || 0;
	        }
	    };
	    PathProxy.prototype.setDPR = function (dpr) {
	        this.dpr = dpr;
	    };
	    PathProxy.prototype.setContext = function (ctx) {
	        this._ctx = ctx;
	    };
	    PathProxy.prototype.getContext = function () {
	        return this._ctx;
	    };
	    PathProxy.prototype.beginPath = function () {
	        this._ctx && this._ctx.beginPath();
	        this.reset();
	        return this;
	    };
	    PathProxy.prototype.reset = function () {
	        if (this._saveData) {
	            this._len = 0;
	        }
	        if (this._lineDash) {
	            this._lineDash = null;
	            this._dashOffset = 0;
	        }
	        if (this._pathSegLen) {
	            this._pathSegLen = null;
	            this._pathLen = 0;
	        }
	        this._version++;
	    };
	    PathProxy.prototype.moveTo = function (x, y) {
	        this.addData(CMD.M, x, y);
	        this._ctx && this._ctx.moveTo(x, y);
	        this._x0 = x;
	        this._y0 = y;
	        this._xi = x;
	        this._yi = y;
	        return this;
	    };
	    PathProxy.prototype.lineTo = function (x, y) {
	        var exceedUnit = mathAbs(x - this._xi) > this._ux
	            || mathAbs(y - this._yi) > this._uy
	            || this._len < 5;
	        this.addData(CMD.L, x, y);
	        if (this._ctx && exceedUnit) {
	            this._needsDash ? this._dashedLineTo(x, y)
	                : this._ctx.lineTo(x, y);
	        }
	        if (exceedUnit) {
	            this._xi = x;
	            this._yi = y;
	        }
	        return this;
	    };
	    PathProxy.prototype.bezierCurveTo = function (x1, y1, x2, y2, x3, y3) {
	        this.addData(CMD.C, x1, y1, x2, y2, x3, y3);
	        if (this._ctx) {
	            this._needsDash ? this._dashedBezierTo(x1, y1, x2, y2, x3, y3)
	                : this._ctx.bezierCurveTo(x1, y1, x2, y2, x3, y3);
	        }
	        this._xi = x3;
	        this._yi = y3;
	        return this;
	    };
	    PathProxy.prototype.quadraticCurveTo = function (x1, y1, x2, y2) {
	        this.addData(CMD.Q, x1, y1, x2, y2);
	        if (this._ctx) {
	            this._needsDash ? this._dashedQuadraticTo(x1, y1, x2, y2)
	                : this._ctx.quadraticCurveTo(x1, y1, x2, y2);
	        }
	        this._xi = x2;
	        this._yi = y2;
	        return this;
	    };
	    PathProxy.prototype.arc = function (cx, cy, r, startAngle, endAngle, anticlockwise) {
	        tmpAngles[0] = startAngle;
	        tmpAngles[1] = endAngle;
	        normalizeArcAngles(tmpAngles, anticlockwise);
	        startAngle = tmpAngles[0];
	        endAngle = tmpAngles[1];
	        var delta = endAngle - startAngle;
	        this.addData(CMD.A, cx, cy, r, r, startAngle, delta, 0, anticlockwise ? 0 : 1);
	        this._ctx && this._ctx.arc(cx, cy, r, startAngle, endAngle, anticlockwise);
	        this._xi = mathCos(endAngle) * r + cx;
	        this._yi = mathSin(endAngle) * r + cy;
	        return this;
	    };
	    PathProxy.prototype.arcTo = function (x1, y1, x2, y2, radius) {
	        if (this._ctx) {
	            this._ctx.arcTo(x1, y1, x2, y2, radius);
	        }
	        return this;
	    };
	    PathProxy.prototype.rect = function (x, y, w, h) {
	        this._ctx && this._ctx.rect(x, y, w, h);
	        this.addData(CMD.R, x, y, w, h);
	        return this;
	    };
	    PathProxy.prototype.closePath = function () {
	        this.addData(CMD.Z);
	        var ctx = this._ctx;
	        var x0 = this._x0;
	        var y0 = this._y0;
	        if (ctx) {
	            this._needsDash && this._dashedLineTo(x0, y0);
	            ctx.closePath();
	        }
	        this._xi = x0;
	        this._yi = y0;
	        return this;
	    };
	    PathProxy.prototype.fill = function (ctx) {
	        ctx && ctx.fill();
	        this.toStatic();
	    };
	    PathProxy.prototype.stroke = function (ctx) {
	        ctx && ctx.stroke();
	        this.toStatic();
	    };
	    PathProxy.prototype.setLineDash = function (lineDash) {
	        if (lineDash instanceof Array) {
	            this._lineDash = lineDash;
	            this._dashIdx = 0;
	            var lineDashSum = 0;
	            for (var i = 0; i < lineDash.length; i++) {
	                lineDashSum += lineDash[i];
	            }
	            this._dashSum = lineDashSum;
	            this._needsDash = true;
	        }
	        else {
	            this._lineDash = null;
	            this._needsDash = false;
	        }
	        return this;
	    };
	    PathProxy.prototype.setLineDashOffset = function (offset) {
	        this._dashOffset = offset;
	        return this;
	    };
	    PathProxy.prototype.len = function () {
	        return this._len;
	    };
	    PathProxy.prototype.setData = function (data) {
	        var len = data.length;
	        if (!(this.data && this.data.length === len) && hasTypedArray) {
	            this.data = new Float32Array(len);
	        }
	        for (var i = 0; i < len; i++) {
	            this.data[i] = data[i];
	        }
	        this._len = len;
	    };
	    PathProxy.prototype.appendPath = function (path) {
	        if (!(path instanceof Array)) {
	            path = [path];
	        }
	        var len = path.length;
	        var appendSize = 0;
	        var offset = this._len;
	        for (var i = 0; i < len; i++) {
	            appendSize += path[i].len();
	        }
	        if (hasTypedArray && (this.data instanceof Float32Array)) {
	            this.data = new Float32Array(offset + appendSize);
	        }
	        for (var i = 0; i < len; i++) {
	            var appendPathData = path[i].data;
	            for (var k = 0; k < appendPathData.length; k++) {
	                this.data[offset++] = appendPathData[k];
	            }
	        }
	        this._len = offset;
	    };
	    PathProxy.prototype.addData = function (cmd, a, b, c, d, e, f, g, h) {
	        if (!this._saveData) {
	            return;
	        }
	        var data = this.data;
	        if (this._len + arguments.length > data.length) {
	            this._expandData();
	            data = this.data;
	        }
	        for (var i = 0; i < arguments.length; i++) {
	            data[this._len++] = arguments[i];
	        }
	    };
	    PathProxy.prototype._expandData = function () {
	        if (!(this.data instanceof Array)) {
	            var newData = [];
	            for (var i = 0; i < this._len; i++) {
	                newData[i] = this.data[i];
	            }
	            this.data = newData;
	        }
	    };
	    PathProxy.prototype._dashedLineTo = function (x1, y1) {
	        var dashSum = this._dashSum;
	        var lineDash = this._lineDash;
	        var ctx = this._ctx;
	        var offset = this._dashOffset;
	        var x0 = this._xi;
	        var y0 = this._yi;
	        var dx = x1 - x0;
	        var dy = y1 - y0;
	        var dist = mathSqrt(dx * dx + dy * dy);
	        var x = x0;
	        var y = y0;
	        var nDash = lineDash.length;
	        var dash;
	        var idx;
	        dx /= dist;
	        dy /= dist;
	        if (offset < 0) {
	            offset = dashSum + offset;
	        }
	        offset %= dashSum;
	        x -= offset * dx;
	        y -= offset * dy;
	        while ((dx > 0 && x <= x1) || (dx < 0 && x >= x1)
	            || (dx === 0 && ((dy > 0 && y <= y1) || (dy < 0 && y >= y1)))) {
	            idx = this._dashIdx;
	            dash = lineDash[idx];
	            x += dx * dash;
	            y += dy * dash;
	            this._dashIdx = (idx + 1) % nDash;
	            if ((dx > 0 && x < x0) || (dx < 0 && x > x0) || (dy > 0 && y < y0) || (dy < 0 && y > y0)) {
	                continue;
	            }
	            ctx[idx % 2 ? 'moveTo' : 'lineTo'](dx >= 0 ? mathMin(x, x1) : mathMax(x, x1), dy >= 0 ? mathMin(y, y1) : mathMax(y, y1));
	        }
	        dx = x - x1;
	        dy = y - y1;
	        this._dashOffset = -mathSqrt(dx * dx + dy * dy);
	    };
	    PathProxy.prototype._dashedBezierTo = function (x1, y1, x2, y2, x3, y3) {
	        var ctx = this._ctx;
	        var dashSum = this._dashSum;
	        var offset = this._dashOffset;
	        var lineDash = this._lineDash;
	        var x0 = this._xi;
	        var y0 = this._yi;
	        var bezierLen = 0;
	        var idx = this._dashIdx;
	        var nDash = lineDash.length;
	        var t;
	        var dx;
	        var dy;
	        var x;
	        var y;
	        var tmpLen = 0;
	        if (offset < 0) {
	            offset = dashSum + offset;
	        }
	        offset %= dashSum;
	        for (t = 0; t < 1; t += 0.1) {
	            dx = curve_1.cubicAt(x0, x1, x2, x3, t + 0.1)
	                - curve_1.cubicAt(x0, x1, x2, x3, t);
	            dy = curve_1.cubicAt(y0, y1, y2, y3, t + 0.1)
	                - curve_1.cubicAt(y0, y1, y2, y3, t);
	            bezierLen += mathSqrt(dx * dx + dy * dy);
	        }
	        for (; idx < nDash; idx++) {
	            tmpLen += lineDash[idx];
	            if (tmpLen > offset) {
	                break;
	            }
	        }
	        t = (tmpLen - offset) / bezierLen;
	        while (t <= 1) {
	            x = curve_1.cubicAt(x0, x1, x2, x3, t);
	            y = curve_1.cubicAt(y0, y1, y2, y3, t);
	            idx % 2 ? ctx.moveTo(x, y)
	                : ctx.lineTo(x, y);
	            t += lineDash[idx] / bezierLen;
	            idx = (idx + 1) % nDash;
	        }
	        (idx % 2 !== 0) && ctx.lineTo(x3, y3);
	        dx = x3 - x;
	        dy = y3 - y;
	        this._dashOffset = -mathSqrt(dx * dx + dy * dy);
	    };
	    PathProxy.prototype._dashedQuadraticTo = function (x1, y1, x2, y2) {
	        var x3 = x2;
	        var y3 = y2;
	        x2 = (x2 + 2 * x1) / 3;
	        y2 = (y2 + 2 * y1) / 3;
	        x1 = (this._xi + 2 * x1) / 3;
	        y1 = (this._yi + 2 * y1) / 3;
	        this._dashedBezierTo(x1, y1, x2, y2, x3, y3);
	    };
	    PathProxy.prototype.toStatic = function () {
	        if (!this._saveData) {
	            return;
	        }
	        var data = this.data;
	        if (data instanceof Array) {
	            data.length = this._len;
	            if (hasTypedArray && this._len > 11) {
	                this.data = new Float32Array(data);
	            }
	        }
	    };
	    PathProxy.prototype.getBoundingRect = function () {
	        min[0] = min[1] = min2[0] = min2[1] = Number.MAX_VALUE;
	        max[0] = max[1] = max2[0] = max2[1] = -Number.MAX_VALUE;
	        var data = this.data;
	        var xi = 0;
	        var yi = 0;
	        var x0 = 0;
	        var y0 = 0;
	        var i;
	        for (i = 0; i < this._len;) {
	            var cmd = data[i++];
	            var isFirst = i === 1;
	            if (isFirst) {
	                xi = data[i];
	                yi = data[i + 1];
	                x0 = xi;
	                y0 = yi;
	            }
	            switch (cmd) {
	                case CMD.M:
	                    xi = x0 = data[i++];
	                    yi = y0 = data[i++];
	                    min2[0] = x0;
	                    min2[1] = y0;
	                    max2[0] = x0;
	                    max2[1] = y0;
	                    break;
	                case CMD.L:
	                    bbox_1.fromLine(xi, yi, data[i], data[i + 1], min2, max2);
	                    xi = data[i++];
	                    yi = data[i++];
	                    break;
	                case CMD.C:
	                    bbox_1.fromCubic(xi, yi, data[i++], data[i++], data[i++], data[i++], data[i], data[i + 1], min2, max2);
	                    xi = data[i++];
	                    yi = data[i++];
	                    break;
	                case CMD.Q:
	                    bbox_1.fromQuadratic(xi, yi, data[i++], data[i++], data[i], data[i + 1], min2, max2);
	                    xi = data[i++];
	                    yi = data[i++];
	                    break;
	                case CMD.A:
	                    var cx = data[i++];
	                    var cy = data[i++];
	                    var rx = data[i++];
	                    var ry = data[i++];
	                    var startAngle = data[i++];
	                    var endAngle = data[i++] + startAngle;
	                    i += 1;
	                    var anticlockwise = !data[i++];
	                    if (isFirst) {
	                        x0 = mathCos(startAngle) * rx + cx;
	                        y0 = mathSin(startAngle) * ry + cy;
	                    }
	                    bbox_1.fromArc(cx, cy, rx, ry, startAngle, endAngle, anticlockwise, min2, max2);
	                    xi = mathCos(endAngle) * rx + cx;
	                    yi = mathSin(endAngle) * ry + cy;
	                    break;
	                case CMD.R:
	                    x0 = xi = data[i++];
	                    y0 = yi = data[i++];
	                    var width = data[i++];
	                    var height = data[i++];
	                    bbox_1.fromLine(x0, y0, x0 + width, y0 + height, min2, max2);
	                    break;
	                case CMD.Z:
	                    xi = x0;
	                    yi = y0;
	                    break;
	            }
	            vec2.min(min, min, min2);
	            vec2.max(max, max, max2);
	        }
	        if (i === 0) {
	            min[0] = min[1] = max[0] = max[1] = 0;
	        }
	        return new BoundingRect_1["default"](min[0], min[1], max[0] - min[0], max[1] - min[1]);
	    };
	    PathProxy.prototype._calculateLength = function () {
	        var data = this.data;
	        var len = this._len;
	        var ux = this._ux;
	        var uy = this._uy;
	        var xi = 0;
	        var yi = 0;
	        var x0 = 0;
	        var y0 = 0;
	        if (!this._pathSegLen) {
	            this._pathSegLen = [];
	        }
	        var pathSegLen = this._pathSegLen;
	        var pathTotalLen = 0;
	        var segCount = 0;
	        for (var i = 0; i < len;) {
	            var cmd = data[i++];
	            var isFirst = i === 1;
	            if (isFirst) {
	                xi = data[i];
	                yi = data[i + 1];
	                x0 = xi;
	                y0 = yi;
	            }
	            var l = -1;
	            switch (cmd) {
	                case CMD.M:
	                    xi = x0 = data[i++];
	                    yi = y0 = data[i++];
	                    break;
	                case CMD.L: {
	                    var x2 = data[i++];
	                    var y2 = data[i++];
	                    var dx = x2 - xi;
	                    var dy = y2 - yi;
	                    if (mathAbs(dx) > ux || mathAbs(dy) > uy || i === len - 1) {
	                        l = Math.sqrt(dx * dx + dy * dy);
	                        xi = x2;
	                        yi = y2;
	                    }
	                    break;
	                }
	                case CMD.C: {
	                    var x1 = data[i++];
	                    var y1 = data[i++];
	                    var x2 = data[i++];
	                    var y2 = data[i++];
	                    var x3 = data[i++];
	                    var y3 = data[i++];
	                    l = curve_1.cubicLength(xi, yi, x1, y1, x2, y2, x3, y3, 10);
	                    xi = x3;
	                    yi = y3;
	                    break;
	                }
	                case CMD.Q: {
	                    var x1 = data[i++];
	                    var y1 = data[i++];
	                    var x2 = data[i++];
	                    var y2 = data[i++];
	                    l = curve_1.quadraticLength(xi, yi, x1, y1, x2, y2, 10);
	                    xi = x2;
	                    yi = y2;
	                    break;
	                }
	                case CMD.A:
	                    var cx = data[i++];
	                    var cy = data[i++];
	                    var rx = data[i++];
	                    var ry = data[i++];
	                    var startAngle = data[i++];
	                    var delta = data[i++];
	                    var endAngle = delta + startAngle;
	                    i += 1;
	                    var anticlockwise = !data[i++];
	                    if (isFirst) {
	                        x0 = mathCos(startAngle) * rx + cx;
	                        y0 = mathSin(startAngle) * ry + cy;
	                    }
	                    l = mathMax(rx, ry) * mathMin(PI2, Math.abs(delta));
	                    xi = mathCos(endAngle) * rx + cx;
	                    yi = mathSin(endAngle) * ry + cy;
	                    break;
	                case CMD.R: {
	                    x0 = xi = data[i++];
	                    y0 = yi = data[i++];
	                    var width = data[i++];
	                    var height = data[i++];
	                    l = width * 2 + height * 2;
	                    break;
	                }
	                case CMD.Z: {
	                    var dx = x0 - xi;
	                    var dy = y0 - yi;
	                    l = Math.sqrt(dx * dx + dy * dy);
	                    xi = x0;
	                    yi = y0;
	                    break;
	                }
	            }
	            if (l >= 0) {
	                pathSegLen[segCount++] = l;
	                pathTotalLen += l;
	            }
	        }
	        this._pathLen = pathTotalLen;
	        return pathTotalLen;
	    };
	    PathProxy.prototype.rebuildPath = function (ctx, percent) {
	        var d = this.data;
	        var ux = this._ux;
	        var uy = this._uy;
	        var len = this._len;
	        var x0;
	        var y0;
	        var xi;
	        var yi;
	        var x;
	        var y;
	        var drawPart = percent < 1;
	        var pathSegLen;
	        var pathTotalLen;
	        var accumLength = 0;
	        var segCount = 0;
	        var displayedLength;
	        if (drawPart) {
	            if (!this._pathSegLen) {
	                this._calculateLength();
	            }
	            pathSegLen = this._pathSegLen;
	            pathTotalLen = this._pathLen;
	            displayedLength = percent * pathTotalLen;
	            if (!displayedLength) {
	                return;
	            }
	        }
	        lo: for (var i = 0; i < len;) {
	            var cmd = d[i++];
	            var isFirst = i === 1;
	            if (isFirst) {
	                xi = d[i];
	                yi = d[i + 1];
	                x0 = xi;
	                y0 = yi;
	            }
	            switch (cmd) {
	                case CMD.M:
	                    x0 = xi = d[i++];
	                    y0 = yi = d[i++];
	                    ctx.moveTo(xi, yi);
	                    break;
	                case CMD.L: {
	                    x = d[i++];
	                    y = d[i++];
	                    if (mathAbs(x - xi) > ux || mathAbs(y - yi) > uy || i === len - 1) {
	                        if (drawPart) {
	                            var l = pathSegLen[segCount++];
	                            if (accumLength + l > displayedLength) {
	                                var t = (displayedLength - accumLength) / l;
	                                ctx.lineTo(xi * (1 - t) + x * t, yi * (1 - t) + y * t);
	                                break lo;
	                            }
	                            accumLength += l;
	                        }
	                        ctx.lineTo(x, y);
	                        xi = x;
	                        yi = y;
	                    }
	                    break;
	                }
	                case CMD.C: {
	                    var x1 = d[i++];
	                    var y1 = d[i++];
	                    var x2 = d[i++];
	                    var y2 = d[i++];
	                    var x3 = d[i++];
	                    var y3 = d[i++];
	                    if (drawPart) {
	                        var l = pathSegLen[segCount++];
	                        if (accumLength + l > displayedLength) {
	                            var t = (displayedLength - accumLength) / l;
	                            curve_1.cubicSubdivide(xi, x1, x2, x3, t, tmpOutX);
	                            curve_1.cubicSubdivide(yi, y1, y2, y3, t, tmpOutY);
	                            ctx.bezierCurveTo(tmpOutX[1], tmpOutY[1], tmpOutX[2], tmpOutY[2], tmpOutX[3], tmpOutY[3]);
	                            break lo;
	                        }
	                        accumLength += l;
	                    }
	                    ctx.bezierCurveTo(x1, y1, x2, y2, x3, y3);
	                    xi = x3;
	                    yi = y3;
	                    break;
	                }
	                case CMD.Q: {
	                    var x1 = d[i++];
	                    var y1 = d[i++];
	                    var x2 = d[i++];
	                    var y2 = d[i++];
	                    if (drawPart) {
	                        var l = pathSegLen[segCount++];
	                        if (accumLength + l > displayedLength) {
	                            var t = (displayedLength - accumLength) / l;
	                            curve_1.quadraticSubdivide(xi, x1, x2, t, tmpOutX);
	                            curve_1.quadraticSubdivide(yi, y1, y2, t, tmpOutY);
	                            ctx.quadraticCurveTo(tmpOutX[1], tmpOutY[1], tmpOutX[2], tmpOutY[2]);
	                            break lo;
	                        }
	                        accumLength += l;
	                    }
	                    ctx.quadraticCurveTo(x1, y1, x2, y2);
	                    xi = x2;
	                    yi = y2;
	                    break;
	                }
	                case CMD.A:
	                    var cx = d[i++];
	                    var cy = d[i++];
	                    var rx = d[i++];
	                    var ry = d[i++];
	                    var startAngle = d[i++];
	                    var delta = d[i++];
	                    var psi = d[i++];
	                    var anticlockwise = !d[i++];
	                    var r = (rx > ry) ? rx : ry;
	                    var scaleX = (rx > ry) ? 1 : rx / ry;
	                    var scaleY = (rx > ry) ? ry / rx : 1;
	                    var isEllipse = mathAbs(rx - ry) > 1e-3;
	                    var endAngle = startAngle + delta;
	                    var breakBuild = false;
	                    if (drawPart) {
	                        var l = pathSegLen[segCount++];
	                        if (accumLength + l > displayedLength) {
	                            endAngle = startAngle + delta * (displayedLength - accumLength) / l;
	                            breakBuild = true;
	                        }
	                        accumLength += l;
	                    }
	                    if (isEllipse && ctx.ellipse) {
	                        ctx.ellipse(cx, cy, rx, ry, psi, startAngle, endAngle, anticlockwise);
	                    }
	                    else {
	                        ctx.arc(cx, cy, r, startAngle, endAngle, anticlockwise);
	                    }
	                    if (breakBuild) {
	                        break lo;
	                    }
	                    if (isFirst) {
	                        x0 = mathCos(startAngle) * rx + cx;
	                        y0 = mathSin(startAngle) * ry + cy;
	                    }
	                    xi = mathCos(endAngle) * rx + cx;
	                    yi = mathSin(endAngle) * ry + cy;
	                    break;
	                case CMD.R:
	                    x0 = xi = d[i];
	                    y0 = yi = d[i + 1];
	                    x = d[i++];
	                    y = d[i++];
	                    var width = d[i++];
	                    var height = d[i++];
	                    if (drawPart) {
	                        var l = pathSegLen[segCount++];
	                        if (accumLength + l > displayedLength) {
	                            var d_1 = displayedLength - accumLength;
	                            ctx.moveTo(x, y);
	                            ctx.lineTo(x + mathMin(d_1, width), y);
	                            d_1 -= width;
	                            if (d_1 > 0) {
	                                ctx.lineTo(x + width, y + mathMin(d_1, height));
	                            }
	                            d_1 -= height;
	                            if (d_1 > 0) {
	                                ctx.lineTo(x + mathMax(width - d_1, 0), y + height);
	                            }
	                            d_1 -= width;
	                            if (d_1 > 0) {
	                                ctx.lineTo(x, y + mathMax(height - d_1, 0));
	                            }
	                            break lo;
	                        }
	                        accumLength += l;
	                    }
	                    ctx.rect(x, y, width, height);
	                    break;
	                case CMD.Z:
	                    if (drawPart) {
	                        var l = pathSegLen[segCount++];
	                        if (accumLength + l > displayedLength) {
	                            var t = (displayedLength - accumLength) / l;
	                            ctx.lineTo(xi * (1 - t) + x0 * t, yi * (1 - t) + y0 * t);
	                            break lo;
	                        }
	                        accumLength += l;
	                    }
	                    ctx.closePath();
	                    xi = x0;
	                    yi = y0;
	            }
	        }
	    };
	    PathProxy.CMD = CMD;
	    PathProxy.initDefaultProps = (function () {
	        var proto = PathProxy.prototype;
	        proto._saveData = true;
	        proto._needsDash = false;
	        proto._dashOffset = 0;
	        proto._dashIdx = 0;
	        proto._dashSum = 0;
	        proto._ux = 0;
	        proto._uy = 0;
	    })();
	    return PathProxy;
	}());
	exports["default"] = PathProxy;


/***/ },
/* 33 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	exports.__esModule = true;
	var vector_1 = __webpack_require__(11);
	var mathPow = Math.pow;
	var mathSqrt = Math.sqrt;
	var EPSILON = 1e-8;
	var EPSILON_NUMERIC = 1e-4;
	var THREE_SQRT = mathSqrt(3);
	var ONE_THIRD = 1 / 3;
	var _v0 = vector_1.create();
	var _v1 = vector_1.create();
	var _v2 = vector_1.create();
	function isAroundZero(val) {
	    return val > -EPSILON && val < EPSILON;
	}
	function isNotAroundZero(val) {
	    return val > EPSILON || val < -EPSILON;
	}
	function cubicAt(p0, p1, p2, p3, t) {
	    var onet = 1 - t;
	    return onet * onet * (onet * p0 + 3 * t * p1)
	        + t * t * (t * p3 + 3 * onet * p2);
	}
	exports.cubicAt = cubicAt;
	function cubicDerivativeAt(p0, p1, p2, p3, t) {
	    var onet = 1 - t;
	    return 3 * (((p1 - p0) * onet + 2 * (p2 - p1) * t) * onet
	        + (p3 - p2) * t * t);
	}
	exports.cubicDerivativeAt = cubicDerivativeAt;
	function cubicRootAt(p0, p1, p2, p3, val, roots) {
	    var a = p3 + 3 * (p1 - p2) - p0;
	    var b = 3 * (p2 - p1 * 2 + p0);
	    var c = 3 * (p1 - p0);
	    var d = p0 - val;
	    var A = b * b - 3 * a * c;
	    var B = b * c - 9 * a * d;
	    var C = c * c - 3 * b * d;
	    var n = 0;
	    if (isAroundZero(A) && isAroundZero(B)) {
	        if (isAroundZero(b)) {
	            roots[0] = 0;
	        }
	        else {
	            var t1 = -c / b;
	            if (t1 >= 0 && t1 <= 1) {
	                roots[n++] = t1;
	            }
	        }
	    }
	    else {
	        var disc = B * B - 4 * A * C;
	        if (isAroundZero(disc)) {
	            var K = B / A;
	            var t1 = -b / a + K;
	            var t2 = -K / 2;
	            if (t1 >= 0 && t1 <= 1) {
	                roots[n++] = t1;
	            }
	            if (t2 >= 0 && t2 <= 1) {
	                roots[n++] = t2;
	            }
	        }
	        else if (disc > 0) {
	            var discSqrt = mathSqrt(disc);
	            var Y1 = A * b + 1.5 * a * (-B + discSqrt);
	            var Y2 = A * b + 1.5 * a * (-B - discSqrt);
	            if (Y1 < 0) {
	                Y1 = -mathPow(-Y1, ONE_THIRD);
	            }
	            else {
	                Y1 = mathPow(Y1, ONE_THIRD);
	            }
	            if (Y2 < 0) {
	                Y2 = -mathPow(-Y2, ONE_THIRD);
	            }
	            else {
	                Y2 = mathPow(Y2, ONE_THIRD);
	            }
	            var t1 = (-b - (Y1 + Y2)) / (3 * a);
	            if (t1 >= 0 && t1 <= 1) {
	                roots[n++] = t1;
	            }
	        }
	        else {
	            var T = (2 * A * b - 3 * a * B) / (2 * mathSqrt(A * A * A));
	            var theta = Math.acos(T) / 3;
	            var ASqrt = mathSqrt(A);
	            var tmp = Math.cos(theta);
	            var t1 = (-b - 2 * ASqrt * tmp) / (3 * a);
	            var t2 = (-b + ASqrt * (tmp + THREE_SQRT * Math.sin(theta))) / (3 * a);
	            var t3 = (-b + ASqrt * (tmp - THREE_SQRT * Math.sin(theta))) / (3 * a);
	            if (t1 >= 0 && t1 <= 1) {
	                roots[n++] = t1;
	            }
	            if (t2 >= 0 && t2 <= 1) {
	                roots[n++] = t2;
	            }
	            if (t3 >= 0 && t3 <= 1) {
	                roots[n++] = t3;
	            }
	        }
	    }
	    return n;
	}
	exports.cubicRootAt = cubicRootAt;
	function cubicExtrema(p0, p1, p2, p3, extrema) {
	    var b = 6 * p2 - 12 * p1 + 6 * p0;
	    var a = 9 * p1 + 3 * p3 - 3 * p0 - 9 * p2;
	    var c = 3 * p1 - 3 * p0;
	    var n = 0;
	    if (isAroundZero(a)) {
	        if (isNotAroundZero(b)) {
	            var t1 = -c / b;
	            if (t1 >= 0 && t1 <= 1) {
	                extrema[n++] = t1;
	            }
	        }
	    }
	    else {
	        var disc = b * b - 4 * a * c;
	        if (isAroundZero(disc)) {
	            extrema[0] = -b / (2 * a);
	        }
	        else if (disc > 0) {
	            var discSqrt = mathSqrt(disc);
	            var t1 = (-b + discSqrt) / (2 * a);
	            var t2 = (-b - discSqrt) / (2 * a);
	            if (t1 >= 0 && t1 <= 1) {
	                extrema[n++] = t1;
	            }
	            if (t2 >= 0 && t2 <= 1) {
	                extrema[n++] = t2;
	            }
	        }
	    }
	    return n;
	}
	exports.cubicExtrema = cubicExtrema;
	function cubicSubdivide(p0, p1, p2, p3, t, out) {
	    var p01 = (p1 - p0) * t + p0;
	    var p12 = (p2 - p1) * t + p1;
	    var p23 = (p3 - p2) * t + p2;
	    var p012 = (p12 - p01) * t + p01;
	    var p123 = (p23 - p12) * t + p12;
	    var p0123 = (p123 - p012) * t + p012;
	    out[0] = p0;
	    out[1] = p01;
	    out[2] = p012;
	    out[3] = p0123;
	    out[4] = p0123;
	    out[5] = p123;
	    out[6] = p23;
	    out[7] = p3;
	}
	exports.cubicSubdivide = cubicSubdivide;
	function cubicProjectPoint(x0, y0, x1, y1, x2, y2, x3, y3, x, y, out) {
	    var t;
	    var interval = 0.005;
	    var d = Infinity;
	    var prev;
	    var next;
	    var d1;
	    var d2;
	    _v0[0] = x;
	    _v0[1] = y;
	    for (var _t = 0; _t < 1; _t += 0.05) {
	        _v1[0] = cubicAt(x0, x1, x2, x3, _t);
	        _v1[1] = cubicAt(y0, y1, y2, y3, _t);
	        d1 = vector_1.distSquare(_v0, _v1);
	        if (d1 < d) {
	            t = _t;
	            d = d1;
	        }
	    }
	    d = Infinity;
	    for (var i = 0; i < 32; i++) {
	        if (interval < EPSILON_NUMERIC) {
	            break;
	        }
	        prev = t - interval;
	        next = t + interval;
	        _v1[0] = cubicAt(x0, x1, x2, x3, prev);
	        _v1[1] = cubicAt(y0, y1, y2, y3, prev);
	        d1 = vector_1.distSquare(_v1, _v0);
	        if (prev >= 0 && d1 < d) {
	            t = prev;
	            d = d1;
	        }
	        else {
	            _v2[0] = cubicAt(x0, x1, x2, x3, next);
	            _v2[1] = cubicAt(y0, y1, y2, y3, next);
	            d2 = vector_1.distSquare(_v2, _v0);
	            if (next <= 1 && d2 < d) {
	                t = next;
	                d = d2;
	            }
	            else {
	                interval *= 0.5;
	            }
	        }
	    }
	    if (out) {
	        out[0] = cubicAt(x0, x1, x2, x3, t);
	        out[1] = cubicAt(y0, y1, y2, y3, t);
	    }
	    return mathSqrt(d);
	}
	exports.cubicProjectPoint = cubicProjectPoint;
	function cubicLength(x0, y0, x1, y1, x2, y2, x3, y3, iteration) {
	    var px = x0;
	    var py = y0;
	    var d = 0;
	    var step = 1 / iteration;
	    for (var i = 1; i <= iteration; i++) {
	        var t = i * step;
	        var x = cubicAt(x0, x1, x2, x3, t);
	        var y = cubicAt(y0, y1, y2, y3, t);
	        var dx = x - px;
	        var dy = y - py;
	        d += Math.sqrt(dx * dx + dy * dy);
	        px = x;
	        py = y;
	    }
	    return d;
	}
	exports.cubicLength = cubicLength;
	function quadraticAt(p0, p1, p2, t) {
	    var onet = 1 - t;
	    return onet * (onet * p0 + 2 * t * p1) + t * t * p2;
	}
	exports.quadraticAt = quadraticAt;
	function quadraticDerivativeAt(p0, p1, p2, t) {
	    return 2 * ((1 - t) * (p1 - p0) + t * (p2 - p1));
	}
	exports.quadraticDerivativeAt = quadraticDerivativeAt;
	function quadraticRootAt(p0, p1, p2, val, roots) {
	    var a = p0 - 2 * p1 + p2;
	    var b = 2 * (p1 - p0);
	    var c = p0 - val;
	    var n = 0;
	    if (isAroundZero(a)) {
	        if (isNotAroundZero(b)) {
	            var t1 = -c / b;
	            if (t1 >= 0 && t1 <= 1) {
	                roots[n++] = t1;
	            }
	        }
	    }
	    else {
	        var disc = b * b - 4 * a * c;
	        if (isAroundZero(disc)) {
	            var t1 = -b / (2 * a);
	            if (t1 >= 0 && t1 <= 1) {
	                roots[n++] = t1;
	            }
	        }
	        else if (disc > 0) {
	            var discSqrt = mathSqrt(disc);
	            var t1 = (-b + discSqrt) / (2 * a);
	            var t2 = (-b - discSqrt) / (2 * a);
	            if (t1 >= 0 && t1 <= 1) {
	                roots[n++] = t1;
	            }
	            if (t2 >= 0 && t2 <= 1) {
	                roots[n++] = t2;
	            }
	        }
	    }
	    return n;
	}
	exports.quadraticRootAt = quadraticRootAt;
	function quadraticExtremum(p0, p1, p2) {
	    var divider = p0 + p2 - 2 * p1;
	    if (divider === 0) {
	        return 0.5;
	    }
	    else {
	        return (p0 - p1) / divider;
	    }
	}
	exports.quadraticExtremum = quadraticExtremum;
	function quadraticSubdivide(p0, p1, p2, t, out) {
	    var p01 = (p1 - p0) * t + p0;
	    var p12 = (p2 - p1) * t + p1;
	    var p012 = (p12 - p01) * t + p01;
	    out[0] = p0;
	    out[1] = p01;
	    out[2] = p012;
	    out[3] = p012;
	    out[4] = p12;
	    out[5] = p2;
	}
	exports.quadraticSubdivide = quadraticSubdivide;
	function quadraticProjectPoint(x0, y0, x1, y1, x2, y2, x, y, out) {
	    var t;
	    var interval = 0.005;
	    var d = Infinity;
	    _v0[0] = x;
	    _v0[1] = y;
	    for (var _t = 0; _t < 1; _t += 0.05) {
	        _v1[0] = quadraticAt(x0, x1, x2, _t);
	        _v1[1] = quadraticAt(y0, y1, y2, _t);
	        var d1 = vector_1.distSquare(_v0, _v1);
	        if (d1 < d) {
	            t = _t;
	            d = d1;
	        }
	    }
	    d = Infinity;
	    for (var i = 0; i < 32; i++) {
	        if (interval < EPSILON_NUMERIC) {
	            break;
	        }
	        var prev = t - interval;
	        var next = t + interval;
	        _v1[0] = quadraticAt(x0, x1, x2, prev);
	        _v1[1] = quadraticAt(y0, y1, y2, prev);
	        var d1 = vector_1.distSquare(_v1, _v0);
	        if (prev >= 0 && d1 < d) {
	            t = prev;
	            d = d1;
	        }
	        else {
	            _v2[0] = quadraticAt(x0, x1, x2, next);
	            _v2[1] = quadraticAt(y0, y1, y2, next);
	            var d2 = vector_1.distSquare(_v2, _v0);
	            if (next <= 1 && d2 < d) {
	                t = next;
	                d = d2;
	            }
	            else {
	                interval *= 0.5;
	            }
	        }
	    }
	    if (out) {
	        out[0] = quadraticAt(x0, x1, x2, t);
	        out[1] = quadraticAt(y0, y1, y2, t);
	    }
	    return mathSqrt(d);
	}
	exports.quadraticProjectPoint = quadraticProjectPoint;
	function quadraticLength(x0, y0, x1, y1, x2, y2, iteration) {
	    var px = x0;
	    var py = y0;
	    var d = 0;
	    var step = 1 / iteration;
	    for (var i = 1; i <= iteration; i++) {
	        var t = i * step;
	        var x = quadraticAt(x0, x1, x2, t);
	        var y = quadraticAt(y0, y1, y2, t);
	        var dx = x - px;
	        var dy = y - py;
	        d += Math.sqrt(dx * dx + dy * dy);
	        px = x;
	        py = y;
	    }
	    return d;
	}
	exports.quadraticLength = quadraticLength;


/***/ },
/* 34 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	exports.__esModule = true;
	var LRU_1 = __webpack_require__(59);
	var kCSSColorTable = {
	    'transparent': [0, 0, 0, 0], 'aliceblue': [240, 248, 255, 1],
	    'antiquewhite': [250, 235, 215, 1], 'aqua': [0, 255, 255, 1],
	    'aquamarine': [127, 255, 212, 1], 'azure': [240, 255, 255, 1],
	    'beige': [245, 245, 220, 1], 'bisque': [255, 228, 196, 1],
	    'black': [0, 0, 0, 1], 'blanchedalmond': [255, 235, 205, 1],
	    'blue': [0, 0, 255, 1], 'blueviolet': [138, 43, 226, 1],
	    'brown': [165, 42, 42, 1], 'burlywood': [222, 184, 135, 1],
	    'cadetblue': [95, 158, 160, 1], 'chartreuse': [127, 255, 0, 1],
	    'chocolate': [210, 105, 30, 1], 'coral': [255, 127, 80, 1],
	    'cornflowerblue': [100, 149, 237, 1], 'cornsilk': [255, 248, 220, 1],
	    'crimson': [220, 20, 60, 1], 'cyan': [0, 255, 255, 1],
	    'darkblue': [0, 0, 139, 1], 'darkcyan': [0, 139, 139, 1],
	    'darkgoldenrod': [184, 134, 11, 1], 'darkgray': [169, 169, 169, 1],
	    'darkgreen': [0, 100, 0, 1], 'darkgrey': [169, 169, 169, 1],
	    'darkkhaki': [189, 183, 107, 1], 'darkmagenta': [139, 0, 139, 1],
	    'darkolivegreen': [85, 107, 47, 1], 'darkorange': [255, 140, 0, 1],
	    'darkorchid': [153, 50, 204, 1], 'darkred': [139, 0, 0, 1],
	    'darksalmon': [233, 150, 122, 1], 'darkseagreen': [143, 188, 143, 1],
	    'darkslateblue': [72, 61, 139, 1], 'darkslategray': [47, 79, 79, 1],
	    'darkslategrey': [47, 79, 79, 1], 'darkturquoise': [0, 206, 209, 1],
	    'darkviolet': [148, 0, 211, 1], 'deeppink': [255, 20, 147, 1],
	    'deepskyblue': [0, 191, 255, 1], 'dimgray': [105, 105, 105, 1],
	    'dimgrey': [105, 105, 105, 1], 'dodgerblue': [30, 144, 255, 1],
	    'firebrick': [178, 34, 34, 1], 'floralwhite': [255, 250, 240, 1],
	    'forestgreen': [34, 139, 34, 1], 'fuchsia': [255, 0, 255, 1],
	    'gainsboro': [220, 220, 220, 1], 'ghostwhite': [248, 248, 255, 1],
	    'gold': [255, 215, 0, 1], 'goldenrod': [218, 165, 32, 1],
	    'gray': [128, 128, 128, 1], 'green': [0, 128, 0, 1],
	    'greenyellow': [173, 255, 47, 1], 'grey': [128, 128, 128, 1],
	    'honeydew': [240, 255, 240, 1], 'hotpink': [255, 105, 180, 1],
	    'indianred': [205, 92, 92, 1], 'indigo': [75, 0, 130, 1],
	    'ivory': [255, 255, 240, 1], 'khaki': [240, 230, 140, 1],
	    'lavender': [230, 230, 250, 1], 'lavenderblush': [255, 240, 245, 1],
	    'lawngreen': [124, 252, 0, 1], 'lemonchiffon': [255, 250, 205, 1],
	    'lightblue': [173, 216, 230, 1], 'lightcoral': [240, 128, 128, 1],
	    'lightcyan': [224, 255, 255, 1], 'lightgoldenrodyellow': [250, 250, 210, 1],
	    'lightgray': [211, 211, 211, 1], 'lightgreen': [144, 238, 144, 1],
	    'lightgrey': [211, 211, 211, 1], 'lightpink': [255, 182, 193, 1],
	    'lightsalmon': [255, 160, 122, 1], 'lightseagreen': [32, 178, 170, 1],
	    'lightskyblue': [135, 206, 250, 1], 'lightslategray': [119, 136, 153, 1],
	    'lightslategrey': [119, 136, 153, 1], 'lightsteelblue': [176, 196, 222, 1],
	    'lightyellow': [255, 255, 224, 1], 'lime': [0, 255, 0, 1],
	    'limegreen': [50, 205, 50, 1], 'linen': [250, 240, 230, 1],
	    'magenta': [255, 0, 255, 1], 'maroon': [128, 0, 0, 1],
	    'mediumaquamarine': [102, 205, 170, 1], 'mediumblue': [0, 0, 205, 1],
	    'mediumorchid': [186, 85, 211, 1], 'mediumpurple': [147, 112, 219, 1],
	    'mediumseagreen': [60, 179, 113, 1], 'mediumslateblue': [123, 104, 238, 1],
	    'mediumspringgreen': [0, 250, 154, 1], 'mediumturquoise': [72, 209, 204, 1],
	    'mediumvioletred': [199, 21, 133, 1], 'midnightblue': [25, 25, 112, 1],
	    'mintcream': [245, 255, 250, 1], 'mistyrose': [255, 228, 225, 1],
	    'moccasin': [255, 228, 181, 1], 'navajowhite': [255, 222, 173, 1],
	    'navy': [0, 0, 128, 1], 'oldlace': [253, 245, 230, 1],
	    'olive': [128, 128, 0, 1], 'olivedrab': [107, 142, 35, 1],
	    'orange': [255, 165, 0, 1], 'orangered': [255, 69, 0, 1],
	    'orchid': [218, 112, 214, 1], 'palegoldenrod': [238, 232, 170, 1],
	    'palegreen': [152, 251, 152, 1], 'paleturquoise': [175, 238, 238, 1],
	    'palevioletred': [219, 112, 147, 1], 'papayawhip': [255, 239, 213, 1],
	    'peachpuff': [255, 218, 185, 1], 'peru': [205, 133, 63, 1],
	    'pink': [255, 192, 203, 1], 'plum': [221, 160, 221, 1],
	    'powderblue': [176, 224, 230, 1], 'purple': [128, 0, 128, 1],
	    'red': [255, 0, 0, 1], 'rosybrown': [188, 143, 143, 1],
	    'royalblue': [65, 105, 225, 1], 'saddlebrown': [139, 69, 19, 1],
	    'salmon': [250, 128, 114, 1], 'sandybrown': [244, 164, 96, 1],
	    'seagreen': [46, 139, 87, 1], 'seashell': [255, 245, 238, 1],
	    'sienna': [160, 82, 45, 1], 'silver': [192, 192, 192, 1],
	    'skyblue': [135, 206, 235, 1], 'slateblue': [106, 90, 205, 1],
	    'slategray': [112, 128, 144, 1], 'slategrey': [112, 128, 144, 1],
	    'snow': [255, 250, 250, 1], 'springgreen': [0, 255, 127, 1],
	    'steelblue': [70, 130, 180, 1], 'tan': [210, 180, 140, 1],
	    'teal': [0, 128, 128, 1], 'thistle': [216, 191, 216, 1],
	    'tomato': [255, 99, 71, 1], 'turquoise': [64, 224, 208, 1],
	    'violet': [238, 130, 238, 1], 'wheat': [245, 222, 179, 1],
	    'white': [255, 255, 255, 1], 'whitesmoke': [245, 245, 245, 1],
	    'yellow': [255, 255, 0, 1], 'yellowgreen': [154, 205, 50, 1]
	};
	function clampCssByte(i) {
	    i = Math.round(i);
	    return i < 0 ? 0 : i > 255 ? 255 : i;
	}
	function clampCssAngle(i) {
	    i = Math.round(i);
	    return i < 0 ? 0 : i > 360 ? 360 : i;
	}
	function clampCssFloat(f) {
	    return f < 0 ? 0 : f > 1 ? 1 : f;
	}
	function parseCssInt(val) {
	    var str = val;
	    if (str.length && str.charAt(str.length - 1) === '%') {
	        return clampCssByte(parseFloat(str) / 100 * 255);
	    }
	    return clampCssByte(parseInt(str, 10));
	}
	function parseCssFloat(val) {
	    var str = val;
	    if (str.length && str.charAt(str.length - 1) === '%') {
	        return clampCssFloat(parseFloat(str) / 100);
	    }
	    return clampCssFloat(parseFloat(str));
	}
	function cssHueToRgb(m1, m2, h) {
	    if (h < 0) {
	        h += 1;
	    }
	    else if (h > 1) {
	        h -= 1;
	    }
	    if (h * 6 < 1) {
	        return m1 + (m2 - m1) * h * 6;
	    }
	    if (h * 2 < 1) {
	        return m2;
	    }
	    if (h * 3 < 2) {
	        return m1 + (m2 - m1) * (2 / 3 - h) * 6;
	    }
	    return m1;
	}
	function lerpNumber(a, b, p) {
	    return a + (b - a) * p;
	}
	function setRgba(out, r, g, b, a) {
	    out[0] = r;
	    out[1] = g;
	    out[2] = b;
	    out[3] = a;
	    return out;
	}
	function copyRgba(out, a) {
	    out[0] = a[0];
	    out[1] = a[1];
	    out[2] = a[2];
	    out[3] = a[3];
	    return out;
	}
	var colorCache = new LRU_1["default"](20);
	var lastRemovedArr = null;
	function putToCache(colorStr, rgbaArr) {
	    if (lastRemovedArr) {
	        copyRgba(lastRemovedArr, rgbaArr);
	    }
	    lastRemovedArr = colorCache.put(colorStr, lastRemovedArr || (rgbaArr.slice()));
	}
	function parse(colorStr, rgbaArr) {
	    if (!colorStr) {
	        return;
	    }
	    rgbaArr = rgbaArr || [];
	    var cached = colorCache.get(colorStr);
	    if (cached) {
	        return copyRgba(rgbaArr, cached);
	    }
	    colorStr = colorStr + '';
	    var str = colorStr.replace(/ /g, '').toLowerCase();
	    if (str in kCSSColorTable) {
	        copyRgba(rgbaArr, kCSSColorTable[str]);
	        putToCache(colorStr, rgbaArr);
	        return rgbaArr;
	    }
	    var strLen = str.length;
	    if (str.charAt(0) === '#') {
	        if (strLen === 4 || strLen === 5) {
	            var iv = parseInt(str.slice(1, 4), 16);
	            if (!(iv >= 0 && iv <= 0xfff)) {
	                setRgba(rgbaArr, 0, 0, 0, 1);
	                return;
	            }
	            setRgba(rgbaArr, ((iv & 0xf00) >> 4) | ((iv & 0xf00) >> 8), (iv & 0xf0) | ((iv & 0xf0) >> 4), (iv & 0xf) | ((iv & 0xf) << 4), strLen === 5 ? parseInt(str.slice(4), 16) / 0xf : 1);
	            putToCache(colorStr, rgbaArr);
	            return rgbaArr;
	        }
	        else if (strLen === 7 || strLen === 9) {
	            var iv = parseInt(str.slice(1, 7), 16);
	            if (!(iv >= 0 && iv <= 0xffffff)) {
	                setRgba(rgbaArr, 0, 0, 0, 1);
	                return;
	            }
	            setRgba(rgbaArr, (iv & 0xff0000) >> 16, (iv & 0xff00) >> 8, iv & 0xff, strLen === 9 ? parseInt(str.slice(7), 16) / 0xff : 1);
	            putToCache(colorStr, rgbaArr);
	            return rgbaArr;
	        }
	        return;
	    }
	    var op = str.indexOf('(');
	    var ep = str.indexOf(')');
	    if (op !== -1 && ep + 1 === strLen) {
	        var fname = str.substr(0, op);
	        var params = str.substr(op + 1, ep - (op + 1)).split(',');
	        var alpha = 1;
	        switch (fname) {
	            case 'rgba':
	                if (params.length !== 4) {
	                    return params.length === 3
	                        ? setRgba(rgbaArr, +params[0], +params[1], +params[2], 1)
	                        : setRgba(rgbaArr, 0, 0, 0, 1);
	                }
	                alpha = parseCssFloat(params.pop());
	            case 'rgb':
	                if (params.length !== 3) {
	                    setRgba(rgbaArr, 0, 0, 0, 1);
	                    return;
	                }
	                setRgba(rgbaArr, parseCssInt(params[0]), parseCssInt(params[1]), parseCssInt(params[2]), alpha);
	                putToCache(colorStr, rgbaArr);
	                return rgbaArr;
	            case 'hsla':
	                if (params.length !== 4) {
	                    setRgba(rgbaArr, 0, 0, 0, 1);
	                    return;
	                }
	                params[3] = parseCssFloat(params[3]);
	                hsla2rgba(params, rgbaArr);
	                putToCache(colorStr, rgbaArr);
	                return rgbaArr;
	            case 'hsl':
	                if (params.length !== 3) {
	                    setRgba(rgbaArr, 0, 0, 0, 1);
	                    return;
	                }
	                hsla2rgba(params, rgbaArr);
	                putToCache(colorStr, rgbaArr);
	                return rgbaArr;
	            default:
	                return;
	        }
	    }
	    setRgba(rgbaArr, 0, 0, 0, 1);
	    return;
	}
	exports.parse = parse;
	function hsla2rgba(hsla, rgba) {
	    var h = (((parseFloat(hsla[0]) % 360) + 360) % 360) / 360;
	    var s = parseCssFloat(hsla[1]);
	    var l = parseCssFloat(hsla[2]);
	    var m2 = l <= 0.5 ? l * (s + 1) : l + s - l * s;
	    var m1 = l * 2 - m2;
	    rgba = rgba || [];
	    setRgba(rgba, clampCssByte(cssHueToRgb(m1, m2, h + 1 / 3) * 255), clampCssByte(cssHueToRgb(m1, m2, h) * 255), clampCssByte(cssHueToRgb(m1, m2, h - 1 / 3) * 255), 1);
	    if (hsla.length === 4) {
	        rgba[3] = hsla[3];
	    }
	    return rgba;
	}
	function rgba2hsla(rgba) {
	    if (!rgba) {
	        return;
	    }
	    var R = rgba[0] / 255;
	    var G = rgba[1] / 255;
	    var B = rgba[2] / 255;
	    var vMin = Math.min(R, G, B);
	    var vMax = Math.max(R, G, B);
	    var delta = vMax - vMin;
	    var L = (vMax + vMin) / 2;
	    var H;
	    var S;
	    if (delta === 0) {
	        H = 0;
	        S = 0;
	    }
	    else {
	        if (L < 0.5) {
	            S = delta / (vMax + vMin);
	        }
	        else {
	            S = delta / (2 - vMax - vMin);
	        }
	        var deltaR = (((vMax - R) / 6) + (delta / 2)) / delta;
	        var deltaG = (((vMax - G) / 6) + (delta / 2)) / delta;
	        var deltaB = (((vMax - B) / 6) + (delta / 2)) / delta;
	        if (R === vMax) {
	            H = deltaB - deltaG;
	        }
	        else if (G === vMax) {
	            H = (1 / 3) + deltaR - deltaB;
	        }
	        else if (B === vMax) {
	            H = (2 / 3) + deltaG - deltaR;
	        }
	        if (H < 0) {
	            H += 1;
	        }
	        if (H > 1) {
	            H -= 1;
	        }
	    }
	    var hsla = [H * 360, S, L];
	    if (rgba[3] != null) {
	        hsla.push(rgba[3]);
	    }
	    return hsla;
	}
	function lift(color, level) {
	    var colorArr = parse(color);
	    if (colorArr) {
	        for (var i = 0; i < 3; i++) {
	            if (level < 0) {
	                colorArr[i] = colorArr[i] * (1 - level) | 0;
	            }
	            else {
	                colorArr[i] = ((255 - colorArr[i]) * level + colorArr[i]) | 0;
	            }
	            if (colorArr[i] > 255) {
	                colorArr[i] = 255;
	            }
	            else if (colorArr[i] < 0) {
	                colorArr[i] = 0;
	            }
	        }
	        return stringify(colorArr, colorArr.length === 4 ? 'rgba' : 'rgb');
	    }
	}
	exports.lift = lift;
	function toHex(color) {
	    var colorArr = parse(color);
	    if (colorArr) {
	        return ((1 << 24) + (colorArr[0] << 16) + (colorArr[1] << 8) + (+colorArr[2])).toString(16).slice(1);
	    }
	}
	exports.toHex = toHex;
	function fastLerp(normalizedValue, colors, out) {
	    if (!(colors && colors.length)
	        || !(normalizedValue >= 0 && normalizedValue <= 1)) {
	        return;
	    }
	    out = out || [];
	    var value = normalizedValue * (colors.length - 1);
	    var leftIndex = Math.floor(value);
	    var rightIndex = Math.ceil(value);
	    var leftColor = colors[leftIndex];
	    var rightColor = colors[rightIndex];
	    var dv = value - leftIndex;
	    out[0] = clampCssByte(lerpNumber(leftColor[0], rightColor[0], dv));
	    out[1] = clampCssByte(lerpNumber(leftColor[1], rightColor[1], dv));
	    out[2] = clampCssByte(lerpNumber(leftColor[2], rightColor[2], dv));
	    out[3] = clampCssFloat(lerpNumber(leftColor[3], rightColor[3], dv));
	    return out;
	}
	exports.fastLerp = fastLerp;
	exports.fastMapToColor = fastLerp;
	function lerp(normalizedValue, colors, fullOutput) {
	    if (!(colors && colors.length)
	        || !(normalizedValue >= 0 && normalizedValue <= 1)) {
	        return;
	    }
	    var value = normalizedValue * (colors.length - 1);
	    var leftIndex = Math.floor(value);
	    var rightIndex = Math.ceil(value);
	    var leftColor = parse(colors[leftIndex]);
	    var rightColor = parse(colors[rightIndex]);
	    var dv = value - leftIndex;
	    var color = stringify([
	        clampCssByte(lerpNumber(leftColor[0], rightColor[0], dv)),
	        clampCssByte(lerpNumber(leftColor[1], rightColor[1], dv)),
	        clampCssByte(lerpNumber(leftColor[2], rightColor[2], dv)),
	        clampCssFloat(lerpNumber(leftColor[3], rightColor[3], dv))
	    ], 'rgba');
	    return fullOutput
	        ? {
	            color: color,
	            leftIndex: leftIndex,
	            rightIndex: rightIndex,
	            value: value
	        }
	        : color;
	}
	exports.lerp = lerp;
	exports.mapToColor = lerp;
	function modifyHSL(color, h, s, l) {
	    var colorArr = parse(color);
	    if (color) {
	        colorArr = rgba2hsla(colorArr);
	        h != null && (colorArr[0] = clampCssAngle(h));
	        s != null && (colorArr[1] = parseCssFloat(s));
	        l != null && (colorArr[2] = parseCssFloat(l));
	        return stringify(hsla2rgba(colorArr), 'rgba');
	    }
	}
	exports.modifyHSL = modifyHSL;
	function modifyAlpha(color, alpha) {
	    var colorArr = parse(color);
	    if (colorArr && alpha != null) {
	        colorArr[3] = clampCssFloat(alpha);
	        return stringify(colorArr, 'rgba');
	    }
	}
	exports.modifyAlpha = modifyAlpha;
	function stringify(arrColor, type) {
	    if (!arrColor || !arrColor.length) {
	        return;
	    }
	    var colorStr = arrColor[0] + ',' + arrColor[1] + ',' + arrColor[2];
	    if (type === 'rgba' || type === 'hsva' || type === 'hsla') {
	        colorStr += ',' + arrColor[3];
	    }
	    return type + '(' + colorStr + ')';
	}
	exports.stringify = stringify;
	function lum(color, backgroundLum) {
	    var arr = parse(color);
	    return arr
	        ? (0.299 * arr[0] + 0.587 * arr[1] + 0.114 * arr[2]) * arr[3] / 255
	            + (1 - arr[3]) * backgroundLum
	        : 0;
	}
	exports.lum = lum;
	function random() {
	    var r = Math.round(Math.random() * 255);
	    var g = Math.round(Math.random() * 255);
	    var b = Math.round(Math.random() * 255);
	    return 'rgb(' + r + ',' + g + ',' + b + ')';
	}
	exports.random = random;


/***/ },
/* 35 */
/***/ function(module, exports, __webpack_require__) {

	
	/*
	* Licensed to the Apache Software Foundation (ASF) under one
	* or more contributor license agreements.  See the NOTICE file
	* distributed with this work for additional information
	* regarding copyright ownership.  The ASF licenses this file
	* to you under the Apache License, Version 2.0 (the
	* "License"); you may not use this file except in compliance
	* with the License.  You may obtain a copy of the License at
	*
	*   http://www.apache.org/licenses/LICENSE-2.0
	*
	* Unless required by applicable law or agreed to in writing,
	* software distributed under the License is distributed on an
	* "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
	* KIND, either express or implied.  See the License for the
	* specific language governing permissions and limitations
	* under the License.
	*/
	
	
	
	/**
	 * AUTO-GENERATED FILE. DO NOT MODIFY.
	 */
	
	"use strict";
	
	exports.__esModule = true;
	
	var echarts = __webpack_require__(6);
	
	__webpack_require__(297);
	
	__webpack_require__(298);
	
	var points_1 = __webpack_require__(354);
	
	var dataSample_1 = __webpack_require__(154);
	
	__webpack_require__(84);
	
	echarts.registerLayout(points_1["default"]('line', true));
	echarts.registerProcessor(echarts.PRIORITY.PROCESSOR.STATISTIC, dataSample_1["default"]('line'));

/***/ },
/* 36 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	exports.__esModule = true;
	var Transformable_1 = __webpack_require__(108);
	var Animator_1 = __webpack_require__(107);
	var BoundingRect_1 = __webpack_require__(17);
	var Eventful_1 = __webpack_require__(37);
	var text_1 = __webpack_require__(26);
	var util_1 = __webpack_require__(1);
	var config_1 = __webpack_require__(49);
	var color_1 = __webpack_require__(34);
	var env_1 = __webpack_require__(13);
	exports.PRESERVED_NORMAL_STATE = '__zr_normal__';
	var PRIMARY_STATES_KEYS = ['x', 'y', 'scaleX', 'scaleY', 'originX', 'originY', 'rotation', 'ignore'];
	var DEFAULT_ANIMATABLE_MAP = {
	    x: true,
	    y: true,
	    scaleX: true,
	    scaleY: true,
	    originX: true,
	    originY: true,
	    rotation: true,
	    ignore: false
	};
	var tmpTextPosCalcRes = {};
	var tmpBoundingRect = new BoundingRect_1["default"](0, 0, 0, 0);
	var Element = (function () {
	    function Element(props) {
	        this.id = util_1.guid();
	        this.animators = [];
	        this.currentStates = [];
	        this.states = {};
	        this._init(props);
	    }
	    Element.prototype._init = function (props) {
	        this.attr(props);
	    };
	    Element.prototype.drift = function (dx, dy, e) {
	        switch (this.draggable) {
	            case 'horizontal':
	                dy = 0;
	                break;
	            case 'vertical':
	                dx = 0;
	                break;
	        }
	        var m = this.transform;
	        if (!m) {
	            m = this.transform = [1, 0, 0, 1, 0, 0];
	        }
	        m[4] += dx;
	        m[5] += dy;
	        this.decomposeTransform();
	        this.markRedraw();
	    };
	    Element.prototype.beforeUpdate = function () { };
	    Element.prototype.afterUpdate = function () { };
	    Element.prototype.update = function () {
	        this.updateTransform();
	        if (this.__dirty) {
	            this.updateInnerText();
	        }
	    };
	    Element.prototype.updateInnerText = function (forceUpdate) {
	        var textEl = this._textContent;
	        if (textEl && (!textEl.ignore || forceUpdate)) {
	            if (!this.textConfig) {
	                this.textConfig = {};
	            }
	            var textConfig = this.textConfig;
	            var isLocal = textConfig.local;
	            var attachedTransform = textEl.attachedTransform;
	            var textAlign = void 0;
	            var textVerticalAlign = void 0;
	            var textStyleChanged = false;
	            if (isLocal) {
	                attachedTransform.parent = this;
	            }
	            else {
	                attachedTransform.parent = null;
	            }
	            var innerOrigin = false;
	            attachedTransform.x = textEl.x;
	            attachedTransform.y = textEl.y;
	            attachedTransform.originX = textEl.originX;
	            attachedTransform.originY = textEl.originY;
	            attachedTransform.rotation = textEl.rotation;
	            attachedTransform.scaleX = textEl.scaleX;
	            attachedTransform.scaleY = textEl.scaleY;
	            if (textConfig.position != null) {
	                var layoutRect = tmpBoundingRect;
	                if (textConfig.layoutRect) {
	                    layoutRect.copy(textConfig.layoutRect);
	                }
	                else {
	                    layoutRect.copy(this.getBoundingRect());
	                }
	                if (!isLocal) {
	                    layoutRect.applyTransform(this.transform);
	                }
	                if (this.calculateTextPosition) {
	                    this.calculateTextPosition(tmpTextPosCalcRes, textConfig, layoutRect);
	                }
	                else {
	                    text_1.calculateTextPosition(tmpTextPosCalcRes, textConfig, layoutRect);
	                }
	                attachedTransform.x = tmpTextPosCalcRes.x;
	                attachedTransform.y = tmpTextPosCalcRes.y;
	                textAlign = tmpTextPosCalcRes.align;
	                textVerticalAlign = tmpTextPosCalcRes.verticalAlign;
	                var textOrigin = textConfig.origin;
	                if (textOrigin && textConfig.rotation != null) {
	                    var relOriginX = void 0;
	                    var relOriginY = void 0;
	                    if (textOrigin === 'center') {
	                        relOriginX = layoutRect.width * 0.5;
	                        relOriginY = layoutRect.height * 0.5;
	                    }
	                    else {
	                        relOriginX = text_1.parsePercent(textOrigin[0], layoutRect.width);
	                        relOriginY = text_1.parsePercent(textOrigin[1], layoutRect.height);
	                    }
	                    innerOrigin = true;
	                    attachedTransform.originX = -attachedTransform.x + relOriginX + (isLocal ? 0 : layoutRect.x);
	                    attachedTransform.originY = -attachedTransform.y + relOriginY + (isLocal ? 0 : layoutRect.y);
	                }
	            }
	            if (textConfig.rotation != null) {
	                attachedTransform.rotation = textConfig.rotation;
	            }
	            var textOffset = textConfig.offset;
	            if (textOffset) {
	                attachedTransform.x += textOffset[0];
	                attachedTransform.y += textOffset[1];
	                if (!innerOrigin) {
	                    attachedTransform.originX = -textOffset[0];
	                    attachedTransform.originY = -textOffset[1];
	                }
	            }
	            var isInside = textConfig.inside == null
	                ? (typeof textConfig.position === 'string' && textConfig.position.indexOf('inside') >= 0)
	                : textConfig.inside;
	            var innerTextDefaultStyle = this._innerTextDefaultStyle || (this._innerTextDefaultStyle = {});
	            var textFill = void 0;
	            var textStroke = void 0;
	            var autoStroke = void 0;
	            if (isInside && this.canBeInsideText()) {
	                textFill = textConfig.insideFill;
	                textStroke = textConfig.insideStroke;
	                if (textFill == null || textFill === 'auto') {
	                    textFill = this.getInsideTextFill();
	                }
	                if (textStroke == null || textStroke === 'auto') {
	                    textStroke = this.getInsideTextStroke(textFill);
	                    autoStroke = true;
	                }
	            }
	            else {
	                textFill = textConfig.outsideFill;
	                textStroke = textConfig.outsideStroke;
	                if (textFill == null || textFill === 'auto') {
	                    textFill = this.getOutsideFill();
	                }
	                if (textStroke == null || textStroke === 'auto') {
	                    textStroke = this.getOutsideStroke(textFill);
	                    autoStroke = true;
	                }
	            }
	            textFill = textFill || '#000';
	            if (textFill !== innerTextDefaultStyle.fill
	                || textStroke !== innerTextDefaultStyle.stroke
	                || autoStroke !== innerTextDefaultStyle.autoStroke
	                || textAlign !== innerTextDefaultStyle.align
	                || textVerticalAlign !== innerTextDefaultStyle.verticalAlign) {
	                textStyleChanged = true;
	                innerTextDefaultStyle.fill = textFill;
	                innerTextDefaultStyle.stroke = textStroke;
	                innerTextDefaultStyle.autoStroke = autoStroke;
	                innerTextDefaultStyle.align = textAlign;
	                innerTextDefaultStyle.verticalAlign = textVerticalAlign;
	                textEl.setDefaultTextStyle(innerTextDefaultStyle);
	            }
	            if (textStyleChanged) {
	                textEl.dirtyStyle();
	            }
	            textEl.markRedraw();
	        }
	    };
	    Element.prototype.canBeInsideText = function () {
	        return true;
	    };
	    Element.prototype.getInsideTextFill = function () {
	        return '#fff';
	    };
	    Element.prototype.getInsideTextStroke = function (textFill) {
	        return '#000';
	    };
	    Element.prototype.getOutsideFill = function () {
	        return this.__zr && this.__zr.isDarkMode() ? config_1.LIGHT_LABEL_COLOR : config_1.DARK_LABEL_COLOR;
	    };
	    Element.prototype.getOutsideStroke = function (textFill) {
	        var backgroundColor = this.__zr && this.__zr.getBackgroundColor();
	        var colorArr = typeof backgroundColor === 'string' && color_1.parse(backgroundColor);
	        if (!colorArr) {
	            colorArr = [255, 255, 255, 1];
	        }
	        var alpha = colorArr[3];
	        var isDark = this.__zr.isDarkMode();
	        for (var i = 0; i < 3; i++) {
	            colorArr[i] = colorArr[i] * alpha + (isDark ? 0 : 255) * (1 - alpha);
	        }
	        colorArr[3] = 1;
	        return color_1.stringify(colorArr, 'rgba');
	    };
	    Element.prototype.traverse = function (cb, context) { };
	    Element.prototype.attrKV = function (key, value) {
	        if (key === 'textConfig') {
	            this.setTextConfig(value);
	        }
	        else if (key === 'textContent') {
	            this.setTextContent(value);
	        }
	        else if (key === 'clipPath') {
	            this.setClipPath(value);
	        }
	        else if (key === 'extra') {
	            this.extra = this.extra || {};
	            util_1.extend(this.extra, value);
	        }
	        else {
	            this[key] = value;
	        }
	    };
	    Element.prototype.hide = function () {
	        this.ignore = true;
	        this.markRedraw();
	    };
	    Element.prototype.show = function () {
	        this.ignore = false;
	        this.markRedraw();
	    };
	    Element.prototype.attr = function (keyOrObj, value) {
	        if (typeof keyOrObj === 'string') {
	            this.attrKV(keyOrObj, value);
	        }
	        else if (util_1.isObject(keyOrObj)) {
	            var obj = keyOrObj;
	            var keysArr = util_1.keys(obj);
	            for (var i = 0; i < keysArr.length; i++) {
	                var key = keysArr[i];
	                this.attrKV(key, keyOrObj[key]);
	            }
	        }
	        this.markRedraw();
	        return this;
	    };
	    Element.prototype.saveCurrentToNormalState = function (toState) {
	        this._innerSaveToNormal(toState);
	        var normalState = this._normalState;
	        for (var i = 0; i < this.animators.length; i++) {
	            var animator = this.animators[i];
	            var fromStateTransition = animator.__fromStateTransition;
	            if (fromStateTransition && fromStateTransition !== exports.PRESERVED_NORMAL_STATE) {
	                continue;
	            }
	            var targetName = animator.targetName;
	            var target = targetName
	                ? normalState[targetName] : normalState;
	            animator.saveFinalToTarget(target);
	        }
	    };
	    Element.prototype._innerSaveToNormal = function (toState) {
	        var normalState = this._normalState;
	        if (!normalState) {
	            normalState = this._normalState = {};
	        }
	        if (toState.textConfig && !normalState.textConfig) {
	            normalState.textConfig = this.textConfig;
	        }
	        this._savePrimaryToNormal(toState, normalState, PRIMARY_STATES_KEYS);
	    };
	    Element.prototype._savePrimaryToNormal = function (toState, normalState, primaryKeys) {
	        for (var i = 0; i < primaryKeys.length; i++) {
	            var key = primaryKeys[i];
	            if (toState[key] != null && !(key in normalState)) {
	                normalState[key] = this[key];
	            }
	        }
	    };
	    Element.prototype.hasState = function () {
	        return this.currentStates.length > 0;
	    };
	    Element.prototype.getState = function (name) {
	        return this.states[name];
	    };
	    Element.prototype.ensureState = function (name) {
	        var states = this.states;
	        if (!states[name]) {
	            states[name] = {};
	        }
	        return states[name];
	    };
	    Element.prototype.clearStates = function (noAnimation) {
	        this.useState(exports.PRESERVED_NORMAL_STATE, false, noAnimation);
	    };
	    Element.prototype.useState = function (stateName, keepCurrentStates, noAnimation) {
	        var toNormalState = stateName === exports.PRESERVED_NORMAL_STATE;
	        var hasStates = this.hasState();
	        if (!hasStates && toNormalState) {
	            return;
	        }
	        var currentStates = this.currentStates;
	        var animationCfg = this.stateTransition;
	        if (util_1.indexOf(currentStates, stateName) >= 0 && (keepCurrentStates || currentStates.length === 1)) {
	            return;
	        }
	        var state;
	        if (this.stateProxy && !toNormalState) {
	            state = this.stateProxy(stateName);
	        }
	        if (!state) {
	            state = (this.states && this.states[stateName]);
	        }
	        if (!state && !toNormalState) {
	            util_1.logError("State " + stateName + " not exists.");
	            return;
	        }
	        if (!toNormalState) {
	            this.saveCurrentToNormalState(state);
	        }
	        var useHoverLayer = !!(state && state.hoverLayer);
	        if (useHoverLayer) {
	            this._toggleHoverLayerFlag(true);
	        }
	        this._applyStateObj(stateName, state, this._normalState, keepCurrentStates, !noAnimation && !this.__inHover && animationCfg && animationCfg.duration > 0, animationCfg);
	        if (this._textContent) {
	            this._textContent.useState(stateName, keepCurrentStates);
	        }
	        if (this._textGuide) {
	            this._textGuide.useState(stateName, keepCurrentStates);
	        }
	        if (toNormalState) {
	            this.currentStates = [];
	            this._normalState = {};
	        }
	        else {
	            if (!keepCurrentStates) {
	                this.currentStates = [stateName];
	            }
	            else {
	                this.currentStates.push(stateName);
	            }
	        }
	        this._updateAnimationTargets();
	        this.markRedraw();
	        if (!useHoverLayer && this.__inHover) {
	            this._toggleHoverLayerFlag(false);
	            this.__dirty &= ~Element.REDARAW_BIT;
	        }
	        return state;
	    };
	    Element.prototype.useStates = function (states, noAnimation) {
	        if (!states.length) {
	            this.clearStates();
	        }
	        else {
	            var stateObjects = [];
	            var currentStates = this.currentStates;
	            var len = states.length;
	            var notChange = len === currentStates.length;
	            if (notChange) {
	                for (var i = 0; i < len; i++) {
	                    if (states[i] !== currentStates[i]) {
	                        notChange = false;
	                        break;
	                    }
	                }
	            }
	            if (notChange) {
	                return;
	            }
	            for (var i = 0; i < len; i++) {
	                var stateName = states[i];
	                var stateObj = void 0;
	                if (this.stateProxy) {
	                    stateObj = this.stateProxy(stateName, states);
	                }
	                if (!stateObj) {
	                    stateObj = this.states[stateName];
	                }
	                if (stateObj) {
	                    stateObjects.push(stateObj);
	                }
	            }
	            var useHoverLayer = !!(stateObjects[len - 1] && stateObjects[len - 1].hoverLayer);
	            if (useHoverLayer) {
	                this._toggleHoverLayerFlag(true);
	            }
	            var mergedState = this._mergeStates(stateObjects);
	            var animationCfg = this.stateTransition;
	            this.saveCurrentToNormalState(mergedState);
	            this._applyStateObj(states.join(','), mergedState, this._normalState, false, !noAnimation && !this.__inHover && animationCfg && animationCfg.duration > 0, animationCfg);
	            if (this._textContent) {
	                this._textContent.useStates(states);
	            }
	            if (this._textGuide) {
	                this._textGuide.useStates(states);
	            }
	            this._updateAnimationTargets();
	            this.currentStates = states.slice();
	            this.markRedraw();
	            if (!useHoverLayer && this.__inHover) {
	                this._toggleHoverLayerFlag(false);
	                this.__dirty &= ~Element.REDARAW_BIT;
	            }
	        }
	    };
	    Element.prototype._updateAnimationTargets = function () {
	        for (var i = 0; i < this.animators.length; i++) {
	            var animator = this.animators[i];
	            if (animator.targetName) {
	                animator.changeTarget(this[animator.targetName]);
	            }
	        }
	    };
	    Element.prototype.removeState = function (state) {
	        var idx = util_1.indexOf(this.currentStates, state);
	        if (idx >= 0) {
	            var currentStates = this.currentStates.slice();
	            currentStates.splice(idx, 1);
	            this.useStates(currentStates);
	        }
	    };
	    Element.prototype.replaceState = function (oldState, newState, forceAdd) {
	        var currentStates = this.currentStates.slice();
	        var idx = util_1.indexOf(currentStates, oldState);
	        var newStateExists = util_1.indexOf(currentStates, newState) >= 0;
	        if (idx >= 0) {
	            if (!newStateExists) {
	                currentStates[idx] = newState;
	            }
	            else {
	                currentStates.splice(idx, 1);
	            }
	        }
	        else if (forceAdd && !newStateExists) {
	            currentStates.push(newState);
	        }
	        this.useStates(currentStates);
	    };
	    Element.prototype.toggleState = function (state, enable) {
	        if (enable) {
	            this.useState(state, true);
	        }
	        else {
	            this.removeState(state);
	        }
	    };
	    Element.prototype._mergeStates = function (states) {
	        var mergedState = {};
	        var mergedTextConfig;
	        for (var i = 0; i < states.length; i++) {
	            var state = states[i];
	            util_1.extend(mergedState, state);
	            if (state.textConfig) {
	                mergedTextConfig = mergedTextConfig || {};
	                util_1.extend(mergedTextConfig, state.textConfig);
	            }
	        }
	        if (mergedTextConfig) {
	            mergedState.textConfig = mergedTextConfig;
	        }
	        return mergedState;
	    };
	    Element.prototype._applyStateObj = function (stateName, state, normalState, keepCurrentStates, transition, animationCfg) {
	        var needsRestoreToNormal = !(state && keepCurrentStates);
	        if (state && state.textConfig) {
	            this.textConfig = util_1.extend({}, keepCurrentStates ? this.textConfig : normalState.textConfig);
	            util_1.extend(this.textConfig, state.textConfig);
	        }
	        else if (needsRestoreToNormal) {
	            if (normalState.textConfig) {
	                this.textConfig = normalState.textConfig;
	            }
	        }
	        var transitionTarget = {};
	        var hasTransition = false;
	        for (var i = 0; i < PRIMARY_STATES_KEYS.length; i++) {
	            var key = PRIMARY_STATES_KEYS[i];
	            var propNeedsTransition = transition && DEFAULT_ANIMATABLE_MAP[key];
	            if (state && state[key] != null) {
	                if (propNeedsTransition) {
	                    hasTransition = true;
	                    transitionTarget[key] = state[key];
	                }
	                else {
	                    this[key] = state[key];
	                }
	            }
	            else if (needsRestoreToNormal) {
	                if (normalState[key] != null) {
	                    if (propNeedsTransition) {
	                        hasTransition = true;
	                        transitionTarget[key] = normalState[key];
	                    }
	                    else {
	                        this[key] = normalState[key];
	                    }
	                }
	            }
	        }
	        if (!transition) {
	            for (var i = 0; i < this.animators.length; i++) {
	                var animator = this.animators[i];
	                var targetName = animator.targetName;
	                animator.__changeFinalValue(targetName
	                    ? (state || normalState)[targetName]
	                    : (state || normalState));
	            }
	        }
	        if (hasTransition) {
	            this._transitionState(stateName, transitionTarget, animationCfg);
	        }
	    };
	    Element.prototype._attachComponent = function (componentEl) {
	        if (componentEl.__zr && !componentEl.__hostTarget) {
	            throw new Error('Text element has been added to zrender.');
	        }
	        if (componentEl === this) {
	            throw new Error('Recursive component attachment.');
	        }
	        var zr = this.__zr;
	        if (zr) {
	            componentEl.addSelfToZr(zr);
	        }
	        componentEl.__zr = zr;
	        componentEl.__hostTarget = this;
	    };
	    Element.prototype._detachComponent = function (componentEl) {
	        if (componentEl.__zr) {
	            componentEl.removeSelfFromZr(componentEl.__zr);
	        }
	        componentEl.__zr = null;
	        componentEl.__hostTarget = null;
	    };
	    Element.prototype.getClipPath = function () {
	        return this._clipPath;
	    };
	    Element.prototype.setClipPath = function (clipPath) {
	        if (this._clipPath && this._clipPath !== clipPath) {
	            this.removeClipPath();
	        }
	        this._attachComponent(clipPath);
	        this._clipPath = clipPath;
	        this.markRedraw();
	    };
	    Element.prototype.removeClipPath = function () {
	        var clipPath = this._clipPath;
	        if (clipPath) {
	            this._detachComponent(clipPath);
	            this._clipPath = null;
	            this.markRedraw();
	        }
	    };
	    Element.prototype.getTextContent = function () {
	        return this._textContent;
	    };
	    Element.prototype.setTextContent = function (textEl) {
	        var previousTextContent = this._textContent;
	        if (previousTextContent === textEl) {
	            return;
	        }
	        if (previousTextContent && previousTextContent !== textEl) {
	            this.removeTextContent();
	        }
	        if (textEl.__zr && !textEl.__hostTarget) {
	            throw new Error('Text element has been added to zrender.');
	        }
	        textEl.attachedTransform = new Transformable_1["default"]();
	        this._attachComponent(textEl);
	        this._textContent = textEl;
	        this.markRedraw();
	    };
	    Element.prototype.setTextConfig = function (cfg) {
	        if (!this.textConfig) {
	            this.textConfig = {};
	        }
	        util_1.extend(this.textConfig, cfg);
	        this.markRedraw();
	    };
	    Element.prototype.removeTextContent = function () {
	        var textEl = this._textContent;
	        if (textEl) {
	            textEl.attachedTransform = null;
	            this._detachComponent(textEl);
	            this._textContent = null;
	            this._innerTextDefaultStyle = null;
	            this.markRedraw();
	        }
	    };
	    Element.prototype.getTextGuideLine = function () {
	        return this._textGuide;
	    };
	    Element.prototype.setTextGuideLine = function (guideLine) {
	        if (this._textGuide && this._textGuide !== guideLine) {
	            this.removeTextGuideLine();
	        }
	        this._attachComponent(guideLine);
	        this._textGuide = guideLine;
	        this.markRedraw();
	    };
	    Element.prototype.removeTextGuideLine = function () {
	        var textGuide = this._textGuide;
	        if (textGuide) {
	            this._detachComponent(textGuide);
	            this._textGuide = null;
	            this.markRedraw();
	        }
	    };
	    Element.prototype.markRedraw = function () {
	        this.__dirty |= Element.REDARAW_BIT;
	        var zr = this.__zr;
	        if (zr) {
	            if (this.__inHover) {
	                zr.refreshHover();
	            }
	            else {
	                zr.refresh();
	            }
	        }
	        if (this.__hostTarget) {
	            this.__hostTarget.markRedraw();
	        }
	    };
	    Element.prototype.dirty = function () {
	        this.markRedraw();
	    };
	    Element.prototype._toggleHoverLayerFlag = function (inHover) {
	        this.__inHover = inHover;
	        var textContent = this._textContent;
	        var textGuide = this._textGuide;
	        if (textContent) {
	            textContent.__inHover = inHover;
	        }
	        if (textGuide) {
	            textGuide.__inHover = inHover;
	        }
	    };
	    Element.prototype.addSelfToZr = function (zr) {
	        this.__zr = zr;
	        var animators = this.animators;
	        if (animators) {
	            for (var i = 0; i < animators.length; i++) {
	                zr.animation.addAnimator(animators[i]);
	            }
	        }
	        if (this._clipPath) {
	            this._clipPath.addSelfToZr(zr);
	        }
	        if (this._textContent) {
	            this._textContent.addSelfToZr(zr);
	        }
	        if (this._textGuide) {
	            this._textGuide.addSelfToZr(zr);
	        }
	    };
	    Element.prototype.removeSelfFromZr = function (zr) {
	        this.__zr = null;
	        var animators = this.animators;
	        if (animators) {
	            for (var i = 0; i < animators.length; i++) {
	                zr.animation.removeAnimator(animators[i]);
	            }
	        }
	        if (this._clipPath) {
	            this._clipPath.removeSelfFromZr(zr);
	        }
	        if (this._textContent) {
	            this._textContent.removeSelfFromZr(zr);
	        }
	        if (this._textGuide) {
	            this._textGuide.removeSelfFromZr(zr);
	        }
	    };
	    Element.prototype.animate = function (key, loop) {
	        var target = key ? this[key] : this;
	        if (!target) {
	            util_1.logError('Property "'
	                + key
	                + '" is not existed in element '
	                + this.id);
	            return;
	        }
	        var animator = new Animator_1["default"](target, loop);
	        this.addAnimator(animator, key);
	        return animator;
	    };
	    Element.prototype.addAnimator = function (animator, key) {
	        var zr = this.__zr;
	        var el = this;
	        animator.during(function () {
	            el.updateDuringAnimation(key);
	        }).done(function () {
	            var animators = el.animators;
	            var idx = util_1.indexOf(animators, animator);
	            if (idx >= 0) {
	                animators.splice(idx, 1);
	            }
	        });
	        this.animators.push(animator);
	        if (zr) {
	            zr.animation.addAnimator(animator);
	        }
	        zr && zr.wakeUp();
	    };
	    Element.prototype.updateDuringAnimation = function (key) {
	        this.markRedraw();
	    };
	    Element.prototype.stopAnimation = function (scope, forwardToLast) {
	        var animators = this.animators;
	        var len = animators.length;
	        var leftAnimators = [];
	        for (var i = 0; i < len; i++) {
	            var animator = animators[i];
	            if (!scope || scope === animator.scope) {
	                animator.stop(forwardToLast);
	            }
	            else {
	                leftAnimators.push(animator);
	            }
	        }
	        this.animators = leftAnimators;
	        return this;
	    };
	    Element.prototype.animateTo = function (target, cfg, animationProps) {
	        animateTo(this, target, cfg, animationProps);
	    };
	    Element.prototype.animateFrom = function (target, cfg, animationProps) {
	        animateTo(this, target, cfg, animationProps, true);
	    };
	    Element.prototype._transitionState = function (stateName, target, cfg, animationProps) {
	        var animators = animateTo(this, target, cfg, animationProps);
	        for (var i = 0; i < animators.length; i++) {
	            animators[i].__fromStateTransition = stateName;
	        }
	    };
	    Element.prototype.getBoundingRect = function () {
	        return null;
	    };
	    Element.prototype.getPaintRect = function () {
	        return null;
	    };
	    Element.REDARAW_BIT = 1;
	    Element.initDefaultProps = (function () {
	        var elProto = Element.prototype;
	        elProto.type = 'element';
	        elProto.name = '';
	        elProto.ignore = false;
	        elProto.silent = false;
	        elProto.isGroup = false;
	        elProto.draggable = false;
	        elProto.dragging = false;
	        elProto.ignoreClip = false;
	        elProto.__inHover = false;
	        elProto.__dirty = Element.REDARAW_BIT;
	        var logs = {};
	        function logDeprecatedError(key, xKey, yKey) {
	            if (!logs[key + xKey + yKey]) {
	                console.warn("DEPRECATED: '" + key + "' has been deprecated. use '" + xKey + "', '" + yKey + "' instead");
	                logs[key + xKey + yKey] = true;
	            }
	        }
	        function createLegacyProperty(key, privateKey, xKey, yKey) {
	            Object.defineProperty(elProto, key, {
	                get: function () {
	                    logDeprecatedError(key, xKey, yKey);
	                    if (!this[privateKey]) {
	                        var pos = this[privateKey] = [];
	                        enhanceArray(this, pos);
	                    }
	                    return this[privateKey];
	                },
	                set: function (pos) {
	                    logDeprecatedError(key, xKey, yKey);
	                    this[xKey] = pos[0];
	                    this[yKey] = pos[1];
	                    this[privateKey] = pos;
	                    enhanceArray(this, pos);
	                }
	            });
	            function enhanceArray(self, pos) {
	                Object.defineProperty(pos, 0, {
	                    get: function () {
	                        return self[xKey];
	                    },
	                    set: function (val) {
	                        self[xKey] = val;
	                    }
	                });
	                Object.defineProperty(pos, 1, {
	                    get: function () {
	                        return self[yKey];
	                    },
	                    set: function (val) {
	                        self[yKey] = val;
	                    }
	                });
	            }
	        }
	        if (Object.defineProperty && (!env_1["default"].browser.ie || env_1["default"].browser.version > 8)) {
	            createLegacyProperty('position', '_legacyPos', 'x', 'y');
	            createLegacyProperty('scale', '_legacyScale', 'scaleX', 'scaleY');
	            createLegacyProperty('origin', '_legacyOrigin', 'originX', 'originY');
	        }
	    })();
	    return Element;
	}());
	util_1.mixin(Element, Eventful_1["default"]);
	util_1.mixin(Element, Transformable_1["default"]);
	function animateTo(animatable, target, cfg, animationProps, reverse) {
	    cfg = cfg || {};
	    var animators = [];
	    animateToShallow(animatable, '', animatable, target, cfg, animationProps, animators, reverse);
	    var finishCount = animators.length;
	    var doneHappened = false;
	    var cfgDone = cfg.done;
	    var cfgAborted = cfg.aborted;
	    var doneCb = function () {
	        doneHappened = true;
	        finishCount--;
	        if (finishCount <= 0) {
	            doneHappened
	                ? (cfgDone && cfgDone())
	                : (cfgAborted && cfgAborted());
	        }
	    };
	    var abortedCb = function () {
	        finishCount--;
	        if (finishCount <= 0) {
	            doneHappened
	                ? (cfgDone && cfgDone())
	                : (cfgAborted && cfgAborted());
	        }
	    };
	    if (!finishCount) {
	        cfgDone && cfgDone();
	    }
	    if (animators.length > 0 && cfg.during) {
	        animators[0].during(function (target, percent) {
	            cfg.during(percent);
	        });
	    }
	    for (var i = 0; i < animators.length; i++) {
	        var animator = animators[i];
	        if (doneCb) {
	            animator.done(doneCb);
	        }
	        if (abortedCb) {
	            animator.aborted(abortedCb);
	        }
	        animator.start(cfg.easing, cfg.force);
	    }
	    return animators;
	}
	function copyArrShallow(source, target, len) {
	    for (var i = 0; i < len; i++) {
	        source[i] = target[i];
	    }
	}
	function is2DArray(value) {
	    return util_1.isArrayLike(value[0]);
	}
	function copyValue(target, source, key) {
	    if (util_1.isArrayLike(source[key])) {
	        if (!util_1.isArrayLike(target[key])) {
	            target[key] = [];
	        }
	        if (util_1.isTypedArray(source[key])) {
	            var len = source[key].length;
	            if (target[key].length !== len) {
	                target[key] = new (source[key].constructor)(len);
	                copyArrShallow(target[key], source[key], len);
	            }
	        }
	        else {
	            var sourceArr = source[key];
	            var targetArr = target[key];
	            var len0 = sourceArr.length;
	            if (is2DArray(sourceArr)) {
	                var len1 = sourceArr[0].length;
	                for (var i = 0; i < len0; i++) {
	                    if (!targetArr[i]) {
	                        targetArr[i] = Array.prototype.slice.call(sourceArr[i]);
	                    }
	                    else {
	                        copyArrShallow(targetArr[i], sourceArr[i], len1);
	                    }
	                }
	            }
	            else {
	                copyArrShallow(targetArr, sourceArr, len0);
	            }
	            targetArr.length = sourceArr.length;
	        }
	    }
	    else {
	        target[key] = source[key];
	    }
	}
	function animateToShallow(animatable, topKey, source, target, cfg, animationProps, animators, reverse) {
	    var animatableKeys = [];
	    var changedKeys = [];
	    var targetKeys = util_1.keys(target);
	    var duration = cfg.duration;
	    var delay = cfg.delay;
	    var additive = cfg.additive;
	    var setToFinal = cfg.setToFinal;
	    var animateAll = !util_1.isObject(animationProps);
	    for (var k = 0; k < targetKeys.length; k++) {
	        var innerKey = targetKeys[k];
	        if (source[innerKey] != null
	            && target[innerKey] != null
	            && (animateAll || animationProps[innerKey])) {
	            if (util_1.isObject(target[innerKey]) && !util_1.isArrayLike(target[innerKey])) {
	                if (topKey) {
	                    if (!reverse) {
	                        source[innerKey] = target[innerKey];
	                        animatable.updateDuringAnimation(topKey);
	                    }
	                    continue;
	                }
	                animateToShallow(animatable, innerKey, source[innerKey], target[innerKey], cfg, animationProps && animationProps[innerKey], animators, reverse);
	            }
	            else {
	                animatableKeys.push(innerKey);
	                changedKeys.push(innerKey);
	            }
	        }
	        else if (!reverse) {
	            source[innerKey] = target[innerKey];
	            animatable.updateDuringAnimation(topKey);
	            changedKeys.push(innerKey);
	        }
	    }
	    var keyLen = animatableKeys.length;
	    if (keyLen > 0
	        || (cfg.force && !animators.length)) {
	        var existsAnimators = animatable.animators;
	        var existsAnimatorsOnSameTarget = [];
	        for (var i = 0; i < existsAnimators.length; i++) {
	            if (existsAnimators[i].targetName === topKey) {
	                existsAnimatorsOnSameTarget.push(existsAnimators[i]);
	            }
	        }
	        if (!additive && existsAnimatorsOnSameTarget.length) {
	            for (var i = 0; i < existsAnimatorsOnSameTarget.length; i++) {
	                var allAborted = existsAnimatorsOnSameTarget[i].stopTracks(changedKeys);
	                if (allAborted) {
	                    var idx = util_1.indexOf(existsAnimators, existsAnimatorsOnSameTarget[i]);
	                    existsAnimators.splice(idx, 1);
	                }
	            }
	        }
	        var revertedSource = void 0;
	        var reversedTarget = void 0;
	        var sourceClone = void 0;
	        if (reverse) {
	            reversedTarget = {};
	            if (setToFinal) {
	                revertedSource = {};
	            }
	            for (var i = 0; i < keyLen; i++) {
	                var innerKey = animatableKeys[i];
	                reversedTarget[innerKey] = source[innerKey];
	                if (setToFinal) {
	                    revertedSource[innerKey] = target[innerKey];
	                }
	                else {
	                    source[innerKey] = target[innerKey];
	                }
	            }
	        }
	        else if (setToFinal) {
	            sourceClone = {};
	            for (var i = 0; i < keyLen; i++) {
	                var innerKey = animatableKeys[i];
	                sourceClone[innerKey] = Animator_1.cloneValue(source[innerKey]);
	                copyValue(source, target, innerKey);
	            }
	        }
	        var animator = new Animator_1["default"](source, false, additive ? existsAnimatorsOnSameTarget : null);
	        animator.targetName = topKey;
	        if (cfg.scope) {
	            animator.scope = cfg.scope;
	        }
	        if (setToFinal && revertedSource) {
	            animator.whenWithKeys(0, revertedSource, animatableKeys);
	        }
	        if (sourceClone) {
	            animator.whenWithKeys(0, sourceClone, animatableKeys);
	        }
	        animator.whenWithKeys(duration == null ? 500 : duration, reverse ? reversedTarget : target, animatableKeys).delay(delay || 0);
	        animatable.addAnimator(animator, topKey);
	        animators.push(animator);
	    }
	}
	exports["default"] = Element;


/***/ },
/* 37 */
/***/ function(module, exports) {

	"use strict";
	exports.__esModule = true;
	var Eventful = (function () {
	    function Eventful(eventProcessors) {
	        if (eventProcessors) {
	            this._$eventProcessor = eventProcessors;
	        }
	    }
	    Eventful.prototype.on = function (event, query, handler, context) {
	        if (!this._$handlers) {
	            this._$handlers = {};
	        }
	        var _h = this._$handlers;
	        if (typeof query === 'function') {
	            context = handler;
	            handler = query;
	            query = null;
	        }
	        if (!handler || !event) {
	            return this;
	        }
	        var eventProcessor = this._$eventProcessor;
	        if (query != null && eventProcessor && eventProcessor.normalizeQuery) {
	            query = eventProcessor.normalizeQuery(query);
	        }
	        if (!_h[event]) {
	            _h[event] = [];
	        }
	        for (var i = 0; i < _h[event].length; i++) {
	            if (_h[event][i].h === handler) {
	                return this;
	            }
	        }
	        var wrap = {
	            h: handler,
	            query: query,
	            ctx: (context || this),
	            callAtLast: handler.zrEventfulCallAtLast
	        };
	        var lastIndex = _h[event].length - 1;
	        var lastWrap = _h[event][lastIndex];
	        (lastWrap && lastWrap.callAtLast)
	            ? _h[event].splice(lastIndex, 0, wrap)
	            : _h[event].push(wrap);
	        return this;
	    };
	    Eventful.prototype.isSilent = function (eventName) {
	        var _h = this._$handlers;
	        return !_h || !_h[eventName] || !_h[eventName].length;
	    };
	    Eventful.prototype.off = function (eventType, handler) {
	        var _h = this._$handlers;
	        if (!_h) {
	            return this;
	        }
	        if (!eventType) {
	            this._$handlers = {};
	            return this;
	        }
	        if (handler) {
	            if (_h[eventType]) {
	                var newList = [];
	                for (var i = 0, l = _h[eventType].length; i < l; i++) {
	                    if (_h[eventType][i].h !== handler) {
	                        newList.push(_h[eventType][i]);
	                    }
	                }
	                _h[eventType] = newList;
	            }
	            if (_h[eventType] && _h[eventType].length === 0) {
	                delete _h[eventType];
	            }
	        }
	        else {
	            delete _h[eventType];
	        }
	        return this;
	    };
	    Eventful.prototype.trigger = function (eventType) {
	        var args = [];
	        for (var _i = 1; _i < arguments.length; _i++) {
	            args[_i - 1] = arguments[_i];
	        }
	        if (!this._$handlers) {
	            return this;
	        }
	        var _h = this._$handlers[eventType];
	        var eventProcessor = this._$eventProcessor;
	        if (_h) {
	            var argLen = args.length;
	            var len = _h.length;
	            for (var i = 0; i < len; i++) {
	                var hItem = _h[i];
	                if (eventProcessor
	                    && eventProcessor.filter
	                    && hItem.query != null
	                    && !eventProcessor.filter(eventType, hItem.query)) {
	                    continue;
	                }
	                switch (argLen) {
	                    case 0:
	                        hItem.h.call(hItem.ctx);
	                        break;
	                    case 1:
	                        hItem.h.call(hItem.ctx, args[0]);
	                        break;
	                    case 2:
	                        hItem.h.call(hItem.ctx, args[0], args[1]);
	                        break;
	                    default:
	                        hItem.h.apply(hItem.ctx, args);
	                        break;
	                }
	            }
	        }
	        eventProcessor && eventProcessor.afterTrigger
	            && eventProcessor.afterTrigger(eventType);
	        return this;
	    };
	    Eventful.prototype.triggerWithContext = function (type) {
	        if (!this._$handlers) {
	            return this;
	        }
	        var _h = this._$handlers[type];
	        var eventProcessor = this._$eventProcessor;
	        if (_h) {
	            var args = arguments;
	            var argLen = args.length;
	            var ctx = args[argLen - 1];
	            var len = _h.length;
	            for (var i = 0; i < len; i++) {
	                var hItem = _h[i];
	                if (eventProcessor
	                    && eventProcessor.filter
	                    && hItem.query != null
	                    && !eventProcessor.filter(type, hItem.query)) {
	                    continue;
	                }
	                switch (argLen) {
	                    case 0:
	                        hItem.h.call(ctx);
	                        break;
	                    case 1:
	                        hItem.h.call(ctx, args[0]);
	                        break;
	                    case 2:
	                        hItem.h.call(ctx, args[0], args[1]);
	                        break;
	                    default:
	                        hItem.h.apply(ctx, args.slice(1, argLen - 1));
	                        break;
	                }
	            }
	        }
	        eventProcessor && eventProcessor.afterTrigger
	            && eventProcessor.afterTrigger(type);
	        return this;
	    };
	    return Eventful;
	}());
	exports["default"] = Eventful;


/***/ },
/* 38 */
/***/ function(module, exports, __webpack_require__) {

	
	/*
	* Licensed to the Apache Software Foundation (ASF) under one
	* or more contributor license agreements.  See the NOTICE file
	* distributed with this work for additional information
	* regarding copyright ownership.  The ASF licenses this file
	* to you under the Apache License, Version 2.0 (the
	* "License"); you may not use this file except in compliance
	* with the License.  You may obtain a copy of the License at
	*
	*   http://www.apache.org/licenses/LICENSE-2.0
	*
	* Unless required by applicable law or agreed to in writing,
	* software distributed under the License is distributed on an
	* "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
	* KIND, either express or implied.  See the License for the
	* specific language governing permissions and limitations
	* under the License.
	*/
	
	
	
	/**
	 * AUTO-GENERATED FILE. DO NOT MODIFY.
	 */
	
	"use strict";
	
	exports.__esModule = true;
	
	var echarts = __webpack_require__(6);
	
	var zrUtil = __webpack_require__(1);
	
	var barGrid_1 = __webpack_require__(149);
	
	__webpack_require__(342);
	
	__webpack_require__(290);
	
	__webpack_require__(291);
	
	__webpack_require__(289);
	
	__webpack_require__(84);
	
	var dataSample_1 = __webpack_require__(154);
	
	echarts.registerLayout(echarts.PRIORITY.VISUAL.LAYOUT, zrUtil.curry(barGrid_1.layout, 'bar'));
	echarts.registerLayout(echarts.PRIORITY.VISUAL.PROGRESSIVE_LAYOUT, barGrid_1.largeLayout);
	echarts.registerVisual({
	  seriesType: 'bar',
	  reset: function (seriesModel) {
	    seriesModel.getData().setVisual('legendSymbol', 'roundRect');
	  }
	});
	echarts.registerProcessor(echarts.PRIORITY.PROCESSOR.STATISTIC, dataSample_1["default"]('bar'));

/***/ },
/* 39 */
/***/ function(module, exports, __webpack_require__) {

	
	/*
	* Licensed to the Apache Software Foundation (ASF) under one
	* or more contributor license agreements.  See the NOTICE file
	* distributed with this work for additional information
	* regarding copyright ownership.  The ASF licenses this file
	* to you under the Apache License, Version 2.0 (the
	* "License"); you may not use this file except in compliance
	* with the License.  You may obtain a copy of the License at
	*
	*   http://www.apache.org/licenses/LICENSE-2.0
	*
	* Unless required by applicable law or agreed to in writing,
	* software distributed under the License is distributed on an
	* "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
	* KIND, either express or implied.  See the License for the
	* specific language governing permissions and limitations
	* under the License.
	*/
	
	
	
	/**
	 * AUTO-GENERATED FILE. DO NOT MODIFY.
	 */
	
	"use strict";
	
	exports.__esModule = true;
	
	var zrUtil = __webpack_require__(1);
	
	var Ordinal_1 = __webpack_require__(368);
	
	var Interval_1 = __webpack_require__(92);
	
	var Scale_1 = __webpack_require__(55);
	
	var barGrid_1 = __webpack_require__(149);
	
	var BoundingRect_1 = __webpack_require__(17);
	
	var Time_1 = __webpack_require__(369);
	
	var Log_1 = __webpack_require__(367);
	
	var dataStackHelper_1 = __webpack_require__(40);
	
	var scaleRawExtentInfo_1 = __webpack_require__(88);
	
	function getScaleExtent(scale, model) {
	  var scaleType = scale.type;
	  var rawExtentResult = scaleRawExtentInfo_1.ensureScaleRawExtentInfo(scale, model, scale.getExtent()).calculate();
	  scale.setBlank(rawExtentResult.isBlank);
	  var min = rawExtentResult.min;
	  var max = rawExtentResult.max;
	  var ecModel = model.ecModel;
	
	  if (ecModel && scaleType === 'time') {
	    var barSeriesModels = barGrid_1.prepareLayoutBarSeries('bar', ecModel);
	    var isBaseAxisAndHasBarSeries_1 = false;
	    zrUtil.each(barSeriesModels, function (seriesModel) {
	      isBaseAxisAndHasBarSeries_1 = isBaseAxisAndHasBarSeries_1 || seriesModel.getBaseAxis() === model.axis;
	    });
	
	    if (isBaseAxisAndHasBarSeries_1) {
	      var barWidthAndOffset = barGrid_1.makeColumnLayout(barSeriesModels);
	      var adjustedScale = adjustScaleForOverflow(min, max, model, barWidthAndOffset);
	      min = adjustedScale.min;
	      max = adjustedScale.max;
	    }
	  }
	
	  return {
	    extent: [min, max],
	    fixMin: rawExtentResult.minFixed,
	    fixMax: rawExtentResult.maxFixed
	  };
	}
	
	exports.getScaleExtent = getScaleExtent;
	
	function adjustScaleForOverflow(min, max, model, barWidthAndOffset) {
	  var axisExtent = model.axis.getExtent();
	  var axisLength = axisExtent[1] - axisExtent[0];
	  var barsOnCurrentAxis = barGrid_1.retrieveColumnLayout(barWidthAndOffset, model.axis);
	
	  if (barsOnCurrentAxis === undefined) {
	    return {
	      min: min,
	      max: max
	    };
	  }
	
	  var minOverflow = Infinity;
	  zrUtil.each(barsOnCurrentAxis, function (item) {
	    minOverflow = Math.min(item.offset, minOverflow);
	  });
	  var maxOverflow = -Infinity;
	  zrUtil.each(barsOnCurrentAxis, function (item) {
	    maxOverflow = Math.max(item.offset + item.width, maxOverflow);
	  });
	  minOverflow = Math.abs(minOverflow);
	  maxOverflow = Math.abs(maxOverflow);
	  var totalOverFlow = minOverflow + maxOverflow;
	  var oldRange = max - min;
	  var oldRangePercentOfNew = 1 - (minOverflow + maxOverflow) / axisLength;
	  var overflowBuffer = oldRange / oldRangePercentOfNew - oldRange;
	  max += overflowBuffer * (maxOverflow / totalOverFlow);
	  min -= overflowBuffer * (minOverflow / totalOverFlow);
	  return {
	    min: min,
	    max: max
	  };
	}
	
	function niceScaleExtent(scale, model) {
	  var extentInfo = getScaleExtent(scale, model);
	  var extent = extentInfo.extent;
	  var splitNumber = model.get('splitNumber');
	
	  if (scale instanceof Log_1["default"]) {
	    scale.base = model.get('logBase');
	  }
	
	  var scaleType = scale.type;
	  scale.setExtent(extent[0], extent[1]);
	  scale.niceExtent({
	    splitNumber: splitNumber,
	    fixMin: extentInfo.fixMin,
	    fixMax: extentInfo.fixMax,
	    minInterval: scaleType === 'interval' || scaleType === 'time' ? model.get('minInterval') : null,
	    maxInterval: scaleType === 'interval' || scaleType === 'time' ? model.get('maxInterval') : null
	  });
	  var interval = model.get('interval');
	
	  if (interval != null) {
	    scale.setInterval && scale.setInterval(interval);
	  }
	}
	
	exports.niceScaleExtent = niceScaleExtent;
	
	function createScaleByModel(model, axisType) {
	  axisType = axisType || model.get('type');
	
	  if (axisType) {
	    switch (axisType) {
	      case 'category':
	        return new Ordinal_1["default"]({
	          ordinalMeta: model.getOrdinalMeta ? model.getOrdinalMeta() : model.getCategories(),
	          extent: [Infinity, -Infinity]
	        });
	
	      case 'time':
	        return new Time_1["default"]({
	          locale: model.ecModel.getLocaleModel(),
	          useUTC: model.ecModel.get('useUTC')
	        });
	
	      default:
	        return new (Scale_1["default"].getClass(axisType) || Interval_1["default"])();
	    }
	  }
	}
	
	exports.createScaleByModel = createScaleByModel;
	
	function ifAxisCrossZero(axis) {
	  var dataExtent = axis.scale.getExtent();
	  var min = dataExtent[0];
	  var max = dataExtent[1];
	  return !(min > 0 && max > 0 || min < 0 && max < 0);
	}
	
	exports.ifAxisCrossZero = ifAxisCrossZero;
	
	function makeLabelFormatter(axis) {
	  var labelFormatter = axis.getLabelModel().get('formatter');
	  var categoryTickStart = axis.type === 'category' ? axis.scale.getExtent()[0] : null;
	
	  if (axis.scale.type === 'time') {
	    return function (tpl) {
	      return function (tick, idx) {
	        return axis.scale.getFormattedLabel(tick, idx, tpl);
	      };
	    }(labelFormatter);
	  } else if (typeof labelFormatter === 'string') {
	    return function (tpl) {
	      return function (tick) {
	        var label = axis.scale.getLabel(tick);
	        var text = tpl.replace('{value}', label != null ? label : '');
	        return text;
	      };
	    }(labelFormatter);
	  } else if (typeof labelFormatter === 'function') {
	    return function (cb) {
	      return function (tick, idx) {
	        if (categoryTickStart != null) {
	          idx = tick.value - categoryTickStart;
	        }
	
	        return cb(getAxisRawValue(axis, tick), idx, tick.level != null ? {
	          level: tick.level
	        } : null);
	      };
	    }(labelFormatter);
	  } else {
	    return function (tick) {
	      return axis.scale.getLabel(tick);
	    };
	  }
	}
	
	exports.makeLabelFormatter = makeLabelFormatter;
	
	function getAxisRawValue(axis, tick) {
	  return axis.type === 'category' ? axis.scale.getLabel(tick) : tick.value;
	}
	
	exports.getAxisRawValue = getAxisRawValue;
	
	function estimateLabelUnionRect(axis) {
	  var axisModel = axis.model;
	  var scale = axis.scale;
	
	  if (!axisModel.get(['axisLabel', 'show']) || scale.isBlank()) {
	    return;
	  }
	
	  var realNumberScaleTicks;
	  var tickCount;
	  var categoryScaleExtent = scale.getExtent();
	
	  if (scale instanceof Ordinal_1["default"]) {
	    tickCount = scale.count();
	  } else {
	    realNumberScaleTicks = scale.getTicks();
	    tickCount = realNumberScaleTicks.length;
	  }
	
	  var axisLabelModel = axis.getLabelModel();
	  var labelFormatter = makeLabelFormatter(axis);
	  var rect;
	  var step = 1;
	
	  if (tickCount > 40) {
	    step = Math.ceil(tickCount / 40);
	  }
	
	  for (var i = 0; i < tickCount; i += step) {
	    var tick = realNumberScaleTicks ? realNumberScaleTicks[i] : {
	      value: categoryScaleExtent[0] + i
	    };
	    var label = labelFormatter(tick, i);
	    var unrotatedSingleRect = axisLabelModel.getTextRect(label);
	    var singleRect = rotateTextRect(unrotatedSingleRect, axisLabelModel.get('rotate') || 0);
	    rect ? rect.union(singleRect) : rect = singleRect;
	  }
	
	  return rect;
	}
	
	exports.estimateLabelUnionRect = estimateLabelUnionRect;
	
	function rotateTextRect(textRect, rotate) {
	  var rotateRadians = rotate * Math.PI / 180;
	  var beforeWidth = textRect.width;
	  var beforeHeight = textRect.height;
	  var afterWidth = beforeWidth * Math.abs(Math.cos(rotateRadians)) + Math.abs(beforeHeight * Math.sin(rotateRadians));
	  var afterHeight = beforeWidth * Math.abs(Math.sin(rotateRadians)) + Math.abs(beforeHeight * Math.cos(rotateRadians));
	  var rotatedRect = new BoundingRect_1["default"](textRect.x, textRect.y, afterWidth, afterHeight);
	  return rotatedRect;
	}
	
	function getOptionCategoryInterval(model) {
	  var interval = model.get('interval');
	  return interval == null ? 'auto' : interval;
	}
	
	exports.getOptionCategoryInterval = getOptionCategoryInterval;
	
	function shouldShowAllLabels(axis) {
	  return axis.type === 'category' && getOptionCategoryInterval(axis.getLabelModel()) === 0;
	}
	
	exports.shouldShowAllLabels = shouldShowAllLabels;
	
	function getDataDimensionsOnAxis(data, axisDim) {
	  var dataDimMap = {};
	  zrUtil.each(data.mapDimensionsAll(axisDim), function (dataDim) {
	    dataDimMap[dataStackHelper_1.getStackedDimension(data, dataDim)] = true;
	  });
	  return zrUtil.keys(dataDimMap);
	}
	
	exports.getDataDimensionsOnAxis = getDataDimensionsOnAxis;
	
	function unionAxisExtentFromData(dataExtent, data, axisDim) {
	  if (data) {
	    zrUtil.each(getDataDimensionsOnAxis(data, axisDim), function (dim) {
	      var seriesExtent = data.getApproximateExtent(dim);
	      seriesExtent[0] < dataExtent[0] && (dataExtent[0] = seriesExtent[0]);
	      seriesExtent[1] > dataExtent[1] && (dataExtent[1] = seriesExtent[1]);
	    });
	  }
	}
	
	exports.unionAxisExtentFromData = unionAxisExtentFromData;

/***/ },
/* 40 */
/***/ function(module, exports, __webpack_require__) {

	
	/*
	* Licensed to the Apache Software Foundation (ASF) under one
	* or more contributor license agreements.  See the NOTICE file
	* distributed with this work for additional information
	* regarding copyright ownership.  The ASF licenses this file
	* to you under the Apache License, Version 2.0 (the
	* "License"); you may not use this file except in compliance
	* with the License.  You may obtain a copy of the License at
	*
	*   http://www.apache.org/licenses/LICENSE-2.0
	*
	* Unless required by applicable law or agreed to in writing,
	* software distributed under the License is distributed on an
	* "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
	* KIND, either express or implied.  See the License for the
	* specific language governing permissions and limitations
	* under the License.
	*/
	
	
	
	/**
	 * AUTO-GENERATED FILE. DO NOT MODIFY.
	 */
	
	"use strict";
	
	exports.__esModule = true;
	
	var util_1 = __webpack_require__(1);
	
	function enableDataStack(seriesModel, dimensionInfoList, opt) {
	  opt = opt || {};
	  var byIndex = opt.byIndex;
	  var stackedCoordDimension = opt.stackedCoordDimension;
	  var mayStack = !!(seriesModel && seriesModel.get('stack'));
	  var stackedByDimInfo;
	  var stackedDimInfo;
	  var stackResultDimension;
	  var stackedOverDimension;
	  util_1.each(dimensionInfoList, function (dimensionInfo, index) {
	    if (util_1.isString(dimensionInfo)) {
	      dimensionInfoList[index] = dimensionInfo = {
	        name: dimensionInfo
	      };
	    }
	
	    if (mayStack && !dimensionInfo.isExtraCoord) {
	      if (!byIndex && !stackedByDimInfo && dimensionInfo.ordinalMeta) {
	        stackedByDimInfo = dimensionInfo;
	      }
	
	      if (!stackedDimInfo && dimensionInfo.type !== 'ordinal' && dimensionInfo.type !== 'time' && (!stackedCoordDimension || stackedCoordDimension === dimensionInfo.coordDim)) {
	        stackedDimInfo = dimensionInfo;
	      }
	    }
	  });
	
	  if (stackedDimInfo && !byIndex && !stackedByDimInfo) {
	    byIndex = true;
	  }
	
	  if (stackedDimInfo) {
	    stackResultDimension = '__\0ecstackresult';
	    stackedOverDimension = '__\0ecstackedover';
	
	    if (stackedByDimInfo) {
	      stackedByDimInfo.createInvertedIndices = true;
	    }
	
	    var stackedDimCoordDim_1 = stackedDimInfo.coordDim;
	    var stackedDimType = stackedDimInfo.type;
	    var stackedDimCoordIndex_1 = 0;
	    util_1.each(dimensionInfoList, function (dimensionInfo) {
	      if (dimensionInfo.coordDim === stackedDimCoordDim_1) {
	        stackedDimCoordIndex_1++;
	      }
	    });
	    dimensionInfoList.push({
	      name: stackResultDimension,
	      coordDim: stackedDimCoordDim_1,
	      coordDimIndex: stackedDimCoordIndex_1,
	      type: stackedDimType,
	      isExtraCoord: true,
	      isCalculationCoord: true
	    });
	    stackedDimCoordIndex_1++;
	    dimensionInfoList.push({
	      name: stackedOverDimension,
	      coordDim: stackedOverDimension,
	      coordDimIndex: stackedDimCoordIndex_1,
	      type: stackedDimType,
	      isExtraCoord: true,
	      isCalculationCoord: true
	    });
	  }
	
	  return {
	    stackedDimension: stackedDimInfo && stackedDimInfo.name,
	    stackedByDimension: stackedByDimInfo && stackedByDimInfo.name,
	    isStackedByIndex: byIndex,
	    stackedOverDimension: stackedOverDimension,
	    stackResultDimension: stackResultDimension
	  };
	}
	
	exports.enableDataStack = enableDataStack;
	
	function isDimensionStacked(data, stackedDim) {
	  return !!stackedDim && stackedDim === data.getCalculationInfo('stackedDimension');
	}
	
	exports.isDimensionStacked = isDimensionStacked;
	
	function getStackedDimension(data, targetDim) {
	  return isDimensionStacked(data, targetDim) ? data.getCalculationInfo('stackResultDimension') : targetDim;
	}
	
	exports.getStackedDimension = getStackedDimension;

/***/ },
/* 41 */
/***/ function(module, exports, __webpack_require__) {

	
	/*
	* Licensed to the Apache Software Foundation (ASF) under one
	* or more contributor license agreements.  See the NOTICE file
	* distributed with this work for additional information
	* regarding copyright ownership.  The ASF licenses this file
	* to you under the Apache License, Version 2.0 (the
	* "License"); you may not use this file except in compliance
	* with the License.  You may obtain a copy of the License at
	*
	*   http://www.apache.org/licenses/LICENSE-2.0
	*
	* Unless required by applicable law or agreed to in writing,
	* software distributed under the License is distributed on an
	* "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
	* KIND, either express or implied.  See the License for the
	* specific language governing permissions and limitations
	* under the License.
	*/
	
	
	
	/**
	 * AUTO-GENERATED FILE. DO NOT MODIFY.
	 */
	
	"use strict";
	
	exports.__esModule = true;
	
	var zrUtil = __webpack_require__(1);
	
	var clazz_1 = __webpack_require__(28);
	
	var log_1 = __webpack_require__(12);
	
	var base = Math.round(Math.random() * 10);
	
	function getUID(type) {
	  return [type || '', base++].join('_');
	}
	
	exports.getUID = getUID;
	
	function enableSubTypeDefaulter(target) {
	  var subTypeDefaulters = {};
	
	  target.registerSubTypeDefaulter = function (componentType, defaulter) {
	    var componentTypeInfo = clazz_1.parseClassType(componentType);
	    subTypeDefaulters[componentTypeInfo.main] = defaulter;
	  };
	
	  target.determineSubType = function (componentType, option) {
	    var type = option.type;
	
	    if (!type) {
	      var componentTypeMain = clazz_1.parseClassType(componentType).main;
	
	      if (target.hasSubTypes(componentType) && subTypeDefaulters[componentTypeMain]) {
	        type = subTypeDefaulters[componentTypeMain](option);
	      }
	    }
	
	    return type;
	  };
	}
	
	exports.enableSubTypeDefaulter = enableSubTypeDefaulter;
	
	function enableTopologicalTravel(entity, dependencyGetter) {
	  entity.topologicalTravel = function (targetNameList, fullNameList, callback, context) {
	    if (!targetNameList.length) {
	      return;
	    }
	
	    var result = makeDepndencyGraph(fullNameList);
	    var graph = result.graph;
	    var noEntryList = result.noEntryList;
	    var targetNameSet = {};
	    zrUtil.each(targetNameList, function (name) {
	      targetNameSet[name] = true;
	    });
	
	    while (noEntryList.length) {
	      var currComponentType = noEntryList.pop();
	      var currVertex = graph[currComponentType];
	      var isInTargetNameSet = !!targetNameSet[currComponentType];
	
	      if (isInTargetNameSet) {
	        callback.call(context, currComponentType, currVertex.originalDeps.slice());
	        delete targetNameSet[currComponentType];
	      }
	
	      zrUtil.each(currVertex.successor, isInTargetNameSet ? removeEdgeAndAdd : removeEdge);
	    }
	
	    zrUtil.each(targetNameSet, function () {
	      var errMsg = '';
	
	      if (false) {
	        errMsg = log_1.makePrintable('Circle dependency may exists: ', targetNameSet, targetNameList, fullNameList);
	      }
	
	      throw new Error(errMsg);
	    });
	
	    function removeEdge(succComponentType) {
	      graph[succComponentType].entryCount--;
	
	      if (graph[succComponentType].entryCount === 0) {
	        noEntryList.push(succComponentType);
	      }
	    }
	
	    function removeEdgeAndAdd(succComponentType) {
	      targetNameSet[succComponentType] = true;
	      removeEdge(succComponentType);
	    }
	  };
	
	  function makeDepndencyGraph(fullNameList) {
	    var graph = {};
	    var noEntryList = [];
	    zrUtil.each(fullNameList, function (name) {
	      var thisItem = createDependencyGraphItem(graph, name);
	      var originalDeps = thisItem.originalDeps = dependencyGetter(name);
	      var availableDeps = getAvailableDependencies(originalDeps, fullNameList);
	      thisItem.entryCount = availableDeps.length;
	
	      if (thisItem.entryCount === 0) {
	        noEntryList.push(name);
	      }
	
	      zrUtil.each(availableDeps, function (dependentName) {
	        if (zrUtil.indexOf(thisItem.predecessor, dependentName) < 0) {
	          thisItem.predecessor.push(dependentName);
	        }
	
	        var thatItem = createDependencyGraphItem(graph, dependentName);
	
	        if (zrUtil.indexOf(thatItem.successor, dependentName) < 0) {
	          thatItem.successor.push(name);
	        }
	      });
	    });
	    return {
	      graph: graph,
	      noEntryList: noEntryList
	    };
	  }
	
	  function createDependencyGraphItem(graph, name) {
	    if (!graph[name]) {
	      graph[name] = {
	        predecessor: [],
	        successor: []
	      };
	    }
	
	    return graph[name];
	  }
	
	  function getAvailableDependencies(originalDeps, fullNameList) {
	    var availableDeps = [];
	    zrUtil.each(originalDeps, function (dep) {
	      zrUtil.indexOf(fullNameList, dep) >= 0 && availableDeps.push(dep);
	    });
	    return availableDeps;
	  }
	}
	
	exports.enableTopologicalTravel = enableTopologicalTravel;
	
	function inheritDefaultOption(superOption, subOption) {
	  return zrUtil.merge(zrUtil.merge({}, superOption, true), subOption, true);
	}
	
	exports.inheritDefaultOption = inheritDefaultOption;

/***/ },
/* 42 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	exports.__esModule = true;
	var Eventful_1 = __webpack_require__(37);
	exports.Dispatcher = Eventful_1["default"];
	var env_1 = __webpack_require__(13);
	var dom_1 = __webpack_require__(181);
	var isDomLevel2 = (typeof window !== 'undefined') && !!window.addEventListener;
	var MOUSE_EVENT_REG = /^(?:mouse|pointer|contextmenu|drag|drop)|click/;
	var _calcOut = [];
	function clientToLocal(el, e, out, calculate) {
	    out = out || {};
	    if (calculate || !env_1["default"].canvasSupported) {
	        calculateZrXY(el, e, out);
	    }
	    else if (env_1["default"].browser.firefox
	        && e.layerX != null
	        && e.layerX !== e.offsetX) {
	        out.zrX = e.layerX;
	        out.zrY = e.layerY;
	    }
	    else if (e.offsetX != null) {
	        out.zrX = e.offsetX;
	        out.zrY = e.offsetY;
	    }
	    else {
	        calculateZrXY(el, e, out);
	    }
	    return out;
	}
	exports.clientToLocal = clientToLocal;
	function calculateZrXY(el, e, out) {
	    if (env_1["default"].domSupported && el.getBoundingClientRect) {
	        var ex = e.clientX;
	        var ey = e.clientY;
	        if (dom_1.isCanvasEl(el)) {
	            var box = el.getBoundingClientRect();
	            out.zrX = ex - box.left;
	            out.zrY = ey - box.top;
	            return;
	        }
	        else {
	            if (dom_1.transformCoordWithViewport(_calcOut, el, ex, ey)) {
	                out.zrX = _calcOut[0];
	                out.zrY = _calcOut[1];
	                return;
	            }
	        }
	    }
	    out.zrX = out.zrY = 0;
	}
	function getNativeEvent(e) {
	    return e
	        || window.event;
	}
	exports.getNativeEvent = getNativeEvent;
	function normalizeEvent(el, e, calculate) {
	    e = getNativeEvent(e);
	    if (e.zrX != null) {
	        return e;
	    }
	    var eventType = e.type;
	    var isTouch = eventType && eventType.indexOf('touch') >= 0;
	    if (!isTouch) {
	        clientToLocal(el, e, e, calculate);
	        var wheelDelta = getWheelDeltaMayPolyfill(e);
	        e.zrDelta = wheelDelta ? wheelDelta / 120 : -(e.detail || 0) / 3;
	    }
	    else {
	        var touch = eventType !== 'touchend'
	            ? e.targetTouches[0]
	            : e.changedTouches[0];
	        touch && clientToLocal(el, touch, e, calculate);
	    }
	    var button = e.button;
	    if (e.which == null && button !== undefined && MOUSE_EVENT_REG.test(e.type)) {
	        e.which = (button & 1 ? 1 : (button & 2 ? 3 : (button & 4 ? 2 : 0)));
	    }
	    return e;
	}
	exports.normalizeEvent = normalizeEvent;
	function getWheelDeltaMayPolyfill(e) {
	    var rawWheelDelta = e.wheelDelta;
	    if (rawWheelDelta) {
	        return rawWheelDelta;
	    }
	    var deltaX = e.deltaX;
	    var deltaY = e.deltaY;
	    if (deltaX == null || deltaY == null) {
	        return rawWheelDelta;
	    }
	    var delta = deltaY !== 0 ? Math.abs(deltaY) : Math.abs(deltaX);
	    var sign = deltaY > 0 ? -1
	        : deltaY < 0 ? 1
	            : deltaX > 0 ? -1
	                : 1;
	    return 3 * delta * sign;
	}
	function addEventListener(el, name, handler, opt) {
	    if (isDomLevel2) {
	        el.addEventListener(name, handler, opt);
	    }
	    else {
	        el.attachEvent('on' + name, handler);
	    }
	}
	exports.addEventListener = addEventListener;
	function removeEventListener(el, name, handler, opt) {
	    if (isDomLevel2) {
	        el.removeEventListener(name, handler, opt);
	    }
	    else {
	        el.detachEvent('on' + name, handler);
	    }
	}
	exports.removeEventListener = removeEventListener;
	exports.stop = isDomLevel2
	    ? function (e) {
	        e.preventDefault();
	        e.stopPropagation();
	        e.cancelBubble = true;
	    }
	    : function (e) {
	        e.returnValue = false;
	        e.cancelBubble = true;
	    };
	function isMiddleOrRightButtonOnMouseUpDown(e) {
	    return e.which === 2 || e.which === 3;
	}
	exports.isMiddleOrRightButtonOnMouseUpDown = isMiddleOrRightButtonOnMouseUpDown;
	function notLeftMouse(e) {
	    return e.which > 1;
	}
	exports.notLeftMouse = notLeftMouse;


/***/ },
/* 43 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	exports.__esModule = true;
	var tslib_1 = __webpack_require__(5);
	var Displayable_1 = __webpack_require__(50);
	var BoundingRect_1 = __webpack_require__(17);
	var util_1 = __webpack_require__(1);
	exports.DEFAULT_IMAGE_STYLE = util_1.defaults({
	    x: 0,
	    y: 0
	}, Displayable_1.DEFAULT_COMMON_STYLE);
	exports.DEFAULT_IMAGE_ANIMATION_PROPS = {
	    style: util_1.defaults({
	        x: true,
	        y: true,
	        width: true,
	        height: true,
	        sx: true,
	        sy: true,
	        sWidth: true,
	        sHeight: true
	    }, Displayable_1.DEFAULT_COMMON_ANIMATION_PROPS.style)
	};
	function isImageLike(source) {
	    return !!(source
	        && typeof source !== 'string'
	        && source.width && source.height);
	}
	var ZRImage = (function (_super) {
	    tslib_1.__extends(ZRImage, _super);
	    function ZRImage() {
	        return _super !== null && _super.apply(this, arguments) || this;
	    }
	    ZRImage.prototype.createStyle = function (obj) {
	        return util_1.createObject(exports.DEFAULT_IMAGE_STYLE, obj);
	    };
	    ZRImage.prototype._getSize = function (dim) {
	        var style = this.style;
	        var size = style[dim];
	        if (size != null) {
	            return size;
	        }
	        var imageSource = isImageLike(style.image)
	            ? style.image : this.__image;
	        if (!imageSource) {
	            return 0;
	        }
	        var otherDim = dim === 'width' ? 'height' : 'width';
	        var otherDimSize = style[otherDim];
	        if (otherDimSize == null) {
	            return imageSource[dim];
	        }
	        else {
	            return imageSource[dim] / imageSource[otherDim] * otherDimSize;
	        }
	    };
	    ZRImage.prototype.getWidth = function () {
	        return this._getSize('width');
	    };
	    ZRImage.prototype.getHeight = function () {
	        return this._getSize('height');
	    };
	    ZRImage.prototype.getAnimationStyleProps = function () {
	        return exports.DEFAULT_IMAGE_ANIMATION_PROPS;
	    };
	    ZRImage.prototype.getBoundingRect = function () {
	        var style = this.style;
	        if (!this._rect) {
	            this._rect = new BoundingRect_1["default"](style.x || 0, style.y || 0, this.getWidth(), this.getHeight());
	        }
	        return this._rect;
	    };
	    return ZRImage;
	}(Displayable_1["default"]));
	ZRImage.prototype.type = 'image';
	exports["default"] = ZRImage;


/***/ },
/* 44 */
/***/ function(module, exports, __webpack_require__) {

	
	/**
	 * Expose `Emitter`.
	 */
	
	if (true) {
	  module.exports = Emitter;
	}
	
	/**
	 * Initialize a new `Emitter`.
	 *
	 * @api public
	 */
	
	function Emitter(obj) {
	  if (obj) return mixin(obj);
	};
	
	/**
	 * Mixin the emitter properties.
	 *
	 * @param {Object} obj
	 * @return {Object}
	 * @api private
	 */
	
	function mixin(obj) {
	  for (var key in Emitter.prototype) {
	    obj[key] = Emitter.prototype[key];
	  }
	  return obj;
	}
	
	/**
	 * Listen on the given `event` with `fn`.
	 *
	 * @param {String} event
	 * @param {Function} fn
	 * @return {Emitter}
	 * @api public
	 */
	
	Emitter.prototype.on =
	Emitter.prototype.addEventListener = function(event, fn){
	  this._callbacks = this._callbacks || {};
	  (this._callbacks['$' + event] = this._callbacks['$' + event] || [])
	    .push(fn);
	  return this;
	};
	
	/**
	 * Adds an `event` listener that will be invoked a single
	 * time then automatically removed.
	 *
	 * @param {String} event
	 * @param {Function} fn
	 * @return {Emitter}
	 * @api public
	 */
	
	Emitter.prototype.once = function(event, fn){
	  function on() {
	    this.off(event, on);
	    fn.apply(this, arguments);
	  }
	
	  on.fn = fn;
	  this.on(event, on);
	  return this;
	};
	
	/**
	 * Remove the given callback for `event` or all
	 * registered callbacks.
	 *
	 * @param {String} event
	 * @param {Function} fn
	 * @return {Emitter}
	 * @api public
	 */
	
	Emitter.prototype.off =
	Emitter.prototype.removeListener =
	Emitter.prototype.removeAllListeners =
	Emitter.prototype.removeEventListener = function(event, fn){
	  this._callbacks = this._callbacks || {};
	
	  // all
	  if (0 == arguments.length) {
	    this._callbacks = {};
	    return this;
	  }
	
	  // specific event
	  var callbacks = this._callbacks['$' + event];
	  if (!callbacks) return this;
	
	  // remove all handlers
	  if (1 == arguments.length) {
	    delete this._callbacks['$' + event];
	    return this;
	  }
	
	  // remove specific handler
	  var cb;
	  for (var i = 0; i < callbacks.length; i++) {
	    cb = callbacks[i];
	    if (cb === fn || cb.fn === fn) {
	      callbacks.splice(i, 1);
	      break;
	    }
	  }
	
	  // Remove event specific arrays for event types that no
	  // one is subscribed for to avoid memory leak.
	  if (callbacks.length === 0) {
	    delete this._callbacks['$' + event];
	  }
	
	  return this;
	};
	
	/**
	 * Emit `event` with the given args.
	 *
	 * @param {String} event
	 * @param {Mixed} ...
	 * @return {Emitter}
	 */
	
	Emitter.prototype.emit = function(event){
	  this._callbacks = this._callbacks || {};
	
	  var args = new Array(arguments.length - 1)
	    , callbacks = this._callbacks['$' + event];
	
	  for (var i = 1; i < arguments.length; i++) {
	    args[i - 1] = arguments[i];
	  }
	
	  if (callbacks) {
	    callbacks = callbacks.slice(0);
	    for (var i = 0, len = callbacks.length; i < len; ++i) {
	      callbacks[i].apply(this, args);
	    }
	  }
	
	  return this;
	};
	
	/**
	 * Return array of callbacks for `event`.
	 *
	 * @param {String} event
	 * @return {Array}
	 * @api public
	 */
	
	Emitter.prototype.listeners = function(event){
	  this._callbacks = this._callbacks || {};
	  return this._callbacks['$' + event] || [];
	};
	
	/**
	 * Check if this emitter has `event` handlers.
	 *
	 * @param {String} event
	 * @return {Boolean}
	 * @api public
	 */
	
	Emitter.prototype.hasListeners = function(event){
	  return !! this.listeners(event).length;
	};


/***/ },
/* 45 */
/***/ function(module, exports, __webpack_require__) {

	
	/*
	* Licensed to the Apache Software Foundation (ASF) under one
	* or more contributor license agreements.  See the NOTICE file
	* distributed with this work for additional information
	* regarding copyright ownership.  The ASF licenses this file
	* to you under the Apache License, Version 2.0 (the
	* "License"); you may not use this file except in compliance
	* with the License.  You may obtain a copy of the License at
	*
	*   http://www.apache.org/licenses/LICENSE-2.0
	*
	* Unless required by applicable law or agreed to in writing,
	* software distributed under the License is distributed on an
	* "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
	* KIND, either express or implied.  See the License for the
	* specific language governing permissions and limitations
	* under the License.
	*/
	
	
	
	/**
	 * AUTO-GENERATED FILE. DO NOT MODIFY.
	 */
	
	"use strict";
	
	exports.__esModule = true;
	
	var util_1 = __webpack_require__(1);
	
	exports.DATA_ZOOM_AXIS_DIMENSIONS = ['x', 'y', 'radius', 'angle', 'single'];
	var SERIES_COORDS = ['cartesian2d', 'polar', 'singleAxis'];
	
	function isCoordSupported(seriesModel) {
	  var coordType = seriesModel.get('coordinateSystem');
	  return util_1.indexOf(SERIES_COORDS, coordType) >= 0;
	}
	
	exports.isCoordSupported = isCoordSupported;
	
	function getAxisMainType(axisDim) {
	  if (false) {
	    util_1.assert(axisDim);
	  }
	
	  return axisDim + 'Axis';
	}
	
	exports.getAxisMainType = getAxisMainType;
	
	function getAxisIndexPropName(axisDim) {
	  if (false) {
	    util_1.assert(axisDim);
	  }
	
	  return axisDim + 'AxisIndex';
	}
	
	exports.getAxisIndexPropName = getAxisIndexPropName;
	
	function getAxisIdPropName(axisDim) {
	  if (false) {
	    util_1.assert(axisDim);
	  }
	
	  return axisDim + 'AxisId';
	}
	
	exports.getAxisIdPropName = getAxisIdPropName;
	
	function findEffectedDataZooms(ecModel, payload) {
	  var axisRecords = util_1.createHashMap();
	  var effectedModels = [];
	  var effectedModelMap = util_1.createHashMap();
	  ecModel.eachComponent({
	    mainType: 'dataZoom',
	    query: payload
	  }, function (dataZoomModel) {
	    if (!effectedModelMap.get(dataZoomModel.uid)) {
	      addToEffected(dataZoomModel);
	    }
	  });
	  var foundNewLink;
	
	  do {
	    foundNewLink = false;
	    ecModel.eachComponent('dataZoom', processSingle);
	  } while (foundNewLink);
	
	  function processSingle(dataZoomModel) {
	    if (!effectedModelMap.get(dataZoomModel.uid) && isLinked(dataZoomModel)) {
	      addToEffected(dataZoomModel);
	      foundNewLink = true;
	    }
	  }
	
	  function addToEffected(dataZoom) {
	    effectedModelMap.set(dataZoom.uid, true);
	    effectedModels.push(dataZoom);
	    markAxisControlled(dataZoom);
	  }
	
	  function isLinked(dataZoomModel) {
	    var isLink = false;
	    dataZoomModel.eachTargetAxis(function (axisDim, axisIndex) {
	      var axisIdxArr = axisRecords.get(axisDim);
	
	      if (axisIdxArr && axisIdxArr[axisIndex]) {
	        isLink = true;
	      }
	    });
	    return isLink;
	  }
	
	  function markAxisControlled(dataZoomModel) {
	    dataZoomModel.eachTargetAxis(function (axisDim, axisIndex) {
	      (axisRecords.get(axisDim) || axisRecords.set(axisDim, []))[axisIndex] = true;
	    });
	  }
	
	  return effectedModels;
	}
	
	exports.findEffectedDataZooms = findEffectedDataZooms;
	
	function collectReferCoordSysModelInfo(dataZoomModel) {
	  var ecModel = dataZoomModel.ecModel;
	  var coordSysInfoWrap = {
	    infoList: [],
	    infoMap: util_1.createHashMap()
	  };
	  dataZoomModel.eachTargetAxis(function (axisDim, axisIndex) {
	    var axisModel = ecModel.getComponent(getAxisMainType(axisDim), axisIndex);
	
	    if (!axisModel) {
	      return;
	    }
	
	    var coordSysModel = axisModel.getCoordSysModel();
	
	    if (!coordSysModel) {
	      return;
	    }
	
	    var coordSysUid = coordSysModel.uid;
	    var coordSysInfo = coordSysInfoWrap.infoMap.get(coordSysUid);
	
	    if (!coordSysInfo) {
	      coordSysInfo = {
	        model: coordSysModel,
	        axisModels: []
	      };
	      coordSysInfoWrap.infoList.push(coordSysInfo);
	      coordSysInfoWrap.infoMap.set(coordSysUid, coordSysInfo);
	    }
	
	    coordSysInfo.axisModels.push(axisModel);
	  });
	  return coordSysInfoWrap;
	}
	
	exports.collectReferCoordSysModelInfo = collectReferCoordSysModelInfo;

/***/ },
/* 46 */
/***/ function(module, exports, __webpack_require__) {

	
	/*
	* Licensed to the Apache Software Foundation (ASF) under one
	* or more contributor license agreements.  See the NOTICE file
	* distributed with this work for additional information
	* regarding copyright ownership.  The ASF licenses this file
	* to you under the Apache License, Version 2.0 (the
	* "License"); you may not use this file except in compliance
	* with the License.  You may obtain a copy of the License at
	*
	*   http://www.apache.org/licenses/LICENSE-2.0
	*
	* Unless required by applicable law or agreed to in writing,
	* software distributed under the License is distributed on an
	* "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
	* KIND, either express or implied.  See the License for the
	* specific language governing permissions and limitations
	* under the License.
	*/
	
	
	
	/**
	 * AUTO-GENERATED FILE. DO NOT MODIFY.
	 */
	
	"use strict";
	
	exports.__esModule = true;
	
	var echarts = __webpack_require__(6);
	
	__webpack_require__(324);
	
	__webpack_require__(325);
	
	echarts.registerPreprocessor(function (opt) {
	  opt.markLine = opt.markLine || {};
	});

/***/ },
/* 47 */
/***/ function(module, exports, __webpack_require__) {

	
	/*
	* Licensed to the Apache Software Foundation (ASF) under one
	* or more contributor license agreements.  See the NOTICE file
	* distributed with this work for additional information
	* regarding copyright ownership.  The ASF licenses this file
	* to you under the Apache License, Version 2.0 (the
	* "License"); you may not use this file except in compliance
	* with the License.  You may obtain a copy of the License at
	*
	*   http://www.apache.org/licenses/LICENSE-2.0
	*
	* Unless required by applicable law or agreed to in writing,
	* software distributed under the License is distributed on an
	* "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
	* KIND, either express or implied.  See the License for the
	* specific language governing permissions and limitations
	* under the License.
	*/
	
	
	
	/**
	 * AUTO-GENERATED FILE. DO NOT MODIFY.
	 */
	
	"use strict";
	
	exports.__esModule = true;
	
	var util_1 = __webpack_require__(1);
	
	var types_1 = __webpack_require__(25);
	
	var model_1 = __webpack_require__(4);
	
	;
	
	var SourceImpl = function () {
	  function SourceImpl(fields) {
	    this.data = fields.data || (fields.sourceFormat === types_1.SOURCE_FORMAT_KEYED_COLUMNS ? {} : []);
	    this.sourceFormat = fields.sourceFormat || types_1.SOURCE_FORMAT_UNKNOWN;
	    this.seriesLayoutBy = fields.seriesLayoutBy || types_1.SERIES_LAYOUT_BY_COLUMN;
	    this.startIndex = fields.startIndex || 0;
	    this.dimensionsDefine = fields.dimensionsDefine;
	    this.dimensionsDetectedCount = fields.dimensionsDetectedCount;
	    this.encodeDefine = fields.encodeDefine;
	    this.metaRawOption = fields.metaRawOption;
	  }
	
	  return SourceImpl;
	}();
	
	function isSourceInstance(val) {
	  return val instanceof SourceImpl;
	}
	
	exports.isSourceInstance = isSourceInstance;
	
	function createSource(sourceData, thisMetaRawOption, sourceFormat, encodeDefine) {
	  sourceFormat = sourceFormat || detectSourceFormat(sourceData);
	  var seriesLayoutBy = thisMetaRawOption.seriesLayoutBy;
	  var determined = determineSourceDimensions(sourceData, sourceFormat, seriesLayoutBy, thisMetaRawOption.sourceHeader, thisMetaRawOption.dimensions);
	  var source = new SourceImpl({
	    data: sourceData,
	    sourceFormat: sourceFormat,
	    seriesLayoutBy: seriesLayoutBy,
	    dimensionsDefine: determined.dimensionsDefine,
	    startIndex: determined.startIndex,
	    dimensionsDetectedCount: determined.dimensionsDetectedCount,
	    encodeDefine: makeEncodeDefine(encodeDefine),
	    metaRawOption: util_1.clone(thisMetaRawOption)
	  });
	  return source;
	}
	
	exports.createSource = createSource;
	
	function createSourceFromSeriesDataOption(data) {
	  return new SourceImpl({
	    data: data,
	    sourceFormat: util_1.isTypedArray(data) ? types_1.SOURCE_FORMAT_TYPED_ARRAY : types_1.SOURCE_FORMAT_ORIGINAL
	  });
	}
	
	exports.createSourceFromSeriesDataOption = createSourceFromSeriesDataOption;
	
	function cloneSourceShallow(source) {
	  return new SourceImpl({
	    data: source.data,
	    sourceFormat: source.sourceFormat,
	    seriesLayoutBy: source.seriesLayoutBy,
	    dimensionsDefine: util_1.clone(source.dimensionsDefine),
	    startIndex: source.startIndex,
	    dimensionsDetectedCount: source.dimensionsDetectedCount,
	    encodeDefine: makeEncodeDefine(source.encodeDefine)
	  });
	}
	
	exports.cloneSourceShallow = cloneSourceShallow;
	
	function makeEncodeDefine(encodeDefine) {
	  return encodeDefine ? util_1.createHashMap(encodeDefine) : null;
	}
	
	function detectSourceFormat(data) {
	  var sourceFormat = types_1.SOURCE_FORMAT_UNKNOWN;
	
	  if (util_1.isTypedArray(data)) {
	    sourceFormat = types_1.SOURCE_FORMAT_TYPED_ARRAY;
	  } else if (util_1.isArray(data)) {
	    if (data.length === 0) {
	      sourceFormat = types_1.SOURCE_FORMAT_ARRAY_ROWS;
	    }
	
	    for (var i = 0, len = data.length; i < len; i++) {
	      var item = data[i];
	
	      if (item == null) {
	        continue;
	      } else if (util_1.isArray(item)) {
	        sourceFormat = types_1.SOURCE_FORMAT_ARRAY_ROWS;
	        break;
	      } else if (util_1.isObject(item)) {
	        sourceFormat = types_1.SOURCE_FORMAT_OBJECT_ROWS;
	        break;
	      }
	    }
	  } else if (util_1.isObject(data)) {
	    for (var key in data) {
	      if (util_1.hasOwn(data, key) && util_1.isArrayLike(data[key])) {
	        sourceFormat = types_1.SOURCE_FORMAT_KEYED_COLUMNS;
	        break;
	      }
	    }
	  } else if (data != null) {
	    throw new Error('Invalid data');
	  }
	
	  return sourceFormat;
	}
	
	function determineSourceDimensions(data, sourceFormat, seriesLayoutBy, sourceHeader, dimensionsDefine) {
	  var dimensionsDetectedCount;
	  var startIndex;
	
	  if (!data) {
	    return {
	      dimensionsDefine: normalizeDimensionsOption(dimensionsDefine),
	      startIndex: startIndex,
	      dimensionsDetectedCount: dimensionsDetectedCount
	    };
	  }
	
	  if (sourceFormat === types_1.SOURCE_FORMAT_ARRAY_ROWS) {
	    var dataArrayRows = data;
	
	    if (sourceHeader === 'auto' || sourceHeader == null) {
	      arrayRowsTravelFirst(function (val) {
	        if (val != null && val !== '-') {
	          if (util_1.isString(val)) {
	            startIndex == null && (startIndex = 1);
	          } else {
	            startIndex = 0;
	          }
	        }
	      }, seriesLayoutBy, dataArrayRows, 10);
	    } else {
	      startIndex = util_1.isNumber(sourceHeader) ? sourceHeader : sourceHeader ? 1 : 0;
	    }
	
	    if (!dimensionsDefine && startIndex === 1) {
	      dimensionsDefine = [];
	      arrayRowsTravelFirst(function (val, index) {
	        dimensionsDefine[index] = val != null ? val + '' : '';
	      }, seriesLayoutBy, dataArrayRows, Infinity);
	    }
	
	    dimensionsDetectedCount = dimensionsDefine ? dimensionsDefine.length : seriesLayoutBy === types_1.SERIES_LAYOUT_BY_ROW ? dataArrayRows.length : dataArrayRows[0] ? dataArrayRows[0].length : null;
	  } else if (sourceFormat === types_1.SOURCE_FORMAT_OBJECT_ROWS) {
	    if (!dimensionsDefine) {
	      dimensionsDefine = objectRowsCollectDimensions(data);
	    }
	  } else if (sourceFormat === types_1.SOURCE_FORMAT_KEYED_COLUMNS) {
	    if (!dimensionsDefine) {
	      dimensionsDefine = [];
	      util_1.each(data, function (colArr, key) {
	        dimensionsDefine.push(key);
	      });
	    }
	  } else if (sourceFormat === types_1.SOURCE_FORMAT_ORIGINAL) {
	    var value0 = model_1.getDataItemValue(data[0]);
	    dimensionsDetectedCount = util_1.isArray(value0) && value0.length || 1;
	  } else if (sourceFormat === types_1.SOURCE_FORMAT_TYPED_ARRAY) {
	    if (false) {
	      util_1.assert(!!dimensionsDefine, 'dimensions must be given if data is TypedArray.');
	    }
	  }
	
	  return {
	    startIndex: startIndex,
	    dimensionsDefine: normalizeDimensionsOption(dimensionsDefine),
	    dimensionsDetectedCount: dimensionsDetectedCount
	  };
	}
	
	function objectRowsCollectDimensions(data) {
	  var firstIndex = 0;
	  var obj;
	
	  while (firstIndex < data.length && !(obj = data[firstIndex++])) {}
	
	  if (obj) {
	    var dimensions_1 = [];
	    util_1.each(obj, function (value, key) {
	      dimensions_1.push(key);
	    });
	    return dimensions_1;
	  }
	}
	
	function normalizeDimensionsOption(dimensionsDefine) {
	  if (!dimensionsDefine) {
	    return;
	  }
	
	  var nameMap = util_1.createHashMap();
	  return util_1.map(dimensionsDefine, function (rawItem, index) {
	    rawItem = util_1.isObject(rawItem) ? rawItem : {
	      name: rawItem
	    };
	    var item = {
	      name: rawItem.name,
	      displayName: rawItem.displayName,
	      type: rawItem.type
	    };
	
	    if (name == null) {
	      return item;
	    }
	
	    item.name += '';
	
	    if (item.displayName == null) {
	      item.displayName = item.name;
	    }
	
	    var exist = nameMap.get(item.name);
	
	    if (!exist) {
	      nameMap.set(item.name, {
	        count: 1
	      });
	    } else {
	      item.name += '-' + exist.count++;
	    }
	
	    return item;
	  });
	}
	
	function arrayRowsTravelFirst(cb, seriesLayoutBy, data, maxLoop) {
	  if (seriesLayoutBy === types_1.SERIES_LAYOUT_BY_ROW) {
	    for (var i = 0; i < data.length && i < maxLoop; i++) {
	      cb(data[i] ? data[i][0] : null, i);
	    }
	  } else {
	    var value0 = data[0] || [];
	
	    for (var i = 0; i < value0.length && i < maxLoop; i++) {
	      cb(value0[i], i);
	    }
	  }
	}

/***/ },
/* 48 */
/***/ function(module, exports, __webpack_require__) {

	
	/*
	* Licensed to the Apache Software Foundation (ASF) under one
	* or more contributor license agreements.  See the NOTICE file
	* distributed with this work for additional information
	* regarding copyright ownership.  The ASF licenses this file
	* to you under the Apache License, Version 2.0 (the
	* "License"); you may not use this file except in compliance
	* with the License.  You may obtain a copy of the License at
	*
	*   http://www.apache.org/licenses/LICENSE-2.0
	*
	* Unless required by applicable law or agreed to in writing,
	* software distributed under the License is distributed on an
	* "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
	* KIND, either express or implied.  See the License for the
	* specific language governing permissions and limitations
	* under the License.
	*/
	
	
	
	/**
	 * AUTO-GENERATED FILE. DO NOT MODIFY.
	 */
	
	"use strict";
	
	exports.__esModule = true;
	
	var zrUtil = __webpack_require__(1);
	
	var graphic = __webpack_require__(7);
	
	var BoundingRect_1 = __webpack_require__(17);
	
	var text_1 = __webpack_require__(26);
	
	var Triangle = graphic.Path.extend({
	  type: 'triangle',
	  shape: {
	    cx: 0,
	    cy: 0,
	    width: 0,
	    height: 0
	  },
	  buildPath: function (path, shape) {
	    var cx = shape.cx;
	    var cy = shape.cy;
	    var width = shape.width / 2;
	    var height = shape.height / 2;
	    path.moveTo(cx, cy - height);
	    path.lineTo(cx + width, cy + height);
	    path.lineTo(cx - width, cy + height);
	    path.closePath();
	  }
	});
	var Diamond = graphic.Path.extend({
	  type: 'diamond',
	  shape: {
	    cx: 0,
	    cy: 0,
	    width: 0,
	    height: 0
	  },
	  buildPath: function (path, shape) {
	    var cx = shape.cx;
	    var cy = shape.cy;
	    var width = shape.width / 2;
	    var height = shape.height / 2;
	    path.moveTo(cx, cy - height);
	    path.lineTo(cx + width, cy);
	    path.lineTo(cx, cy + height);
	    path.lineTo(cx - width, cy);
	    path.closePath();
	  }
	});
	var Pin = graphic.Path.extend({
	  type: 'pin',
	  shape: {
	    x: 0,
	    y: 0,
	    width: 0,
	    height: 0
	  },
	  buildPath: function (path, shape) {
	    var x = shape.x;
	    var y = shape.y;
	    var w = shape.width / 5 * 3;
	    var h = Math.max(w, shape.height);
	    var r = w / 2;
	    var dy = r * r / (h - r);
	    var cy = y - h + r + dy;
	    var angle = Math.asin(dy / r);
	    var dx = Math.cos(angle) * r;
	    var tanX = Math.sin(angle);
	    var tanY = Math.cos(angle);
	    var cpLen = r * 0.6;
	    var cpLen2 = r * 0.7;
	    path.moveTo(x - dx, cy + dy);
	    path.arc(x, cy, r, Math.PI - angle, Math.PI * 2 + angle);
	    path.bezierCurveTo(x + dx - tanX * cpLen, cy + dy + tanY * cpLen, x, y - cpLen2, x, y);
	    path.bezierCurveTo(x, y - cpLen2, x - dx + tanX * cpLen, cy + dy + tanY * cpLen, x - dx, cy + dy);
	    path.closePath();
	  }
	});
	var Arrow = graphic.Path.extend({
	  type: 'arrow',
	  shape: {
	    x: 0,
	    y: 0,
	    width: 0,
	    height: 0
	  },
	  buildPath: function (ctx, shape) {
	    var height = shape.height;
	    var width = shape.width;
	    var x = shape.x;
	    var y = shape.y;
	    var dx = width / 3 * 2;
	    ctx.moveTo(x, y);
	    ctx.lineTo(x + dx, y + height);
	    ctx.lineTo(x, y + height / 4 * 3);
	    ctx.lineTo(x - dx, y + height);
	    ctx.lineTo(x, y);
	    ctx.closePath();
	  }
	});
	var symbolCtors = {
	  line: graphic.Rect,
	  rect: graphic.Rect,
	  roundRect: graphic.Rect,
	  square: graphic.Rect,
	  circle: graphic.Circle,
	  diamond: Diamond,
	  pin: Pin,
	  arrow: Arrow,
	  triangle: Triangle
	};
	var symbolShapeMakers = {
	  line: function (x, y, w, h, shape) {
	    var thickness = 2;
	    shape.x = x;
	    shape.y = y + h / 2 - thickness / 2;
	    shape.width = w;
	    shape.height = thickness;
	  },
	  rect: function (x, y, w, h, shape) {
	    shape.x = x;
	    shape.y = y;
	    shape.width = w;
	    shape.height = h;
	  },
	  roundRect: function (x, y, w, h, shape) {
	    shape.x = x;
	    shape.y = y;
	    shape.width = w;
	    shape.height = h;
	    shape.r = Math.min(w, h) / 4;
	  },
	  square: function (x, y, w, h, shape) {
	    var size = Math.min(w, h);
	    shape.x = x;
	    shape.y = y;
	    shape.width = size;
	    shape.height = size;
	  },
	  circle: function (x, y, w, h, shape) {
	    shape.cx = x + w / 2;
	    shape.cy = y + h / 2;
	    shape.r = Math.min(w, h) / 2;
	  },
	  diamond: function (x, y, w, h, shape) {
	    shape.cx = x + w / 2;
	    shape.cy = y + h / 2;
	    shape.width = w;
	    shape.height = h;
	  },
	  pin: function (x, y, w, h, shape) {
	    shape.x = x + w / 2;
	    shape.y = y + h / 2;
	    shape.width = w;
	    shape.height = h;
	  },
	  arrow: function (x, y, w, h, shape) {
	    shape.x = x + w / 2;
	    shape.y = y + h / 2;
	    shape.width = w;
	    shape.height = h;
	  },
	  triangle: function (x, y, w, h, shape) {
	    shape.cx = x + w / 2;
	    shape.cy = y + h / 2;
	    shape.width = w;
	    shape.height = h;
	  }
	};
	exports.symbolBuildProxies = {};
	zrUtil.each(symbolCtors, function (Ctor, name) {
	  exports.symbolBuildProxies[name] = new Ctor();
	});
	var SymbolClz = graphic.Path.extend({
	  type: 'symbol',
	  shape: {
	    symbolType: '',
	    x: 0,
	    y: 0,
	    width: 0,
	    height: 0
	  },
	  calculateTextPosition: function (out, config, rect) {
	    var res = text_1.calculateTextPosition(out, config, rect);
	    var shape = this.shape;
	
	    if (shape && shape.symbolType === 'pin' && config.position === 'inside') {
	      res.y = rect.y + rect.height * 0.4;
	    }
	
	    return res;
	  },
	  buildPath: function (ctx, shape, inBundle) {
	    var symbolType = shape.symbolType;
	
	    if (symbolType !== 'none') {
	      var proxySymbol = exports.symbolBuildProxies[symbolType];
	
	      if (!proxySymbol) {
	        symbolType = 'rect';
	        proxySymbol = exports.symbolBuildProxies[symbolType];
	      }
	
	      symbolShapeMakers[symbolType](shape.x, shape.y, shape.width, shape.height, proxySymbol.shape);
	      proxySymbol.buildPath(ctx, proxySymbol.shape, inBundle);
	    }
	  }
	});
	
	function symbolPathSetColor(color, innerColor) {
	  if (this.type !== 'image') {
	    var symbolStyle = this.style;
	
	    if (this.__isEmptyBrush) {
	      symbolStyle.stroke = color;
	      symbolStyle.fill = innerColor || '#fff';
	      symbolStyle.lineWidth = 2;
	    } else {
	      symbolStyle.fill = color;
	    }
	
	    this.markRedraw();
	  }
	}
	
	function createSymbol(symbolType, x, y, w, h, color, keepAspect) {
	  var isEmpty = symbolType.indexOf('empty') === 0;
	
	  if (isEmpty) {
	    symbolType = symbolType.substr(5, 1).toLowerCase() + symbolType.substr(6);
	  }
	
	  var symbolPath;
	
	  if (symbolType.indexOf('image://') === 0) {
	    symbolPath = graphic.makeImage(symbolType.slice(8), new BoundingRect_1["default"](x, y, w, h), keepAspect ? 'center' : 'cover');
	  } else if (symbolType.indexOf('path://') === 0) {
	    symbolPath = graphic.makePath(symbolType.slice(7), {}, new BoundingRect_1["default"](x, y, w, h), keepAspect ? 'center' : 'cover');
	  } else {
	    symbolPath = new SymbolClz({
	      shape: {
	        symbolType: symbolType,
	        x: x,
	        y: y,
	        width: w,
	        height: h
	      }
	    });
	  }
	
	  symbolPath.__isEmptyBrush = isEmpty;
	  symbolPath.setColor = symbolPathSetColor;
	
	  if (color) {
	    symbolPath.setColor(color);
	  }
	
	  return symbolPath;
	}
	
	exports.createSymbol = createSymbol;

/***/ },
/* 49 */
/***/ function(module, exports) {

	"use strict";
	exports.__esModule = true;
	var dpr = 1;
	if (typeof window !== 'undefined') {
	    dpr = Math.max(window.devicePixelRatio
	        || (window.screen.deviceXDPI / window.screen.logicalXDPI)
	        || 1, 1);
	}
	exports.debugMode = 0;
	exports.devicePixelRatio = dpr;
	exports.DARK_MODE_THRESHOLD = 0.4;
	exports.DARK_LABEL_COLOR = '#333';
	exports.LIGHT_LABEL_COLOR = '#ccc';
	exports.LIGHTER_LABEL_COLOR = '#eee';


/***/ },
/* 50 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	exports.__esModule = true;
	var tslib_1 = __webpack_require__(5);
	var Element_1 = __webpack_require__(36);
	var BoundingRect_1 = __webpack_require__(17);
	var util_1 = __webpack_require__(1);
	var STYLE_MAGIC_KEY = '__zr_style_' + Math.round((Math.random() * 10));
	exports.DEFAULT_COMMON_STYLE = {
	    shadowBlur: 0,
	    shadowOffsetX: 0,
	    shadowOffsetY: 0,
	    shadowColor: '#000',
	    opacity: 1,
	    blend: 'source-over'
	};
	exports.DEFAULT_COMMON_ANIMATION_PROPS = {
	    style: {
	        shadowBlur: true,
	        shadowOffsetX: true,
	        shadowOffsetY: true,
	        shadowColor: true,
	        opacity: true
	    }
	};
	exports.DEFAULT_COMMON_STYLE[STYLE_MAGIC_KEY] = true;
	var PRIMARY_STATES_KEYS = ['z', 'z2', 'invisible'];
	var Displayable = (function (_super) {
	    tslib_1.__extends(Displayable, _super);
	    function Displayable(props) {
	        return _super.call(this, props) || this;
	    }
	    Displayable.prototype._init = function (props) {
	        var keysArr = util_1.keys(props);
	        for (var i = 0; i < keysArr.length; i++) {
	            var key = keysArr[i];
	            if (key === 'style') {
	                this.useStyle(props[key]);
	            }
	            else {
	                _super.prototype.attrKV.call(this, key, props[key]);
	            }
	        }
	        if (!this.style) {
	            this.useStyle({});
	        }
	    };
	    Displayable.prototype.beforeBrush = function () { };
	    Displayable.prototype.afterBrush = function () { };
	    Displayable.prototype.innerBeforeBrush = function () { };
	    Displayable.prototype.innerAfterBrush = function () { };
	    Displayable.prototype.shouldBePainted = function (viewWidth, viewHeight, considerClipPath, considerAncestors) {
	        var m = this.transform;
	        if (this.ignore
	            || this.invisible
	            || this.style.opacity === 0
	            || (this.culling
	                && isDisplayableCulled(this, viewWidth, viewHeight))
	            || (m && !m[0] && !m[3])) {
	            return false;
	        }
	        if (considerClipPath && this.__clipPaths) {
	            for (var i = 0; i < this.__clipPaths.length; ++i) {
	                if (this.__clipPaths[i].isZeroArea()) {
	                    return false;
	                }
	            }
	        }
	        if (considerAncestors && this.parent) {
	            var parent_1 = this.parent;
	            while (parent_1) {
	                if (parent_1.ignore) {
	                    return false;
	                }
	                parent_1 = parent_1.parent;
	            }
	        }
	        return true;
	    };
	    Displayable.prototype.contain = function (x, y) {
	        return this.rectContain(x, y);
	    };
	    Displayable.prototype.traverse = function (cb, context) {
	        cb.call(context, this);
	    };
	    Displayable.prototype.rectContain = function (x, y) {
	        var coord = this.transformCoordToLocal(x, y);
	        var rect = this.getBoundingRect();
	        return rect.contain(coord[0], coord[1]);
	    };
	    Displayable.prototype.getPaintRect = function () {
	        var rect = this._paintRect;
	        if (!this._paintRect || this.__dirty) {
	            var transform = this.transform;
	            var elRect = this.getBoundingRect();
	            var style = this.style;
	            var shadowSize = style.shadowBlur || 0;
	            var shadowOffsetX = style.shadowOffsetX || 0;
	            var shadowOffsetY = style.shadowOffsetY || 0;
	            rect = this._paintRect || (this._paintRect = new BoundingRect_1["default"](0, 0, 0, 0));
	            if (transform) {
	                BoundingRect_1["default"].applyTransform(rect, elRect, transform);
	            }
	            else {
	                rect.copy(elRect);
	            }
	            if (shadowSize || shadowOffsetX || shadowOffsetY) {
	                rect.width += shadowSize * 2 + Math.abs(shadowOffsetX);
	                rect.height += shadowSize * 2 + Math.abs(shadowOffsetY);
	                rect.x = Math.min(rect.x, rect.x + shadowOffsetX - shadowSize);
	                rect.y = Math.min(rect.y, rect.y + shadowOffsetY - shadowSize);
	            }
	            var tolerance = this.dirtyRectTolerance;
	            if (!rect.isZero()) {
	                rect.x = Math.floor(rect.x - tolerance);
	                rect.y = Math.floor(rect.y - tolerance);
	                rect.width = Math.ceil(rect.width + 1 + tolerance * 2);
	                rect.height = Math.ceil(rect.height + 1 + tolerance * 2);
	            }
	        }
	        return rect;
	    };
	    Displayable.prototype.setPrevPaintRect = function (paintRect) {
	        if (paintRect) {
	            this._prevPaintRect = this._prevPaintRect || new BoundingRect_1["default"](0, 0, 0, 0);
	            this._prevPaintRect.copy(paintRect);
	        }
	        else {
	            this._prevPaintRect = null;
	        }
	    };
	    Displayable.prototype.getPrevPaintRect = function () {
	        return this._prevPaintRect;
	    };
	    Displayable.prototype.animateStyle = function (loop) {
	        return this.animate('style', loop);
	    };
	    Displayable.prototype.updateDuringAnimation = function (targetKey) {
	        if (targetKey === 'style') {
	            this.dirtyStyle();
	        }
	        else {
	            this.markRedraw();
	        }
	    };
	    Displayable.prototype.attrKV = function (key, value) {
	        if (key !== 'style') {
	            _super.prototype.attrKV.call(this, key, value);
	        }
	        else {
	            if (!this.style) {
	                this.useStyle(value);
	            }
	            else {
	                this.setStyle(value);
	            }
	        }
	    };
	    Displayable.prototype.setStyle = function (keyOrObj, value) {
	        if (typeof keyOrObj === 'string') {
	            this.style[keyOrObj] = value;
	        }
	        else {
	            util_1.extend(this.style, keyOrObj);
	        }
	        this.dirtyStyle();
	        return this;
	    };
	    Displayable.prototype.dirtyStyle = function () {
	        this.markRedraw();
	        this.__dirty |= Displayable.STYLE_CHANGED_BIT;
	        if (this._rect) {
	            this._rect = null;
	        }
	    };
	    Displayable.prototype.dirty = function () {
	        this.dirtyStyle();
	    };
	    Displayable.prototype.styleChanged = function () {
	        return !!(this.__dirty & Displayable.STYLE_CHANGED_BIT);
	    };
	    Displayable.prototype.styleUpdated = function () {
	        this.__dirty &= ~Displayable.STYLE_CHANGED_BIT;
	    };
	    Displayable.prototype.createStyle = function (obj) {
	        return util_1.createObject(exports.DEFAULT_COMMON_STYLE, obj);
	    };
	    Displayable.prototype.useStyle = function (obj) {
	        if (!obj[STYLE_MAGIC_KEY]) {
	            obj = this.createStyle(obj);
	        }
	        if (this.__inHover) {
	            this.__hoverStyle = obj;
	        }
	        else {
	            this.style = obj;
	        }
	        this.dirtyStyle();
	    };
	    Displayable.prototype.isStyleObject = function (obj) {
	        return obj[STYLE_MAGIC_KEY];
	    };
	    Displayable.prototype._innerSaveToNormal = function (toState) {
	        _super.prototype._innerSaveToNormal.call(this, toState);
	        var normalState = this._normalState;
	        if (toState.style && !normalState.style) {
	            normalState.style = this._mergeStyle(this.createStyle(), this.style);
	        }
	        this._savePrimaryToNormal(toState, normalState, PRIMARY_STATES_KEYS);
	    };
	    Displayable.prototype._applyStateObj = function (stateName, state, normalState, keepCurrentStates, transition, animationCfg) {
	        _super.prototype._applyStateObj.call(this, stateName, state, normalState, keepCurrentStates, transition, animationCfg);
	        var needsRestoreToNormal = !(state && keepCurrentStates);
	        var targetStyle;
	        if (state && state.style) {
	            if (transition) {
	                if (keepCurrentStates) {
	                    targetStyle = state.style;
	                }
	                else {
	                    targetStyle = this._mergeStyle(this.createStyle(), normalState.style);
	                    this._mergeStyle(targetStyle, state.style);
	                }
	            }
	            else {
	                targetStyle = this._mergeStyle(this.createStyle(), keepCurrentStates ? this.style : normalState.style);
	                this._mergeStyle(targetStyle, state.style);
	            }
	        }
	        else if (needsRestoreToNormal) {
	            targetStyle = normalState.style;
	        }
	        if (targetStyle) {
	            if (transition) {
	                var sourceStyle = this.style;
	                this.style = this.createStyle(needsRestoreToNormal ? {} : sourceStyle);
	                if (needsRestoreToNormal) {
	                    var changedKeys = util_1.keys(sourceStyle);
	                    for (var i = 0; i < changedKeys.length; i++) {
	                        var key = changedKeys[i];
	                        if (key in targetStyle) {
	                            targetStyle[key] = targetStyle[key];
	                            this.style[key] = sourceStyle[key];
	                        }
	                    }
	                }
	                var targetKeys = util_1.keys(targetStyle);
	                for (var i = 0; i < targetKeys.length; i++) {
	                    var key = targetKeys[i];
	                    this.style[key] = this.style[key];
	                }
	                this._transitionState(stateName, {
	                    style: targetStyle
	                }, animationCfg, this.getAnimationStyleProps());
	            }
	            else {
	                this.useStyle(targetStyle);
	            }
	        }
	        for (var i = 0; i < PRIMARY_STATES_KEYS.length; i++) {
	            var key = PRIMARY_STATES_KEYS[i];
	            if (state && state[key] != null) {
	                this[key] = state[key];
	            }
	            else if (needsRestoreToNormal) {
	                if (normalState[key] != null) {
	                    this[key] = normalState[key];
	                }
	            }
	        }
	    };
	    Displayable.prototype._mergeStates = function (states) {
	        var mergedState = _super.prototype._mergeStates.call(this, states);
	        var mergedStyle;
	        for (var i = 0; i < states.length; i++) {
	            var state = states[i];
	            if (state.style) {
	                mergedStyle = mergedStyle || {};
	                this._mergeStyle(mergedStyle, state.style);
	            }
	        }
	        if (mergedStyle) {
	            mergedState.style = mergedStyle;
	        }
	        return mergedState;
	    };
	    Displayable.prototype._mergeStyle = function (targetStyle, sourceStyle) {
	        util_1.extend(targetStyle, sourceStyle);
	        return targetStyle;
	    };
	    Displayable.prototype.getAnimationStyleProps = function () {
	        return exports.DEFAULT_COMMON_ANIMATION_PROPS;
	    };
	    Displayable.STYLE_CHANGED_BIT = 2;
	    Displayable.initDefaultProps = (function () {
	        var dispProto = Displayable.prototype;
	        dispProto.type = 'displayable';
	        dispProto.invisible = false;
	        dispProto.z = 0;
	        dispProto.z2 = 0;
	        dispProto.zlevel = 0;
	        dispProto.culling = false;
	        dispProto.cursor = 'pointer';
	        dispProto.rectHover = false;
	        dispProto.incremental = false;
	        dispProto._rect = null;
	        dispProto.dirtyRectTolerance = 0;
	        dispProto.__dirty = Element_1["default"].REDARAW_BIT | Displayable.STYLE_CHANGED_BIT;
	    })();
	    return Displayable;
	}(Element_1["default"]));
	var tmpRect = new BoundingRect_1["default"](0, 0, 0, 0);
	var viewRect = new BoundingRect_1["default"](0, 0, 0, 0);
	function isDisplayableCulled(el, width, height) {
	    tmpRect.copy(el.getBoundingRect());
	    if (el.transform) {
	        tmpRect.applyTransform(el.transform);
	    }
	    viewRect.width = width;
	    viewRect.height = height;
	    return !tmpRect.intersect(viewRect);
	}
	exports["default"] = Displayable;


/***/ },
/* 51 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	exports.__esModule = true;
	var tslib_1 = __webpack_require__(5);
	var zrUtil = __webpack_require__(1);
	var Element_1 = __webpack_require__(36);
	var BoundingRect_1 = __webpack_require__(17);
	var Group = (function (_super) {
	    tslib_1.__extends(Group, _super);
	    function Group(opts) {
	        var _this = _super.call(this) || this;
	        _this.isGroup = true;
	        _this._children = [];
	        _this.attr(opts);
	        return _this;
	    }
	    Group.prototype.childrenRef = function () {
	        return this._children;
	    };
	    Group.prototype.children = function () {
	        return this._children.slice();
	    };
	    Group.prototype.childAt = function (idx) {
	        return this._children[idx];
	    };
	    Group.prototype.childOfName = function (name) {
	        var children = this._children;
	        for (var i = 0; i < children.length; i++) {
	            if (children[i].name === name) {
	                return children[i];
	            }
	        }
	    };
	    Group.prototype.childCount = function () {
	        return this._children.length;
	    };
	    Group.prototype.add = function (child) {
	        if (child) {
	            if (child !== this && child.parent !== this) {
	                this._children.push(child);
	                this._doAdd(child);
	            }
	            if (child.__hostTarget) {
	                throw 'This elemenet has been used as an attachment';
	            }
	        }
	        return this;
	    };
	    Group.prototype.addBefore = function (child, nextSibling) {
	        if (child && child !== this && child.parent !== this
	            && nextSibling && nextSibling.parent === this) {
	            var children = this._children;
	            var idx = children.indexOf(nextSibling);
	            if (idx >= 0) {
	                children.splice(idx, 0, child);
	                this._doAdd(child);
	            }
	        }
	        return this;
	    };
	    Group.prototype.replaceAt = function (child, index) {
	        var children = this._children;
	        var old = children[index];
	        if (child && child !== this && child.parent !== this && child !== old) {
	            children[index] = child;
	            old.parent = null;
	            var zr = this.__zr;
	            if (zr) {
	                old.removeSelfFromZr(zr);
	            }
	            this._doAdd(child);
	        }
	        return this;
	    };
	    Group.prototype._doAdd = function (child) {
	        if (child.parent) {
	            child.parent.remove(child);
	        }
	        child.parent = this;
	        var zr = this.__zr;
	        if (zr && zr !== child.__zr) {
	            child.addSelfToZr(zr);
	        }
	        zr && zr.refresh();
	    };
	    Group.prototype.remove = function (child) {
	        var zr = this.__zr;
	        var children = this._children;
	        var idx = zrUtil.indexOf(children, child);
	        if (idx < 0) {
	            return this;
	        }
	        children.splice(idx, 1);
	        child.parent = null;
	        if (zr) {
	            child.removeSelfFromZr(zr);
	        }
	        zr && zr.refresh();
	        return this;
	    };
	    Group.prototype.removeAll = function () {
	        var children = this._children;
	        var zr = this.__zr;
	        for (var i = 0; i < children.length; i++) {
	            var child = children[i];
	            if (zr) {
	                child.removeSelfFromZr(zr);
	            }
	            child.parent = null;
	        }
	        children.length = 0;
	        return this;
	    };
	    Group.prototype.eachChild = function (cb, context) {
	        var children = this._children;
	        for (var i = 0; i < children.length; i++) {
	            var child = children[i];
	            cb.call(context, child, i);
	        }
	        return this;
	    };
	    Group.prototype.traverse = function (cb, context) {
	        for (var i = 0; i < this._children.length; i++) {
	            var child = this._children[i];
	            var stopped = cb.call(context, child);
	            if (child.isGroup && !stopped) {
	                child.traverse(cb, context);
	            }
	        }
	        return this;
	    };
	    Group.prototype.addSelfToZr = function (zr) {
	        _super.prototype.addSelfToZr.call(this, zr);
	        for (var i = 0; i < this._children.length; i++) {
	            var child = this._children[i];
	            child.addSelfToZr(zr);
	        }
	    };
	    Group.prototype.removeSelfFromZr = function (zr) {
	        _super.prototype.removeSelfFromZr.call(this, zr);
	        for (var i = 0; i < this._children.length; i++) {
	            var child = this._children[i];
	            child.removeSelfFromZr(zr);
	        }
	    };
	    Group.prototype.getBoundingRect = function (includeChildren) {
	        var tmpRect = new BoundingRect_1["default"](0, 0, 0, 0);
	        var children = includeChildren || this._children;
	        var tmpMat = [];
	        var rect = null;
	        for (var i = 0; i < children.length; i++) {
	            var child = children[i];
	            if (child.ignore || child.invisible) {
	                continue;
	            }
	            var childRect = child.getBoundingRect();
	            var transform = child.getLocalTransform(tmpMat);
	            if (transform) {
	                BoundingRect_1["default"].applyTransform(tmpRect, childRect, transform);
	                rect = rect || tmpRect.clone();
	                rect.union(tmpRect);
	            }
	            else {
	                rect = rect || childRect.clone();
	                rect.union(childRect);
	            }
	        }
	        return rect || tmpRect;
	    };
	    return Group;
	}(Element_1["default"]));
	Group.prototype.type = 'group';
	exports["default"] = Group;


/***/ },
/* 52 */
/***/ function(module, exports, __webpack_require__) {

	
	/*
	* Licensed to the Apache Software Foundation (ASF) under one
	* or more contributor license agreements.  See the NOTICE file
	* distributed with this work for additional information
	* regarding copyright ownership.  The ASF licenses this file
	* to you under the Apache License, Version 2.0 (the
	* "License"); you may not use this file except in compliance
	* with the License.  You may obtain a copy of the License at
	*
	*   http://www.apache.org/licenses/LICENSE-2.0
	*
	* Unless required by applicable law or agreed to in writing,
	* software distributed under the License is distributed on an
	* "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
	* KIND, either express or implied.  See the License for the
	* specific language governing permissions and limitations
	* under the License.
	*/
	
	
	
	/**
	 * AUTO-GENERATED FILE. DO NOT MODIFY.
	 */
	
	"use strict";
	
	exports.__esModule = true;
	
	var format_1 = __webpack_require__(29);
	
	var util_1 = __webpack_require__(1);
	
	var dataValueHelper_1 = __webpack_require__(89);
	
	var number_1 = __webpack_require__(9);
	
	var TOOLTIP_NAME_TEXT_STYLE_CSS = 'font-size:12px;color:#6e7079';
	var TOOLTIP_TEXT_STYLE_RICH = {
	  fontSize: 12,
	  fill: '#6e7079'
	};
	var TOOLTIP_VALUE_TEXT_STYLE_CSS = 'font-size:14px;color:#464646;font-weight:900';
	var TOOLTIP_VALUE_TEXT_STYLE_RICH = {
	  fontSize: 14,
	  fill: '#464646',
	  fontWeight: 900
	};
	var TOOLTIP_LINE_HEIGHT_CSS = 'line-height:1';
	var HTML_GAPS = [0, 10, 20, 30];
	var RICH_TEXT_GAPS = ['', '\n', '\n\n', '\n\n\n'];
	
	function createTooltipMarkup(type, option) {
	  option.type = type;
	  return option;
	}
	
	exports.createTooltipMarkup = createTooltipMarkup;
	
	function getBuilder(fragment) {
	  return util_1.hasOwn(builderMap, fragment.type) && builderMap[fragment.type];
	}
	
	var builderMap = {
	  section: {
	    planLayout: function (fragment) {
	      var subBlockLen = fragment.blocks.length;
	      var thisBlockHasInnerGap = subBlockLen > 1 || subBlockLen > 0 && !fragment.noHeader;
	      var thisGapLevelBetweenSubBlocks = 0;
	      util_1.each(fragment.blocks, function (subBlock) {
	        getBuilder(subBlock).planLayout(subBlock);
	        var subGapLevel = subBlock.__gapLevelBetweenSubBlocks;
	
	        if (subGapLevel >= thisGapLevelBetweenSubBlocks) {
	          thisGapLevelBetweenSubBlocks = subGapLevel + (thisBlockHasInnerGap && (!subGapLevel || subBlock.type === 'section' && !subBlock.noHeader) ? 1 : 0);
	        }
	      });
	      fragment.__gapLevelBetweenSubBlocks = thisGapLevelBetweenSubBlocks;
	    },
	    build: function (ctx, fragment, topMarginForOuterGap) {
	      var noHeader = fragment.noHeader;
	      var gaps = getGap(fragment);
	      var subMarkupText = buildSubBlocks(ctx, fragment, noHeader ? topMarginForOuterGap : gaps.html);
	
	      if (noHeader) {
	        return subMarkupText;
	      }
	
	      var displayableHeader = format_1.makeValueReadable(fragment.header, 'ordinal', ctx.useUTC);
	
	      if (ctx.renderMode === 'richText') {
	        return wrapInlineNameRichText(ctx, displayableHeader) + gaps.richText + subMarkupText;
	      } else {
	        return wrapBlockHTML("<div style=\"" + TOOLTIP_NAME_TEXT_STYLE_CSS + ";" + TOOLTIP_LINE_HEIGHT_CSS + ";\">" + format_1.encodeHTML(displayableHeader) + '</div>' + subMarkupText, topMarginForOuterGap);
	      }
	    }
	  },
	  nameValue: {
	    planLayout: function (fragment) {
	      fragment.__gapLevelBetweenSubBlocks = 0;
	    },
	    build: function (ctx, fragment, topMarginForOuterGap) {
	      var renderMode = ctx.renderMode;
	      var noName = fragment.noName;
	      var noValue = fragment.noValue;
	      var noMarker = !fragment.markerType;
	      var name = fragment.name;
	      var value = fragment.value;
	      var useUTC = ctx.useUTC;
	
	      if (noName && noValue) {
	        return;
	      }
	
	      var markerStr = noMarker ? '' : ctx.markupStyleCreator.makeTooltipMarker(fragment.markerType, fragment.markerColor || '#333', renderMode);
	      var readableName = noName ? '' : format_1.makeValueReadable(name, 'ordinal', useUTC);
	      var valueTypeOption = fragment.valueType;
	      var readableValueList = noValue ? [] : util_1.isArray(value) ? util_1.map(value, function (val, idx) {
	        return format_1.makeValueReadable(val, util_1.isArray(valueTypeOption) ? valueTypeOption[idx] : valueTypeOption, useUTC);
	      }) : [format_1.makeValueReadable(value, util_1.isArray(valueTypeOption) ? valueTypeOption[0] : valueTypeOption, useUTC)];
	      var valueAlignRight = !noMarker || !noName;
	      var valueCloseToMarker = !noMarker && noName;
	      return renderMode === 'richText' ? (noMarker ? '' : markerStr) + (noName ? '' : wrapInlineNameRichText(ctx, readableName)) + (noValue ? '' : wrapInlineValueRichText(ctx, readableValueList, valueAlignRight, valueCloseToMarker)) : wrapBlockHTML((noMarker ? '' : markerStr) + (noName ? '' : wrapInlineNameHTML(readableName, !noMarker)) + (noValue ? '' : wrapInlineValueHTML(readableValueList, valueAlignRight, valueCloseToMarker)), topMarginForOuterGap);
	    }
	  }
	};
	
	function buildSubBlocks(ctx, fragment, topMarginForOuterGap) {
	  var subMarkupTextList = [];
	  var subBlocks = fragment.blocks || [];
	  util_1.assert(!subBlocks || util_1.isArray(subBlocks));
	  subBlocks = subBlocks || [];
	  var orderMode = ctx.orderMode;
	
	  if (fragment.sortBlocks && orderMode) {
	    subBlocks = subBlocks.slice();
	    var orderMap = {
	      valueAsc: 'asc',
	      valueDesc: 'desc'
	    };
	
	    if (util_1.hasOwn(orderMap, orderMode)) {
	      var comparator_1 = new dataValueHelper_1.SortOrderComparator(orderMap[orderMode], null);
	      subBlocks.sort(function (a, b) {
	        return comparator_1.evaluate(a.sortParam, b.sortParam);
	      });
	    } else if (orderMode === 'seriesDesc') {
	      subBlocks.reverse();
	    }
	  }
	
	  var gaps = getGap(fragment);
	  util_1.each(subBlocks, function (subBlock, idx) {
	    var subMarkupText = getBuilder(subBlock).build(ctx, subBlock, idx > 0 ? gaps.html : 0);
	    subMarkupText != null && subMarkupTextList.push(subMarkupText);
	  });
	
	  if (!subMarkupTextList.length) {
	    return;
	  }
	
	  return ctx.renderMode === 'richText' ? subMarkupTextList.join(gaps.richText) : wrapBlockHTML(subMarkupTextList.join(''), topMarginForOuterGap);
	}
	
	function buildTooltipMarkup(fragment, markupStyleCreator, renderMode, orderMode, useUTC) {
	  if (!fragment) {
	    return;
	  }
	
	  var builder = getBuilder(fragment);
	  builder.planLayout(fragment);
	  var ctx = {
	    useUTC: useUTC,
	    renderMode: renderMode,
	    orderMode: orderMode,
	    markupStyleCreator: markupStyleCreator
	  };
	  return builder.build(ctx, fragment, 0);
	}
	
	exports.buildTooltipMarkup = buildTooltipMarkup;
	
	function getGap(fragment) {
	  var gapLevelBetweenSubBlocks = fragment.__gapLevelBetweenSubBlocks;
	  return {
	    html: HTML_GAPS[gapLevelBetweenSubBlocks],
	    richText: RICH_TEXT_GAPS[gapLevelBetweenSubBlocks]
	  };
	}
	
	function wrapBlockHTML(encodedContent, topGap) {
	  var clearfix = '<div style="clear:both"></div>';
	  var marginCSS = "margin: " + topGap + "px 0 0";
	  return "<div style=\"" + marginCSS + ";" + TOOLTIP_LINE_HEIGHT_CSS + ";\">" + encodedContent + clearfix + '</div>';
	}
	
	function wrapInlineNameHTML(name, leftHasMarker) {
	  var marginCss = leftHasMarker ? 'margin-left:2px' : '';
	  return "<span style=\"" + TOOLTIP_NAME_TEXT_STYLE_CSS + ";" + marginCss + "\">" + format_1.encodeHTML(name) + '</span>';
	}
	
	function wrapInlineValueHTML(valueList, alignRight, valueCloseToMarker) {
	  var paddingStr = valueCloseToMarker ? '10px' : '20px';
	  var alignCSS = alignRight ? "float:right;margin-left:" + paddingStr : '';
	  return "<span style=\"" + alignCSS + ";" + TOOLTIP_VALUE_TEXT_STYLE_CSS + "\">" + util_1.map(valueList, function (value) {
	    return format_1.encodeHTML(value);
	  }).join('&nbsp;&nbsp;') + '</span>';
	}
	
	function wrapInlineNameRichText(ctx, name) {
	  return ctx.markupStyleCreator.wrapRichTextStyle(name, TOOLTIP_TEXT_STYLE_RICH);
	}
	
	function wrapInlineValueRichText(ctx, valueList, alignRight, valueCloseToMarker) {
	  var styles = [TOOLTIP_VALUE_TEXT_STYLE_RICH];
	  var paddingLeft = valueCloseToMarker ? 10 : 20;
	  alignRight && styles.push({
	    padding: [0, 0, 0, paddingLeft],
	    align: 'right'
	  });
	  return ctx.markupStyleCreator.wrapRichTextStyle(valueList.join('  '), styles);
	}
	
	function retrieveVisualColorForTooltipMarker(series, dataIndex) {
	  var style = series.getData().getItemVisual(dataIndex, 'style');
	  var color = style[series.visualDrawType];
	  return format_1.convertToColorString(color);
	}
	
	exports.retrieveVisualColorForTooltipMarker = retrieveVisualColorForTooltipMarker;
	
	function getPaddingFromTooltipModel(model, renderMode) {
	  var padding = model.get('padding');
	  return padding != null ? padding : renderMode === 'richText' ? [8, 10] : 10;
	}
	
	exports.getPaddingFromTooltipModel = getPaddingFromTooltipModel;
	
	var TooltipMarkupStyleCreator = function () {
	  function TooltipMarkupStyleCreator() {
	    this.richTextStyles = {};
	    this._nextStyleNameId = number_1.getRandomIdBase();
	  }
	
	  TooltipMarkupStyleCreator.prototype._generateStyleName = function () {
	    return '__EC_aUTo_' + this._nextStyleNameId++;
	  };
	
	  TooltipMarkupStyleCreator.prototype.makeTooltipMarker = function (markerType, colorStr, renderMode) {
	    var markerId = renderMode === 'richText' ? this._generateStyleName() : null;
	    var marker = format_1.getTooltipMarker({
	      color: colorStr,
	      type: markerType,
	      renderMode: renderMode,
	      markerId: markerId
	    });
	
	    if (util_1.isString(marker)) {
	      return marker;
	    } else {
	      if (false) {
	        util_1.assert(markerId);
	      }
	
	      this.richTextStyles[markerId] = marker.style;
	      return marker.content;
	    }
	  };
	
	  TooltipMarkupStyleCreator.prototype.wrapRichTextStyle = function (text, styles) {
	    var finalStl = {};
	
	    if (util_1.isArray(styles)) {
	      util_1.each(styles, function (stl) {
	        return util_1.extend(finalStl, stl);
	      });
	    } else {
	      util_1.extend(finalStl, styles);
	    }
	
	    var styleName = this._generateStyleName();
	
	    this.richTextStyles[styleName] = finalStl;
	    return "{" + styleName + "|" + text + "}";
	  };
	
	  return TooltipMarkupStyleCreator;
	}();
	
	exports.TooltipMarkupStyleCreator = TooltipMarkupStyleCreator;

/***/ },
/* 53 */
/***/ function(module, exports, __webpack_require__) {

	
	/*
	* Licensed to the Apache Software Foundation (ASF) under one
	* or more contributor license agreements.  See the NOTICE file
	* distributed with this work for additional information
	* regarding copyright ownership.  The ASF licenses this file
	* to you under the Apache License, Version 2.0 (the
	* "License"); you may not use this file except in compliance
	* with the License.  You may obtain a copy of the License at
	*
	*   http://www.apache.org/licenses/LICENSE-2.0
	*
	* Unless required by applicable law or agreed to in writing,
	* software distributed under the License is distributed on an
	* "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
	* KIND, either express or implied.  See the License for the
	* specific language governing permissions and limitations
	* under the License.
	*/
	
	
	
	/**
	 * AUTO-GENERATED FILE. DO NOT MODIFY.
	 */
	
	"use strict";
	
	var _a, _b, _c;
	
	exports.__esModule = true;
	
	var util_1 = __webpack_require__(1);
	
	var model_1 = __webpack_require__(4);
	
	var Source_1 = __webpack_require__(47);
	
	var types_1 = __webpack_require__(25);
	
	var providerMethods;
	var mountMethods;
	
	var DefaultDataProvider = function () {
	  function DefaultDataProvider(sourceParam, dimSize) {
	    var source = !Source_1.isSourceInstance(sourceParam) ? Source_1.createSourceFromSeriesDataOption(sourceParam) : sourceParam;
	    this._source = source;
	    var data = this._data = source.data;
	
	    if (source.sourceFormat === types_1.SOURCE_FORMAT_TYPED_ARRAY) {
	      if (false) {
	        if (dimSize == null) {
	          throw new Error('Typed array data must specify dimension size');
	        }
	      }
	
	      this._offset = 0;
	      this._dimSize = dimSize;
	      this._data = data;
	    }
	
	    mountMethods(this, data, source);
	  }
	
	  DefaultDataProvider.prototype.getSource = function () {
	    return this._source;
	  };
	
	  DefaultDataProvider.prototype.count = function () {
	    return 0;
	  };
	
	  DefaultDataProvider.prototype.getItem = function (idx, out) {
	    return;
	  };
	
	  DefaultDataProvider.prototype.appendData = function (newData) {};
	
	  DefaultDataProvider.prototype.clean = function () {};
	
	  DefaultDataProvider.protoInitialize = function () {
	    var proto = DefaultDataProvider.prototype;
	    proto.pure = false;
	    proto.persistent = true;
	  }();
	
	  DefaultDataProvider.internalField = function () {
	    var _a;
	
	    mountMethods = function (provider, data, source) {
	      var sourceFormat = source.sourceFormat;
	      var seriesLayoutBy = source.seriesLayoutBy;
	      var startIndex = source.startIndex;
	      var dimsDef = source.dimensionsDefine;
	      var methods = providerMethods[getMethodMapKey(sourceFormat, seriesLayoutBy)];
	
	      if (false) {
	        util_1.assert(methods, 'Invalide sourceFormat: ' + sourceFormat);
	      }
	
	      util_1.extend(provider, methods);
	
	      if (sourceFormat === types_1.SOURCE_FORMAT_TYPED_ARRAY) {
	        provider.getItem = getItemForTypedArray;
	        provider.count = countForTypedArray;
	        provider.fillStorage = fillStorageForTypedArray;
	      } else {
	        var rawItemGetter = getRawSourceItemGetter(sourceFormat, seriesLayoutBy);
	        provider.getItem = util_1.bind(rawItemGetter, null, data, startIndex, dimsDef);
	        var rawCounter = getRawSourceDataCounter(sourceFormat, seriesLayoutBy);
	        provider.count = util_1.bind(rawCounter, null, data, startIndex, dimsDef);
	      }
	    };
	
	    var getItemForTypedArray = function (idx, out) {
	      idx = idx - this._offset;
	      out = out || [];
	      var data = this._data;
	      var dimSize = this._dimSize;
	      var offset = dimSize * idx;
	
	      for (var i = 0; i < dimSize; i++) {
	        out[i] = data[offset + i];
	      }
	
	      return out;
	    };
	
	    var fillStorageForTypedArray = function (start, end, storage, extent) {
	      var data = this._data;
	      var dimSize = this._dimSize;
	
	      for (var dim = 0; dim < dimSize; dim++) {
	        var dimExtent = extent[dim];
	        var min = dimExtent[0] == null ? Infinity : dimExtent[0];
	        var max = dimExtent[1] == null ? -Infinity : dimExtent[1];
	        var count = end - start;
	        var arr = storage[dim];
	
	        for (var i = 0; i < count; i++) {
	          var val = data[(start + i) * dimSize + dim];
	          arr[start + i] = val;
	          val < min && (min = val);
	          val > max && (max = val);
	        }
	
	        dimExtent[0] = min;
	        dimExtent[1] = max;
	      }
	    };
	
	    var countForTypedArray = function () {
	      return this._data ? this._data.length / this._dimSize : 0;
	    };
	
	    providerMethods = (_a = {}, _a[types_1.SOURCE_FORMAT_ARRAY_ROWS + '_' + types_1.SERIES_LAYOUT_BY_COLUMN] = {
	      pure: true,
	      appendData: appendDataSimply
	    }, _a[types_1.SOURCE_FORMAT_ARRAY_ROWS + '_' + types_1.SERIES_LAYOUT_BY_ROW] = {
	      pure: true,
	      appendData: function () {
	        throw new Error('Do not support appendData when set seriesLayoutBy: "row".');
	      }
	    }, _a[types_1.SOURCE_FORMAT_OBJECT_ROWS] = {
	      pure: true,
	      appendData: appendDataSimply
	    }, _a[types_1.SOURCE_FORMAT_KEYED_COLUMNS] = {
	      pure: true,
	      appendData: function (newData) {
	        var data = this._data;
	        util_1.each(newData, function (newCol, key) {
	          var oldCol = data[key] || (data[key] = []);
	
	          for (var i = 0; i < (newCol || []).length; i++) {
	            oldCol.push(newCol[i]);
	          }
	        });
	      }
	    }, _a[types_1.SOURCE_FORMAT_ORIGINAL] = {
	      appendData: appendDataSimply
	    }, _a[types_1.SOURCE_FORMAT_TYPED_ARRAY] = {
	      persistent: false,
	      pure: true,
	      appendData: function (newData) {
	        if (false) {
	          util_1.assert(util_1.isTypedArray(newData), 'Added data must be TypedArray if data in initialization is TypedArray');
	        }
	
	        this._data = newData;
	      },
	      clean: function () {
	        this._offset += this.count();
	        this._data = null;
	      }
	    }, _a);
	
	    function appendDataSimply(newData) {
	      for (var i = 0; i < newData.length; i++) {
	        this._data.push(newData[i]);
	      }
	    }
	  }();
	
	  return DefaultDataProvider;
	}();
	
	exports.DefaultDataProvider = DefaultDataProvider;
	
	var getItemSimply = function (rawData, startIndex, dimsDef, idx) {
	  return rawData[idx];
	};
	
	var rawSourceItemGetterMap = (_a = {}, _a[types_1.SOURCE_FORMAT_ARRAY_ROWS + '_' + types_1.SERIES_LAYOUT_BY_COLUMN] = function (rawData, startIndex, dimsDef, idx) {
	  return rawData[idx + startIndex];
	}, _a[types_1.SOURCE_FORMAT_ARRAY_ROWS + '_' + types_1.SERIES_LAYOUT_BY_ROW] = function (rawData, startIndex, dimsDef, idx) {
	  idx += startIndex;
	  var item = [];
	  var data = rawData;
	
	  for (var i = 0; i < data.length; i++) {
	    var row = data[i];
	    item.push(row ? row[idx] : null);
	  }
	
	  return item;
	}, _a[types_1.SOURCE_FORMAT_OBJECT_ROWS] = getItemSimply, _a[types_1.SOURCE_FORMAT_KEYED_COLUMNS] = function (rawData, startIndex, dimsDef, idx) {
	  var item = [];
	
	  for (var i = 0; i < dimsDef.length; i++) {
	    var dimName = dimsDef[i].name;
	
	    if (false) {
	      if (dimName == null) {
	        throw new Error();
	      }
	    }
	
	    var col = rawData[dimName];
	    item.push(col ? col[idx] : null);
	  }
	
	  return item;
	}, _a[types_1.SOURCE_FORMAT_ORIGINAL] = getItemSimply, _a);
	
	function getRawSourceItemGetter(sourceFormat, seriesLayoutBy) {
	  var method = rawSourceItemGetterMap[getMethodMapKey(sourceFormat, seriesLayoutBy)];
	
	  if (false) {
	    util_1.assert(method, 'Do not suppport get item on "' + sourceFormat + '", "' + seriesLayoutBy + '".');
	  }
	
	  return method;
	}
	
	exports.getRawSourceItemGetter = getRawSourceItemGetter;
	
	var countSimply = function (rawData, startIndex, dimsDef) {
	  return rawData.length;
	};
	
	var rawSourceDataCounterMap = (_b = {}, _b[types_1.SOURCE_FORMAT_ARRAY_ROWS + '_' + types_1.SERIES_LAYOUT_BY_COLUMN] = function (rawData, startIndex, dimsDef) {
	  return Math.max(0, rawData.length - startIndex);
	}, _b[types_1.SOURCE_FORMAT_ARRAY_ROWS + '_' + types_1.SERIES_LAYOUT_BY_ROW] = function (rawData, startIndex, dimsDef) {
	  var row = rawData[0];
	  return row ? Math.max(0, row.length - startIndex) : 0;
	}, _b[types_1.SOURCE_FORMAT_OBJECT_ROWS] = countSimply, _b[types_1.SOURCE_FORMAT_KEYED_COLUMNS] = function (rawData, startIndex, dimsDef) {
	  var dimName = dimsDef[0].name;
	
	  if (false) {
	    if (dimName == null) {
	      throw new Error();
	    }
	  }
	
	  var col = rawData[dimName];
	  return col ? col.length : 0;
	}, _b[types_1.SOURCE_FORMAT_ORIGINAL] = countSimply, _b);
	
	function getRawSourceDataCounter(sourceFormat, seriesLayoutBy) {
	  var method = rawSourceDataCounterMap[getMethodMapKey(sourceFormat, seriesLayoutBy)];
	
	  if (false) {
	    util_1.assert(method, 'Do not suppport count on "' + sourceFormat + '", "' + seriesLayoutBy + '".');
	  }
	
	  return method;
	}
	
	exports.getRawSourceDataCounter = getRawSourceDataCounter;
	
	var getRawValueSimply = function (dataItem, dimIndex, dimName) {
	  return dimIndex != null ? dataItem[dimIndex] : dataItem;
	};
	
	var rawSourceValueGetterMap = (_c = {}, _c[types_1.SOURCE_FORMAT_ARRAY_ROWS] = getRawValueSimply, _c[types_1.SOURCE_FORMAT_OBJECT_ROWS] = function (dataItem, dimIndex, dimName) {
	  return dimIndex != null ? dataItem[dimName] : dataItem;
	}, _c[types_1.SOURCE_FORMAT_KEYED_COLUMNS] = getRawValueSimply, _c[types_1.SOURCE_FORMAT_ORIGINAL] = function (dataItem, dimIndex, dimName) {
	  var value = model_1.getDataItemValue(dataItem);
	  return dimIndex == null || !(value instanceof Array) ? value : value[dimIndex];
	}, _c[types_1.SOURCE_FORMAT_TYPED_ARRAY] = getRawValueSimply, _c);
	
	function getRawSourceValueGetter(sourceFormat) {
	  var method = rawSourceValueGetterMap[sourceFormat];
	
	  if (false) {
	    util_1.assert(method, 'Do not suppport get value on "' + sourceFormat + '".');
	  }
	
	  return method;
	}
	
	exports.getRawSourceValueGetter = getRawSourceValueGetter;
	
	function getMethodMapKey(sourceFormat, seriesLayoutBy) {
	  return sourceFormat === types_1.SOURCE_FORMAT_ARRAY_ROWS ? sourceFormat + '_' + seriesLayoutBy : sourceFormat;
	}
	
	function retrieveRawValue(data, dataIndex, dim) {
	  if (!data) {
	    return;
	  }
	
	  var dataItem = data.getRawDataItem(dataIndex);
	
	  if (dataItem == null) {
	    return;
	  }
	
	  var sourceFormat = data.getProvider().getSource().sourceFormat;
	  var dimName;
	  var dimIndex;
	  var dimInfo = data.getDimensionInfo(dim);
	
	  if (dimInfo) {
	    dimName = dimInfo.name;
	    dimIndex = dimInfo.index;
	  }
	
	  return getRawSourceValueGetter(sourceFormat)(dataItem, dimIndex, dimName);
	}
	
	exports.retrieveRawValue = retrieveRawValue;
	
	function retrieveRawAttr(data, dataIndex, attr) {
	  if (!data) {
	    return;
	  }
	
	  var sourceFormat = data.getProvider().getSource().sourceFormat;
	
	  if (sourceFormat !== types_1.SOURCE_FORMAT_ORIGINAL && sourceFormat !== types_1.SOURCE_FORMAT_OBJECT_ROWS) {
	    return;
	  }
	
	  var dataItem = data.getRawDataItem(dataIndex);
	
	  if (sourceFormat === types_1.SOURCE_FORMAT_ORIGINAL && !util_1.isObject(dataItem)) {
	    dataItem = null;
	  }
	
	  if (dataItem) {
	    return dataItem[attr];
	  }
	}
	
	exports.retrieveRawAttr = retrieveRawAttr;

/***/ },
/* 54 */
/***/ function(module, exports, __webpack_require__) {

	
	/*
	* Licensed to the Apache Software Foundation (ASF) under one
	* or more contributor license agreements.  See the NOTICE file
	* distributed with this work for additional information
	* regarding copyright ownership.  The ASF licenses this file
	* to you under the Apache License, Version 2.0 (the
	* "License"); you may not use this file except in compliance
	* with the License.  You may obtain a copy of the License at
	*
	*   http://www.apache.org/licenses/LICENSE-2.0
	*
	* Unless required by applicable law or agreed to in writing,
	* software distributed under the License is distributed on an
	* "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
	* KIND, either express or implied.  See the License for the
	* specific language governing permissions and limitations
	* under the License.
	*/
	
	
	
	/**
	 * AUTO-GENERATED FILE. DO NOT MODIFY.
	 */
	
	"use strict";
	
	exports.__esModule = true;
	
	var model_1 = __webpack_require__(4);
	
	var util_1 = __webpack_require__(1);
	
	var types_1 = __webpack_require__(25);
	
	exports.BE_ORDINAL = {
	  Must: 1,
	  Might: 2,
	  Not: 3
	};
	var innerGlobalModel = model_1.makeInner();
	
	function resetSourceDefaulter(ecModel) {
	  innerGlobalModel(ecModel).datasetMap = util_1.createHashMap();
	}
	
	exports.resetSourceDefaulter = resetSourceDefaulter;
	
	function inheritSourceMetaRawOption(upstream, newMetaRawOption) {
	  var parentMetaRawOption = upstream ? upstream.metaRawOption : null;
	  var seriesLayoutBy = util_1.retrieve2(newMetaRawOption.seriesLayoutBy, parentMetaRawOption ? parentMetaRawOption.seriesLayoutBy : null);
	  var sourceHeader = util_1.retrieve2(newMetaRawOption.sourceHeader, upstream ? upstream.startIndex : null);
	  var dimensions = util_1.retrieve2(newMetaRawOption.dimensions, upstream ? upstream.dimensionsDefine : null);
	  return {
	    seriesLayoutBy: seriesLayoutBy,
	    sourceHeader: sourceHeader,
	    dimensions: dimensions
	  };
	}
	
	exports.inheritSourceMetaRawOption = inheritSourceMetaRawOption;
	
	function makeSeriesEncodeForAxisCoordSys(coordDimensions, seriesModel, source) {
	  var encode = {};
	  var datasetModel = querySeriesUpstreamDatasetModel(seriesModel);
	
	  if (!datasetModel || !coordDimensions) {
	    return encode;
	  }
	
	  var encodeItemName = [];
	  var encodeSeriesName = [];
	  var ecModel = seriesModel.ecModel;
	  var datasetMap = innerGlobalModel(ecModel).datasetMap;
	  var key = datasetModel.uid + '_' + source.seriesLayoutBy;
	  var baseCategoryDimIndex;
	  var categoryWayValueDimStart;
	  coordDimensions = coordDimensions.slice();
	  util_1.each(coordDimensions, function (coordDimInfoLoose, coordDimIdx) {
	    var coordDimInfo = util_1.isObject(coordDimInfoLoose) ? coordDimInfoLoose : coordDimensions[coordDimIdx] = {
	      name: coordDimInfoLoose
	    };
	
	    if (coordDimInfo.type === 'ordinal' && baseCategoryDimIndex == null) {
	      baseCategoryDimIndex = coordDimIdx;
	      categoryWayValueDimStart = getDataDimCountOnCoordDim(coordDimInfo);
	    }
	
	    encode[coordDimInfo.name] = [];
	  });
	  var datasetRecord = datasetMap.get(key) || datasetMap.set(key, {
	    categoryWayDim: categoryWayValueDimStart,
	    valueWayDim: 0
	  });
	  util_1.each(coordDimensions, function (coordDimInfo, coordDimIdx) {
	    var coordDimName = coordDimInfo.name;
	    var count = getDataDimCountOnCoordDim(coordDimInfo);
	
	    if (baseCategoryDimIndex == null) {
	      var start = datasetRecord.valueWayDim;
	      pushDim(encode[coordDimName], start, count);
	      pushDim(encodeSeriesName, start, count);
	      datasetRecord.valueWayDim += count;
	    } else if (baseCategoryDimIndex === coordDimIdx) {
	      pushDim(encode[coordDimName], 0, count);
	      pushDim(encodeItemName, 0, count);
	    } else {
	      var start = datasetRecord.categoryWayDim;
	      pushDim(encode[coordDimName], start, count);
	      pushDim(encodeSeriesName, start, count);
	      datasetRecord.categoryWayDim += count;
	    }
	  });
	
	  function pushDim(dimIdxArr, idxFrom, idxCount) {
	    for (var i = 0; i < idxCount; i++) {
	      dimIdxArr.push(idxFrom + i);
	    }
	  }
	
	  function getDataDimCountOnCoordDim(coordDimInfo) {
	    var dimsDef = coordDimInfo.dimsDef;
	    return dimsDef ? dimsDef.length : 1;
	  }
	
	  encodeItemName.length && (encode.itemName = encodeItemName);
	  encodeSeriesName.length && (encode.seriesName = encodeSeriesName);
	  return encode;
	}
	
	exports.makeSeriesEncodeForAxisCoordSys = makeSeriesEncodeForAxisCoordSys;
	
	function makeSeriesEncodeForNameBased(seriesModel, source, dimCount) {
	  var encode = {};
	  var datasetModel = querySeriesUpstreamDatasetModel(seriesModel);
	
	  if (!datasetModel) {
	    return encode;
	  }
	
	  var sourceFormat = source.sourceFormat;
	  var dimensionsDefine = source.dimensionsDefine;
	  var potentialNameDimIndex;
	
	  if (sourceFormat === types_1.SOURCE_FORMAT_OBJECT_ROWS || sourceFormat === types_1.SOURCE_FORMAT_KEYED_COLUMNS) {
	    util_1.each(dimensionsDefine, function (dim, idx) {
	      if ((util_1.isObject(dim) ? dim.name : dim) === 'name') {
	        potentialNameDimIndex = idx;
	      }
	    });
	  }
	
	  var idxResult = function () {
	    var idxRes0 = {};
	    var idxRes1 = {};
	    var guessRecords = [];
	
	    for (var i = 0, len = Math.min(5, dimCount); i < len; i++) {
	      var guessResult = doGuessOrdinal(source.data, sourceFormat, source.seriesLayoutBy, dimensionsDefine, source.startIndex, i);
	      guessRecords.push(guessResult);
	      var isPureNumber = guessResult === exports.BE_ORDINAL.Not;
	
	      if (isPureNumber && idxRes0.v == null && i !== potentialNameDimIndex) {
	        idxRes0.v = i;
	      }
	
	      if (idxRes0.n == null || idxRes0.n === idxRes0.v || !isPureNumber && guessRecords[idxRes0.n] === exports.BE_ORDINAL.Not) {
	        idxRes0.n = i;
	      }
	
	      if (fulfilled(idxRes0) && guessRecords[idxRes0.n] !== exports.BE_ORDINAL.Not) {
	        return idxRes0;
	      }
	
	      if (!isPureNumber) {
	        if (guessResult === exports.BE_ORDINAL.Might && idxRes1.v == null && i !== potentialNameDimIndex) {
	          idxRes1.v = i;
	        }
	
	        if (idxRes1.n == null || idxRes1.n === idxRes1.v) {
	          idxRes1.n = i;
	        }
	      }
	    }
	
	    function fulfilled(idxResult) {
	      return idxResult.v != null && idxResult.n != null;
	    }
	
	    return fulfilled(idxRes0) ? idxRes0 : fulfilled(idxRes1) ? idxRes1 : null;
	  }();
	
	  if (idxResult) {
	    encode.value = [idxResult.v];
	    var nameDimIndex = potentialNameDimIndex != null ? potentialNameDimIndex : idxResult.n;
	    encode.itemName = [nameDimIndex];
	    encode.seriesName = [nameDimIndex];
	  }
	
	  return encode;
	}
	
	exports.makeSeriesEncodeForNameBased = makeSeriesEncodeForNameBased;
	
	function querySeriesUpstreamDatasetModel(seriesModel) {
	  var thisData = seriesModel.get('data', true);
	
	  if (!thisData) {
	    return model_1.queryReferringComponents(seriesModel.ecModel, 'dataset', {
	      index: seriesModel.get('datasetIndex', true),
	      id: seriesModel.get('datasetId', true)
	    }, model_1.SINGLE_REFERRING).models[0];
	  }
	}
	
	exports.querySeriesUpstreamDatasetModel = querySeriesUpstreamDatasetModel;
	
	function queryDatasetUpstreamDatasetModels(datasetModel) {
	  if (!datasetModel.get('transform', true) && !datasetModel.get('fromTransformResult', true)) {
	    return [];
	  }
	
	  return model_1.queryReferringComponents(datasetModel.ecModel, 'dataset', {
	    index: datasetModel.get('fromDatasetIndex', true),
	    id: datasetModel.get('fromDatasetId', true)
	  }, model_1.SINGLE_REFERRING).models;
	}
	
	exports.queryDatasetUpstreamDatasetModels = queryDatasetUpstreamDatasetModels;
	
	function guessOrdinal(source, dimIndex) {
	  return doGuessOrdinal(source.data, source.sourceFormat, source.seriesLayoutBy, source.dimensionsDefine, source.startIndex, dimIndex);
	}
	
	exports.guessOrdinal = guessOrdinal;
	
	function doGuessOrdinal(data, sourceFormat, seriesLayoutBy, dimensionsDefine, startIndex, dimIndex) {
	  var result;
	  var maxLoop = 5;
	
	  if (util_1.isTypedArray(data)) {
	    return exports.BE_ORDINAL.Not;
	  }
	
	  var dimName;
	  var dimType;
	
	  if (dimensionsDefine) {
	    var dimDefItem = dimensionsDefine[dimIndex];
	
	    if (util_1.isObject(dimDefItem)) {
	      dimName = dimDefItem.name;
	      dimType = dimDefItem.type;
	    } else if (util_1.isString(dimDefItem)) {
	      dimName = dimDefItem;
	    }
	  }
	
	  if (dimType != null) {
	    return dimType === 'ordinal' ? exports.BE_ORDINAL.Must : exports.BE_ORDINAL.Not;
	  }
	
	  if (sourceFormat === types_1.SOURCE_FORMAT_ARRAY_ROWS) {
	    var dataArrayRows = data;
	
	    if (seriesLayoutBy === types_1.SERIES_LAYOUT_BY_ROW) {
	      var sample = dataArrayRows[dimIndex];
	
	      for (var i = 0; i < (sample || []).length && i < maxLoop; i++) {
	        if ((result = detectValue(sample[startIndex + i])) != null) {
	          return result;
	        }
	      }
	    } else {
	      for (var i = 0; i < dataArrayRows.length && i < maxLoop; i++) {
	        var row = dataArrayRows[startIndex + i];
	
	        if (row && (result = detectValue(row[dimIndex])) != null) {
	          return result;
	        }
	      }
	    }
	  } else if (sourceFormat === types_1.SOURCE_FORMAT_OBJECT_ROWS) {
	    var dataObjectRows = data;
	
	    if (!dimName) {
	      return exports.BE_ORDINAL.Not;
	    }
	
	    for (var i = 0; i < dataObjectRows.length && i < maxLoop; i++) {
	      var item = dataObjectRows[i];
	
	      if (item && (result = detectValue(item[dimName])) != null) {
	        return result;
	      }
	    }
	  } else if (sourceFormat === types_1.SOURCE_FORMAT_KEYED_COLUMNS) {
	    var dataKeyedColumns = data;
	
	    if (!dimName) {
	      return exports.BE_ORDINAL.Not;
	    }
	
	    var sample = dataKeyedColumns[dimName];
	
	    if (!sample || util_1.isTypedArray(sample)) {
	      return exports.BE_ORDINAL.Not;
	    }
	
	    for (var i = 0; i < sample.length && i < maxLoop; i++) {
	      if ((result = detectValue(sample[i])) != null) {
	        return result;
	      }
	    }
	  } else if (sourceFormat === types_1.SOURCE_FORMAT_ORIGINAL) {
	    var dataOriginal = data;
	
	    for (var i = 0; i < dataOriginal.length && i < maxLoop; i++) {
	      var item = dataOriginal[i];
	      var val = model_1.getDataItemValue(item);
	
	      if (!util_1.isArray(val)) {
	        return exports.BE_ORDINAL.Not;
	      }
	
	      if ((result = detectValue(val[dimIndex])) != null) {
	        return result;
	      }
	    }
	  }
	
	  function detectValue(val) {
	    var beStr = util_1.isString(val);
	
	    if (val != null && isFinite(val) && val !== '') {
	      return beStr ? exports.BE_ORDINAL.Might : exports.BE_ORDINAL.Not;
	    } else if (beStr && val !== '-') {
	      return exports.BE_ORDINAL.Must;
	    }
	  }
	
	  return exports.BE_ORDINAL.Not;
	}

/***/ },
/* 55 */
/***/ function(module, exports, __webpack_require__) {

	
	/*
	* Licensed to the Apache Software Foundation (ASF) under one
	* or more contributor license agreements.  See the NOTICE file
	* distributed with this work for additional information
	* regarding copyright ownership.  The ASF licenses this file
	* to you under the Apache License, Version 2.0 (the
	* "License"); you may not use this file except in compliance
	* with the License.  You may obtain a copy of the License at
	*
	*   http://www.apache.org/licenses/LICENSE-2.0
	*
	* Unless required by applicable law or agreed to in writing,
	* software distributed under the License is distributed on an
	* "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
	* KIND, either express or implied.  See the License for the
	* specific language governing permissions and limitations
	* under the License.
	*/
	
	
	
	/**
	 * AUTO-GENERATED FILE. DO NOT MODIFY.
	 */
	
	"use strict";
	
	exports.__esModule = true;
	
	var clazzUtil = __webpack_require__(28);
	
	var Scale = function () {
	  function Scale(setting) {
	    this._setting = setting || {};
	    this._extent = [Infinity, -Infinity];
	  }
	
	  Scale.prototype.getSetting = function (name) {
	    return this._setting[name];
	  };
	
	  Scale.prototype.unionExtent = function (other) {
	    var extent = this._extent;
	    other[0] < extent[0] && (extent[0] = other[0]);
	    other[1] > extent[1] && (extent[1] = other[1]);
	  };
	
	  Scale.prototype.unionExtentFromData = function (data, dim) {
	    this.unionExtent(data.getApproximateExtent(dim));
	  };
	
	  Scale.prototype.getExtent = function () {
	    return this._extent.slice();
	  };
	
	  Scale.prototype.setExtent = function (start, end) {
	    var thisExtent = this._extent;
	
	    if (!isNaN(start)) {
	      thisExtent[0] = start;
	    }
	
	    if (!isNaN(end)) {
	      thisExtent[1] = end;
	    }
	  };
	
	  Scale.prototype.isInExtentRange = function (value) {
	    return this._extent[0] <= value && this._extent[1] >= value;
	  };
	
	  Scale.prototype.isBlank = function () {
	    return this._isBlank;
	  };
	
	  Scale.prototype.setBlank = function (isBlank) {
	    this._isBlank = isBlank;
	  };
	
	  return Scale;
	}();
	
	clazzUtil.enableClassManagement(Scale, {
	  registerWhenExtend: true
	});
	exports["default"] = Scale;

/***/ },
/* 56 */
/***/ function(module, exports) {

	
	/*
	* Licensed to the Apache Software Foundation (ASF) under one
	* or more contributor license agreements.  See the NOTICE file
	* distributed with this work for additional information
	* regarding copyright ownership.  The ASF licenses this file
	* to you under the Apache License, Version 2.0 (the
	* "License"); you may not use this file except in compliance
	* with the License.  You may obtain a copy of the License at
	*
	*   http://www.apache.org/licenses/LICENSE-2.0
	*
	* Unless required by applicable law or agreed to in writing,
	* software distributed under the License is distributed on an
	* "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
	* KIND, either express or implied.  See the License for the
	* specific language governing permissions and limitations
	* under the License.
	*/
	
	
	
	/**
	 * AUTO-GENERATED FILE. DO NOT MODIFY.
	 */
	
	"use strict";
	
	exports.__esModule = true;
	var ORIGIN_METHOD = '\0__throttleOriginMethod';
	var RATE = '\0__throttleRate';
	var THROTTLE_TYPE = '\0__throttleType';
	;
	
	function throttle(fn, delay, debounce) {
	  var currCall;
	  var lastCall = 0;
	  var lastExec = 0;
	  var timer = null;
	  var diff;
	  var scope;
	  var args;
	  var debounceNextCall;
	  delay = delay || 0;
	
	  function exec() {
	    lastExec = new Date().getTime();
	    timer = null;
	    fn.apply(scope, args || []);
	  }
	
	  var cb = function () {
	    var cbArgs = [];
	
	    for (var _i = 0; _i < arguments.length; _i++) {
	      cbArgs[_i] = arguments[_i];
	    }
	
	    currCall = new Date().getTime();
	    scope = this;
	    args = cbArgs;
	    var thisDelay = debounceNextCall || delay;
	    var thisDebounce = debounceNextCall || debounce;
	    debounceNextCall = null;
	    diff = currCall - (thisDebounce ? lastCall : lastExec) - thisDelay;
	    clearTimeout(timer);
	
	    if (thisDebounce) {
	      timer = setTimeout(exec, thisDelay);
	    } else {
	      if (diff >= 0) {
	        exec();
	      } else {
	        timer = setTimeout(exec, -diff);
	      }
	    }
	
	    lastCall = currCall;
	  };
	
	  cb.clear = function () {
	    if (timer) {
	      clearTimeout(timer);
	      timer = null;
	    }
	  };
	
	  cb.debounceNextCall = function (debounceDelay) {
	    debounceNextCall = debounceDelay;
	  };
	
	  return cb;
	}
	
	exports.throttle = throttle;
	
	function createOrUpdate(obj, fnAttr, rate, throttleType) {
	  var fn = obj[fnAttr];
	
	  if (!fn) {
	    return;
	  }
	
	  var originFn = fn[ORIGIN_METHOD] || fn;
	  var lastThrottleType = fn[THROTTLE_TYPE];
	  var lastRate = fn[RATE];
	
	  if (lastRate !== rate || lastThrottleType !== throttleType) {
	    if (rate == null || !throttleType) {
	      return obj[fnAttr] = originFn;
	    }
	
	    fn = obj[fnAttr] = throttle(originFn, rate, throttleType === 'debounce');
	    fn[ORIGIN_METHOD] = originFn;
	    fn[THROTTLE_TYPE] = throttleType;
	    fn[RATE] = rate;
	  }
	
	  return fn;
	}
	
	exports.createOrUpdate = createOrUpdate;
	
	function clear(obj, fnAttr) {
	  var fn = obj[fnAttr];
	
	  if (fn && fn[ORIGIN_METHOD]) {
	    obj[fnAttr] = fn[ORIGIN_METHOD];
	  }
	}
	
	exports.clear = clear;

/***/ },
/* 57 */
/***/ function(module, exports, __webpack_require__) {

	const encodePacket = __webpack_require__(388);
	const decodePacket = __webpack_require__(387);
	
	const SEPARATOR = String.fromCharCode(30); // see https://en.wikipedia.org/wiki/Delimiter#ASCII_delimited_text
	
	const encodePayload = (packets, callback) => {
	  // some packets may be added to the array while encoding, so the initial length must be saved
	  const length = packets.length;
	  const encodedPackets = new Array(length);
	  let count = 0;
	
	  packets.forEach((packet, i) => {
	    // force base64 encoding for binary packets
	    encodePacket(packet, false, encodedPacket => {
	      encodedPackets[i] = encodedPacket;
	      if (++count === length) {
	        callback(encodedPackets.join(SEPARATOR));
	      }
	    });
	  });
	};
	
	const decodePayload = (encodedPayload, binaryType) => {
	  const encodedPackets = encodedPayload.split(SEPARATOR);
	  const packets = [];
	  for (let i = 0; i < encodedPackets.length; i++) {
	    const decodedPacket = decodePacket(encodedPackets[i], binaryType);
	    packets.push(decodedPacket);
	    if (decodedPacket.type === "error") {
	      break;
	    }
	  }
	  return packets;
	};
	
	module.exports = {
	  protocol: 4,
	  encodePacket,
	  encodePayload,
	  decodePacket,
	  decodePayload
	};


/***/ },
/* 58 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	function checkDCE() {
	  /* global __REACT_DEVTOOLS_GLOBAL_HOOK__ */
	  if (
	    typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ === 'undefined' ||
	    typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.checkDCE !== 'function'
	  ) {
	    return;
	  }
	  if (false) {
	    // This branch is unreachable because this function is only called
	    // in production, but the condition is true only in development.
	    // Therefore if the branch is still here, dead code elimination wasn't
	    // properly applied.
	    // Don't change the message. React DevTools relies on it. Also make sure
	    // this message doesn't occur elsewhere in this function, or it will cause
	    // a false positive.
	    throw new Error('^_^');
	  }
	  try {
	    // Verify that the code above has been dead code eliminated (DCE'd).
	    __REACT_DEVTOOLS_GLOBAL_HOOK__.checkDCE(checkDCE);
	  } catch (err) {
	    // DevTools shouldn't crash React, no matter what.
	    // We should still report in case we break this code.
	    console.error(err);
	  }
	}
	
	if (true) {
	  // DCE check should happen before ReactDOM bundle executes so that
	  // DevTools can report bad minification during injection.
	  checkDCE();
	  module.exports = __webpack_require__(406);
	} else {
	  module.exports = require('./cjs/react-dom.development.js');
	}


/***/ },
/* 59 */
/***/ function(module, exports) {

	"use strict";
	exports.__esModule = true;
	var Entry = (function () {
	    function Entry(val) {
	        this.value = val;
	    }
	    return Entry;
	}());
	exports.Entry = Entry;
	var LinkedList = (function () {
	    function LinkedList() {
	        this._len = 0;
	    }
	    LinkedList.prototype.insert = function (val) {
	        var entry = new Entry(val);
	        this.insertEntry(entry);
	        return entry;
	    };
	    LinkedList.prototype.insertEntry = function (entry) {
	        if (!this.head) {
	            this.head = this.tail = entry;
	        }
	        else {
	            this.tail.next = entry;
	            entry.prev = this.tail;
	            entry.next = null;
	            this.tail = entry;
	        }
	        this._len++;
	    };
	    LinkedList.prototype.remove = function (entry) {
	        var prev = entry.prev;
	        var next = entry.next;
	        if (prev) {
	            prev.next = next;
	        }
	        else {
	            this.head = next;
	        }
	        if (next) {
	            next.prev = prev;
	        }
	        else {
	            this.tail = prev;
	        }
	        entry.next = entry.prev = null;
	        this._len--;
	    };
	    LinkedList.prototype.len = function () {
	        return this._len;
	    };
	    LinkedList.prototype.clear = function () {
	        this.head = this.tail = null;
	        this._len = 0;
	    };
	    return LinkedList;
	}());
	exports.LinkedList = LinkedList;
	var LRU = (function () {
	    function LRU(maxSize) {
	        this._list = new LinkedList();
	        this._maxSize = 10;
	        this._map = {};
	        this._maxSize = maxSize;
	    }
	    LRU.prototype.put = function (key, value) {
	        var list = this._list;
	        var map = this._map;
	        var removed = null;
	        if (map[key] == null) {
	            var len = list.len();
	            var entry = this._lastRemovedEntry;
	            if (len >= this._maxSize && len > 0) {
	                var leastUsedEntry = list.head;
	                list.remove(leastUsedEntry);
	                delete map[leastUsedEntry.key];
	                removed = leastUsedEntry.value;
	                this._lastRemovedEntry = leastUsedEntry;
	            }
	            if (entry) {
	                entry.value = value;
	            }
	            else {
	                entry = new Entry(value);
	            }
	            entry.key = key;
	            list.insertEntry(entry);
	            map[key] = entry;
	        }
	        return removed;
	    };
	    LRU.prototype.get = function (key) {
	        var entry = this._map[key];
	        var list = this._list;
	        if (entry != null) {
	            if (entry !== list.tail) {
	                list.remove(entry);
	                list.insertEntry(entry);
	            }
	            return entry.value;
	        }
	    };
	    LRU.prototype.clear = function () {
	        this._list.clear();
	        this._map = {};
	    };
	    LRU.prototype.len = function () {
	        return this._list.len();
	    };
	    return LRU;
	}());
	exports["default"] = LRU;


/***/ },
/* 60 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	exports.__esModule = true;
	var tslib_1 = __webpack_require__(5);
	var parseText_1 = __webpack_require__(189);
	var TSpan_1 = __webpack_require__(80);
	var util_1 = __webpack_require__(1);
	var text_1 = __webpack_require__(26);
	var Image_1 = __webpack_require__(43);
	var Rect_1 = __webpack_require__(61);
	var BoundingRect_1 = __webpack_require__(17);
	var matrix_1 = __webpack_require__(27);
	var Displayable_1 = __webpack_require__(50);
	var DEFAULT_RICH_TEXT_COLOR = {
	    fill: '#000'
	};
	var DEFAULT_STROKE_LINE_WIDTH = 2;
	exports.DEFAULT_TEXT_ANIMATION_PROPS = {
	    style: util_1.defaults({
	        fill: true,
	        stroke: true,
	        fillOpacity: true,
	        strokeOpacity: true,
	        lineWidth: true,
	        fontSize: true,
	        lineHeight: true,
	        width: true,
	        height: true,
	        textShadowColor: true,
	        textShadowBlur: true,
	        textShadowOffsetX: true,
	        textShadowOffsetY: true,
	        backgroundColor: true,
	        padding: true,
	        borderColor: true,
	        borderWidth: true,
	        borderRadius: true
	    }, Displayable_1.DEFAULT_COMMON_ANIMATION_PROPS.style)
	};
	var ZRText = (function (_super) {
	    tslib_1.__extends(ZRText, _super);
	    function ZRText(opts) {
	        var _this = _super.call(this) || this;
	        _this.type = 'text';
	        _this._children = [];
	        _this._defaultStyle = DEFAULT_RICH_TEXT_COLOR;
	        _this.attr(opts);
	        return _this;
	    }
	    ZRText.prototype.childrenRef = function () {
	        return this._children;
	    };
	    ZRText.prototype.update = function () {
	        if (this.styleChanged()) {
	            this._updateSubTexts();
	        }
	        for (var i = 0; i < this._children.length; i++) {
	            var child = this._children[i];
	            child.zlevel = this.zlevel;
	            child.z = this.z;
	            child.z2 = this.z2;
	            child.culling = this.culling;
	            child.cursor = this.cursor;
	            child.invisible = this.invisible;
	        }
	        var attachedTransform = this.attachedTransform;
	        if (attachedTransform) {
	            attachedTransform.updateTransform();
	            var m = attachedTransform.transform;
	            if (m) {
	                this.transform = this.transform || [];
	                matrix_1.copy(this.transform, m);
	            }
	            else {
	                this.transform = null;
	            }
	        }
	        else {
	            _super.prototype.update.call(this);
	        }
	    };
	    ZRText.prototype.getComputedTransform = function () {
	        if (this.__hostTarget) {
	            this.__hostTarget.getComputedTransform();
	            this.__hostTarget.updateInnerText(true);
	        }
	        return this.attachedTransform ? this.attachedTransform.getComputedTransform()
	            : _super.prototype.getComputedTransform.call(this);
	    };
	    ZRText.prototype._updateSubTexts = function () {
	        this._childCursor = 0;
	        normalizeTextStyle(this.style);
	        this.style.rich
	            ? this._updateRichTexts()
	            : this._updatePlainTexts();
	        this._children.length = this._childCursor;
	        this.styleUpdated();
	    };
	    ZRText.prototype.addSelfToZr = function (zr) {
	        _super.prototype.addSelfToZr.call(this, zr);
	        for (var i = 0; i < this._children.length; i++) {
	            this._children[i].__zr = zr;
	        }
	    };
	    ZRText.prototype.removeSelfFromZr = function (zr) {
	        _super.prototype.removeSelfFromZr.call(this, zr);
	        for (var i = 0; i < this._children.length; i++) {
	            this._children[i].__zr = null;
	        }
	    };
	    ZRText.prototype.getBoundingRect = function () {
	        if (this.styleChanged()) {
	            this._updateSubTexts();
	        }
	        if (!this._rect) {
	            var tmpRect = new BoundingRect_1["default"](0, 0, 0, 0);
	            var children = this._children;
	            var tmpMat = [];
	            var rect = null;
	            for (var i = 0; i < children.length; i++) {
	                var child = children[i];
	                var childRect = child.getBoundingRect();
	                var transform = child.getLocalTransform(tmpMat);
	                if (transform) {
	                    tmpRect.copy(childRect);
	                    tmpRect.applyTransform(transform);
	                    rect = rect || tmpRect.clone();
	                    rect.union(tmpRect);
	                }
	                else {
	                    rect = rect || childRect.clone();
	                    rect.union(childRect);
	                }
	            }
	            this._rect = rect || tmpRect;
	        }
	        return this._rect;
	    };
	    ZRText.prototype.setDefaultTextStyle = function (defaultTextStyle) {
	        this._defaultStyle = defaultTextStyle || DEFAULT_RICH_TEXT_COLOR;
	    };
	    ZRText.prototype.setTextContent = function (textContent) {
	        throw new Error('Can\'t attach text on another text');
	    };
	    ZRText.prototype._mergeStyle = function (targetStyle, sourceStyle) {
	        if (!sourceStyle) {
	            return targetStyle;
	        }
	        var sourceRich = sourceStyle.rich;
	        var targetRich = targetStyle.rich || (sourceRich && {});
	        util_1.extend(targetStyle, sourceStyle);
	        if (sourceRich && targetRich) {
	            this._mergeRich(targetRich, sourceRich);
	            targetStyle.rich = targetRich;
	        }
	        else if (targetRich) {
	            targetStyle.rich = targetRich;
	        }
	        return targetStyle;
	    };
	    ZRText.prototype._mergeRich = function (targetRich, sourceRich) {
	        var richNames = util_1.keys(sourceRich);
	        for (var i = 0; i < richNames.length; i++) {
	            var richName = richNames[i];
	            targetRich[richName] = targetRich[richName] || {};
	            util_1.extend(targetRich[richName], sourceRich[richName]);
	        }
	    };
	    ZRText.prototype.getAnimationStyleProps = function () {
	        return exports.DEFAULT_TEXT_ANIMATION_PROPS;
	    };
	    ZRText.prototype._getOrCreateChild = function (Ctor) {
	        var child = this._children[this._childCursor];
	        if (!child || !(child instanceof Ctor)) {
	            child = new Ctor();
	        }
	        this._children[this._childCursor++] = child;
	        child.__zr = this.__zr;
	        child.parent = this;
	        return child;
	    };
	    ZRText.prototype._updatePlainTexts = function () {
	        var style = this.style;
	        var textFont = style.font || text_1.DEFAULT_FONT;
	        var textPadding = style.padding;
	        var text = getStyleText(style);
	        var contentBlock = parseText_1.parsePlainText(text, style);
	        var needDrawBg = needDrawBackground(style);
	        var bgColorDrawn = !!(style.backgroundColor);
	        var outerHeight = contentBlock.outerHeight;
	        var textLines = contentBlock.lines;
	        var lineHeight = contentBlock.lineHeight;
	        var defaultStyle = this._defaultStyle;
	        var baseX = style.x || 0;
	        var baseY = style.y || 0;
	        var textAlign = style.align || defaultStyle.align || 'left';
	        var verticalAlign = style.verticalAlign || defaultStyle.verticalAlign || 'top';
	        var textX = baseX;
	        var textY = text_1.adjustTextY(baseY, contentBlock.contentHeight, verticalAlign);
	        if (needDrawBg || textPadding) {
	            var outerWidth_1 = contentBlock.width;
	            textPadding && (outerWidth_1 += textPadding[1] + textPadding[3]);
	            var boxX = text_1.adjustTextX(baseX, outerWidth_1, textAlign);
	            var boxY = text_1.adjustTextY(baseY, outerHeight, verticalAlign);
	            needDrawBg && this._renderBackground(style, style, boxX, boxY, outerWidth_1, outerHeight);
	        }
	        textY += lineHeight / 2;
	        if (textPadding) {
	            textX = getTextXForPadding(baseX, textAlign, textPadding);
	            if (verticalAlign === 'top') {
	                textY += textPadding[0];
	            }
	            else if (verticalAlign === 'bottom') {
	                textY -= textPadding[2];
	            }
	        }
	        var defaultLineWidth = 0;
	        var useDefaultFill = false;
	        var textFill = getFill('fill' in style
	            ? style.fill
	            : (useDefaultFill = true, defaultStyle.fill));
	        var textStroke = getStroke('stroke' in style
	            ? style.stroke
	            : (!bgColorDrawn
	                && (!defaultStyle.autoStroke || useDefaultFill))
	                ? (defaultLineWidth = DEFAULT_STROKE_LINE_WIDTH, defaultStyle.stroke)
	                : null);
	        var hasShadow = style.textShadowBlur > 0;
	        var fixedBoundingRect = style.width != null
	            && (style.overflow === 'truncate' || style.overflow === 'break' || style.overflow === 'breakAll');
	        var calculatedLineHeight = contentBlock.calculatedLineHeight;
	        for (var i = 0; i < textLines.length; i++) {
	            var el = this._getOrCreateChild(TSpan_1["default"]);
	            var subElStyle = el.createStyle();
	            el.useStyle(subElStyle);
	            subElStyle.text = textLines[i];
	            subElStyle.x = textX;
	            subElStyle.y = textY;
	            if (textAlign) {
	                subElStyle.textAlign = textAlign;
	            }
	            subElStyle.textBaseline = 'middle';
	            subElStyle.opacity = style.opacity;
	            subElStyle.strokeFirst = true;
	            if (hasShadow) {
	                subElStyle.shadowBlur = style.textShadowBlur || 0;
	                subElStyle.shadowColor = style.textShadowColor || 'transparent';
	                subElStyle.shadowOffsetX = style.textShadowOffsetX || 0;
	                subElStyle.shadowOffsetY = style.textShadowOffsetY || 0;
	            }
	            if (textStroke) {
	                subElStyle.stroke = textStroke;
	                subElStyle.lineWidth = style.lineWidth || defaultLineWidth;
	                subElStyle.lineDash = style.lineDash;
	                subElStyle.lineDashOffset = style.lineDashOffset || 0;
	            }
	            if (textFill) {
	                subElStyle.fill = textFill;
	            }
	            subElStyle.font = textFont;
	            textY += lineHeight;
	            if (fixedBoundingRect) {
	                el.setBoundingRect(new BoundingRect_1["default"](text_1.adjustTextX(subElStyle.x, style.width, subElStyle.textAlign), text_1.adjustTextY(subElStyle.y, calculatedLineHeight, subElStyle.textBaseline), style.width, calculatedLineHeight));
	            }
	        }
	    };
	    ZRText.prototype._updateRichTexts = function () {
	        var style = this.style;
	        var text = getStyleText(style);
	        var contentBlock = parseText_1.parseRichText(text, style);
	        var contentWidth = contentBlock.width;
	        var outerWidth = contentBlock.outerWidth;
	        var outerHeight = contentBlock.outerHeight;
	        var textPadding = style.padding;
	        var baseX = style.x || 0;
	        var baseY = style.y || 0;
	        var defaultStyle = this._defaultStyle;
	        var textAlign = style.align || defaultStyle.align;
	        var verticalAlign = style.verticalAlign || defaultStyle.verticalAlign;
	        var boxX = text_1.adjustTextX(baseX, outerWidth, textAlign);
	        var boxY = text_1.adjustTextY(baseY, outerHeight, verticalAlign);
	        var xLeft = boxX;
	        var lineTop = boxY;
	        if (textPadding) {
	            xLeft += textPadding[3];
	            lineTop += textPadding[0];
	        }
	        var xRight = xLeft + contentWidth;
	        if (needDrawBackground(style)) {
	            this._renderBackground(style, style, boxX, boxY, outerWidth, outerHeight);
	        }
	        var bgColorDrawn = !!(style.backgroundColor);
	        for (var i = 0; i < contentBlock.lines.length; i++) {
	            var line = contentBlock.lines[i];
	            var tokens = line.tokens;
	            var tokenCount = tokens.length;
	            var lineHeight = line.lineHeight;
	            var remainedWidth = line.width;
	            var leftIndex = 0;
	            var lineXLeft = xLeft;
	            var lineXRight = xRight;
	            var rightIndex = tokenCount - 1;
	            var token = void 0;
	            while (leftIndex < tokenCount
	                && (token = tokens[leftIndex], !token.align || token.align === 'left')) {
	                this._placeToken(token, style, lineHeight, lineTop, lineXLeft, 'left', bgColorDrawn);
	                remainedWidth -= token.width;
	                lineXLeft += token.width;
	                leftIndex++;
	            }
	            while (rightIndex >= 0
	                && (token = tokens[rightIndex], token.align === 'right')) {
	                this._placeToken(token, style, lineHeight, lineTop, lineXRight, 'right', bgColorDrawn);
	                remainedWidth -= token.width;
	                lineXRight -= token.width;
	                rightIndex--;
	            }
	            lineXLeft += (contentWidth - (lineXLeft - xLeft) - (xRight - lineXRight) - remainedWidth) / 2;
	            while (leftIndex <= rightIndex) {
	                token = tokens[leftIndex];
	                this._placeToken(token, style, lineHeight, lineTop, lineXLeft + token.width / 2, 'center', bgColorDrawn);
	                lineXLeft += token.width;
	                leftIndex++;
	            }
	            lineTop += lineHeight;
	        }
	    };
	    ZRText.prototype._placeToken = function (token, style, lineHeight, lineTop, x, textAlign, parentBgColorDrawn) {
	        var tokenStyle = style.rich[token.styleName] || {};
	        tokenStyle.text = token.text;
	        var verticalAlign = token.verticalAlign;
	        var y = lineTop + lineHeight / 2;
	        if (verticalAlign === 'top') {
	            y = lineTop + token.height / 2;
	        }
	        else if (verticalAlign === 'bottom') {
	            y = lineTop + lineHeight - token.height / 2;
	        }
	        var needDrawBg = !token.isLineHolder && needDrawBackground(tokenStyle);
	        needDrawBg && this._renderBackground(tokenStyle, style, textAlign === 'right'
	            ? x - token.width
	            : textAlign === 'center'
	                ? x - token.width / 2
	                : x, y - token.height / 2, token.width, token.height);
	        var bgColorDrawn = !!tokenStyle.backgroundColor;
	        var textPadding = token.textPadding;
	        if (textPadding) {
	            x = getTextXForPadding(x, textAlign, textPadding);
	            y -= token.height / 2 - textPadding[0] - token.innerHeight / 2;
	        }
	        var el = this._getOrCreateChild(TSpan_1["default"]);
	        var subElStyle = el.createStyle();
	        el.useStyle(subElStyle);
	        var defaultStyle = this._defaultStyle;
	        var useDefaultFill = false;
	        var defaultLineWidth = 0;
	        var textFill = getStroke('fill' in tokenStyle ? tokenStyle.fill
	            : 'fill' in style ? style.fill
	                : (useDefaultFill = true, defaultStyle.fill));
	        var textStroke = getStroke('stroke' in tokenStyle ? tokenStyle.stroke
	            : 'stroke' in style ? style.stroke
	                : (!bgColorDrawn
	                    && !parentBgColorDrawn
	                    && (!defaultStyle.autoStroke || useDefaultFill)) ? (defaultLineWidth = DEFAULT_STROKE_LINE_WIDTH, defaultStyle.stroke)
	                    : null);
	        var hasShadow = tokenStyle.textShadowBlur > 0
	            || style.textShadowBlur > 0;
	        subElStyle.text = token.text;
	        subElStyle.x = x;
	        subElStyle.y = y;
	        if (hasShadow) {
	            subElStyle.shadowBlur = tokenStyle.textShadowBlur || style.textShadowBlur || 0;
	            subElStyle.shadowColor = tokenStyle.textShadowColor || style.textShadowColor || 'transparent';
	            subElStyle.shadowOffsetX = tokenStyle.textShadowOffsetX || style.textShadowOffsetX || 0;
	            subElStyle.shadowOffsetY = tokenStyle.textShadowOffsetY || style.textShadowOffsetY || 0;
	        }
	        subElStyle.textAlign = textAlign;
	        subElStyle.textBaseline = 'middle';
	        subElStyle.font = token.font || text_1.DEFAULT_FONT;
	        subElStyle.opacity = util_1.retrieve3(tokenStyle.opacity, style.opacity, 1);
	        if (textStroke) {
	            subElStyle.lineWidth = util_1.retrieve3(tokenStyle.lineWidth, style.lineWidth, defaultLineWidth);
	            subElStyle.lineDash = util_1.retrieve2(tokenStyle.lineDash, style.lineDash);
	            subElStyle.lineDashOffset = style.lineDashOffset || 0;
	            subElStyle.stroke = textStroke;
	        }
	        if (textFill) {
	            subElStyle.fill = textFill;
	        }
	        var textWidth = token.contentWidth;
	        var textHeight = token.contentHeight;
	        el.setBoundingRect(new BoundingRect_1["default"](text_1.adjustTextX(subElStyle.x, textWidth, subElStyle.textAlign), text_1.adjustTextY(subElStyle.y, textHeight, subElStyle.textBaseline), textWidth, textHeight));
	    };
	    ZRText.prototype._renderBackground = function (style, topStyle, x, y, width, height) {
	        var textBackgroundColor = style.backgroundColor;
	        var textBorderWidth = style.borderWidth;
	        var textBorderColor = style.borderColor;
	        var isPlainBg = util_1.isString(textBackgroundColor);
	        var textBorderRadius = style.borderRadius;
	        var self = this;
	        var rectEl;
	        var imgEl;
	        if (isPlainBg || (textBorderWidth && textBorderColor)) {
	            rectEl = this._getOrCreateChild(Rect_1["default"]);
	            rectEl.useStyle(rectEl.createStyle());
	            rectEl.style.fill = null;
	            var rectShape = rectEl.shape;
	            rectShape.x = x;
	            rectShape.y = y;
	            rectShape.width = width;
	            rectShape.height = height;
	            rectShape.r = textBorderRadius;
	            rectEl.dirtyShape();
	        }
	        if (isPlainBg) {
	            var rectStyle = rectEl.style;
	            rectStyle.fill = textBackgroundColor || null;
	            rectStyle.fillOpacity = util_1.retrieve2(style.fillOpacity, 1);
	        }
	        else if (textBackgroundColor && textBackgroundColor.image) {
	            imgEl = this._getOrCreateChild(Image_1["default"]);
	            imgEl.onload = function () {
	                self.dirtyStyle();
	            };
	            var imgStyle = imgEl.style;
	            imgStyle.image = textBackgroundColor.image;
	            imgStyle.x = x;
	            imgStyle.y = y;
	            imgStyle.width = width;
	            imgStyle.height = height;
	        }
	        if (textBorderWidth && textBorderColor) {
	            var rectStyle = rectEl.style;
	            rectStyle.lineWidth = textBorderWidth;
	            rectStyle.stroke = textBorderColor;
	            rectStyle.strokeOpacity = util_1.retrieve2(style.strokeOpacity, 1);
	            rectStyle.lineDash = style.borderDash;
	            rectStyle.lineDashOffset = style.borderDashOffset || 0;
	            rectEl.strokeContainThreshold = 0;
	            if (rectEl.hasFill() && rectEl.hasStroke()) {
	                rectStyle.strokeFirst = true;
	                rectStyle.lineWidth *= 2;
	            }
	        }
	        var commonStyle = (rectEl || imgEl).style;
	        commonStyle.shadowBlur = style.shadowBlur || 0;
	        commonStyle.shadowColor = style.shadowColor || 'transparent';
	        commonStyle.shadowOffsetX = style.shadowOffsetX || 0;
	        commonStyle.shadowOffsetY = style.shadowOffsetY || 0;
	        commonStyle.opacity = util_1.retrieve3(style.opacity, topStyle.opacity, 1);
	    };
	    ZRText.makeFont = function (style) {
	        var font = '';
	        if (style.fontSize || style.fontFamily || style.fontWeight) {
	            var fontSize = '';
	            if (typeof style.fontSize === 'string'
	                && (style.fontSize.indexOf('px') !== -1
	                    || style.fontSize.indexOf('rem') !== -1
	                    || style.fontSize.indexOf('em') !== -1)) {
	                fontSize = style.fontSize;
	            }
	            else if (!isNaN(+style.fontSize)) {
	                fontSize = style.fontSize + 'px';
	            }
	            else {
	                fontSize = '12px';
	            }
	            font = [
	                style.fontStyle,
	                style.fontWeight,
	                fontSize,
	                style.fontFamily || 'sans-serif'
	            ].join(' ');
	        }
	        return font && util_1.trim(font) || style.textFont || style.font;
	    };
	    return ZRText;
	}(Displayable_1["default"]));
	var VALID_TEXT_ALIGN = { left: true, right: 1, center: 1 };
	var VALID_TEXT_VERTICAL_ALIGN = { top: 1, bottom: 1, middle: 1 };
	function normalizeTextStyle(style) {
	    normalizeStyle(style);
	    util_1.each(style.rich, normalizeStyle);
	    return style;
	}
	exports.normalizeTextStyle = normalizeTextStyle;
	function normalizeStyle(style) {
	    if (style) {
	        style.font = ZRText.makeFont(style);
	        var textAlign = style.align;
	        textAlign === 'middle' && (textAlign = 'center');
	        style.align = (textAlign == null || VALID_TEXT_ALIGN[textAlign]) ? textAlign : 'left';
	        var verticalAlign = style.verticalAlign;
	        verticalAlign === 'center' && (verticalAlign = 'middle');
	        style.verticalAlign = (verticalAlign == null || VALID_TEXT_VERTICAL_ALIGN[verticalAlign]) ? verticalAlign : 'top';
	        var textPadding = style.padding;
	        if (textPadding) {
	            style.padding = util_1.normalizeCssArray(style.padding);
	        }
	    }
	}
	function getStroke(stroke, lineWidth) {
	    return (stroke == null || lineWidth <= 0 || stroke === 'transparent' || stroke === 'none')
	        ? null
	        : (stroke.image || stroke.colorStops)
	            ? '#000'
	            : stroke;
	}
	function getFill(fill) {
	    return (fill == null || fill === 'none')
	        ? null
	        : (fill.image || fill.colorStops)
	            ? '#000'
	            : fill;
	}
	function getTextXForPadding(x, textAlign, textPadding) {
	    return textAlign === 'right'
	        ? (x - textPadding[1])
	        : textAlign === 'center'
	            ? (x + textPadding[3] / 2 - textPadding[1] / 2)
	            : (x + textPadding[3]);
	}
	function getStyleText(style) {
	    var text = style.text;
	    text != null && (text += '');
	    return text;
	}
	function needDrawBackground(style) {
	    return !!(style.backgroundColor
	        || (style.borderWidth && style.borderColor));
	}
	exports["default"] = ZRText;


/***/ },
/* 61 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	exports.__esModule = true;
	var tslib_1 = __webpack_require__(5);
	var Path_1 = __webpack_require__(8);
	var roundRectHelper = __webpack_require__(464);
	var subPixelOptimize_1 = __webpack_require__(110);
	var RectShape = (function () {
	    function RectShape() {
	        this.x = 0;
	        this.y = 0;
	        this.width = 0;
	        this.height = 0;
	    }
	    return RectShape;
	}());
	var subPixelOptimizeOutputShape = {};
	var Rect = (function (_super) {
	    tslib_1.__extends(Rect, _super);
	    function Rect(opts) {
	        return _super.call(this, opts) || this;
	    }
	    Rect.prototype.getDefaultShape = function () {
	        return new RectShape();
	    };
	    Rect.prototype.buildPath = function (ctx, shape) {
	        var x;
	        var y;
	        var width;
	        var height;
	        if (this.subPixelOptimize) {
	            var optimizedShape = subPixelOptimize_1.subPixelOptimizeRect(subPixelOptimizeOutputShape, shape, this.style);
	            x = optimizedShape.x;
	            y = optimizedShape.y;
	            width = optimizedShape.width;
	            height = optimizedShape.height;
	            optimizedShape.r = shape.r;
	            shape = optimizedShape;
	        }
	        else {
	            x = shape.x;
	            y = shape.y;
	            width = shape.width;
	            height = shape.height;
	        }
	        if (!shape.r) {
	            ctx.rect(x, y, width, height);
	        }
	        else {
	            roundRectHelper.buildPath(ctx, shape);
	        }
	    };
	    Rect.prototype.isZeroArea = function () {
	        return !this.shape.width || !this.shape.height;
	    };
	    return Rect;
	}(Path_1["default"]));
	Rect.prototype.type = 'rect';
	exports["default"] = Rect;


/***/ },
/* 62 */
/***/ function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;/*!
	  Copyright (c) 2017 Jed Watson.
	  Licensed under the MIT License (MIT), see
	  http://jedwatson.github.io/classnames
	*/
	/* global define */
	
	(function () {
		'use strict';
	
		var hasOwn = {}.hasOwnProperty;
	
		function classNames () {
			var classes = [];
	
			for (var i = 0; i < arguments.length; i++) {
				var arg = arguments[i];
				if (!arg) continue;
	
				var argType = typeof arg;
	
				if (argType === 'string' || argType === 'number') {
					classes.push(arg);
				} else if (Array.isArray(arg) && arg.length) {
					var inner = classNames.apply(null, arg);
					if (inner) {
						classes.push(inner);
					}
				} else if (argType === 'object') {
					for (var key in arg) {
						if (hasOwn.call(arg, key) && arg[key]) {
							classes.push(key);
						}
					}
				}
			}
	
			return classes.join(' ');
		}
	
		if (typeof module !== 'undefined' && module.exports) {
			classNames.default = classNames;
			module.exports = classNames;
		} else if (true) {
			// register as 'classnames', consistent with npm package name
			!(__WEBPACK_AMD_DEFINE_ARRAY__ = [], __WEBPACK_AMD_DEFINE_RESULT__ = function () {
				return classNames;
			}.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
		} else {
			window.classNames = classNames;
		}
	}());


/***/ },
/* 63 */
/***/ function(module, exports, __webpack_require__) {

	
	/*
	* Licensed to the Apache Software Foundation (ASF) under one
	* or more contributor license agreements.  See the NOTICE file
	* distributed with this work for additional information
	* regarding copyright ownership.  The ASF licenses this file
	* to you under the Apache License, Version 2.0 (the
	* "License"); you may not use this file except in compliance
	* with the License.  You may obtain a copy of the License at
	*
	*   http://www.apache.org/licenses/LICENSE-2.0
	*
	* Unless required by applicable law or agreed to in writing,
	* software distributed under the License is distributed on an
	* "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
	* KIND, either express or implied.  See the License for the
	* specific language governing permissions and limitations
	* under the License.
	*/
	
	
	
	/**
	 * AUTO-GENERATED FILE. DO NOT MODIFY.
	 */
	
	"use strict";
	
	exports.__esModule = true;
	
	var Model_1 = __webpack_require__(24);
	
	var util_1 = __webpack_require__(1);
	
	function collect(ecModel, api) {
	  var result = {
	    axesInfo: {},
	    seriesInvolved: false,
	    coordSysAxesInfo: {},
	    coordSysMap: {}
	  };
	  collectAxesInfo(result, ecModel, api);
	  result.seriesInvolved && collectSeriesInfo(result, ecModel);
	  return result;
	}
	
	exports.collect = collect;
	
	function collectAxesInfo(result, ecModel, api) {
	  var globalTooltipModel = ecModel.getComponent('tooltip');
	  var globalAxisPointerModel = ecModel.getComponent('axisPointer');
	  var linksOption = globalAxisPointerModel.get('link', true) || [];
	  var linkGroups = [];
	  util_1.each(api.getCoordinateSystems(), function (coordSys) {
	    if (!coordSys.axisPointerEnabled) {
	      return;
	    }
	
	    var coordSysKey = makeKey(coordSys.model);
	    var axesInfoInCoordSys = result.coordSysAxesInfo[coordSysKey] = {};
	    result.coordSysMap[coordSysKey] = coordSys;
	    var coordSysModel = coordSys.model;
	    var baseTooltipModel = coordSysModel.getModel('tooltip', globalTooltipModel);
	    util_1.each(coordSys.getAxes(), util_1.curry(saveTooltipAxisInfo, false, null));
	
	    if (coordSys.getTooltipAxes && globalTooltipModel && baseTooltipModel.get('show')) {
	      var triggerAxis = baseTooltipModel.get('trigger') === 'axis';
	      var cross = baseTooltipModel.get(['axisPointer', 'type']) === 'cross';
	      var tooltipAxes = coordSys.getTooltipAxes(baseTooltipModel.get(['axisPointer', 'axis']));
	
	      if (triggerAxis || cross) {
	        util_1.each(tooltipAxes.baseAxes, util_1.curry(saveTooltipAxisInfo, cross ? 'cross' : true, triggerAxis));
	      }
	
	      if (cross) {
	        util_1.each(tooltipAxes.otherAxes, util_1.curry(saveTooltipAxisInfo, 'cross', false));
	      }
	    }
	
	    function saveTooltipAxisInfo(fromTooltip, triggerTooltip, axis) {
	      var axisPointerModel = axis.model.getModel('axisPointer', globalAxisPointerModel);
	      var axisPointerShow = axisPointerModel.get('show');
	
	      if (!axisPointerShow || axisPointerShow === 'auto' && !fromTooltip && !isHandleTrigger(axisPointerModel)) {
	        return;
	      }
	
	      if (triggerTooltip == null) {
	        triggerTooltip = axisPointerModel.get('triggerTooltip');
	      }
	
	      axisPointerModel = fromTooltip ? makeAxisPointerModel(axis, baseTooltipModel, globalAxisPointerModel, ecModel, fromTooltip, triggerTooltip) : axisPointerModel;
	      var snap = axisPointerModel.get('snap');
	      var axisKey = makeKey(axis.model);
	      var involveSeries = triggerTooltip || snap || axis.type === 'category';
	      var axisInfo = result.axesInfo[axisKey] = {
	        key: axisKey,
	        axis: axis,
	        coordSys: coordSys,
	        axisPointerModel: axisPointerModel,
	        triggerTooltip: triggerTooltip,
	        involveSeries: involveSeries,
	        snap: snap,
	        useHandle: isHandleTrigger(axisPointerModel),
	        seriesModels: [],
	        linkGroup: null
	      };
	      axesInfoInCoordSys[axisKey] = axisInfo;
	      result.seriesInvolved = result.seriesInvolved || involveSeries;
	      var groupIndex = getLinkGroupIndex(linksOption, axis);
	
	      if (groupIndex != null) {
	        var linkGroup = linkGroups[groupIndex] || (linkGroups[groupIndex] = {
	          axesInfo: {}
	        });
	        linkGroup.axesInfo[axisKey] = axisInfo;
	        linkGroup.mapper = linksOption[groupIndex].mapper;
	        axisInfo.linkGroup = linkGroup;
	      }
	    }
	  });
	}
	
	function makeAxisPointerModel(axis, baseTooltipModel, globalAxisPointerModel, ecModel, fromTooltip, triggerTooltip) {
	  var tooltipAxisPointerModel = baseTooltipModel.getModel('axisPointer');
	  var fields = ['type', 'snap', 'lineStyle', 'shadowStyle', 'label', 'animation', 'animationDurationUpdate', 'animationEasingUpdate', 'z'];
	  var volatileOption = {};
	  util_1.each(fields, function (field) {
	    volatileOption[field] = util_1.clone(tooltipAxisPointerModel.get(field));
	  });
	  volatileOption.snap = axis.type !== 'category' && !!triggerTooltip;
	
	  if (tooltipAxisPointerModel.get('type') === 'cross') {
	    volatileOption.type = 'line';
	  }
	
	  var labelOption = volatileOption.label || (volatileOption.label = {});
	  labelOption.show == null && (labelOption.show = false);
	
	  if (fromTooltip === 'cross') {
	    var tooltipAxisPointerLabelShow = tooltipAxisPointerModel.get(['label', 'show']);
	    labelOption.show = tooltipAxisPointerLabelShow != null ? tooltipAxisPointerLabelShow : true;
	
	    if (!triggerTooltip) {
	      var crossStyle = volatileOption.lineStyle = tooltipAxisPointerModel.get('crossStyle');
	      crossStyle && util_1.defaults(labelOption, crossStyle.textStyle);
	    }
	  }
	
	  return axis.model.getModel('axisPointer', new Model_1["default"](volatileOption, globalAxisPointerModel, ecModel));
	}
	
	function collectSeriesInfo(result, ecModel) {
	  ecModel.eachSeries(function (seriesModel) {
	    var coordSys = seriesModel.coordinateSystem;
	    var seriesTooltipTrigger = seriesModel.get(['tooltip', 'trigger'], true);
	    var seriesTooltipShow = seriesModel.get(['tooltip', 'show'], true);
	
	    if (!coordSys || seriesTooltipTrigger === 'none' || seriesTooltipTrigger === false || seriesTooltipTrigger === 'item' || seriesTooltipShow === false || seriesModel.get(['axisPointer', 'show'], true) === false) {
	      return;
	    }
	
	    util_1.each(result.coordSysAxesInfo[makeKey(coordSys.model)], function (axisInfo) {
	      var axis = axisInfo.axis;
	
	      if (coordSys.getAxis(axis.dim) === axis) {
	        axisInfo.seriesModels.push(seriesModel);
	        axisInfo.seriesDataCount == null && (axisInfo.seriesDataCount = 0);
	        axisInfo.seriesDataCount += seriesModel.getData().count();
	      }
	    });
	  });
	}
	
	function getLinkGroupIndex(linksOption, axis) {
	  var axisModel = axis.model;
	  var dim = axis.dim;
	
	  for (var i = 0; i < linksOption.length; i++) {
	    var linkOption = linksOption[i] || {};
	
	    if (checkPropInLink(linkOption[dim + 'AxisId'], axisModel.id) || checkPropInLink(linkOption[dim + 'AxisIndex'], axisModel.componentIndex) || checkPropInLink(linkOption[dim + 'AxisName'], axisModel.name)) {
	      return i;
	    }
	  }
	}
	
	function checkPropInLink(linkPropValue, axisPropValue) {
	  return linkPropValue === 'all' || util_1.isArray(linkPropValue) && util_1.indexOf(linkPropValue, axisPropValue) >= 0 || linkPropValue === axisPropValue;
	}
	
	function fixValue(axisModel) {
	  var axisInfo = getAxisInfo(axisModel);
	
	  if (!axisInfo) {
	    return;
	  }
	
	  var axisPointerModel = axisInfo.axisPointerModel;
	  var scale = axisInfo.axis.scale;
	  var option = axisPointerModel.option;
	  var status = axisPointerModel.get('status');
	  var value = axisPointerModel.get('value');
	
	  if (value != null) {
	    value = scale.parse(value);
	  }
	
	  var useHandle = isHandleTrigger(axisPointerModel);
	
	  if (status == null) {
	    option.status = useHandle ? 'show' : 'hide';
	  }
	
	  var extent = scale.getExtent().slice();
	  extent[0] > extent[1] && extent.reverse();
	
	  if (value == null || value > extent[1]) {
	    value = extent[1];
	  }
	
	  if (value < extent[0]) {
	    value = extent[0];
	  }
	
	  option.value = value;
	
	  if (useHandle) {
	    option.status = axisInfo.axis.scale.isBlank() ? 'hide' : 'show';
	  }
	}
	
	exports.fixValue = fixValue;
	
	function getAxisInfo(axisModel) {
	  var coordSysAxesInfo = (axisModel.ecModel.getComponent('axisPointer') || {}).coordSysAxesInfo;
	  return coordSysAxesInfo && coordSysAxesInfo.axesInfo[makeKey(axisModel)];
	}
	
	exports.getAxisInfo = getAxisInfo;
	
	function getAxisPointerModel(axisModel) {
	  var axisInfo = getAxisInfo(axisModel);
	  return axisInfo && axisInfo.axisPointerModel;
	}
	
	exports.getAxisPointerModel = getAxisPointerModel;
	
	function isHandleTrigger(axisPointerModel) {
	  return !!axisPointerModel.get(['handle', 'show']);
	}
	
	function makeKey(model) {
	  return model.type + '||' + model.id;
	}
	
	exports.makeKey = makeKey;

/***/ },
/* 64 */
/***/ function(module, exports, __webpack_require__) {

	
	/*
	* Licensed to the Apache Software Foundation (ASF) under one
	* or more contributor license agreements.  See the NOTICE file
	* distributed with this work for additional information
	* regarding copyright ownership.  The ASF licenses this file
	* to you under the Apache License, Version 2.0 (the
	* "License"); you may not use this file except in compliance
	* with the License.  You may obtain a copy of the License at
	*
	*   http://www.apache.org/licenses/LICENSE-2.0
	*
	* Unless required by applicable law or agreed to in writing,
	* software distributed under the License is distributed on an
	* "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
	* KIND, either express or implied.  See the License for the
	* specific language governing permissions and limitations
	* under the License.
	*/
	
	
	
	/**
	 * AUTO-GENERATED FILE. DO NOT MODIFY.
	 */
	
	"use strict";
	
	exports.__esModule = true;
	
	__webpack_require__(315);
	
	__webpack_require__(314);

/***/ },
/* 65 */
/***/ function(module, exports, __webpack_require__) {

	
	/*
	* Licensed to the Apache Software Foundation (ASF) under one
	* or more contributor license agreements.  See the NOTICE file
	* distributed with this work for additional information
	* regarding copyright ownership.  The ASF licenses this file
	* to you under the Apache License, Version 2.0 (the
	* "License"); you may not use this file except in compliance
	* with the License.  You may obtain a copy of the License at
	*
	*   http://www.apache.org/licenses/LICENSE-2.0
	*
	* Unless required by applicable law or agreed to in writing,
	* software distributed under the License is distributed on an
	* "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
	* KIND, either express or implied.  See the License for the
	* specific language governing permissions and limitations
	* under the License.
	*/
	
	
	
	/**
	 * AUTO-GENERATED FILE. DO NOT MODIFY.
	 */
	
	"use strict";
	
	exports.__esModule = true;
	
	var tslib_1 = __webpack_require__(3);
	
	var util_1 = __webpack_require__(1);
	
	var Component_1 = __webpack_require__(10);
	
	var helper_1 = __webpack_require__(45);
	
	var model_1 = __webpack_require__(4);
	
	var DataZoomAxisInfo = function () {
	  function DataZoomAxisInfo() {
	    this.indexList = [];
	    this.indexMap = [];
	  }
	
	  DataZoomAxisInfo.prototype.add = function (axisCmptIdx) {
	    if (!this.indexMap[axisCmptIdx]) {
	      this.indexList.push(axisCmptIdx);
	      this.indexMap[axisCmptIdx] = true;
	    }
	  };
	
	  return DataZoomAxisInfo;
	}();
	
	var DataZoomModel = function (_super) {
	  tslib_1.__extends(DataZoomModel, _super);
	
	  function DataZoomModel() {
	    var _this = _super !== null && _super.apply(this, arguments) || this;
	
	    _this.type = DataZoomModel.type;
	    _this._autoThrottle = true;
	    _this._noTarget = true;
	    _this._rangePropMode = ['percent', 'percent'];
	    return _this;
	  }
	
	  DataZoomModel.prototype.init = function (option, parentModel, ecModel) {
	    var inputRawOption = retrieveRawOption(option);
	    this.settledOption = inputRawOption;
	    this.mergeDefaultAndTheme(option, ecModel);
	
	    this._doInit(inputRawOption);
	  };
	
	  DataZoomModel.prototype.mergeOption = function (newOption) {
	    var inputRawOption = retrieveRawOption(newOption);
	    util_1.merge(this.option, newOption, true);
	    util_1.merge(this.settledOption, inputRawOption, true);
	
	    this._doInit(inputRawOption);
	  };
	
	  DataZoomModel.prototype._doInit = function (inputRawOption) {
	    var thisOption = this.option;
	
	    this._setDefaultThrottle(inputRawOption);
	
	    this._updateRangeUse(inputRawOption);
	
	    var settledOption = this.settledOption;
	    util_1.each([['start', 'startValue'], ['end', 'endValue']], function (names, index) {
	      if (this._rangePropMode[index] === 'value') {
	        thisOption[names[0]] = settledOption[names[0]] = null;
	      }
	    }, this);
	
	    this._resetTarget();
	  };
	
	  DataZoomModel.prototype._resetTarget = function () {
	    var optionOrient = this.get('orient', true);
	    var targetAxisIndexMap = this._targetAxisInfoMap = util_1.createHashMap();
	
	    var hasAxisSpecified = this._fillSpecifiedTargetAxis(targetAxisIndexMap);
	
	    if (hasAxisSpecified) {
	      this._orient = optionOrient || this._makeAutoOrientByTargetAxis();
	    } else {
	      this._orient = optionOrient || 'horizontal';
	
	      this._fillAutoTargetAxisByOrient(targetAxisIndexMap, this._orient);
	    }
	
	    this._noTarget = true;
	    targetAxisIndexMap.each(function (axisInfo) {
	      if (axisInfo.indexList.length) {
	        this._noTarget = false;
	      }
	    }, this);
	  };
	
	  DataZoomModel.prototype._fillSpecifiedTargetAxis = function (targetAxisIndexMap) {
	    var hasAxisSpecified = false;
	    util_1.each(helper_1.DATA_ZOOM_AXIS_DIMENSIONS, function (axisDim) {
	      var refering = this.getReferringComponents(helper_1.getAxisMainType(axisDim), model_1.MULTIPLE_REFERRING);
	
	      if (!refering.specified) {
	        return;
	      }
	
	      hasAxisSpecified = true;
	      var axisInfo = new DataZoomAxisInfo();
	      util_1.each(refering.models, function (axisModel) {
	        axisInfo.add(axisModel.componentIndex);
	      });
	      targetAxisIndexMap.set(axisDim, axisInfo);
	    }, this);
	    return hasAxisSpecified;
	  };
	
	  DataZoomModel.prototype._fillAutoTargetAxisByOrient = function (targetAxisIndexMap, orient) {
	    var ecModel = this.ecModel;
	    var needAuto = true;
	
	    if (needAuto) {
	      var axisDim = orient === 'vertical' ? 'y' : 'x';
	      var axisModels = ecModel.findComponents({
	        mainType: axisDim + 'Axis'
	      });
	      setParallelAxis(axisModels, axisDim);
	    }
	
	    if (needAuto) {
	      var axisModels = ecModel.findComponents({
	        mainType: 'singleAxis',
	        filter: function (axisModel) {
	          return axisModel.get('orient', true) === orient;
	        }
	      });
	      setParallelAxis(axisModels, 'single');
	    }
	
	    function setParallelAxis(axisModels, axisDim) {
	      var axisModel = axisModels[0];
	
	      if (!axisModel) {
	        return;
	      }
	
	      var axisInfo = new DataZoomAxisInfo();
	      axisInfo.add(axisModel.componentIndex);
	      targetAxisIndexMap.set(axisDim, axisInfo);
	      needAuto = false;
	
	      if (axisDim === 'x' || axisDim === 'y') {
	        var gridModel_1 = axisModel.getReferringComponents('grid', model_1.SINGLE_REFERRING).models[0];
	        gridModel_1 && util_1.each(axisModels, function (axModel) {
	          if (axisModel.componentIndex !== axModel.componentIndex && gridModel_1 === axModel.getReferringComponents('grid', model_1.SINGLE_REFERRING).models[0]) {
	            axisInfo.add(axModel.componentIndex);
	          }
	        });
	      }
	    }
	
	    if (needAuto) {
	      util_1.each(helper_1.DATA_ZOOM_AXIS_DIMENSIONS, function (axisDim) {
	        if (!needAuto) {
	          return;
	        }
	
	        var axisModels = ecModel.findComponents({
	          mainType: helper_1.getAxisMainType(axisDim),
	          filter: function (axisModel) {
	            return axisModel.get('type', true) === 'category';
	          }
	        });
	
	        if (axisModels[0]) {
	          var axisInfo = new DataZoomAxisInfo();
	          axisInfo.add(axisModels[0].componentIndex);
	          targetAxisIndexMap.set(axisDim, axisInfo);
	          needAuto = false;
	        }
	      }, this);
	    }
	  };
	
	  DataZoomModel.prototype._makeAutoOrientByTargetAxis = function () {
	    var dim;
	    this.eachTargetAxis(function (axisDim) {
	      !dim && (dim = axisDim);
	    }, this);
	    return dim === 'y' ? 'vertical' : 'horizontal';
	  };
	
	  DataZoomModel.prototype._setDefaultThrottle = function (inputRawOption) {
	    if (inputRawOption.hasOwnProperty('throttle')) {
	      this._autoThrottle = false;
	    }
	
	    if (this._autoThrottle) {
	      var globalOption = this.ecModel.option;
	      this.option.throttle = globalOption.animation && globalOption.animationDurationUpdate > 0 ? 100 : 20;
	    }
	  };
	
	  DataZoomModel.prototype._updateRangeUse = function (inputRawOption) {
	    var rangePropMode = this._rangePropMode;
	    var rangeModeInOption = this.get('rangeMode');
	    util_1.each([['start', 'startValue'], ['end', 'endValue']], function (names, index) {
	      var percentSpecified = inputRawOption[names[0]] != null;
	      var valueSpecified = inputRawOption[names[1]] != null;
	
	      if (percentSpecified && !valueSpecified) {
	        rangePropMode[index] = 'percent';
	      } else if (!percentSpecified && valueSpecified) {
	        rangePropMode[index] = 'value';
	      } else if (rangeModeInOption) {
	        rangePropMode[index] = rangeModeInOption[index];
	      } else if (percentSpecified) {
	        rangePropMode[index] = 'percent';
	      }
	    });
	  };
	
	  DataZoomModel.prototype.noTarget = function () {
	    return this._noTarget;
	  };
	
	  DataZoomModel.prototype.getFirstTargetAxisModel = function () {
	    var firstAxisModel;
	    this.eachTargetAxis(function (axisDim, axisIndex) {
	      if (firstAxisModel == null) {
	        firstAxisModel = this.ecModel.getComponent(helper_1.getAxisMainType(axisDim), axisIndex);
	      }
	    }, this);
	    return firstAxisModel;
	  };
	
	  DataZoomModel.prototype.eachTargetAxis = function (callback, context) {
	    this._targetAxisInfoMap.each(function (axisInfo, axisDim) {
	      util_1.each(axisInfo.indexList, function (axisIndex) {
	        callback.call(context, axisDim, axisIndex);
	      });
	    });
	  };
	
	  DataZoomModel.prototype.getAxisProxy = function (axisDim, axisIndex) {
	    var axisModel = this.getAxisModel(axisDim, axisIndex);
	
	    if (axisModel) {
	      return axisModel.__dzAxisProxy;
	    }
	  };
	
	  DataZoomModel.prototype.getAxisModel = function (axisDim, axisIndex) {
	    if (false) {
	      util_1.assert(axisDim && axisIndex != null);
	    }
	
	    var axisInfo = this._targetAxisInfoMap.get(axisDim);
	
	    if (axisInfo && axisInfo.indexMap[axisIndex]) {
	      return this.ecModel.getComponent(helper_1.getAxisMainType(axisDim), axisIndex);
	    }
	  };
	
	  DataZoomModel.prototype.setRawRange = function (opt) {
	    var thisOption = this.option;
	    var settledOption = this.settledOption;
	    util_1.each([['start', 'startValue'], ['end', 'endValue']], function (names) {
	      if (opt[names[0]] != null || opt[names[1]] != null) {
	        thisOption[names[0]] = settledOption[names[0]] = opt[names[0]];
	        thisOption[names[1]] = settledOption[names[1]] = opt[names[1]];
	      }
	    }, this);
	
	    this._updateRangeUse(opt);
	  };
	
	  DataZoomModel.prototype.setCalculatedRange = function (opt) {
	    var option = this.option;
	    util_1.each(['start', 'startValue', 'end', 'endValue'], function (name) {
	      option[name] = opt[name];
	    });
	  };
	
	  DataZoomModel.prototype.getPercentRange = function () {
	    var axisProxy = this.findRepresentativeAxisProxy();
	
	    if (axisProxy) {
	      return axisProxy.getDataPercentWindow();
	    }
	  };
	
	  DataZoomModel.prototype.getValueRange = function (axisDim, axisIndex) {
	    if (axisDim == null && axisIndex == null) {
	      var axisProxy = this.findRepresentativeAxisProxy();
	
	      if (axisProxy) {
	        return axisProxy.getDataValueWindow();
	      }
	    } else {
	      return this.getAxisProxy(axisDim, axisIndex).getDataValueWindow();
	    }
	  };
	
	  DataZoomModel.prototype.findRepresentativeAxisProxy = function (axisModel) {
	    if (axisModel) {
	      return axisModel.__dzAxisProxy;
	    }
	
	    var firstProxy;
	
	    var axisDimList = this._targetAxisInfoMap.keys();
	
	    for (var i = 0; i < axisDimList.length; i++) {
	      var axisDim = axisDimList[i];
	
	      var axisInfo = this._targetAxisInfoMap.get(axisDim);
	
	      for (var j = 0; j < axisInfo.indexList.length; j++) {
	        var proxy = this.getAxisProxy(axisDim, axisInfo.indexList[j]);
	
	        if (proxy.hostedBy(this)) {
	          return proxy;
	        }
	
	        if (!firstProxy) {
	          firstProxy = proxy;
	        }
	      }
	    }
	
	    return firstProxy;
	  };
	
	  DataZoomModel.prototype.getRangePropMode = function () {
	    return this._rangePropMode.slice();
	  };
	
	  DataZoomModel.prototype.getOrient = function () {
	    if (false) {
	      util_1.assert(this._orient);
	    }
	
	    return this._orient;
	  };
	
	  DataZoomModel.type = 'dataZoom';
	  DataZoomModel.dependencies = ['xAxis', 'yAxis', 'radiusAxis', 'angleAxis', 'singleAxis', 'series', 'toolbox'];
	  DataZoomModel.defaultOption = {
	    zlevel: 0,
	    z: 4,
	    filterMode: 'filter',
	    start: 0,
	    end: 100
	  };
	  return DataZoomModel;
	}(Component_1["default"]);
	
	function retrieveRawOption(option) {
	  var ret = {};
	  util_1.each(['start', 'end', 'startValue', 'endValue', 'throttle'], function (name) {
	    option.hasOwnProperty(name) && (ret[name] = option[name]);
	  });
	  return ret;
	}
	
	exports["default"] = DataZoomModel;

/***/ },
/* 66 */
/***/ function(module, exports, __webpack_require__) {

	
	/*
	* Licensed to the Apache Software Foundation (ASF) under one
	* or more contributor license agreements.  See the NOTICE file
	* distributed with this work for additional information
	* regarding copyright ownership.  The ASF licenses this file
	* to you under the Apache License, Version 2.0 (the
	* "License"); you may not use this file except in compliance
	* with the License.  You may obtain a copy of the License at
	*
	*   http://www.apache.org/licenses/LICENSE-2.0
	*
	* Unless required by applicable law or agreed to in writing,
	* software distributed under the License is distributed on an
	* "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
	* KIND, either express or implied.  See the License for the
	* specific language governing permissions and limitations
	* under the License.
	*/
	
	
	
	/**
	 * AUTO-GENERATED FILE. DO NOT MODIFY.
	 */
	
	"use strict";
	
	exports.__esModule = true;
	
	var tslib_1 = __webpack_require__(3);
	
	var Component_1 = __webpack_require__(18);
	
	var DataZoomView = function (_super) {
	  tslib_1.__extends(DataZoomView, _super);
	
	  function DataZoomView() {
	    var _this = _super !== null && _super.apply(this, arguments) || this;
	
	    _this.type = DataZoomView.type;
	    return _this;
	  }
	
	  DataZoomView.prototype.render = function (dataZoomModel, ecModel, api, payload) {
	    this.dataZoomModel = dataZoomModel;
	    this.ecModel = ecModel;
	    this.api = api;
	  };
	
	  DataZoomView.type = 'dataZoom';
	  return DataZoomView;
	}(Component_1["default"]);
	
	Component_1["default"].registerClass(DataZoomView);
	exports["default"] = DataZoomView;

/***/ },
/* 67 */
/***/ function(module, exports, __webpack_require__) {

	
	/*
	* Licensed to the Apache Software Foundation (ASF) under one
	* or more contributor license agreements.  See the NOTICE file
	* distributed with this work for additional information
	* regarding copyright ownership.  The ASF licenses this file
	* to you under the Apache License, Version 2.0 (the
	* "License"); you may not use this file except in compliance
	* with the License.  You may obtain a copy of the License at
	*
	*   http://www.apache.org/licenses/LICENSE-2.0
	*
	* Unless required by applicable law or agreed to in writing,
	* software distributed under the License is distributed on an
	* "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
	* KIND, either express or implied.  See the License for the
	* specific language governing permissions and limitations
	* under the License.
	*/
	
	
	
	/**
	 * AUTO-GENERATED FILE. DO NOT MODIFY.
	 */
	
	"use strict";
	
	exports.__esModule = true;
	
	var zrUtil = __webpack_require__(1);
	
	var model_1 = __webpack_require__(4);
	
	function layout(gridModel, axisModel, opt) {
	  opt = opt || {};
	  var grid = gridModel.coordinateSystem;
	  var axis = axisModel.axis;
	  var layout = {};
	  var otherAxisOnZeroOf = axis.getAxesOnZeroOf()[0];
	  var rawAxisPosition = axis.position;
	  var axisPosition = otherAxisOnZeroOf ? 'onZero' : rawAxisPosition;
	  var axisDim = axis.dim;
	  var rect = grid.getRect();
	  var rectBound = [rect.x, rect.x + rect.width, rect.y, rect.y + rect.height];
	  var idx = {
	    left: 0,
	    right: 1,
	    top: 0,
	    bottom: 1,
	    onZero: 2
	  };
	  var axisOffset = axisModel.get('offset') || 0;
	  var posBound = axisDim === 'x' ? [rectBound[2] - axisOffset, rectBound[3] + axisOffset] : [rectBound[0] - axisOffset, rectBound[1] + axisOffset];
	
	  if (otherAxisOnZeroOf) {
	    var onZeroCoord = otherAxisOnZeroOf.toGlobalCoord(otherAxisOnZeroOf.dataToCoord(0));
	    posBound[idx.onZero] = Math.max(Math.min(onZeroCoord, posBound[1]), posBound[0]);
	  }
	
	  layout.position = [axisDim === 'y' ? posBound[idx[axisPosition]] : rectBound[0], axisDim === 'x' ? posBound[idx[axisPosition]] : rectBound[3]];
	  layout.rotation = Math.PI / 2 * (axisDim === 'x' ? 0 : 1);
	  var dirMap = {
	    top: -1,
	    bottom: 1,
	    left: -1,
	    right: 1
	  };
	  layout.labelDirection = layout.tickDirection = layout.nameDirection = dirMap[rawAxisPosition];
	  layout.labelOffset = otherAxisOnZeroOf ? posBound[idx[rawAxisPosition]] - posBound[idx.onZero] : 0;
	
	  if (axisModel.get(['axisTick', 'inside'])) {
	    layout.tickDirection = -layout.tickDirection;
	  }
	
	  if (zrUtil.retrieve(opt.labelInside, axisModel.get(['axisLabel', 'inside']))) {
	    layout.labelDirection = -layout.labelDirection;
	  }
	
	  var labelRotate = axisModel.get(['axisLabel', 'rotate']);
	  layout.labelRotate = axisPosition === 'top' ? -labelRotate : labelRotate;
	  layout.z2 = 1;
	  return layout;
	}
	
	exports.layout = layout;
	
	function isCartesian2DSeries(seriesModel) {
	  return seriesModel.get('coordinateSystem') === 'cartesian2d';
	}
	
	exports.isCartesian2DSeries = isCartesian2DSeries;
	
	function findAxisModels(seriesModel) {
	  var axisModelMap = {
	    xAxisModel: null,
	    yAxisModel: null
	  };
	  zrUtil.each(axisModelMap, function (v, key) {
	    var axisType = key.replace(/Model$/, '');
	    var axisModel = seriesModel.getReferringComponents(axisType, model_1.SINGLE_REFERRING).models[0];
	
	    if (false) {
	      if (!axisModel) {
	        throw new Error(axisType + ' "' + zrUtil.retrieve3(seriesModel.get(axisType + 'Index'), seriesModel.get(axisType + 'Id'), 0) + '" not found');
	      }
	    }
	
	    axisModelMap[key] = axisModel;
	  });
	  return axisModelMap;
	}
	
	exports.findAxisModels = findAxisModels;

/***/ },
/* 68 */
/***/ function(module, exports, __webpack_require__) {

	
	/*
	* Licensed to the Apache Software Foundation (ASF) under one
	* or more contributor license agreements.  See the NOTICE file
	* distributed with this work for additional information
	* regarding copyright ownership.  The ASF licenses this file
	* to you under the Apache License, Version 2.0 (the
	* "License"); you may not use this file except in compliance
	* with the License.  You may obtain a copy of the License at
	*
	*   http://www.apache.org/licenses/LICENSE-2.0
	*
	* Unless required by applicable law or agreed to in writing,
	* software distributed under the License is distributed on an
	* "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
	* KIND, either express or implied.  See the License for the
	* specific language governing permissions and limitations
	* under the License.
	*/
	
	
	
	/**
	 * AUTO-GENERATED FILE. DO NOT MODIFY.
	 */
	
	"use strict";
	
	exports.__esModule = true;
	
	var tslib_1 = __webpack_require__(3);
	
	var zrUtil = __webpack_require__(1);
	
	var env_1 = __webpack_require__(13);
	
	var modelUtil = __webpack_require__(4);
	
	var Component_1 = __webpack_require__(10);
	
	var palette_1 = __webpack_require__(153);
	
	var dataFormat_1 = __webpack_require__(91);
	
	var layout_1 = __webpack_require__(30);
	
	var task_1 = __webpack_require__(93);
	
	var clazz_1 = __webpack_require__(28);
	
	var sourceManager_1 = __webpack_require__(147);
	
	var seriesFormatTooltip_1 = __webpack_require__(332);
	
	var inner = modelUtil.makeInner();
	
	function getSelectionKey(data, dataIndex) {
	  return data.getName(dataIndex) || data.getId(dataIndex);
	}
	
	var SeriesModel = function (_super) {
	  tslib_1.__extends(SeriesModel, _super);
	
	  function SeriesModel() {
	    var _this = _super !== null && _super.apply(this, arguments) || this;
	
	    _this._selectedDataIndicesMap = {};
	    return _this;
	  }
	
	  SeriesModel.prototype.init = function (option, parentModel, ecModel) {
	    this.seriesIndex = this.componentIndex;
	    this.dataTask = task_1.createTask({
	      count: dataTaskCount,
	      reset: dataTaskReset
	    });
	    this.dataTask.context = {
	      model: this
	    };
	    this.mergeDefaultAndTheme(option, ecModel);
	    var sourceManager = inner(this).sourceManager = new sourceManager_1.SourceManager(this);
	    sourceManager.prepareSource();
	    var data = this.getInitialData(option, ecModel);
	    wrapData(data, this);
	    this.dataTask.context.data = data;
	
	    if (false) {
	      zrUtil.assert(data, 'getInitialData returned invalid data.');
	    }
	
	    inner(this).dataBeforeProcessed = data;
	    autoSeriesName(this);
	
	    this._initSelectedMapFromData(data);
	  };
	
	  SeriesModel.prototype.mergeDefaultAndTheme = function (option, ecModel) {
	    var layoutMode = layout_1.fetchLayoutMode(this);
	    var inputPositionParams = layoutMode ? layout_1.getLayoutParams(option) : {};
	    var themeSubType = this.subType;
	
	    if (Component_1["default"].hasClass(themeSubType)) {
	      themeSubType += 'Series';
	    }
	
	    zrUtil.merge(option, ecModel.getTheme().get(this.subType));
	    zrUtil.merge(option, this.getDefaultOption());
	    modelUtil.defaultEmphasis(option, 'label', ['show']);
	    this.fillDataTextStyle(option.data);
	
	    if (layoutMode) {
	      layout_1.mergeLayoutParam(option, inputPositionParams, layoutMode);
	    }
	  };
	
	  SeriesModel.prototype.mergeOption = function (newSeriesOption, ecModel) {
	    newSeriesOption = zrUtil.merge(this.option, newSeriesOption, true);
	    this.fillDataTextStyle(newSeriesOption.data);
	    var layoutMode = layout_1.fetchLayoutMode(this);
	
	    if (layoutMode) {
	      layout_1.mergeLayoutParam(this.option, newSeriesOption, layoutMode);
	    }
	
	    var sourceManager = inner(this).sourceManager;
	    sourceManager.dirty();
	    sourceManager.prepareSource();
	    var data = this.getInitialData(newSeriesOption, ecModel);
	    wrapData(data, this);
	    this.dataTask.dirty();
	    this.dataTask.context.data = data;
	    inner(this).dataBeforeProcessed = data;
	    autoSeriesName(this);
	
	    this._initSelectedMapFromData(data);
	  };
	
	  SeriesModel.prototype.fillDataTextStyle = function (data) {
	    if (data && !zrUtil.isTypedArray(data)) {
	      var props = ['show'];
	
	      for (var i = 0; i < data.length; i++) {
	        if (data[i] && data[i].label) {
	          modelUtil.defaultEmphasis(data[i], 'label', props);
	        }
	      }
	    }
	  };
	
	  SeriesModel.prototype.getInitialData = function (option, ecModel) {
	    return;
	  };
	
	  SeriesModel.prototype.appendData = function (params) {
	    var data = this.getRawData();
	    data.appendData(params.data);
	  };
	
	  SeriesModel.prototype.getData = function (dataType) {
	    var task = getCurrentTask(this);
	
	    if (task) {
	      var data = task.context.data;
	      return dataType == null ? data : data.getLinkedData(dataType);
	    } else {
	      return inner(this).data;
	    }
	  };
	
	  SeriesModel.prototype.getAllData = function () {
	    var mainData = this.getData();
	    return mainData && mainData.getLinkedDataAll ? mainData.getLinkedDataAll() : [{
	      data: mainData
	    }];
	  };
	
	  SeriesModel.prototype.setData = function (data) {
	    var task = getCurrentTask(this);
	
	    if (task) {
	      var context = task.context;
	      context.outputData = data;
	
	      if (task !== this.dataTask) {
	        context.data = data;
	      }
	    }
	
	    inner(this).data = data;
	  };
	
	  SeriesModel.prototype.getSource = function () {
	    return inner(this).sourceManager.getSource();
	  };
	
	  SeriesModel.prototype.getRawData = function () {
	    return inner(this).dataBeforeProcessed;
	  };
	
	  SeriesModel.prototype.getBaseAxis = function () {
	    var coordSys = this.coordinateSystem;
	    return coordSys && coordSys.getBaseAxis && coordSys.getBaseAxis();
	  };
	
	  SeriesModel.prototype.formatTooltip = function (dataIndex, multipleSeries, dataType) {
	    return seriesFormatTooltip_1.defaultSeriesFormatTooltip({
	      series: this,
	      dataIndex: dataIndex,
	      multipleSeries: multipleSeries
	    });
	  };
	
	  SeriesModel.prototype.isAnimationEnabled = function () {
	    if (env_1["default"].node) {
	      return false;
	    }
	
	    var animationEnabled = this.getShallow('animation');
	
	    if (animationEnabled) {
	      if (this.getData().count() > this.getShallow('animationThreshold')) {
	        animationEnabled = false;
	      }
	    }
	
	    return !!animationEnabled;
	  };
	
	  SeriesModel.prototype.restoreData = function () {
	    this.dataTask.dirty();
	  };
	
	  SeriesModel.prototype.getColorFromPalette = function (name, scope, requestColorNum) {
	    var ecModel = this.ecModel;
	    var color = palette_1.PaletteMixin.prototype.getColorFromPalette.call(this, name, scope, requestColorNum);
	
	    if (!color) {
	      color = ecModel.getColorFromPalette(name, scope, requestColorNum);
	    }
	
	    return color;
	  };
	
	  SeriesModel.prototype.coordDimToDataDim = function (coordDim) {
	    return this.getRawData().mapDimensionsAll(coordDim);
	  };
	
	  SeriesModel.prototype.getProgressive = function () {
	    return this.get('progressive');
	  };
	
	  SeriesModel.prototype.getProgressiveThreshold = function () {
	    return this.get('progressiveThreshold');
	  };
	
	  SeriesModel.prototype.select = function (innerDataIndices, dataType) {
	    this._innerSelect(this.getData(dataType), innerDataIndices);
	  };
	
	  SeriesModel.prototype.unselect = function (innerDataIndices, dataType) {
	    var selectedMap = this.option.selectedMap;
	
	    if (!selectedMap) {
	      return;
	    }
	
	    var data = this.getData(dataType);
	
	    for (var i = 0; i < innerDataIndices.length; i++) {
	      var dataIndex = innerDataIndices[i];
	      var nameOrId = getSelectionKey(data, dataIndex);
	      selectedMap[nameOrId] = false;
	      this._selectedDataIndicesMap[nameOrId] = -1;
	    }
	  };
	
	  SeriesModel.prototype.toggleSelect = function (innerDataIndices, dataType) {
	    var tmpArr = [];
	
	    for (var i = 0; i < innerDataIndices.length; i++) {
	      tmpArr[0] = innerDataIndices[i];
	      this.isSelected(innerDataIndices[i], dataType) ? this.unselect(tmpArr, dataType) : this.select(tmpArr, dataType);
	    }
	  };
	
	  SeriesModel.prototype.getSelectedDataIndices = function () {
	    var selectedDataIndicesMap = this._selectedDataIndicesMap;
	    var nameOrIds = zrUtil.keys(selectedDataIndicesMap);
	    var dataIndices = [];
	
	    for (var i = 0; i < nameOrIds.length; i++) {
	      var dataIndex = selectedDataIndicesMap[nameOrIds[i]];
	
	      if (dataIndex >= 0) {
	        dataIndices.push(dataIndex);
	      }
	    }
	
	    return dataIndices;
	  };
	
	  SeriesModel.prototype.isSelected = function (dataIndex, dataType) {
	    var selectedMap = this.option.selectedMap;
	
	    if (!selectedMap) {
	      return false;
	    }
	
	    var data = this.getData(dataType);
	    var nameOrId = getSelectionKey(data, dataIndex);
	    return selectedMap[nameOrId] || false;
	  };
	
	  SeriesModel.prototype._innerSelect = function (data, innerDataIndices) {
	    var _a, _b;
	
	    var selectedMode = this.option.selectedMode;
	    var len = innerDataIndices.length;
	
	    if (!selectedMode || !len) {
	      return;
	    }
	
	    if (selectedMode === 'multiple') {
	      var selectedMap = this.option.selectedMap || (this.option.selectedMap = {});
	
	      for (var i = 0; i < len; i++) {
	        var dataIndex = innerDataIndices[i];
	        var nameOrId = getSelectionKey(data, dataIndex);
	        selectedMap[nameOrId] = true;
	        this._selectedDataIndicesMap[nameOrId] = data.getRawIndex(dataIndex);
	      }
	    } else if (selectedMode === 'single' || selectedMode === true) {
	      var lastDataIndex = innerDataIndices[len - 1];
	      var nameOrId = getSelectionKey(data, lastDataIndex);
	      this.option.selectedMap = (_a = {}, _a[nameOrId] = true, _a);
	      this._selectedDataIndicesMap = (_b = {}, _b[nameOrId] = data.getRawIndex(lastDataIndex), _b);
	    }
	  };
	
	  SeriesModel.prototype._initSelectedMapFromData = function (data) {
	    if (this.option.selectedMap) {
	      return;
	    }
	
	    var dataIndices = [];
	
	    if (data.hasItemOption) {
	      data.each(function (idx) {
	        var rawItem = data.getRawDataItem(idx);
	
	        if (typeof rawItem === 'object' && rawItem.selected) {
	          dataIndices.push(idx);
	        }
	      });
	    }
	
	    if (dataIndices.length > 0) {
	      this._innerSelect(data, dataIndices);
	    }
	  };
	
	  SeriesModel.registerClass = function (clz) {
	    return Component_1["default"].registerClass(clz);
	  };
	
	  SeriesModel.protoInitialize = function () {
	    var proto = SeriesModel.prototype;
	    proto.type = 'series.__base__';
	    proto.seriesIndex = 0;
	    proto.useColorPaletteOnData = false;
	    proto.ignoreStyleOnData = false;
	    proto.hasSymbolVisual = false;
	    proto.defaultSymbol = 'circle';
	    proto.visualStyleAccessPath = 'itemStyle';
	    proto.visualDrawType = 'fill';
	  }();
	
	  return SeriesModel;
	}(Component_1["default"]);
	
	zrUtil.mixin(SeriesModel, dataFormat_1.DataFormatMixin);
	zrUtil.mixin(SeriesModel, palette_1.PaletteMixin);
	clazz_1.mountExtend(SeriesModel, Component_1["default"]);
	
	function autoSeriesName(seriesModel) {
	  var name = seriesModel.name;
	
	  if (!modelUtil.isNameSpecified(seriesModel)) {
	    seriesModel.name = getSeriesAutoName(seriesModel) || name;
	  }
	}
	
	function getSeriesAutoName(seriesModel) {
	  var data = seriesModel.getRawData();
	  var dataDims = data.mapDimensionsAll('seriesName');
	  var nameArr = [];
	  zrUtil.each(dataDims, function (dataDim) {
	    var dimInfo = data.getDimensionInfo(dataDim);
	    dimInfo.displayName && nameArr.push(dimInfo.displayName);
	  });
	  return nameArr.join(' ');
	}
	
	function dataTaskCount(context) {
	  return context.model.getRawData().count();
	}
	
	function dataTaskReset(context) {
	  var seriesModel = context.model;
	  seriesModel.setData(seriesModel.getRawData().cloneShallow());
	  return dataTaskProgress;
	}
	
	function dataTaskProgress(param, context) {
	  if (context.outputData && param.end > context.outputData.count()) {
	    context.model.getRawData().cloneShallow(context.outputData);
	  }
	}
	
	function wrapData(data, seriesModel) {
	  zrUtil.each(tslib_1.__spreadArrays(data.CHANGABLE_METHODS, data.DOWNSAMPLE_METHODS), function (methodName) {
	    data.wrapMethod(methodName, zrUtil.curry(onDataChange, seriesModel));
	  });
	}
	
	function onDataChange(seriesModel, newList) {
	  var task = getCurrentTask(seriesModel);
	
	  if (task) {
	    task.setOutputEnd((newList || this).count());
	  }
	
	  return newList;
	}
	
	function getCurrentTask(seriesModel) {
	  var scheduler = (seriesModel.ecModel || {}).scheduler;
	  var pipeline = scheduler && scheduler.getPipeline(seriesModel.uid);
	
	  if (pipeline) {
	    var task = pipeline.currentTask;
	
	    if (task) {
	      var agentStubMap = task.agentStubMap;
	
	      if (agentStubMap) {
	        task = agentStubMap.get(seriesModel.uid);
	      }
	    }
	
	    return task;
	  }
	}
	
	exports["default"] = SeriesModel;

/***/ },
/* 69 */
/***/ function(module, exports, __webpack_require__) {

	
	/*
	* Licensed to the Apache Software Foundation (ASF) under one
	* or more contributor license agreements.  See the NOTICE file
	* distributed with this work for additional information
	* regarding copyright ownership.  The ASF licenses this file
	* to you under the Apache License, Version 2.0 (the
	* "License"); you may not use this file except in compliance
	* with the License.  You may obtain a copy of the License at
	*
	*   http://www.apache.org/licenses/LICENSE-2.0
	*
	* Unless required by applicable law or agreed to in writing,
	* software distributed under the License is distributed on an
	* "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
	* KIND, either express or implied.  See the License for the
	* specific language governing permissions and limitations
	* under the License.
	*/
	
	
	
	/**
	 * AUTO-GENERATED FILE. DO NOT MODIFY.
	 */
	
	"use strict";
	
	exports.__esModule = true;
	
	var zrUtil = __webpack_require__(1);
	
	function makeStyleMapper(properties, ignoreParent) {
	  for (var i = 0; i < properties.length; i++) {
	    if (!properties[i][1]) {
	      properties[i][1] = properties[i][0];
	    }
	  }
	
	  ignoreParent = ignoreParent || false;
	  return function (model, excludes, includes) {
	    var style = {};
	
	    for (var i = 0; i < properties.length; i++) {
	      var propName = properties[i][1];
	
	      if (excludes && zrUtil.indexOf(excludes, propName) >= 0 || includes && zrUtil.indexOf(includes, propName) < 0) {
	        continue;
	      }
	
	      var val = model.getShallow(propName, ignoreParent);
	
	      if (val != null) {
	        style[properties[i][0]] = val;
	      }
	    }
	
	    return style;
	  };
	}
	
	exports["default"] = makeStyleMapper;

/***/ },
/* 70 */
/***/ function(module, exports, __webpack_require__) {

	
	/*
	* Licensed to the Apache Software Foundation (ASF) under one
	* or more contributor license agreements.  See the NOTICE file
	* distributed with this work for additional information
	* regarding copyright ownership.  The ASF licenses this file
	* to you under the Apache License, Version 2.0 (the
	* "License"); you may not use this file except in compliance
	* with the License.  You may obtain a copy of the License at
	*
	*   http://www.apache.org/licenses/LICENSE-2.0
	*
	* Unless required by applicable law or agreed to in writing,
	* software distributed under the License is distributed on an
	* "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
	* KIND, either express or implied.  See the License for the
	* specific language governing permissions and limitations
	* under the License.
	*/
	
	
	
	/**
	 * AUTO-GENERATED FILE. DO NOT MODIFY.
	 */
	
	"use strict";
	
	exports.__esModule = true;
	
	var numberUtil = __webpack_require__(9);
	
	var roundNumber = numberUtil.round;
	
	function intervalScaleNiceTicks(extent, splitNumber, minInterval, maxInterval) {
	  var result = {};
	  var span = extent[1] - extent[0];
	  var interval = result.interval = numberUtil.nice(span / splitNumber, true);
	
	  if (minInterval != null && interval < minInterval) {
	    interval = result.interval = minInterval;
	  }
	
	  if (maxInterval != null && interval > maxInterval) {
	    interval = result.interval = maxInterval;
	  }
	
	  var precision = result.intervalPrecision = getIntervalPrecision(interval);
	  var niceTickExtent = result.niceTickExtent = [roundNumber(Math.ceil(extent[0] / interval) * interval, precision), roundNumber(Math.floor(extent[1] / interval) * interval, precision)];
	  fixExtent(niceTickExtent, extent);
	  return result;
	}
	
	exports.intervalScaleNiceTicks = intervalScaleNiceTicks;
	
	function getIntervalPrecision(interval) {
	  return numberUtil.getPrecisionSafe(interval) + 2;
	}
	
	exports.getIntervalPrecision = getIntervalPrecision;
	
	function clamp(niceTickExtent, idx, extent) {
	  niceTickExtent[idx] = Math.max(Math.min(niceTickExtent[idx], extent[1]), extent[0]);
	}
	
	function fixExtent(niceTickExtent, extent) {
	  !isFinite(niceTickExtent[0]) && (niceTickExtent[0] = extent[0]);
	  !isFinite(niceTickExtent[1]) && (niceTickExtent[1] = extent[1]);
	  clamp(niceTickExtent, 0, extent);
	  clamp(niceTickExtent, 1, extent);
	
	  if (niceTickExtent[0] > niceTickExtent[1]) {
	    niceTickExtent[0] = niceTickExtent[1];
	  }
	}
	
	exports.fixExtent = fixExtent;
	
	function contain(val, extent) {
	  return val >= extent[0] && val <= extent[1];
	}
	
	exports.contain = contain;
	
	function normalize(val, extent) {
	  if (extent[1] === extent[0]) {
	    return 0.5;
	  }
	
	  return (val - extent[0]) / (extent[1] - extent[0]);
	}
	
	exports.normalize = normalize;
	
	function scale(val, extent) {
	  return val * (extent[1] - extent[0]) + extent[0];
	}
	
	exports.scale = scale;

/***/ },
/* 71 */
/***/ function(module, exports) {

	module.exports = (() => {
	  if (typeof self !== "undefined") {
	    return self;
	  } else if (typeof window !== "undefined") {
	    return window;
	  } else {
	    return Function("return this")();
	  }
	})();


/***/ },
/* 72 */
[485, 385],
/* 73 */
/***/ function(module, exports) {

	"use strict";
	
	exports.__esModule = true;
	exports.isTabPanel = exports.isTabList = exports.isTab = void 0;
	
	function makeTypeChecker(tabsRole) {
	  return function (element) {
	    return !!element.type && element.type.tabsRole === tabsRole;
	  };
	}
	
	var isTab = makeTypeChecker('Tab');
	exports.isTab = isTab;
	var isTabList = makeTypeChecker('TabList');
	exports.isTabList = isTabList;
	var isTabPanel = makeTypeChecker('TabPanel');
	exports.isTabPanel = isTabPanel;

/***/ },
/* 74 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	
	exports.__esModule = true;
	exports.resetIdCounter = exports.TabPanel = exports.Tab = exports.TabList = exports.Tabs = void 0;
	
	var _Tabs = _interopRequireDefault(__webpack_require__(418));
	
	exports.Tabs = _Tabs["default"];
	
	var _TabList = _interopRequireDefault(__webpack_require__(416));
	
	exports.TabList = _TabList["default"];
	
	var _Tab = _interopRequireDefault(__webpack_require__(415));
	
	exports.Tab = _Tab["default"];
	
	var _TabPanel = _interopRequireDefault(__webpack_require__(417));
	
	exports.TabPanel = _TabPanel["default"];
	
	var _uuid = __webpack_require__(168);
	
	exports.resetIdCounter = _uuid.reset;
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { "default": obj }; }

/***/ },
/* 75 */
[485, 427],
/* 76 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	var isProduction = ("production") === 'production';
	function warning(condition, message) {
	  if (!isProduction) {
	    if (condition) {
	      return;
	    }
	
	    var text = "Warning: " + message;
	
	    if (typeof console !== 'undefined') {
	      console.warn(text);
	    }
	
	    try {
	      throw Error(text);
	    } catch (x) {}
	  }
	}
	
	module.exports = warning;


/***/ },
/* 77 */
/***/ function(module, exports, __webpack_require__) {

	module.exports = __webpack_require__.p + "static/media/my_history.4a6950ac.png";

/***/ },
/* 78 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	exports.__esModule = true;
	var Displayable_1 = __webpack_require__(50);
	var PathProxy_1 = __webpack_require__(32);
	var image_1 = __webpack_require__(188);
	var helper_1 = __webpack_require__(178);
	var Path_1 = __webpack_require__(8);
	var Image_1 = __webpack_require__(43);
	var TSpan_1 = __webpack_require__(80);
	var text_1 = __webpack_require__(26);
	var export_1 = __webpack_require__(183);
	var util_1 = __webpack_require__(1);
	var dashStyle_1 = __webpack_require__(463);
	var Element_1 = __webpack_require__(36);
	var pathProxyForDraw = new PathProxy_1["default"](true);
	function styleHasStroke(style) {
	    var stroke = style.stroke;
	    return !(stroke == null || stroke === 'none' || !(style.lineWidth > 0));
	}
	function styleHasFill(style) {
	    var fill = style.fill;
	    return fill != null && fill !== 'none';
	}
	function doFillPath(ctx, style) {
	    if (style.fillOpacity != null && style.fillOpacity !== 1) {
	        var originalGlobalAlpha = ctx.globalAlpha;
	        ctx.globalAlpha = style.fillOpacity * style.opacity;
	        ctx.fill();
	        ctx.globalAlpha = originalGlobalAlpha;
	    }
	    else {
	        ctx.fill();
	    }
	}
	function doStrokePath(ctx, style) {
	    if (style.strokeOpacity != null && style.strokeOpacity !== 1) {
	        var originalGlobalAlpha = ctx.globalAlpha;
	        ctx.globalAlpha = style.strokeOpacity * style.opacity;
	        ctx.stroke();
	        ctx.globalAlpha = originalGlobalAlpha;
	    }
	    else {
	        ctx.stroke();
	    }
	}
	function createCanvasPattern(ctx, pattern, el) {
	    var image = image_1.createOrUpdateImage(pattern.image, pattern.__image, el);
	    if (image_1.isImageReady(image)) {
	        var canvasPattern = ctx.createPattern(image, pattern.repeat || 'repeat');
	        if (typeof DOMMatrix === 'function') {
	            var matrix = new DOMMatrix();
	            matrix.rotateSelf(0, 0, (pattern.rotation || 0) / Math.PI * 180);
	            matrix.scaleSelf((pattern.scaleX || 1), (pattern.scaleY || 1));
	            matrix.translateSelf((pattern.x || 0), (pattern.y || 0));
	            canvasPattern.setTransform(matrix);
	        }
	        return canvasPattern;
	    }
	}
	exports.createCanvasPattern = createCanvasPattern;
	function brushPath(ctx, el, style, inBatch) {
	    var hasStroke = styleHasStroke(style);
	    var hasFill = styleHasFill(style);
	    var strokePercent = style.strokePercent;
	    var strokePart = strokePercent < 1;
	    var firstDraw = !el.path;
	    if ((!el.silent || strokePart) && firstDraw) {
	        el.createPathProxy();
	    }
	    var path = el.path || pathProxyForDraw;
	    if (!inBatch) {
	        var fill = style.fill;
	        var stroke = style.stroke;
	        var hasFillGradient = hasFill && !!fill.colorStops;
	        var hasStrokeGradient = hasStroke && !!stroke.colorStops;
	        var hasFillPattern = hasFill && !!fill.image;
	        var hasStrokePattern = hasStroke && !!stroke.image;
	        var fillGradient = void 0;
	        var strokeGradient = void 0;
	        var fillPattern = void 0;
	        var strokePattern = void 0;
	        var rect = void 0;
	        if (hasFillGradient || hasStrokeGradient) {
	            rect = el.getBoundingRect();
	        }
	        if (hasFillGradient) {
	            fillGradient = el.__dirty
	                ? helper_1.getCanvasGradient(ctx, fill, rect)
	                : el.__canvasFillGradient;
	            el.__canvasFillGradient = fillGradient;
	        }
	        if (hasStrokeGradient) {
	            strokeGradient = el.__dirty
	                ? helper_1.getCanvasGradient(ctx, stroke, rect)
	                : el.__canvasStrokeGradient;
	            el.__canvasStrokeGradient = strokeGradient;
	        }
	        if (hasFillPattern) {
	            fillPattern = (el.__dirty || !el.__canvasFillPattern)
	                ? createCanvasPattern(ctx, fill, el)
	                : el.__canvasFillPattern;
	            el.__canvasFillPattern = fillPattern;
	        }
	        if (hasStrokePattern) {
	            strokePattern = (el.__dirty || !el.__canvasStrokePattern)
	                ? createCanvasPattern(ctx, stroke, el)
	                : el.__canvasStrokePattern;
	            el.__canvasStrokePattern = fillPattern;
	        }
	        if (hasFillGradient) {
	            ctx.fillStyle = fillGradient;
	        }
	        else if (hasFillPattern) {
	            if (fillPattern) {
	                ctx.fillStyle = fillPattern;
	            }
	            else {
	                hasFill = false;
	            }
	        }
	        if (hasStrokeGradient) {
	            ctx.strokeStyle = strokeGradient;
	        }
	        else if (hasStrokePattern) {
	            if (strokePattern) {
	                ctx.strokeStyle = strokePattern;
	            }
	            else {
	                hasStroke = false;
	            }
	        }
	    }
	    var lineDash = style.lineDash && style.lineWidth > 0 && dashStyle_1.normalizeLineDash(style.lineDash, style.lineWidth);
	    var lineDashOffset = style.lineDashOffset;
	    var ctxLineDash = !!ctx.setLineDash;
	    var scale = el.getGlobalScale();
	    path.setScale(scale[0], scale[1], el.segmentIgnoreThreshold);
	    if (lineDash) {
	        var lineScale_1 = (style.strokeNoScale && el.getLineScale) ? el.getLineScale() : 1;
	        if (lineScale_1 && lineScale_1 !== 1) {
	            lineDash = util_1.map(lineDash, function (rawVal) {
	                return rawVal / lineScale_1;
	            });
	            lineDashOffset /= lineScale_1;
	        }
	    }
	    var needsRebuild = true;
	    if (firstDraw || (el.__dirty & Path_1["default"].SHAPE_CHANGED_BIT)
	        || (lineDash && !ctxLineDash && hasStroke)) {
	        path.setDPR(ctx.dpr);
	        if (strokePart) {
	            path.setContext(null);
	        }
	        else {
	            path.setContext(ctx);
	            needsRebuild = false;
	        }
	        path.reset();
	        if (lineDash && !ctxLineDash) {
	            path.setLineDash(lineDash);
	            path.setLineDashOffset(lineDashOffset);
	        }
	        el.buildPath(path, el.shape, inBatch);
	        path.toStatic();
	        el.pathUpdated();
	    }
	    if (needsRebuild) {
	        path.rebuildPath(ctx, strokePart ? strokePercent : 1);
	    }
	    if (lineDash && ctxLineDash) {
	        ctx.setLineDash(lineDash);
	        ctx.lineDashOffset = lineDashOffset;
	    }
	    if (!inBatch) {
	        if (style.strokeFirst) {
	            if (hasStroke) {
	                doStrokePath(ctx, style);
	            }
	            if (hasFill) {
	                doFillPath(ctx, style);
	            }
	        }
	        else {
	            if (hasFill) {
	                doFillPath(ctx, style);
	            }
	            if (hasStroke) {
	                doStrokePath(ctx, style);
	            }
	        }
	    }
	    if (lineDash && ctxLineDash) {
	        ctx.setLineDash([]);
	    }
	}
	function brushImage(ctx, el, style) {
	    var image = el.__image = image_1.createOrUpdateImage(style.image, el.__image, el, el.onload);
	    if (!image || !image_1.isImageReady(image)) {
	        return;
	    }
	    var x = style.x || 0;
	    var y = style.y || 0;
	    var width = el.getWidth();
	    var height = el.getHeight();
	    var aspect = image.width / image.height;
	    if (width == null && height != null) {
	        width = height * aspect;
	    }
	    else if (height == null && width != null) {
	        height = width / aspect;
	    }
	    else if (width == null && height == null) {
	        width = image.width;
	        height = image.height;
	    }
	    if (style.sWidth && style.sHeight) {
	        var sx = style.sx || 0;
	        var sy = style.sy || 0;
	        ctx.drawImage(image, sx, sy, style.sWidth, style.sHeight, x, y, width, height);
	    }
	    else if (style.sx && style.sy) {
	        var sx = style.sx;
	        var sy = style.sy;
	        var sWidth = width - sx;
	        var sHeight = height - sy;
	        ctx.drawImage(image, sx, sy, sWidth, sHeight, x, y, width, height);
	    }
	    else {
	        ctx.drawImage(image, x, y, width, height);
	    }
	}
	function brushText(ctx, el, style) {
	    var text = style.text;
	    text != null && (text += '');
	    if (text) {
	        ctx.font = style.font || text_1.DEFAULT_FONT;
	        ctx.textAlign = style.textAlign;
	        ctx.textBaseline = style.textBaseline;
	        var hasLineDash = void 0;
	        if (ctx.setLineDash) {
	            var lineDash = style.lineDash && style.lineWidth > 0 && dashStyle_1.normalizeLineDash(style.lineDash, style.lineWidth);
	            var lineDashOffset = style.lineDashOffset;
	            if (lineDash) {
	                var lineScale_2 = (style.strokeNoScale && el.getLineScale) ? el.getLineScale() : 1;
	                if (lineScale_2 && lineScale_2 !== 1) {
	                    lineDash = util_1.map(lineDash, function (rawVal) {
	                        return rawVal / lineScale_2;
	                    });
	                    lineDashOffset /= lineScale_2;
	                }
	                ctx.setLineDash(lineDash);
	                ctx.lineDashOffset = lineDashOffset;
	                hasLineDash = true;
	            }
	        }
	        if (style.strokeFirst) {
	            if (styleHasStroke(style)) {
	                ctx.strokeText(text, style.x, style.y);
	            }
	            if (styleHasFill(style)) {
	                ctx.fillText(text, style.x, style.y);
	            }
	        }
	        else {
	            if (styleHasFill(style)) {
	                ctx.fillText(text, style.x, style.y);
	            }
	            if (styleHasStroke(style)) {
	                ctx.strokeText(text, style.x, style.y);
	            }
	        }
	        if (hasLineDash) {
	            ctx.setLineDash([]);
	        }
	    }
	}
	var SHADOW_NUMBER_PROPS = ['shadowBlur', 'shadowOffsetX', 'shadowOffsetY'];
	var STROKE_PROPS = [
	    ['lineCap', 'butt'], ['lineJoin', 'miter'], ['miterLimit', 10]
	];
	function bindCommonProps(ctx, style, prevStyle, forceSetAll, scope) {
	    var styleChanged = false;
	    if (!forceSetAll) {
	        prevStyle = prevStyle || {};
	        if (style === prevStyle) {
	            return false;
	        }
	    }
	    if (forceSetAll || style.opacity !== prevStyle.opacity) {
	        if (!styleChanged) {
	            flushPathDrawn(ctx, scope);
	            styleChanged = true;
	        }
	        ctx.globalAlpha = style.opacity == null ? Displayable_1.DEFAULT_COMMON_STYLE.opacity : style.opacity;
	    }
	    if (forceSetAll || style.blend !== prevStyle.blend) {
	        if (!styleChanged) {
	            flushPathDrawn(ctx, scope);
	            styleChanged = true;
	        }
	        ctx.globalCompositeOperation = style.blend || Displayable_1.DEFAULT_COMMON_STYLE.blend;
	    }
	    for (var i = 0; i < SHADOW_NUMBER_PROPS.length; i++) {
	        var propName = SHADOW_NUMBER_PROPS[i];
	        if (forceSetAll || style[propName] !== prevStyle[propName]) {
	            if (!styleChanged) {
	                flushPathDrawn(ctx, scope);
	                styleChanged = true;
	            }
	            ctx[propName] = ctx.dpr * (style[propName] || 0);
	        }
	    }
	    if (forceSetAll || style.shadowColor !== prevStyle.shadowColor) {
	        if (!styleChanged) {
	            flushPathDrawn(ctx, scope);
	            styleChanged = true;
	        }
	        ctx.shadowColor = style.shadowColor || Displayable_1.DEFAULT_COMMON_STYLE.shadowColor;
	    }
	    return styleChanged;
	}
	function bindPathAndTextCommonStyle(ctx, el, prevEl, forceSetAll, scope) {
	    var style = getStyle(el, scope.inHover);
	    var prevStyle = forceSetAll
	        ? null
	        : (prevEl && getStyle(prevEl, scope.inHover) || {});
	    if (style === prevStyle) {
	        return false;
	    }
	    var styleChanged = bindCommonProps(ctx, style, prevStyle, forceSetAll, scope);
	    if (forceSetAll || style.fill !== prevStyle.fill) {
	        if (!styleChanged) {
	            flushPathDrawn(ctx, scope);
	            styleChanged = true;
	        }
	        ctx.fillStyle = style.fill;
	    }
	    if (forceSetAll || style.stroke !== prevStyle.stroke) {
	        if (!styleChanged) {
	            flushPathDrawn(ctx, scope);
	            styleChanged = true;
	        }
	        ctx.strokeStyle = style.stroke;
	    }
	    if (forceSetAll || style.opacity !== prevStyle.opacity) {
	        if (!styleChanged) {
	            flushPathDrawn(ctx, scope);
	            styleChanged = true;
	        }
	        ctx.globalAlpha = style.opacity == null ? 1 : style.opacity;
	    }
	    if (el.hasStroke()) {
	        var lineWidth = style.lineWidth;
	        var newLineWidth = lineWidth / ((style.strokeNoScale && el && el.getLineScale) ? el.getLineScale() : 1);
	        if (ctx.lineWidth !== newLineWidth) {
	            if (!styleChanged) {
	                flushPathDrawn(ctx, scope);
	                styleChanged = true;
	            }
	            ctx.lineWidth = newLineWidth;
	        }
	    }
	    for (var i = 0; i < STROKE_PROPS.length; i++) {
	        var prop = STROKE_PROPS[i];
	        var propName = prop[0];
	        if (forceSetAll || style[propName] !== prevStyle[propName]) {
	            if (!styleChanged) {
	                flushPathDrawn(ctx, scope);
	                styleChanged = true;
	            }
	            ctx[propName] = style[propName] || prop[1];
	        }
	    }
	    return styleChanged;
	}
	function bindImageStyle(ctx, el, prevEl, forceSetAll, scope) {
	    return bindCommonProps(ctx, getStyle(el, scope.inHover), prevEl && getStyle(prevEl, scope.inHover), forceSetAll, scope);
	}
	function setContextTransform(ctx, el) {
	    var m = el.transform;
	    var dpr = ctx.dpr || 1;
	    if (m) {
	        ctx.setTransform(dpr * m[0], dpr * m[1], dpr * m[2], dpr * m[3], dpr * m[4], dpr * m[5]);
	    }
	    else {
	        ctx.setTransform(dpr, 0, 0, dpr, 0, 0);
	    }
	}
	function updateClipStatus(clipPaths, ctx, scope) {
	    var allClipped = false;
	    for (var i = 0; i < clipPaths.length; i++) {
	        var clipPath = clipPaths[i];
	        allClipped = allClipped || clipPath.isZeroArea();
	        setContextTransform(ctx, clipPath);
	        ctx.beginPath();
	        clipPath.buildPath(ctx, clipPath.shape);
	        ctx.clip();
	    }
	    scope.allClipped = allClipped;
	}
	function isTransformChanged(m0, m1) {
	    if (m0 && m1) {
	        return m0[0] !== m1[0]
	            || m0[1] !== m1[1]
	            || m0[2] !== m1[2]
	            || m0[3] !== m1[3]
	            || m0[4] !== m1[4]
	            || m0[5] !== m1[5];
	    }
	    else if (!m0 && !m1) {
	        return false;
	    }
	    return true;
	}
	var DRAW_TYPE_PATH = 1;
	var DRAW_TYPE_IMAGE = 2;
	var DRAW_TYPE_TEXT = 3;
	var DRAW_TYPE_INCREMENTAL = 4;
	function canPathBatch(style) {
	    var hasFill = styleHasFill(style);
	    var hasStroke = styleHasStroke(style);
	    return !(style.lineDash
	        || !(+hasFill ^ +hasStroke)
	        || (hasFill && typeof style.fill !== 'string')
	        || (hasStroke && typeof style.stroke !== 'string')
	        || style.strokePercent < 1
	        || style.strokeOpacity < 1
	        || style.fillOpacity < 1);
	}
	function flushPathDrawn(ctx, scope) {
	    scope.batchFill && ctx.fill();
	    scope.batchStroke && ctx.stroke();
	    scope.batchFill = '';
	    scope.batchStroke = '';
	}
	function getStyle(el, inHover) {
	    return inHover ? (el.__hoverStyle || el.style) : el.style;
	}
	function brushSingle(ctx, el) {
	    brush(ctx, el, { inHover: false, viewWidth: 0, viewHeight: 0 }, true);
	}
	exports.brushSingle = brushSingle;
	function brush(ctx, el, scope, isLast) {
	    var m = el.transform;
	    if (!el.shouldBePainted(scope.viewWidth, scope.viewHeight, false, false)) {
	        el.__dirty &= ~Element_1["default"].REDARAW_BIT;
	        el.__isRendered = false;
	        return;
	    }
	    var clipPaths = el.__clipPaths;
	    var prevElClipPaths = scope.prevElClipPaths;
	    var forceSetTransform = false;
	    var forceSetStyle = false;
	    if (!prevElClipPaths || helper_1.isClipPathChanged(clipPaths, prevElClipPaths)) {
	        if (prevElClipPaths && prevElClipPaths.length) {
	            flushPathDrawn(ctx, scope);
	            ctx.restore();
	            forceSetStyle = forceSetTransform = true;
	            scope.prevElClipPaths = null;
	            scope.allClipped = false;
	            scope.prevEl = null;
	        }
	        if (clipPaths && clipPaths.length) {
	            flushPathDrawn(ctx, scope);
	            ctx.save();
	            updateClipStatus(clipPaths, ctx, scope);
	            forceSetTransform = true;
	        }
	        scope.prevElClipPaths = clipPaths;
	    }
	    if (scope.allClipped) {
	        el.__isRendered = false;
	        return;
	    }
	    el.beforeBrush && el.beforeBrush();
	    el.innerBeforeBrush();
	    var prevEl = scope.prevEl;
	    if (!prevEl) {
	        forceSetStyle = forceSetTransform = true;
	    }
	    var canBatchPath = el instanceof Path_1["default"]
	        && el.autoBatch
	        && canPathBatch(el.style);
	    if (forceSetTransform || isTransformChanged(m, prevEl.transform)) {
	        flushPathDrawn(ctx, scope);
	        setContextTransform(ctx, el);
	    }
	    else if (!canBatchPath) {
	        flushPathDrawn(ctx, scope);
	    }
	    var style = getStyle(el, scope.inHover);
	    if (el instanceof Path_1["default"]) {
	        if (scope.lastDrawType !== DRAW_TYPE_PATH) {
	            forceSetStyle = true;
	            scope.lastDrawType = DRAW_TYPE_PATH;
	        }
	        bindPathAndTextCommonStyle(ctx, el, prevEl, forceSetStyle, scope);
	        if (!canBatchPath || (!scope.batchFill && !scope.batchStroke)) {
	            ctx.beginPath();
	        }
	        brushPath(ctx, el, style, canBatchPath);
	        if (canBatchPath) {
	            scope.batchFill = style.fill || '';
	            scope.batchStroke = style.stroke || '';
	        }
	    }
	    else {
	        if (el instanceof TSpan_1["default"]) {
	            if (scope.lastDrawType !== DRAW_TYPE_TEXT) {
	                forceSetStyle = true;
	                scope.lastDrawType = DRAW_TYPE_TEXT;
	            }
	            bindPathAndTextCommonStyle(ctx, el, prevEl, forceSetStyle, scope);
	            brushText(ctx, el, style);
	        }
	        else if (el instanceof Image_1["default"]) {
	            if (scope.lastDrawType !== DRAW_TYPE_IMAGE) {
	                forceSetStyle = true;
	                scope.lastDrawType = DRAW_TYPE_IMAGE;
	            }
	            bindImageStyle(ctx, el, prevEl, forceSetStyle, scope);
	            brushImage(ctx, el, style);
	        }
	        else if (el instanceof export_1.IncrementalDisplayable) {
	            if (scope.lastDrawType !== DRAW_TYPE_INCREMENTAL) {
	                forceSetStyle = true;
	                scope.lastDrawType = DRAW_TYPE_INCREMENTAL;
	            }
	            brushIncremental(ctx, el, scope);
	        }
	    }
	    if (canBatchPath && isLast) {
	        flushPathDrawn(ctx, scope);
	    }
	    el.innerAfterBrush();
	    el.afterBrush && el.afterBrush();
	    scope.prevEl = el;
	    el.__dirty = 0;
	    el.__isRendered = true;
	}
	exports.brush = brush;
	function brushIncremental(ctx, el, scope) {
	    var displayables = el.getDisplayables();
	    var temporalDisplayables = el.getTemporalDisplayables();
	    ctx.save();
	    var innerScope = {
	        prevElClipPaths: null,
	        prevEl: null,
	        allClipped: false,
	        viewWidth: scope.viewWidth,
	        viewHeight: scope.viewHeight,
	        inHover: scope.inHover
	    };
	    var i;
	    var len;
	    for (i = el.getCursor(), len = displayables.length; i < len; i++) {
	        var displayable = displayables[i];
	        displayable.beforeBrush && displayable.beforeBrush();
	        displayable.innerBeforeBrush();
	        brush(ctx, displayable, innerScope, i === len - 1);
	        displayable.innerAfterBrush();
	        displayable.afterBrush && displayable.afterBrush();
	        innerScope.prevEl = displayable;
	    }
	    for (var i_1 = 0, len_1 = temporalDisplayables.length; i_1 < len_1; i_1++) {
	        var displayable = temporalDisplayables[i_1];
	        displayable.beforeBrush && displayable.beforeBrush();
	        displayable.innerBeforeBrush();
	        brush(ctx, displayable, innerScope, i_1 === len_1 - 1);
	        displayable.innerAfterBrush();
	        displayable.afterBrush && displayable.afterBrush();
	        innerScope.prevEl = displayable;
	    }
	    el.clearTemporalDisplayables();
	    el.notClear = true;
	    ctx.restore();
	}


/***/ },
/* 79 */
/***/ function(module, exports) {

	"use strict";
	exports.__esModule = true;
	var Point = (function () {
	    function Point(x, y) {
	        this.x = x || 0;
	        this.y = y || 0;
	    }
	    Point.prototype.copy = function (other) {
	        this.x = other.x;
	        this.y = other.y;
	        return this;
	    };
	    Point.prototype.clone = function () {
	        return new Point(this.x, this.y);
	    };
	    Point.prototype.set = function (x, y) {
	        this.x = x;
	        this.y = y;
	        return this;
	    };
	    Point.prototype.equal = function (other) {
	        return other.x === this.x && other.y === this.y;
	    };
	    Point.prototype.add = function (other) {
	        this.x += other.x;
	        this.y += other.y;
	        return this;
	    };
	    Point.prototype.scale = function (scalar) {
	        this.x *= scalar;
	        this.y *= scalar;
	    };
	    Point.prototype.scaleAndAdd = function (other, scalar) {
	        this.x += other.x * scalar;
	        this.y += other.y * scalar;
	    };
	    Point.prototype.sub = function (other) {
	        this.x -= other.x;
	        this.y -= other.y;
	        return this;
	    };
	    Point.prototype.dot = function (other) {
	        return this.x * other.x + this.y * other.y;
	    };
	    Point.prototype.len = function () {
	        return Math.sqrt(this.x * this.x + this.y * this.y);
	    };
	    Point.prototype.lenSquare = function () {
	        return this.x * this.x + this.y * this.y;
	    };
	    Point.prototype.normalize = function () {
	        var len = this.len();
	        this.x /= len;
	        this.y /= len;
	        return this;
	    };
	    Point.prototype.distance = function (other) {
	        var dx = this.x - other.x;
	        var dy = this.y - other.y;
	        return Math.sqrt(dx * dx + dy * dy);
	    };
	    Point.prototype.distanceSquare = function (other) {
	        var dx = this.x - other.x;
	        var dy = this.y - other.y;
	        return dx * dx + dy * dy;
	    };
	    Point.prototype.negate = function () {
	        this.x = -this.x;
	        this.y = -this.y;
	        return this;
	    };
	    Point.prototype.transform = function (m) {
	        if (!m) {
	            return;
	        }
	        var x = this.x;
	        var y = this.y;
	        this.x = m[0] * x + m[2] * y + m[4];
	        this.y = m[1] * x + m[3] * y + m[5];
	        return this;
	    };
	    Point.prototype.toArray = function (out) {
	        out[0] = this.x;
	        out[1] = this.y;
	        return out;
	    };
	    Point.prototype.fromArray = function (input) {
	        this.x = input[0];
	        this.y = input[1];
	    };
	    Point.set = function (p, x, y) {
	        p.x = x;
	        p.y = y;
	    };
	    Point.copy = function (p, p2) {
	        p.x = p2.x;
	        p.y = p2.y;
	    };
	    Point.len = function (p) {
	        return Math.sqrt(p.x * p.x + p.y * p.y);
	    };
	    Point.lenSquare = function (p) {
	        return p.x * p.x + p.y * p.y;
	    };
	    Point.dot = function (p0, p1) {
	        return p0.x * p1.x + p0.y * p1.y;
	    };
	    Point.add = function (out, p0, p1) {
	        out.x = p0.x + p1.x;
	        out.y = p0.y + p1.y;
	    };
	    Point.sub = function (out, p0, p1) {
	        out.x = p0.x - p1.x;
	        out.y = p0.y - p1.y;
	    };
	    Point.scale = function (out, p0, scalar) {
	        out.x = p0.x * scalar;
	        out.y = p0.y * scalar;
	    };
	    Point.scaleAndAdd = function (out, p0, p1, scalar) {
	        out.x = p0.x + p1.x * scalar;
	        out.y = p0.y + p1.y * scalar;
	    };
	    Point.lerp = function (out, p0, p1, t) {
	        var onet = 1 - t;
	        out.x = onet * p0.x + t * p1.x;
	        out.y = onet * p0.y + t * p1.y;
	    };
	    return Point;
	}());
	exports["default"] = Point;


/***/ },
/* 80 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	exports.__esModule = true;
	var tslib_1 = __webpack_require__(5);
	var Displayable_1 = __webpack_require__(50);
	var text_1 = __webpack_require__(26);
	var Path_1 = __webpack_require__(8);
	var util_1 = __webpack_require__(1);
	exports.DEFAULT_TSPAN_STYLE = util_1.defaults({
	    strokeFirst: true,
	    font: text_1.DEFAULT_FONT,
	    x: 0,
	    y: 0,
	    textAlign: 'left',
	    textBaseline: 'top',
	    miterLimit: 2
	}, Path_1.DEFAULT_PATH_STYLE);
	var TSpan = (function (_super) {
	    tslib_1.__extends(TSpan, _super);
	    function TSpan() {
	        return _super !== null && _super.apply(this, arguments) || this;
	    }
	    TSpan.prototype.hasStroke = function () {
	        var style = this.style;
	        var stroke = style.stroke;
	        return stroke != null && stroke !== 'none' && style.lineWidth > 0;
	    };
	    TSpan.prototype.hasFill = function () {
	        var style = this.style;
	        var fill = style.fill;
	        return fill != null && fill !== 'none';
	    };
	    TSpan.prototype.createStyle = function (obj) {
	        return util_1.createObject(exports.DEFAULT_TSPAN_STYLE, obj);
	    };
	    TSpan.prototype.setBoundingRect = function (rect) {
	        this._rect = rect;
	    };
	    TSpan.prototype.getBoundingRect = function () {
	        var style = this.style;
	        if (!this._rect) {
	            var text = style.text;
	            text != null ? (text += '') : (text = '');
	            var rect = text_1.getBoundingRect(text, style.font, style.textAlign, style.textBaseline);
	            rect.x += style.x || 0;
	            rect.y += style.y || 0;
	            if (this.hasStroke()) {
	                var w = style.lineWidth;
	                rect.x -= w / 2;
	                rect.y -= w / 2;
	                rect.width += w;
	                rect.height += w;
	            }
	            this._rect = rect;
	        }
	        return this._rect;
	    };
	    TSpan.initDefaultProps = (function () {
	        var tspanProto = TSpan.prototype;
	        tspanProto.dirtyRectTolerance = 10;
	    })();
	    return TSpan;
	}(Displayable_1["default"]));
	TSpan.prototype.type = 'tspan';
	exports["default"] = TSpan;


/***/ },
/* 81 */
/***/ function(module, exports, __webpack_require__) {

	
	/*
	* Licensed to the Apache Software Foundation (ASF) under one
	* or more contributor license agreements.  See the NOTICE file
	* distributed with this work for additional information
	* regarding copyright ownership.  The ASF licenses this file
	* to you under the Apache License, Version 2.0 (the
	* "License"); you may not use this file except in compliance
	* with the License.  You may obtain a copy of the License at
	*
	*   http://www.apache.org/licenses/LICENSE-2.0
	*
	* Unless required by applicable law or agreed to in writing,
	* software distributed under the License is distributed on an
	* "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
	* KIND, either express or implied.  See the License for the
	* specific language governing permissions and limitations
	* under the License.
	*/
	
	
	
	/**
	 * AUTO-GENERATED FILE. DO NOT MODIFY.
	 */
	
	"use strict";
	
	exports.__esModule = true;
	
	var zrUtil = __webpack_require__(1);
	
	var coordinateSystemCreators = {};
	
	var CoordinateSystemManager = function () {
	  function CoordinateSystemManager() {
	    this._coordinateSystems = [];
	  }
	
	  CoordinateSystemManager.prototype.create = function (ecModel, api) {
	    var coordinateSystems = [];
	    zrUtil.each(coordinateSystemCreators, function (creater, type) {
	      var list = creater.create(ecModel, api);
	      coordinateSystems = coordinateSystems.concat(list || []);
	    });
	    this._coordinateSystems = coordinateSystems;
	  };
	
	  CoordinateSystemManager.prototype.update = function (ecModel, api) {
	    zrUtil.each(this._coordinateSystems, function (coordSys) {
	      coordSys.update && coordSys.update(ecModel, api);
	    });
	  };
	
	  CoordinateSystemManager.prototype.getCoordinateSystems = function () {
	    return this._coordinateSystems.slice();
	  };
	
	  CoordinateSystemManager.register = function (type, creator) {
	    coordinateSystemCreators[type] = creator;
	  };
	
	  CoordinateSystemManager.get = function (type) {
	    return coordinateSystemCreators[type];
	  };
	
	  return CoordinateSystemManager;
	}();
	
	exports["default"] = CoordinateSystemManager;

/***/ },
/* 82 */
/***/ function(module, exports, __webpack_require__) {

	
	/*
	* Licensed to the Apache Software Foundation (ASF) under one
	* or more contributor license agreements.  See the NOTICE file
	* distributed with this work for additional information
	* regarding copyright ownership.  The ASF licenses this file
	* to you under the Apache License, Version 2.0 (the
	* "License"); you may not use this file except in compliance
	* with the License.  You may obtain a copy of the License at
	*
	*   http://www.apache.org/licenses/LICENSE-2.0
	*
	* Unless required by applicable law or agreed to in writing,
	* software distributed under the License is distributed on an
	* "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
	* KIND, either express or implied.  See the License for the
	* specific language governing permissions and limitations
	* under the License.
	*/
	
	
	
	/**
	 * AUTO-GENERATED FILE. DO NOT MODIFY.
	 */
	
	"use strict";
	
	exports.__esModule = true;
	
	var model_1 = __webpack_require__(4);
	
	function createRenderPlanner() {
	  var inner = model_1.makeInner();
	  return function (seriesModel) {
	    var fields = inner(seriesModel);
	    var pipelineContext = seriesModel.pipelineContext;
	    var originalLarge = !!fields.large;
	    var originalProgressive = !!fields.progressiveRender;
	    var large = fields.large = !!(pipelineContext && pipelineContext.large);
	    var progressive = fields.progressiveRender = !!(pipelineContext && pipelineContext.progressiveRender);
	    return !!(originalLarge !== large || originalProgressive !== progressive) && 'reset';
	  };
	}
	
	exports["default"] = createRenderPlanner;

/***/ },
/* 83 */
/***/ function(module, exports, __webpack_require__) {

	
	/*
	* Licensed to the Apache Software Foundation (ASF) under one
	* or more contributor license agreements.  See the NOTICE file
	* distributed with this work for additional information
	* regarding copyright ownership.  The ASF licenses this file
	* to you under the Apache License, Version 2.0 (the
	* "License"); you may not use this file except in compliance
	* with the License.  You may obtain a copy of the License at
	*
	*   http://www.apache.org/licenses/LICENSE-2.0
	*
	* Unless required by applicable law or agreed to in writing,
	* software distributed under the License is distributed on an
	* "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
	* KIND, either express or implied.  See the License for the
	* specific language governing permissions and limitations
	* under the License.
	*/
	
	
	
	/**
	 * AUTO-GENERATED FILE. DO NOT MODIFY.
	 */
	
	"use strict";
	
	exports.__esModule = true;
	
	var dataProvider_1 = __webpack_require__(53);
	
	var util_1 = __webpack_require__(1);
	
	function getDefaultLabel(data, dataIndex) {
	  var labelDims = data.mapDimensionsAll('defaultedLabel');
	  var len = labelDims.length;
	
	  if (len === 1) {
	    return dataProvider_1.retrieveRawValue(data, dataIndex, labelDims[0]);
	  } else if (len) {
	    var vals = [];
	
	    for (var i = 0; i < labelDims.length; i++) {
	      vals.push(dataProvider_1.retrieveRawValue(data, dataIndex, labelDims[i]));
	    }
	
	    return vals.join(' ');
	  }
	}
	
	exports.getDefaultLabel = getDefaultLabel;
	
	function getDefaultInterpolatedLabel(data, interpolatedValue) {
	  var labelDims = data.mapDimensionsAll('defaultedLabel');
	
	  if (!util_1.isArray(interpolatedValue)) {
	    return interpolatedValue + '';
	  }
	
	  var vals = [];
	
	  for (var i = 0; i < labelDims.length; i++) {
	    var dimInfo = data.getDimensionInfo(labelDims[i]);
	
	    if (dimInfo) {
	      vals.push(interpolatedValue[dimInfo.index]);
	    }
	  }
	
	  return vals.join(' ');
	}
	
	exports.getDefaultInterpolatedLabel = getDefaultInterpolatedLabel;

/***/ },
/* 84 */
/***/ function(module, exports, __webpack_require__) {

	
	/*
	* Licensed to the Apache Software Foundation (ASF) under one
	* or more contributor license agreements.  See the NOTICE file
	* distributed with this work for additional information
	* regarding copyright ownership.  The ASF licenses this file
	* to you under the Apache License, Version 2.0 (the
	* "License"); you may not use this file except in compliance
	* with the License.  You may obtain a copy of the License at
	*
	*   http://www.apache.org/licenses/LICENSE-2.0
	*
	* Unless required by applicable law or agreed to in writing,
	* software distributed under the License is distributed on an
	* "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
	* KIND, either express or implied.  See the License for the
	* specific language governing permissions and limitations
	* under the License.
	*/
	
	
	
	/**
	 * AUTO-GENERATED FILE. DO NOT MODIFY.
	 */
	
	"use strict";
	
	exports.__esModule = true;
	
	var tslib_1 = __webpack_require__(3);
	
	var echarts = __webpack_require__(6);
	
	var zrUtil = __webpack_require__(1);
	
	var graphic = __webpack_require__(7);
	
	__webpack_require__(301);
	
	__webpack_require__(344);
	
	var Component_1 = __webpack_require__(18);
	
	var GridModel_1 = __webpack_require__(343);
	
	var Component_2 = __webpack_require__(10);
	
	var GridView = function (_super) {
	  tslib_1.__extends(GridView, _super);
	
	  function GridView() {
	    var _this = _super !== null && _super.apply(this, arguments) || this;
	
	    _this.type = 'grid';
	    return _this;
	  }
	
	  GridView.prototype.render = function (gridModel, ecModel) {
	    this.group.removeAll();
	
	    if (gridModel.get('show')) {
	      this.group.add(new graphic.Rect({
	        shape: gridModel.coordinateSystem.getRect(),
	        style: zrUtil.defaults({
	          fill: gridModel.get('backgroundColor')
	        }, gridModel.getItemStyle()),
	        silent: true,
	        z2: -1
	      }));
	    }
	  };
	
	  GridView.type = 'grid';
	  return GridView;
	}(Component_1["default"]);
	
	Component_1["default"].registerClass(GridView);
	Component_2["default"].registerClass(GridModel_1["default"]);
	echarts.registerPreprocessor(function (option) {
	  if (option.xAxis && option.yAxis && !option.grid) {
	    option.grid = {};
	  }
	});

/***/ },
/* 85 */
/***/ function(module, exports) {

	
	/*
	* Licensed to the Apache Software Foundation (ASF) under one
	* or more contributor license agreements.  See the NOTICE file
	* distributed with this work for additional information
	* regarding copyright ownership.  The ASF licenses this file
	* to you under the Apache License, Version 2.0 (the
	* "License"); you may not use this file except in compliance
	* with the License.  You may obtain a copy of the License at
	*
	*   http://www.apache.org/licenses/LICENSE-2.0
	*
	* Unless required by applicable law or agreed to in writing,
	* software distributed under the License is distributed on an
	* "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
	* KIND, either express or implied.  See the License for the
	* specific language governing permissions and limitations
	* under the License.
	*/
	
	
	
	/**
	 * AUTO-GENERATED FILE. DO NOT MODIFY.
	 */
	
	"use strict";
	
	exports.__esModule = true;
	
	function sliderMove(delta, handleEnds, extent, handleIndex, minSpan, maxSpan) {
	  delta = delta || 0;
	  var extentSpan = extent[1] - extent[0];
	
	  if (minSpan != null) {
	    minSpan = restrict(minSpan, [0, extentSpan]);
	  }
	
	  if (maxSpan != null) {
	    maxSpan = Math.max(maxSpan, minSpan != null ? minSpan : 0);
	  }
	
	  if (handleIndex === 'all') {
	    var handleSpan = Math.abs(handleEnds[1] - handleEnds[0]);
	    handleSpan = restrict(handleSpan, [0, extentSpan]);
	    minSpan = maxSpan = restrict(handleSpan, [minSpan, maxSpan]);
	    handleIndex = 0;
	  }
	
	  handleEnds[0] = restrict(handleEnds[0], extent);
	  handleEnds[1] = restrict(handleEnds[1], extent);
	  var originalDistSign = getSpanSign(handleEnds, handleIndex);
	  handleEnds[handleIndex] += delta;
	  var extentMinSpan = minSpan || 0;
	  var realExtent = extent.slice();
	  originalDistSign.sign < 0 ? realExtent[0] += extentMinSpan : realExtent[1] -= extentMinSpan;
	  handleEnds[handleIndex] = restrict(handleEnds[handleIndex], realExtent);
	  var currDistSign;
	  currDistSign = getSpanSign(handleEnds, handleIndex);
	
	  if (minSpan != null && (currDistSign.sign !== originalDistSign.sign || currDistSign.span < minSpan)) {
	    handleEnds[1 - handleIndex] = handleEnds[handleIndex] + originalDistSign.sign * minSpan;
	  }
	
	  currDistSign = getSpanSign(handleEnds, handleIndex);
	
	  if (maxSpan != null && currDistSign.span > maxSpan) {
	    handleEnds[1 - handleIndex] = handleEnds[handleIndex] + currDistSign.sign * maxSpan;
	  }
	
	  return handleEnds;
	}
	
	exports["default"] = sliderMove;
	
	function getSpanSign(handleEnds, handleIndex) {
	  var dist = handleEnds[handleIndex] - handleEnds[1 - handleIndex];
	  return {
	    span: Math.abs(dist),
	    sign: dist > 0 ? -1 : dist < 0 ? 1 : handleIndex ? -1 : 1
	  };
	}
	
	function restrict(value, extend) {
	  return Math.min(extend[1] != null ? extend[1] : Infinity, Math.max(extend[0] != null ? extend[0] : -Infinity, value));
	}

/***/ },
/* 86 */
/***/ function(module, exports, __webpack_require__) {

	
	/*
	* Licensed to the Apache Software Foundation (ASF) under one
	* or more contributor license agreements.  See the NOTICE file
	* distributed with this work for additional information
	* regarding copyright ownership.  The ASF licenses this file
	* to you under the Apache License, Version 2.0 (the
	* "License"); you may not use this file except in compliance
	* with the License.  You may obtain a copy of the License at
	*
	*   http://www.apache.org/licenses/LICENSE-2.0
	*
	* Unless required by applicable law or agreed to in writing,
	* software distributed under the License is distributed on an
	* "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
	* KIND, either express or implied.  See the License for the
	* specific language governing permissions and limitations
	* under the License.
	*/
	
	
	
	/**
	 * AUTO-GENERATED FILE. DO NOT MODIFY.
	 */
	
	"use strict";
	
	exports.__esModule = true;
	
	var tslib_1 = __webpack_require__(3);
	
	var zrUtil = __webpack_require__(1);
	
	var env_1 = __webpack_require__(13);
	
	var dataFormat_1 = __webpack_require__(91);
	
	var Component_1 = __webpack_require__(10);
	
	var model_1 = __webpack_require__(4);
	
	var tooltipMarkup_1 = __webpack_require__(52);
	
	function fillLabel(opt) {
	  model_1.defaultEmphasis(opt, 'label', ['show']);
	}
	
	var inner = model_1.makeInner();
	
	var MarkerModel = function (_super) {
	  tslib_1.__extends(MarkerModel, _super);
	
	  function MarkerModel() {
	    var _this = _super !== null && _super.apply(this, arguments) || this;
	
	    _this.type = MarkerModel.type;
	    _this.createdBySelf = false;
	    return _this;
	  }
	
	  MarkerModel.prototype.init = function (option, parentModel, ecModel) {
	    if (false) {
	      if (this.type === 'marker') {
	        throw new Error('Marker component is abstract component. Use markLine, markPoint, markArea instead.');
	      }
	    }
	
	    this.mergeDefaultAndTheme(option, ecModel);
	
	    this._mergeOption(option, ecModel, false, true);
	  };
	
	  MarkerModel.prototype.isAnimationEnabled = function () {
	    if (env_1["default"].node) {
	      return false;
	    }
	
	    var hostSeries = this.__hostSeries;
	    return this.getShallow('animation') && hostSeries && hostSeries.isAnimationEnabled();
	  };
	
	  MarkerModel.prototype.mergeOption = function (newOpt, ecModel) {
	    this._mergeOption(newOpt, ecModel, false, false);
	  };
	
	  MarkerModel.prototype._mergeOption = function (newOpt, ecModel, createdBySelf, isInit) {
	    var componentType = this.mainType;
	
	    if (!createdBySelf) {
	      ecModel.eachSeries(function (seriesModel) {
	        var markerOpt = seriesModel.get(this.mainType, true);
	        var markerModel = inner(seriesModel)[componentType];
	
	        if (!markerOpt || !markerOpt.data) {
	          inner(seriesModel)[componentType] = null;
	          return;
	        }
	
	        if (!markerModel) {
	          if (isInit) {
	            fillLabel(markerOpt);
	          }
	
	          zrUtil.each(markerOpt.data, function (item) {
	            if (item instanceof Array) {
	              fillLabel(item[0]);
	              fillLabel(item[1]);
	            } else {
	              fillLabel(item);
	            }
	          });
	          markerModel = this.createMarkerModelFromSeries(markerOpt, this, ecModel);
	          zrUtil.extend(markerModel, {
	            mainType: this.mainType,
	            seriesIndex: seriesModel.seriesIndex,
	            name: seriesModel.name,
	            createdBySelf: true
	          });
	          markerModel.__hostSeries = seriesModel;
	        } else {
	          markerModel._mergeOption(markerOpt, ecModel, true);
	        }
	
	        inner(seriesModel)[componentType] = markerModel;
	      }, this);
	    }
	  };
	
	  MarkerModel.prototype.formatTooltip = function (dataIndex, multipleSeries, dataType) {
	    var data = this.getData();
	    var value = this.getRawValue(dataIndex);
	    var itemName = data.getName(dataIndex);
	    return tooltipMarkup_1.createTooltipMarkup('section', {
	      header: this.name,
	      blocks: [tooltipMarkup_1.createTooltipMarkup('nameValue', {
	        name: itemName,
	        value: value,
	        noName: !itemName,
	        noValue: value == null
	      })]
	    });
	  };
	
	  MarkerModel.prototype.getData = function () {
	    return this._data;
	  };
	
	  MarkerModel.prototype.setData = function (data) {
	    this._data = data;
	  };
	
	  MarkerModel.getMarkerModelFromSeries = function (seriesModel, componentType) {
	    return inner(seriesModel)[componentType];
	  };
	
	  MarkerModel.type = 'marker';
	  MarkerModel.dependencies = ['series', 'grid', 'polar', 'geo'];
	  return MarkerModel;
	}(Component_1["default"]);
	
	zrUtil.mixin(MarkerModel, dataFormat_1.DataFormatMixin.prototype);
	exports["default"] = MarkerModel;

/***/ },
/* 87 */
/***/ function(module, exports) {

	
	/*
	* Licensed to the Apache Software Foundation (ASF) under one
	* or more contributor license agreements.  See the NOTICE file
	* distributed with this work for additional information
	* regarding copyright ownership.  The ASF licenses this file
	* to you under the Apache License, Version 2.0 (the
	* "License"); you may not use this file except in compliance
	* with the License.  You may obtain a copy of the License at
	*
	*   http://www.apache.org/licenses/LICENSE-2.0
	*
	* Unless required by applicable law or agreed to in writing,
	* software distributed under the License is distributed on an
	* "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
	* KIND, either express or implied.  See the License for the
	* specific language governing permissions and limitations
	* under the License.
	*/
	
	
	
	/**
	 * AUTO-GENERATED FILE. DO NOT MODIFY.
	 */
	
	"use strict";
	
	exports.__esModule = true;
	
	function isCoordinateSystemType(coordSys, type) {
	  return coordSys.type === type;
	}
	
	exports.isCoordinateSystemType = isCoordinateSystemType;

/***/ },
/* 88 */
/***/ function(module, exports, __webpack_require__) {

	
	/*
	* Licensed to the Apache Software Foundation (ASF) under one
	* or more contributor license agreements.  See the NOTICE file
	* distributed with this work for additional information
	* regarding copyright ownership.  The ASF licenses this file
	* to you under the Apache License, Version 2.0 (the
	* "License"); you may not use this file except in compliance
	* with the License.  You may obtain a copy of the License at
	*
	*   http://www.apache.org/licenses/LICENSE-2.0
	*
	* Unless required by applicable law or agreed to in writing,
	* software distributed under the License is distributed on an
	* "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
	* KIND, either express or implied.  See the License for the
	* specific language governing permissions and limitations
	* under the License.
	*/
	
	
	
	/**
	 * AUTO-GENERATED FILE. DO NOT MODIFY.
	 */
	
	"use strict";
	
	exports.__esModule = true;
	
	var util_1 = __webpack_require__(1);
	
	var text_1 = __webpack_require__(26);
	
	var ScaleRawExtentInfo = function () {
	  function ScaleRawExtentInfo(scale, model, originalExtent) {
	    this._prepareParams(scale, model, originalExtent);
	  }
	
	  ScaleRawExtentInfo.prototype._prepareParams = function (scale, model, dataExtent) {
	    if (dataExtent[1] < dataExtent[0]) {
	      dataExtent = [NaN, NaN];
	    }
	
	    this._dataMin = dataExtent[0];
	    this._dataMax = dataExtent[1];
	    var isOrdinal = this._isOrdinal = scale.type === 'ordinal';
	    this._needCrossZero = model.getNeedCrossZero && model.getNeedCrossZero();
	    var modelMinRaw = this._modelMinRaw = model.get('min', true);
	
	    if (util_1.isFunction(modelMinRaw)) {
	      this._modelMinNum = parseAxisModelMinMax(scale, modelMinRaw({
	        min: dataExtent[0],
	        max: dataExtent[1]
	      }));
	    } else if (modelMinRaw !== 'dataMin') {
	      this._modelMinNum = parseAxisModelMinMax(scale, modelMinRaw);
	    }
	
	    var modelMaxRaw = this._modelMaxRaw = model.get('max', true);
	
	    if (util_1.isFunction(modelMaxRaw)) {
	      this._modelMaxNum = parseAxisModelMinMax(scale, modelMaxRaw({
	        min: dataExtent[0],
	        max: dataExtent[1]
	      }));
	    } else if (modelMaxRaw !== 'dataMax') {
	      this._modelMaxNum = parseAxisModelMinMax(scale, modelMaxRaw);
	    }
	
	    if (isOrdinal) {
	      this._axisDataLen = model.getCategories().length;
	    } else {
	      var boundaryGap = model.get('boundaryGap');
	      var boundaryGapArr = util_1.isArray(boundaryGap) ? boundaryGap : [boundaryGap || 0, boundaryGap || 0];
	
	      if (typeof boundaryGapArr[0] === 'boolean' || typeof boundaryGapArr[1] === 'boolean') {
	        if (false) {
	          console.warn('Boolean type for boundaryGap is only ' + 'allowed for ordinal axis. Please use string in ' + 'percentage instead, e.g., "20%". Currently, ' + 'boundaryGap is set to be 0.');
	        }
	
	        this._boundaryGapInner = [0, 0];
	      } else {
	        this._boundaryGapInner = [text_1.parsePercent(boundaryGapArr[0], 1), text_1.parsePercent(boundaryGapArr[1], 1)];
	      }
	    }
	  };
	
	  ScaleRawExtentInfo.prototype.calculate = function () {
	    var isOrdinal = this._isOrdinal;
	    var dataMin = this._dataMin;
	    var dataMax = this._dataMax;
	    var axisDataLen = this._axisDataLen;
	    var boundaryGapInner = this._boundaryGapInner;
	    var span = !isOrdinal ? dataMax - dataMin || Math.abs(dataMin) : null;
	    var min = this._modelMinRaw === 'dataMin' ? dataMin : this._modelMinNum;
	    var max = this._modelMaxRaw === 'dataMax' ? dataMax : this._modelMaxNum;
	    var minFixed = min != null;
	    var maxFixed = max != null;
	
	    if (min == null) {
	      min = isOrdinal ? axisDataLen ? 0 : NaN : dataMin - boundaryGapInner[0] * span;
	    }
	
	    if (max == null) {
	      max = isOrdinal ? axisDataLen ? axisDataLen - 1 : NaN : dataMax + boundaryGapInner[1] * span;
	    }
	
	    (min == null || !isFinite(min)) && (min = NaN);
	    (max == null || !isFinite(max)) && (max = NaN);
	
	    if (min > max) {
	      min = NaN;
	      max = NaN;
	    }
	
	    var isBlank = util_1.eqNaN(min) || util_1.eqNaN(max) || isOrdinal && !axisDataLen;
	
	    if (this._needCrossZero) {
	      if (min > 0 && max > 0 && !minFixed) {
	        min = 0;
	      }
	
	      if (min < 0 && max < 0 && !maxFixed) {
	        max = 0;
	      }
	    }
	
	    var determinedMin = this._determinedMin;
	    var determinedMax = this._determinedMax;
	
	    if (determinedMin != null) {
	      min = determinedMin;
	      minFixed = true;
	    }
	
	    if (determinedMax != null) {
	      max = determinedMax;
	      maxFixed = true;
	    }
	
	    return {
	      min: min,
	      max: max,
	      minFixed: minFixed,
	      maxFixed: maxFixed,
	      isBlank: isBlank
	    };
	  };
	
	  ScaleRawExtentInfo.prototype.modifyDataMinMax = function (minMaxName, val) {
	    if (false) {
	      util_1.assert(!this.frozen);
	    }
	
	    this[DATA_MIN_MAX_ATTR[minMaxName]] = val;
	  };
	
	  ScaleRawExtentInfo.prototype.setDeterminedMinMax = function (minMaxName, val) {
	    var attr = DETERMINED_MIN_MAX_ATTR[minMaxName];
	
	    if (false) {
	      util_1.assert(!this.frozen && this[attr] == null);
	    }
	
	    this[attr] = val;
	  };
	
	  ScaleRawExtentInfo.prototype.freeze = function () {
	    this.frozen = true;
	  };
	
	  return ScaleRawExtentInfo;
	}();
	
	exports.ScaleRawExtentInfo = ScaleRawExtentInfo;
	var DETERMINED_MIN_MAX_ATTR = {
	  min: '_determinedMin',
	  max: '_determinedMax'
	};
	var DATA_MIN_MAX_ATTR = {
	  min: '_dataMin',
	  max: '_dataMax'
	};
	
	function ensureScaleRawExtentInfo(scale, model, originalExtent) {
	  var rawExtentInfo = scale.rawExtentInfo;
	
	  if (rawExtentInfo) {
	    return rawExtentInfo;
	  }
	
	  rawExtentInfo = new ScaleRawExtentInfo(scale, model, originalExtent);
	  scale.rawExtentInfo = rawExtentInfo;
	  return rawExtentInfo;
	}
	
	exports.ensureScaleRawExtentInfo = ensureScaleRawExtentInfo;
	
	function parseAxisModelMinMax(scale, minMax) {
	  return minMax == null ? null : util_1.eqNaN(minMax) ? NaN : scale.parse(minMax);
	}
	
	exports.parseAxisModelMinMax = parseAxisModelMinMax;

/***/ },
/* 89 */
/***/ function(module, exports, __webpack_require__) {

	
	/*
	* Licensed to the Apache Software Foundation (ASF) under one
	* or more contributor license agreements.  See the NOTICE file
	* distributed with this work for additional information
	* regarding copyright ownership.  The ASF licenses this file
	* to you under the Apache License, Version 2.0 (the
	* "License"); you may not use this file except in compliance
	* with the License.  You may obtain a copy of the License at
	*
	*   http://www.apache.org/licenses/LICENSE-2.0
	*
	* Unless required by applicable law or agreed to in writing,
	* software distributed under the License is distributed on an
	* "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
	* KIND, either express or implied.  See the License for the
	* specific language governing permissions and limitations
	* under the License.
	*/
	
	
	
	/**
	 * AUTO-GENERATED FILE. DO NOT MODIFY.
	 */
	
	"use strict";
	
	exports.__esModule = true;
	
	var number_1 = __webpack_require__(9);
	
	var util_1 = __webpack_require__(1);
	
	var log_1 = __webpack_require__(12);
	
	function parseDataValue(value, opt) {
	  var dimType = opt && opt.type;
	
	  if (dimType === 'ordinal') {
	    var ordinalMeta = opt && opt.ordinalMeta;
	    return ordinalMeta ? ordinalMeta.parseAndCollect(value) : value;
	  }
	
	  if (dimType === 'time' && typeof value !== 'number' && value != null && value !== '-') {
	    value = +number_1.parseDate(value);
	  }
	
	  return value == null || value === '' ? NaN : +value;
	}
	
	exports.parseDataValue = parseDataValue;
	;
	var valueParserMap = util_1.createHashMap({
	  'number': function (val) {
	    return parseFloat(val);
	  },
	  'time': function (val) {
	    return +number_1.parseDate(val);
	  },
	  'trim': function (val) {
	    return typeof val === 'string' ? util_1.trim(val) : val;
	  }
	});
	
	function getRawValueParser(type) {
	  return valueParserMap.get(type);
	}
	
	exports.getRawValueParser = getRawValueParser;
	var ORDER_COMPARISON_OP_MAP = {
	  lt: function (lval, rval) {
	    return lval < rval;
	  },
	  lte: function (lval, rval) {
	    return lval <= rval;
	  },
	  gt: function (lval, rval) {
	    return lval > rval;
	  },
	  gte: function (lval, rval) {
	    return lval >= rval;
	  }
	};
	
	var FilterOrderComparator = function () {
	  function FilterOrderComparator(op, rval) {
	    if (typeof rval !== 'number') {
	      var errMsg = '';
	
	      if (false) {
	        errMsg = 'rvalue of "<", ">", "<=", ">=" can only be number in filter.';
	      }
	
	      log_1.throwError(errMsg);
	    }
	
	    this._opFn = ORDER_COMPARISON_OP_MAP[op];
	    this._rvalFloat = number_1.numericToNumber(rval);
	  }
	
	  FilterOrderComparator.prototype.evaluate = function (lval) {
	    return typeof lval === 'number' ? this._opFn(lval, this._rvalFloat) : this._opFn(number_1.numericToNumber(lval), this._rvalFloat);
	  };
	
	  return FilterOrderComparator;
	}();
	
	var SortOrderComparator = function () {
	  function SortOrderComparator(order, incomparable) {
	    var isDesc = order === 'desc';
	    this._resultLT = isDesc ? 1 : -1;
	
	    if (incomparable == null) {
	      incomparable = isDesc ? 'min' : 'max';
	    }
	
	    this._incomparable = incomparable === 'min' ? -Infinity : Infinity;
	  }
	
	  SortOrderComparator.prototype.evaluate = function (lval, rval) {
	    var lvalTypeof = typeof lval;
	    var rvalTypeof = typeof rval;
	    var lvalFloat = lvalTypeof === 'number' ? lval : number_1.numericToNumber(lval);
	    var rvalFloat = rvalTypeof === 'number' ? rval : number_1.numericToNumber(rval);
	    var lvalNotNumeric = isNaN(lvalFloat);
	    var rvalNotNumeric = isNaN(rvalFloat);
	
	    if (lvalNotNumeric) {
	      lvalFloat = this._incomparable;
	    }
	
	    if (rvalNotNumeric) {
	      rvalFloat = this._incomparable;
	    }
	
	    if (lvalNotNumeric && rvalNotNumeric) {
	      var lvalIsStr = lvalTypeof === 'string';
	      var rvalIsStr = rvalTypeof === 'string';
	
	      if (lvalIsStr) {
	        lvalFloat = rvalIsStr ? lval : 0;
	      }
	
	      if (rvalIsStr) {
	        rvalFloat = lvalIsStr ? rval : 0;
	      }
	    }
	
	    return lvalFloat < rvalFloat ? this._resultLT : lvalFloat > rvalFloat ? -this._resultLT : 0;
	  };
	
	  return SortOrderComparator;
	}();
	
	exports.SortOrderComparator = SortOrderComparator;
	
	var FilterEqualityComparator = function () {
	  function FilterEqualityComparator(isEq, rval) {
	    this._rval = rval;
	    this._isEQ = isEq;
	    this._rvalTypeof = typeof rval;
	    this._rvalFloat = number_1.numericToNumber(rval);
	  }
	
	  FilterEqualityComparator.prototype.evaluate = function (lval) {
	    var eqResult = lval === this._rval;
	
	    if (!eqResult) {
	      var lvalTypeof = typeof lval;
	
	      if (lvalTypeof !== this._rvalTypeof && (lvalTypeof === 'number' || this._rvalTypeof === 'number')) {
	        eqResult = number_1.numericToNumber(lval) === this._rvalFloat;
	      }
	    }
	
	    return this._isEQ ? eqResult : !eqResult;
	  };
	
	  return FilterEqualityComparator;
	}();
	
	function createFilterComparator(op, rval) {
	  return op === 'eq' || op === 'ne' ? new FilterEqualityComparator(op === 'eq', rval) : util_1.hasOwn(ORDER_COMPARISON_OP_MAP, op) ? new FilterOrderComparator(op, rval) : null;
	}
	
	exports.createFilterComparator = createFilterComparator;

/***/ },
/* 90 */
/***/ function(module, exports, __webpack_require__) {

	
	/*
	* Licensed to the Apache Software Foundation (ASF) under one
	* or more contributor license agreements.  See the NOTICE file
	* distributed with this work for additional information
	* regarding copyright ownership.  The ASF licenses this file
	* to you under the Apache License, Version 2.0 (the
	* "License"); you may not use this file except in compliance
	* with the License.  You may obtain a copy of the License at
	*
	*   http://www.apache.org/licenses/LICENSE-2.0
	*
	* Unless required by applicable law or agreed to in writing,
	* software distributed under the License is distributed on an
	* "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
	* KIND, either express or implied.  See the License for the
	* specific language governing permissions and limitations
	* under the License.
	*/
	
	
	
	/**
	 * AUTO-GENERATED FILE. DO NOT MODIFY.
	 */
	
	"use strict";
	
	exports.__esModule = true;
	
	var Model_1 = __webpack_require__(24);
	
	var env_1 = __webpack_require__(13);
	
	var langEN_1 = __webpack_require__(349);
	
	var langZH_1 = __webpack_require__(350);
	
	var util_1 = __webpack_require__(1);
	
	var LOCALE_ZH = 'ZH';
	var LOCALE_EN = 'EN';
	var DEFAULT_LOCALE = LOCALE_EN;
	var localeStorage = {};
	var localeModels = {};
	exports.SYSTEM_LANG = !env_1["default"].domSupported ? DEFAULT_LOCALE : function () {
	  var langStr = (document.documentElement.lang || navigator.language || navigator.browserLanguage).toUpperCase();
	  return langStr.indexOf(LOCALE_ZH) > -1 ? LOCALE_ZH : DEFAULT_LOCALE;
	}();
	
	function registerLocale(locale, localeObj) {
	  locale = locale.toUpperCase();
	  localeModels[locale] = new Model_1["default"](localeObj);
	  localeStorage[locale] = localeObj;
	}
	
	exports.registerLocale = registerLocale;
	
	function createLocaleObject(locale) {
	  if (util_1.isString(locale)) {
	    var localeObj = localeStorage[locale.toUpperCase()] || {};
	
	    if (locale === LOCALE_ZH || locale === LOCALE_EN) {
	      return util_1.clone(localeObj);
	    } else {
	      return util_1.merge(util_1.clone(localeObj), util_1.clone(localeStorage[DEFAULT_LOCALE]), false);
	    }
	  } else {
	    return util_1.merge(util_1.clone(locale), util_1.clone(localeStorage[DEFAULT_LOCALE]), false);
	  }
	}
	
	exports.createLocaleObject = createLocaleObject;
	
	function getLocaleModel(lang) {
	  return localeModels[lang];
	}
	
	exports.getLocaleModel = getLocaleModel;
	
	function getDefaultLocaleModel() {
	  return localeModels[DEFAULT_LOCALE];
	}
	
	exports.getDefaultLocaleModel = getDefaultLocaleModel;
	registerLocale(LOCALE_EN, langEN_1["default"]);
	registerLocale(LOCALE_ZH, langZH_1["default"]);

/***/ },
/* 91 */
/***/ function(module, exports, __webpack_require__) {

	
	/*
	* Licensed to the Apache Software Foundation (ASF) under one
	* or more contributor license agreements.  See the NOTICE file
	* distributed with this work for additional information
	* regarding copyright ownership.  The ASF licenses this file
	* to you under the Apache License, Version 2.0 (the
	* "License"); you may not use this file except in compliance
	* with the License.  You may obtain a copy of the License at
	*
	*   http://www.apache.org/licenses/LICENSE-2.0
	*
	* Unless required by applicable law or agreed to in writing,
	* software distributed under the License is distributed on an
	* "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
	* KIND, either express or implied.  See the License for the
	* specific language governing permissions and limitations
	* under the License.
	*/
	
	
	
	/**
	 * AUTO-GENERATED FILE. DO NOT MODIFY.
	 */
	
	"use strict";
	
	exports.__esModule = true;
	
	var zrUtil = __webpack_require__(1);
	
	var dataProvider_1 = __webpack_require__(53);
	
	var format_1 = __webpack_require__(29);
	
	var log_1 = __webpack_require__(12);
	
	var DIMENSION_LABEL_REG = /\{@(.+?)\}/g;
	
	var DataFormatMixin = function () {
	  function DataFormatMixin() {}
	
	  DataFormatMixin.prototype.getDataParams = function (dataIndex, dataType) {
	    var data = this.getData(dataType);
	    var rawValue = this.getRawValue(dataIndex, dataType);
	    var rawDataIndex = data.getRawIndex(dataIndex);
	    var name = data.getName(dataIndex);
	    var itemOpt = data.getRawDataItem(dataIndex);
	    var style = data.getItemVisual(dataIndex, 'style');
	    var color = style && style[data.getItemVisual(dataIndex, 'drawType') || 'fill'];
	    var borderColor = style && style.stroke;
	    var mainType = this.mainType;
	    var isSeries = mainType === 'series';
	    var userOutput = data.userOutput;
	    return {
	      componentType: mainType,
	      componentSubType: this.subType,
	      componentIndex: this.componentIndex,
	      seriesType: isSeries ? this.subType : null,
	      seriesIndex: this.seriesIndex,
	      seriesId: isSeries ? this.id : null,
	      seriesName: isSeries ? this.name : null,
	      name: name,
	      dataIndex: rawDataIndex,
	      data: itemOpt,
	      dataType: dataType,
	      value: rawValue,
	      color: color,
	      borderColor: borderColor,
	      dimensionNames: userOutput ? userOutput.dimensionNames : null,
	      encode: userOutput ? userOutput.encode : null,
	      $vars: ['seriesName', 'name', 'value']
	    };
	  };
	
	  DataFormatMixin.prototype.getFormattedLabel = function (dataIndex, status, dataType, labelDimIndex, formatter, extendParams) {
	    status = status || 'normal';
	    var data = this.getData(dataType);
	    var params = this.getDataParams(dataIndex, dataType);
	
	    if (extendParams) {
	      zrUtil.extend(params, extendParams);
	    }
	
	    if (labelDimIndex != null && params.value instanceof Array) {
	      params.value = params.value[labelDimIndex];
	    }
	
	    if (!formatter) {
	      var itemModel = data.getItemModel(dataIndex);
	      formatter = itemModel.get(status === 'normal' ? ['label', 'formatter'] : [status, 'label', 'formatter']);
	    }
	
	    if (typeof formatter === 'function') {
	      params.status = status;
	      params.dimensionIndex = labelDimIndex;
	      return formatter(params);
	    } else if (typeof formatter === 'string') {
	      var str = format_1.formatTpl(formatter, params);
	      return str.replace(DIMENSION_LABEL_REG, function (origin, dim) {
	        var len = dim.length;
	
	        if (dim.charAt(0) === '[' && dim.charAt(len - 1) === ']') {
	          dim = +dim.slice(1, len - 1);
	        }
	
	        return dataProvider_1.retrieveRawValue(data, dataIndex, dim);
	      });
	    }
	  };
	
	  DataFormatMixin.prototype.getRawValue = function (idx, dataType) {
	    return dataProvider_1.retrieveRawValue(this.getData(dataType), idx);
	  };
	
	  DataFormatMixin.prototype.formatTooltip = function (dataIndex, multipleSeries, dataType) {
	    return;
	  };
	
	  return DataFormatMixin;
	}();
	
	exports.DataFormatMixin = DataFormatMixin;
	;
	
	function normalizeTooltipFormatResult(result) {
	  var markupText;
	  var markupFragment;
	
	  if (zrUtil.isObject(result)) {
	    if (result.type) {
	      markupFragment = result;
	    } else {
	      if (false) {
	        console.warn('The return type of `formatTooltip` is not supported: ' + log_1.makePrintable(result));
	      }
	    }
	  } else {
	    markupText = result;
	  }
	
	  return {
	    markupText: markupText,
	    markupFragment: markupFragment
	  };
	}
	
	exports.normalizeTooltipFormatResult = normalizeTooltipFormatResult;

/***/ },
/* 92 */
/***/ function(module, exports, __webpack_require__) {

	
	/*
	* Licensed to the Apache Software Foundation (ASF) under one
	* or more contributor license agreements.  See the NOTICE file
	* distributed with this work for additional information
	* regarding copyright ownership.  The ASF licenses this file
	* to you under the Apache License, Version 2.0 (the
	* "License"); you may not use this file except in compliance
	* with the License.  You may obtain a copy of the License at
	*
	*   http://www.apache.org/licenses/LICENSE-2.0
	*
	* Unless required by applicable law or agreed to in writing,
	* software distributed under the License is distributed on an
	* "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
	* KIND, either express or implied.  See the License for the
	* specific language governing permissions and limitations
	* under the License.
	*/
	
	
	
	/**
	 * AUTO-GENERATED FILE. DO NOT MODIFY.
	 */
	
	"use strict";
	
	exports.__esModule = true;
	
	var tslib_1 = __webpack_require__(3);
	
	var numberUtil = __webpack_require__(9);
	
	var formatUtil = __webpack_require__(29);
	
	var Scale_1 = __webpack_require__(55);
	
	var helper = __webpack_require__(70);
	
	var roundNumber = numberUtil.round;
	
	var IntervalScale = function (_super) {
	  tslib_1.__extends(IntervalScale, _super);
	
	  function IntervalScale() {
	    var _this = _super !== null && _super.apply(this, arguments) || this;
	
	    _this.type = 'interval';
	    _this._interval = 0;
	    _this._intervalPrecision = 2;
	    return _this;
	  }
	
	  IntervalScale.prototype.parse = function (val) {
	    return val;
	  };
	
	  IntervalScale.prototype.contain = function (val) {
	    return helper.contain(val, this._extent);
	  };
	
	  IntervalScale.prototype.normalize = function (val) {
	    return helper.normalize(val, this._extent);
	  };
	
	  IntervalScale.prototype.scale = function (val) {
	    return helper.scale(val, this._extent);
	  };
	
	  IntervalScale.prototype.setExtent = function (start, end) {
	    var thisExtent = this._extent;
	
	    if (!isNaN(start)) {
	      thisExtent[0] = parseFloat(start);
	    }
	
	    if (!isNaN(end)) {
	      thisExtent[1] = parseFloat(end);
	    }
	  };
	
	  IntervalScale.prototype.unionExtent = function (other) {
	    var extent = this._extent;
	    other[0] < extent[0] && (extent[0] = other[0]);
	    other[1] > extent[1] && (extent[1] = other[1]);
	    this.setExtent(extent[0], extent[1]);
	  };
	
	  IntervalScale.prototype.getInterval = function () {
	    return this._interval;
	  };
	
	  IntervalScale.prototype.setInterval = function (interval) {
	    this._interval = interval;
	    this._niceExtent = this._extent.slice();
	    this._intervalPrecision = helper.getIntervalPrecision(interval);
	  };
	
	  IntervalScale.prototype.getTicks = function (expandToNicedExtent) {
	    var interval = this._interval;
	    var extent = this._extent;
	    var niceTickExtent = this._niceExtent;
	    var intervalPrecision = this._intervalPrecision;
	    var ticks = [];
	
	    if (!interval) {
	      return ticks;
	    }
	
	    var safeLimit = 10000;
	
	    if (extent[0] < niceTickExtent[0]) {
	      if (expandToNicedExtent) {
	        ticks.push({
	          value: roundNumber(niceTickExtent[0] - interval, intervalPrecision)
	        });
	      } else {
	        ticks.push({
	          value: extent[0]
	        });
	      }
	    }
	
	    var tick = niceTickExtent[0];
	
	    while (tick <= niceTickExtent[1]) {
	      ticks.push({
	        value: tick
	      });
	      tick = roundNumber(tick + interval, intervalPrecision);
	
	      if (tick === ticks[ticks.length - 1].value) {
	        break;
	      }
	
	      if (ticks.length > safeLimit) {
	        return [];
	      }
	    }
	
	    var lastNiceTick = ticks.length ? ticks[ticks.length - 1].value : niceTickExtent[1];
	
	    if (extent[1] > lastNiceTick) {
	      if (expandToNicedExtent) {
	        ticks.push({
	          value: roundNumber(lastNiceTick + interval, intervalPrecision)
	        });
	      } else {
	        ticks.push({
	          value: extent[1]
	        });
	      }
	    }
	
	    return ticks;
	  };
	
	  IntervalScale.prototype.getMinorTicks = function (splitNumber) {
	    var ticks = this.getTicks(true);
	    var minorTicks = [];
	    var extent = this.getExtent();
	
	    for (var i = 1; i < ticks.length; i++) {
	      var nextTick = ticks[i];
	      var prevTick = ticks[i - 1];
	      var count = 0;
	      var minorTicksGroup = [];
	      var interval = nextTick.value - prevTick.value;
	      var minorInterval = interval / splitNumber;
	
	      while (count < splitNumber - 1) {
	        var minorTick = roundNumber(prevTick.value + (count + 1) * minorInterval);
	
	        if (minorTick > extent[0] && minorTick < extent[1]) {
	          minorTicksGroup.push(minorTick);
	        }
	
	        count++;
	      }
	
	      minorTicks.push(minorTicksGroup);
	    }
	
	    return minorTicks;
	  };
	
	  IntervalScale.prototype.getLabel = function (data, opt) {
	    if (data == null) {
	      return '';
	    }
	
	    var precision = opt && opt.precision;
	
	    if (precision == null) {
	      precision = numberUtil.getPrecisionSafe(data.value) || 0;
	    } else if (precision === 'auto') {
	      precision = this._intervalPrecision;
	    }
	
	    var dataNum = roundNumber(data.value, precision, true);
	    return formatUtil.addCommas(dataNum);
	  };
	
	  IntervalScale.prototype.niceTicks = function (splitNumber, minInterval, maxInterval) {
	    splitNumber = splitNumber || 5;
	    var extent = this._extent;
	    var span = extent[1] - extent[0];
	
	    if (!isFinite(span)) {
	      return;
	    }
	
	    if (span < 0) {
	      span = -span;
	      extent.reverse();
	    }
	
	    var result = helper.intervalScaleNiceTicks(extent, splitNumber, minInterval, maxInterval);
	    this._intervalPrecision = result.intervalPrecision;
	    this._interval = result.interval;
	    this._niceExtent = result.niceTickExtent;
	  };
	
	  IntervalScale.prototype.niceExtent = function (opt) {
	    var extent = this._extent;
	
	    if (extent[0] === extent[1]) {
	      if (extent[0] !== 0) {
	        var expandSize = extent[0];
	
	        if (!opt.fixMax) {
	          extent[1] += expandSize / 2;
	          extent[0] -= expandSize / 2;
	        } else {
	          extent[0] -= expandSize / 2;
	        }
	      } else {
	        extent[1] = 1;
	      }
	    }
	
	    var span = extent[1] - extent[0];
	
	    if (!isFinite(span)) {
	      extent[0] = 0;
	      extent[1] = 1;
	    }
	
	    this.niceTicks(opt.splitNumber, opt.minInterval, opt.maxInterval);
	    var interval = this._interval;
	
	    if (!opt.fixMin) {
	      extent[0] = roundNumber(Math.floor(extent[0] / interval) * interval);
	    }
	
	    if (!opt.fixMax) {
	      extent[1] = roundNumber(Math.ceil(extent[1] / interval) * interval);
	    }
	  };
	
	  IntervalScale.type = 'interval';
	  return IntervalScale;
	}(Scale_1["default"]);
	
	Scale_1["default"].registerClass(IntervalScale);
	exports["default"] = IntervalScale;

/***/ },
/* 93 */
/***/ function(module, exports, __webpack_require__) {

	
	/*
	* Licensed to the Apache Software Foundation (ASF) under one
	* or more contributor license agreements.  See the NOTICE file
	* distributed with this work for additional information
	* regarding copyright ownership.  The ASF licenses this file
	* to you under the Apache License, Version 2.0 (the
	* "License"); you may not use this file except in compliance
	* with the License.  You may obtain a copy of the License at
	*
	*   http://www.apache.org/licenses/LICENSE-2.0
	*
	* Unless required by applicable law or agreed to in writing,
	* software distributed under the License is distributed on an
	* "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
	* KIND, either express or implied.  See the License for the
	* specific language governing permissions and limitations
	* under the License.
	*/
	
	
	
	/**
	 * AUTO-GENERATED FILE. DO NOT MODIFY.
	 */
	
	"use strict";
	
	exports.__esModule = true;
	
	var util_1 = __webpack_require__(1);
	
	;
	
	function createTask(define) {
	  return new Task(define);
	}
	
	exports.createTask = createTask;
	
	var Task = function () {
	  function Task(define) {
	    define = define || {};
	    this._reset = define.reset;
	    this._plan = define.plan;
	    this._count = define.count;
	    this._onDirty = define.onDirty;
	    this._dirty = true;
	  }
	
	  Task.prototype.perform = function (performArgs) {
	    var upTask = this._upstream;
	    var skip = performArgs && performArgs.skip;
	
	    if (this._dirty && upTask) {
	      var context = this.context;
	      context.data = context.outputData = upTask.context.outputData;
	    }
	
	    if (this.__pipeline) {
	      this.__pipeline.currentTask = this;
	    }
	
	    var planResult;
	
	    if (this._plan && !skip) {
	      planResult = this._plan(this.context);
	    }
	
	    var lastModBy = normalizeModBy(this._modBy);
	    var lastModDataCount = this._modDataCount || 0;
	    var modBy = normalizeModBy(performArgs && performArgs.modBy);
	    var modDataCount = performArgs && performArgs.modDataCount || 0;
	
	    if (lastModBy !== modBy || lastModDataCount !== modDataCount) {
	      planResult = 'reset';
	    }
	
	    function normalizeModBy(val) {
	      !(val >= 1) && (val = 1);
	      return val;
	    }
	
	    var forceFirstProgress;
	
	    if (this._dirty || planResult === 'reset') {
	      this._dirty = false;
	      forceFirstProgress = this._doReset(skip);
	    }
	
	    this._modBy = modBy;
	    this._modDataCount = modDataCount;
	    var step = performArgs && performArgs.step;
	
	    if (upTask) {
	      if (false) {
	        util_1.assert(upTask._outputDueEnd != null);
	      }
	
	      this._dueEnd = upTask._outputDueEnd;
	    } else {
	      if (false) {
	        util_1.assert(!this._progress || this._count);
	      }
	
	      this._dueEnd = this._count ? this._count(this.context) : Infinity;
	    }
	
	    if (this._progress) {
	      var start = this._dueIndex;
	      var end = Math.min(step != null ? this._dueIndex + step : Infinity, this._dueEnd);
	
	      if (!skip && (forceFirstProgress || start < end)) {
	        var progress = this._progress;
	
	        if (util_1.isArray(progress)) {
	          for (var i = 0; i < progress.length; i++) {
	            this._doProgress(progress[i], start, end, modBy, modDataCount);
	          }
	        } else {
	          this._doProgress(progress, start, end, modBy, modDataCount);
	        }
	      }
	
	      this._dueIndex = end;
	      var outputDueEnd = this._settedOutputEnd != null ? this._settedOutputEnd : end;
	
	      if (false) {
	        util_1.assert(outputDueEnd >= this._outputDueEnd);
	      }
	
	      this._outputDueEnd = outputDueEnd;
	    } else {
	      this._dueIndex = this._outputDueEnd = this._settedOutputEnd != null ? this._settedOutputEnd : this._dueEnd;
	    }
	
	    return this.unfinished();
	  };
	
	  Task.prototype.dirty = function () {
	    this._dirty = true;
	    this._onDirty && this._onDirty(this.context);
	  };
	
	  Task.prototype._doProgress = function (progress, start, end, modBy, modDataCount) {
	    iterator.reset(start, end, modBy, modDataCount);
	    this._callingProgress = progress;
	
	    this._callingProgress({
	      start: start,
	      end: end,
	      count: end - start,
	      next: iterator.next
	    }, this.context);
	  };
	
	  Task.prototype._doReset = function (skip) {
	    this._dueIndex = this._outputDueEnd = this._dueEnd = 0;
	    this._settedOutputEnd = null;
	    var progress;
	    var forceFirstProgress;
	
	    if (!skip && this._reset) {
	      progress = this._reset(this.context);
	
	      if (progress && progress.progress) {
	        forceFirstProgress = progress.forceFirstProgress;
	        progress = progress.progress;
	      }
	
	      if (util_1.isArray(progress) && !progress.length) {
	        progress = null;
	      }
	    }
	
	    this._progress = progress;
	    this._modBy = this._modDataCount = null;
	    var downstream = this._downstream;
	    downstream && downstream.dirty();
	    return forceFirstProgress;
	  };
	
	  Task.prototype.unfinished = function () {
	    return this._progress && this._dueIndex < this._dueEnd;
	  };
	
	  Task.prototype.pipe = function (downTask) {
	    if (false) {
	      util_1.assert(downTask && !downTask._disposed && downTask !== this);
	    }
	
	    if (this._downstream !== downTask || this._dirty) {
	      this._downstream = downTask;
	      downTask._upstream = this;
	      downTask.dirty();
	    }
	  };
	
	  Task.prototype.dispose = function () {
	    if (this._disposed) {
	      return;
	    }
	
	    this._upstream && (this._upstream._downstream = null);
	    this._downstream && (this._downstream._upstream = null);
	    this._dirty = false;
	    this._disposed = true;
	  };
	
	  Task.prototype.getUpstream = function () {
	    return this._upstream;
	  };
	
	  Task.prototype.getDownstream = function () {
	    return this._downstream;
	  };
	
	  Task.prototype.setOutputEnd = function (end) {
	    this._outputDueEnd = this._settedOutputEnd = end;
	  };
	
	  return Task;
	}();
	
	exports.Task = Task;
	
	var iterator = function () {
	  var end;
	  var current;
	  var modBy;
	  var modDataCount;
	  var winCount;
	  var it = {
	    reset: function (s, e, sStep, sCount) {
	      current = s;
	      end = e;
	      modBy = sStep;
	      modDataCount = sCount;
	      winCount = Math.ceil(modDataCount / modBy);
	      it.next = modBy > 1 && modDataCount > 0 ? modNext : sequentialNext;
	    }
	  };
	  return it;
	
	  function sequentialNext() {
	    return current < end ? current++ : null;
	  }
	
	  function modNext() {
	    var dataIndex = current % winCount * modBy + Math.ceil(current / winCount);
	    var result = current >= end ? null : dataIndex < modDataCount ? dataIndex : current;
	    current++;
	    return result;
	  }
	}();

/***/ },
/* 94 */
/***/ function(module, exports, __webpack_require__) {

	
	/*
	* Licensed to the Apache Software Foundation (ASF) under one
	* or more contributor license agreements.  See the NOTICE file
	* distributed with this work for additional information
	* regarding copyright ownership.  The ASF licenses this file
	* to you under the Apache License, Version 2.0 (the
	* "License"); you may not use this file except in compliance
	* with the License.  You may obtain a copy of the License at
	*
	*   http://www.apache.org/licenses/LICENSE-2.0
	*
	* Unless required by applicable law or agreed to in writing,
	* software distributed under the License is distributed on an
	* "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
	* KIND, either express or implied.  See the License for the
	* specific language governing permissions and limitations
	* under the License.
	*/
	
	
	
	/**
	 * AUTO-GENERATED FILE. DO NOT MODIFY.
	 */
	
	"use strict";
	
	exports.__esModule = true;
	
	var zrUtil = __webpack_require__(1);
	
	var numberUtil = __webpack_require__(9);
	
	var locale_1 = __webpack_require__(90);
	
	var Model_1 = __webpack_require__(24);
	
	exports.ONE_SECOND = 1000;
	exports.ONE_MINUTE = exports.ONE_SECOND * 60;
	exports.ONE_HOUR = exports.ONE_MINUTE * 60;
	exports.ONE_DAY = exports.ONE_HOUR * 24;
	exports.ONE_YEAR = exports.ONE_DAY * 365;
	exports.defaultLeveledFormatter = {
	  year: '{yyyy}',
	  month: '{MMM}',
	  day: '{d}',
	  hour: '{HH}:{mm}',
	  minute: '{HH}:{mm}',
	  second: '{HH}:{mm}:{ss}',
	  millisecond: '{hh}:{mm}:{ss} {SSS}',
	  none: '{yyyy}-{MM}-{dd} {hh}:{mm}:{ss} {SSS}'
	};
	var fullDayFormatter = '{yyyy}-{MM}-{dd}';
	exports.fullLeveledFormatter = {
	  year: '{yyyy}',
	  month: '{yyyy}-{MM}',
	  day: fullDayFormatter,
	  hour: fullDayFormatter + ' ' + exports.defaultLeveledFormatter.hour,
	  minute: fullDayFormatter + ' ' + exports.defaultLeveledFormatter.minute,
	  second: fullDayFormatter + ' ' + exports.defaultLeveledFormatter.second,
	  millisecond: exports.defaultLeveledFormatter.none
	};
	exports.primaryTimeUnits = ['year', 'month', 'day', 'hour', 'minute', 'second', 'millisecond'];
	exports.timeUnits = ['year', 'half-year', 'quarter', 'month', 'week', 'half-week', 'day', 'half-day', 'quarter-day', 'hour', 'minute', 'second', 'millisecond'];
	
	function pad(str, len) {
	  str += '';
	  return '0000'.substr(0, len - str.length) + str;
	}
	
	exports.pad = pad;
	
	function getPrimaryTimeUnit(timeUnit) {
	  switch (timeUnit) {
	    case 'half-year':
	    case 'quarter':
	      return 'month';
	
	    case 'week':
	    case 'half-week':
	      return 'day';
	
	    case 'half-day':
	    case 'quarter-day':
	      return 'hour';
	
	    default:
	      return timeUnit;
	  }
	}
	
	exports.getPrimaryTimeUnit = getPrimaryTimeUnit;
	
	function isPrimaryTimeUnit(timeUnit) {
	  return timeUnit === getPrimaryTimeUnit(timeUnit);
	}
	
	exports.isPrimaryTimeUnit = isPrimaryTimeUnit;
	
	function getDefaultFormatPrecisionOfInterval(timeUnit) {
	  switch (timeUnit) {
	    case 'year':
	    case 'month':
	      return 'day';
	
	    case 'millisecond':
	      return 'millisecond';
	
	    default:
	      return 'second';
	  }
	}
	
	exports.getDefaultFormatPrecisionOfInterval = getDefaultFormatPrecisionOfInterval;
	
	function format(time, template, isUTC, lang) {
	  var date = numberUtil.parseDate(time);
	  var y = date[fullYearGetterName(isUTC)]();
	  var M = date[monthGetterName(isUTC)]() + 1;
	  var q = Math.floor((M - 1) / 4) + 1;
	  var d = date[dateGetterName(isUTC)]();
	  var e = date['get' + (isUTC ? 'UTC' : '') + 'Day']();
	  var H = date[hoursGetterName(isUTC)]();
	  var h = (H - 1) % 12 + 1;
	  var m = date[minutesGetterName(isUTC)]();
	  var s = date[secondsGetterName(isUTC)]();
	  var S = date[millisecondsGetterName(isUTC)]();
	  var localeModel = lang instanceof Model_1["default"] ? lang : locale_1.getLocaleModel(lang || locale_1.SYSTEM_LANG) || locale_1.getDefaultLocaleModel();
	  var timeModel = localeModel.getModel('time');
	  var month = timeModel.get('month');
	  var monthAbbr = timeModel.get('monthAbbr');
	  var dayOfWeek = timeModel.get('dayOfWeek');
	  var dayOfWeekAbbr = timeModel.get('dayOfWeekAbbr');
	  return (template || '').replace(/{yyyy}/g, y + '').replace(/{yy}/g, y % 100 + '').replace(/{Q}/g, q + '').replace(/{MMMM}/g, month[M - 1]).replace(/{MMM}/g, monthAbbr[M - 1]).replace(/{MM}/g, pad(M, 2)).replace(/{M}/g, M + '').replace(/{dd}/g, pad(d, 2)).replace(/{d}/g, d + '').replace(/{eeee}/g, dayOfWeek[e]).replace(/{ee}/g, dayOfWeekAbbr[e]).replace(/{e}/g, e + '').replace(/{HH}/g, pad(H, 2)).replace(/{H}/g, H + '').replace(/{hh}/g, pad(h + '', 2)).replace(/{h}/g, h + '').replace(/{mm}/g, pad(m, 2)).replace(/{m}/g, m + '').replace(/{ss}/g, pad(s, 2)).replace(/{s}/g, s + '').replace(/{SSS}/g, pad(S, 3)).replace(/{S}/g, S + '');
	}
	
	exports.format = format;
	
	function leveledFormat(tick, idx, formatter, lang, isUTC) {
	  var template = null;
	
	  if (typeof formatter === 'string') {
	    template = formatter;
	  } else if (typeof formatter === 'function') {
	    template = formatter(tick.value, idx, {
	      level: tick.level
	    });
	  } else {
	    var defaults = zrUtil.extend({}, exports.defaultLeveledFormatter);
	
	    if (tick.level > 0) {
	      for (var i = 0; i < exports.primaryTimeUnits.length; ++i) {
	        defaults[exports.primaryTimeUnits[i]] = "{primary|" + defaults[exports.primaryTimeUnits[i]] + "}";
	      }
	    }
	
	    var mergedFormatter = formatter ? formatter.inherit === false ? formatter : zrUtil.defaults(formatter, defaults) : defaults;
	    var unit = getUnitFromValue(tick.value, isUTC);
	
	    if (mergedFormatter[unit]) {
	      template = mergedFormatter[unit];
	    } else if (mergedFormatter.inherit) {
	      var targetId = exports.timeUnits.indexOf(unit);
	
	      for (var i = targetId - 1; i >= 0; --i) {
	        if (mergedFormatter[unit]) {
	          template = mergedFormatter[unit];
	          break;
	        }
	      }
	
	      template = template || defaults.none;
	    }
	
	    if (zrUtil.isArray(template)) {
	      var levelId = tick.level == null ? 0 : tick.level >= 0 ? tick.level : template.length + tick.level;
	      levelId = Math.min(levelId, template.length - 1);
	      template = template[levelId];
	    }
	  }
	
	  return format(new Date(tick.value), template, isUTC, lang);
	}
	
	exports.leveledFormat = leveledFormat;
	
	function getUnitFromValue(value, isUTC) {
	  var date = numberUtil.parseDate(value);
	  var M = date[monthGetterName(isUTC)]() + 1;
	  var d = date[dateGetterName(isUTC)]();
	  var h = date[hoursGetterName(isUTC)]();
	  var m = date[minutesGetterName(isUTC)]();
	  var s = date[secondsGetterName(isUTC)]();
	  var S = date[millisecondsGetterName(isUTC)]();
	  var isSecond = S === 0;
	  var isMinute = isSecond && s === 0;
	  var isHour = isMinute && m === 0;
	  var isDay = isHour && h === 0;
	  var isMonth = isDay && d === 1;
	  var isYear = isMonth && M === 1;
	
	  if (isYear) {
	    return 'year';
	  } else if (isMonth) {
	    return 'month';
	  } else if (isDay) {
	    return 'day';
	  } else if (isHour) {
	    return 'hour';
	  } else if (isMinute) {
	    return 'minute';
	  } else if (isSecond) {
	    return 'second';
	  } else {
	    return 'millisecond';
	  }
	}
	
	exports.getUnitFromValue = getUnitFromValue;
	
	function getUnitValue(value, unit, isUTC) {
	  var date = typeof value === 'number' ? numberUtil.parseDate(value) : value;
	  unit = unit || getUnitFromValue(value, isUTC);
	
	  switch (unit) {
	    case 'year':
	      return date[fullYearGetterName(isUTC)]();
	
	    case 'half-year':
	      return date[monthGetterName(isUTC)]() >= 6 ? 1 : 0;
	
	    case 'quarter':
	      return Math.floor((date[monthGetterName(isUTC)]() + 1) / 4);
	
	    case 'month':
	      return date[monthGetterName(isUTC)]();
	
	    case 'day':
	      return date[dateGetterName(isUTC)]();
	
	    case 'half-day':
	      return date[hoursGetterName(isUTC)]() / 24;
	
	    case 'hour':
	      return date[hoursGetterName(isUTC)]();
	
	    case 'minute':
	      return date[minutesGetterName(isUTC)]();
	
	    case 'second':
	      return date[secondsGetterName(isUTC)]();
	
	    case 'millisecond':
	      return date[millisecondsGetterName(isUTC)]();
	  }
	}
	
	exports.getUnitValue = getUnitValue;
	
	function fullYearGetterName(isUTC) {
	  return isUTC ? 'getUTCFullYear' : 'getFullYear';
	}
	
	exports.fullYearGetterName = fullYearGetterName;
	
	function monthGetterName(isUTC) {
	  return isUTC ? 'getUTCMonth' : 'getMonth';
	}
	
	exports.monthGetterName = monthGetterName;
	
	function dateGetterName(isUTC) {
	  return isUTC ? 'getUTCDate' : 'getDate';
	}
	
	exports.dateGetterName = dateGetterName;
	
	function hoursGetterName(isUTC) {
	  return isUTC ? 'getUTCHours' : 'getHours';
	}
	
	exports.hoursGetterName = hoursGetterName;
	
	function minutesGetterName(isUTC) {
	  return isUTC ? 'getUTCMinutes' : 'getMinutes';
	}
	
	exports.minutesGetterName = minutesGetterName;
	
	function secondsGetterName(isUTC) {
	  return isUTC ? 'getUTCSeconds' : 'getSeconds';
	}
	
	exports.secondsGetterName = secondsGetterName;
	
	function millisecondsGetterName(isUTC) {
	  return isUTC ? 'getUTCSeconds' : 'getSeconds';
	}
	
	exports.millisecondsGetterName = millisecondsGetterName;
	
	function fullYearSetterName(isUTC) {
	  return isUTC ? 'setUTCFullYear' : 'setFullYear';
	}
	
	exports.fullYearSetterName = fullYearSetterName;
	
	function monthSetterName(isUTC) {
	  return isUTC ? 'setUTCMonth' : 'setMonth';
	}
	
	exports.monthSetterName = monthSetterName;
	
	function dateSetterName(isUTC) {
	  return isUTC ? 'setUTCDate' : 'setDate';
	}
	
	exports.dateSetterName = dateSetterName;
	
	function hoursSetterName(isUTC) {
	  return isUTC ? 'setUTCHours' : 'setHours';
	}
	
	exports.hoursSetterName = hoursSetterName;
	
	function minutesSetterName(isUTC) {
	  return isUTC ? 'setUTCMinutes' : 'setMinutes';
	}
	
	exports.minutesSetterName = minutesSetterName;
	
	function secondsSetterName(isUTC) {
	  return isUTC ? 'setUTCSeconds' : 'setSeconds';
	}
	
	exports.secondsSetterName = secondsSetterName;
	
	function millisecondsSetterName(isUTC) {
	  return isUTC ? 'setUTCSeconds' : 'setSeconds';
	}
	
	exports.millisecondsSetterName = millisecondsSetterName;

/***/ },
/* 95 */
/***/ function(module, exports, __webpack_require__) {

	
	/*
	* Licensed to the Apache Software Foundation (ASF) under one
	* or more contributor license agreements.  See the NOTICE file
	* distributed with this work for additional information
	* regarding copyright ownership.  The ASF licenses this file
	* to you under the Apache License, Version 2.0 (the
	* "License"); you may not use this file except in compliance
	* with the License.  You may obtain a copy of the License at
	*
	*   http://www.apache.org/licenses/LICENSE-2.0
	*
	* Unless required by applicable law or agreed to in writing,
	* software distributed under the License is distributed on an
	* "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
	* KIND, either express or implied.  See the License for the
	* specific language governing permissions and limitations
	* under the License.
	*/
	
	
	
	/**
	 * AUTO-GENERATED FILE. DO NOT MODIFY.
	 */
	
	"use strict";
	
	exports.__esModule = true;
	
	var util_1 = __webpack_require__(1);
	
	var supportFloat32Array = typeof Float32Array !== 'undefined';
	var Float32ArrayCtor = !supportFloat32Array ? Array : Float32Array;
	
	function createFloat32Array(arg) {
	  if (util_1.isArray(arg)) {
	    return supportFloat32Array ? new Float32Array(arg) : arg;
	  }
	
	  return new Float32ArrayCtor(arg);
	}
	
	exports.createFloat32Array = createFloat32Array;

/***/ },
/* 96 */
/***/ function(module, exports, __webpack_require__) {

	
	/*
	* Licensed to the Apache Software Foundation (ASF) under one
	* or more contributor license agreements.  See the NOTICE file
	* distributed with this work for additional information
	* regarding copyright ownership.  The ASF licenses this file
	* to you under the Apache License, Version 2.0 (the
	* "License"); you may not use this file except in compliance
	* with the License.  You may obtain a copy of the License at
	*
	*   http://www.apache.org/licenses/LICENSE-2.0
	*
	* Unless required by applicable law or agreed to in writing,
	* software distributed under the License is distributed on an
	* "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
	* KIND, either express or implied.  See the License for the
	* specific language governing permissions and limitations
	* under the License.
	*/
	
	
	
	/**
	 * AUTO-GENERATED FILE. DO NOT MODIFY.
	 */
	
	"use strict";
	
	exports.__esModule = true;
	
	var util_1 = __webpack_require__(1);
	
	var Group_1 = __webpack_require__(51);
	
	var componentUtil = __webpack_require__(41);
	
	var clazzUtil = __webpack_require__(28);
	
	var modelUtil = __webpack_require__(4);
	
	var states_1 = __webpack_require__(22);
	
	var task_1 = __webpack_require__(93);
	
	var createRenderPlanner_1 = __webpack_require__(82);
	
	var inner = modelUtil.makeInner();
	var renderPlanner = createRenderPlanner_1["default"]();
	
	var ChartView = function () {
	  function ChartView() {
	    this.group = new Group_1["default"]();
	    this.uid = componentUtil.getUID('viewChart');
	    this.renderTask = task_1.createTask({
	      plan: renderTaskPlan,
	      reset: renderTaskReset
	    });
	    this.renderTask.context = {
	      view: this
	    };
	  }
	
	  ChartView.prototype.init = function (ecModel, api) {};
	
	  ChartView.prototype.render = function (seriesModel, ecModel, api, payload) {};
	
	  ChartView.prototype.highlight = function (seriesModel, ecModel, api, payload) {
	    toggleHighlight(seriesModel.getData(), payload, 'emphasis');
	  };
	
	  ChartView.prototype.downplay = function (seriesModel, ecModel, api, payload) {
	    toggleHighlight(seriesModel.getData(), payload, 'normal');
	  };
	
	  ChartView.prototype.remove = function (ecModel, api) {
	    this.group.removeAll();
	  };
	
	  ChartView.prototype.dispose = function (ecModel, api) {};
	
	  ChartView.prototype.updateView = function (seriesModel, ecModel, api, payload) {
	    this.render(seriesModel, ecModel, api, payload);
	  };
	
	  ChartView.prototype.updateLayout = function (seriesModel, ecModel, api, payload) {
	    this.render(seriesModel, ecModel, api, payload);
	  };
	
	  ChartView.prototype.updateVisual = function (seriesModel, ecModel, api, payload) {
	    this.render(seriesModel, ecModel, api, payload);
	  };
	
	  ChartView.markUpdateMethod = function (payload, methodName) {
	    inner(payload).updateMethod = methodName;
	  };
	
	  ChartView.protoInitialize = function () {
	    var proto = ChartView.prototype;
	    proto.type = 'chart';
	  }();
	
	  return ChartView;
	}();
	
	;
	
	function elSetState(el, state, highlightDigit) {
	  if (el) {
	    (state === 'emphasis' ? states_1.enterEmphasis : states_1.leaveEmphasis)(el, highlightDigit);
	  }
	}
	
	function toggleHighlight(data, payload, state) {
	  var dataIndex = modelUtil.queryDataIndex(data, payload);
	  var highlightDigit = payload && payload.highlightKey != null ? states_1.getHighlightDigit(payload.highlightKey) : null;
	
	  if (dataIndex != null) {
	    util_1.each(modelUtil.normalizeToArray(dataIndex), function (dataIdx) {
	      elSetState(data.getItemGraphicEl(dataIdx), state, highlightDigit);
	    });
	  } else {
	    data.eachItemGraphicEl(function (el) {
	      elSetState(el, state, highlightDigit);
	    });
	  }
	}
	
	clazzUtil.enableClassExtend(ChartView, ['dispose']);
	clazzUtil.enableClassManagement(ChartView, {
	  registerWhenExtend: true
	});
	
	function renderTaskPlan(context) {
	  return renderPlanner(context.model);
	}
	
	function renderTaskReset(context) {
	  var seriesModel = context.model;
	  var ecModel = context.ecModel;
	  var api = context.api;
	  var payload = context.payload;
	  var progressiveRender = seriesModel.pipelineContext.progressiveRender;
	  var view = context.view;
	  var updateMethod = payload && inner(payload).updateMethod;
	  var methodName = progressiveRender ? 'incrementalPrepareRender' : updateMethod && view[updateMethod] ? updateMethod : 'render';
	
	  if (methodName !== 'render') {
	    view[methodName](seriesModel, ecModel, api, payload);
	  }
	
	  return progressMethodMap[methodName];
	}
	
	var progressMethodMap = {
	  incrementalPrepareRender: {
	    progress: function (params, context) {
	      context.view.incrementalRender(params, context.model, context.ecModel, context.api, context.payload);
	    }
	  },
	  render: {
	    forceFirstProgress: true,
	    progress: function (params, context) {
	      context.view.render(context.model, context.ecModel, context.api, context.payload);
	    }
	  }
	};
	exports["default"] = ChartView;

/***/ },
/* 97 */
/***/ function(module, exports, __webpack_require__) {

	const parser = __webpack_require__(57);
	const Emitter = __webpack_require__(44);
	
	class Transport extends Emitter {
	  /**
	   * Transport abstract constructor.
	   *
	   * @param {Object} options.
	   * @api private
	   */
	  constructor(opts) {
	    super();
	
	    this.opts = opts;
	    this.query = opts.query;
	    this.readyState = "";
	    this.socket = opts.socket;
	  }
	
	  /**
	   * Emits an error.
	   *
	   * @param {String} str
	   * @return {Transport} for chaining
	   * @api public
	   */
	  onError(msg, desc) {
	    const err = new Error(msg);
	    err.type = "TransportError";
	    err.description = desc;
	    this.emit("error", err);
	    return this;
	  }
	
	  /**
	   * Opens the transport.
	   *
	   * @api public
	   */
	  open() {
	    if ("closed" === this.readyState || "" === this.readyState) {
	      this.readyState = "opening";
	      this.doOpen();
	    }
	
	    return this;
	  }
	
	  /**
	   * Closes the transport.
	   *
	   * @api private
	   */
	  close() {
	    if ("opening" === this.readyState || "open" === this.readyState) {
	      this.doClose();
	      this.onClose();
	    }
	
	    return this;
	  }
	
	  /**
	   * Sends multiple packets.
	   *
	   * @param {Array} packets
	   * @api private
	   */
	  send(packets) {
	    if ("open" === this.readyState) {
	      this.write(packets);
	    } else {
	      throw new Error("Transport not open");
	    }
	  }
	
	  /**
	   * Called upon open
	   *
	   * @api private
	   */
	  onOpen() {
	    this.readyState = "open";
	    this.writable = true;
	    this.emit("open");
	  }
	
	  /**
	   * Called with data.
	   *
	   * @param {String} data
	   * @api private
	   */
	  onData(data) {
	    const packet = parser.decodePacket(data, this.socket.binaryType);
	    this.onPacket(packet);
	  }
	
	  /**
	   * Called with a decoded packet.
	   */
	  onPacket(packet) {
	    this.emit("packet", packet);
	  }
	
	  /**
	   * Called upon close.
	   *
	   * @api private
	   */
	  onClose() {
	    this.readyState = "closed";
	    this.emit("close");
	  }
	}
	
	module.exports = Transport;


/***/ },
/* 98 */
/***/ function(module, exports) {

	/*
	object-assign
	(c) Sindre Sorhus
	@license MIT
	*/
	
	'use strict';
	/* eslint-disable no-unused-vars */
	var getOwnPropertySymbols = Object.getOwnPropertySymbols;
	var hasOwnProperty = Object.prototype.hasOwnProperty;
	var propIsEnumerable = Object.prototype.propertyIsEnumerable;
	
	function toObject(val) {
		if (val === null || val === undefined) {
			throw new TypeError('Object.assign cannot be called with null or undefined');
		}
	
		return Object(val);
	}
	
	function shouldUseNative() {
		try {
			if (!Object.assign) {
				return false;
			}
	
			// Detect buggy property enumeration order in older V8 versions.
	
			// https://bugs.chromium.org/p/v8/issues/detail?id=4118
			var test1 = new String('abc');  // eslint-disable-line no-new-wrappers
			test1[5] = 'de';
			if (Object.getOwnPropertyNames(test1)[0] === '5') {
				return false;
			}
	
			// https://bugs.chromium.org/p/v8/issues/detail?id=3056
			var test2 = {};
			for (var i = 0; i < 10; i++) {
				test2['_' + String.fromCharCode(i)] = i;
			}
			var order2 = Object.getOwnPropertyNames(test2).map(function (n) {
				return test2[n];
			});
			if (order2.join('') !== '0123456789') {
				return false;
			}
	
			// https://bugs.chromium.org/p/v8/issues/detail?id=3056
			var test3 = {};
			'abcdefghijklmnopqrst'.split('').forEach(function (letter) {
				test3[letter] = letter;
			});
			if (Object.keys(Object.assign({}, test3)).join('') !==
					'abcdefghijklmnopqrst') {
				return false;
			}
	
			return true;
		} catch (err) {
			// We don't expect any of the above to throw, but better to be safe.
			return false;
		}
	}
	
	module.exports = shouldUseNative() ? Object.assign : function (target, source) {
		var from;
		var to = toObject(target);
		var symbols;
	
		for (var s = 1; s < arguments.length; s++) {
			from = Object(arguments[s]);
	
			for (var key in from) {
				if (hasOwnProperty.call(from, key)) {
					to[key] = from[key];
				}
			}
	
			if (getOwnPropertySymbols) {
				symbols = getOwnPropertySymbols(from);
				for (var i = 0; i < symbols.length; i++) {
					if (propIsEnumerable.call(from, symbols[i])) {
						to[symbols[i]] = from[symbols[i]];
					}
				}
			}
		}
	
		return to;
	};


/***/ },
/* 99 */
/***/ function(module, exports) {

	/**
	 * Compiles a querystring
	 * Returns string representation of the object
	 *
	 * @param {Object}
	 * @api private
	 */
	
	exports.encode = function (obj) {
	  var str = '';
	
	  for (var i in obj) {
	    if (obj.hasOwnProperty(i)) {
	      if (str.length) str += '&';
	      str += encodeURIComponent(i) + '=' + encodeURIComponent(obj[i]);
	    }
	  }
	
	  return str;
	};
	
	/**
	 * Parses a simple querystring into an object
	 *
	 * @param {String} qs
	 * @api private
	 */
	
	exports.decode = function(qs){
	  var qry = {};
	  var pairs = qs.split('&');
	  for (var i = 0, l = pairs.length; i < l; i++) {
	    var pair = pairs[i].split('=');
	    qry[decodeURIComponent(pair[0])] = decodeURIComponent(pair[1]);
	  }
	  return qry;
	};


/***/ },
/* 100 */
/***/ function(module, exports) {

	// shim for using process in browser
	var process = module.exports = {};
	
	// cached from whatever global is present so that test runners that stub it
	// don't break things.  But we need to wrap it in a try catch in case it is
	// wrapped in strict mode code which doesn't define any globals.  It's inside a
	// function because try/catches deoptimize in certain engines.
	
	var cachedSetTimeout;
	var cachedClearTimeout;
	
	function defaultSetTimout() {
	    throw new Error('setTimeout has not been defined');
	}
	function defaultClearTimeout () {
	    throw new Error('clearTimeout has not been defined');
	}
	(function () {
	    try {
	        if (typeof setTimeout === 'function') {
	            cachedSetTimeout = setTimeout;
	        } else {
	            cachedSetTimeout = defaultSetTimout;
	        }
	    } catch (e) {
	        cachedSetTimeout = defaultSetTimout;
	    }
	    try {
	        if (typeof clearTimeout === 'function') {
	            cachedClearTimeout = clearTimeout;
	        } else {
	            cachedClearTimeout = defaultClearTimeout;
	        }
	    } catch (e) {
	        cachedClearTimeout = defaultClearTimeout;
	    }
	} ())
	function runTimeout(fun) {
	    if (cachedSetTimeout === setTimeout) {
	        //normal enviroments in sane situations
	        return setTimeout(fun, 0);
	    }
	    // if setTimeout wasn't available but was latter defined
	    if ((cachedSetTimeout === defaultSetTimout || !cachedSetTimeout) && setTimeout) {
	        cachedSetTimeout = setTimeout;
	        return setTimeout(fun, 0);
	    }
	    try {
	        // when when somebody has screwed with setTimeout but no I.E. maddness
	        return cachedSetTimeout(fun, 0);
	    } catch(e){
	        try {
	            // When we are in I.E. but the script has been evaled so I.E. doesn't trust the global object when called normally
	            return cachedSetTimeout.call(null, fun, 0);
	        } catch(e){
	            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error
	            return cachedSetTimeout.call(this, fun, 0);
	        }
	    }
	
	
	}
	function runClearTimeout(marker) {
	    if (cachedClearTimeout === clearTimeout) {
	        //normal enviroments in sane situations
	        return clearTimeout(marker);
	    }
	    // if clearTimeout wasn't available but was latter defined
	    if ((cachedClearTimeout === defaultClearTimeout || !cachedClearTimeout) && clearTimeout) {
	        cachedClearTimeout = clearTimeout;
	        return clearTimeout(marker);
	    }
	    try {
	        // when when somebody has screwed with setTimeout but no I.E. maddness
	        return cachedClearTimeout(marker);
	    } catch (e){
	        try {
	            // When we are in I.E. but the script has been evaled so I.E. doesn't  trust the global object when called normally
	            return cachedClearTimeout.call(null, marker);
	        } catch (e){
	            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error.
	            // Some versions of I.E. have different rules for clearTimeout vs setTimeout
	            return cachedClearTimeout.call(this, marker);
	        }
	    }
	
	
	
	}
	var queue = [];
	var draining = false;
	var currentQueue;
	var queueIndex = -1;
	
	function cleanUpNextTick() {
	    if (!draining || !currentQueue) {
	        return;
	    }
	    draining = false;
	    if (currentQueue.length) {
	        queue = currentQueue.concat(queue);
	    } else {
	        queueIndex = -1;
	    }
	    if (queue.length) {
	        drainQueue();
	    }
	}
	
	function drainQueue() {
	    if (draining) {
	        return;
	    }
	    var timeout = runTimeout(cleanUpNextTick);
	    draining = true;
	
	    var len = queue.length;
	    while(len) {
	        currentQueue = queue;
	        queue = [];
	        while (++queueIndex < len) {
	            if (currentQueue) {
	                currentQueue[queueIndex].run();
	            }
	        }
	        queueIndex = -1;
	        len = queue.length;
	    }
	    currentQueue = null;
	    draining = false;
	    runClearTimeout(timeout);
	}
	
	process.nextTick = function (fun) {
	    var args = new Array(arguments.length - 1);
	    if (arguments.length > 1) {
	        for (var i = 1; i < arguments.length; i++) {
	            args[i - 1] = arguments[i];
	        }
	    }
	    queue.push(new Item(fun, args));
	    if (queue.length === 1 && !draining) {
	        runTimeout(drainQueue);
	    }
	};
	
	// v8 likes predictible objects
	function Item(fun, array) {
	    this.fun = fun;
	    this.array = array;
	}
	Item.prototype.run = function () {
	    this.fun.apply(null, this.array);
	};
	process.title = 'browser';
	process.browser = true;
	process.env = {};
	process.argv = [];
	process.version = ''; // empty string to avoid regexp issues
	process.versions = {};
	
	function noop() {}
	
	process.on = noop;
	process.addListener = noop;
	process.once = noop;
	process.off = noop;
	process.removeListener = noop;
	process.removeAllListeners = noop;
	process.emit = noop;
	process.prependListener = noop;
	process.prependOnceListener = noop;
	
	process.listeners = function (name) { return [] }
	
	process.binding = function (name) {
	    throw new Error('process.binding is not supported');
	};
	
	process.cwd = function () { return '/' };
	process.chdir = function (dir) {
	    throw new Error('process.chdir is not supported');
	};
	process.umask = function() { return 0; };


/***/ },
/* 101 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	
	exports.__esModule = true;
	exports.deepMap = deepMap;
	exports.deepForEach = deepForEach;
	
	var _react = __webpack_require__(2);
	
	var _elementTypes = __webpack_require__(73);
	
	function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }
	
	function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }
	
	function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }
	
	function isTabChild(child) {
	  return (0, _elementTypes.isTab)(child) || (0, _elementTypes.isTabList)(child) || (0, _elementTypes.isTabPanel)(child);
	}
	
	function deepMap(children, callback) {
	  return _react.Children.map(children, function (child) {
	    // null happens when conditionally rendering TabPanel/Tab
	    // see https://github.com/reactjs/react-tabs/issues/37
	    if (child === null) return null;
	
	    if (isTabChild(child)) {
	      return callback(child);
	    }
	
	    if (child.props && child.props.children && typeof child.props.children === 'object') {
	      // Clone the child that has children and map them too
	      return (0, _react.cloneElement)(child, _objectSpread({}, child.props, {
	        children: deepMap(child.props.children, callback)
	      }));
	    }
	
	    return child;
	  });
	}
	
	function deepForEach(children, callback) {
	  return _react.Children.forEach(children, function (child) {
	    // null happens when conditionally rendering TabPanel/Tab
	    // see https://github.com/reactjs/react-tabs/issues/37
	    if (child === null) return;
	
	    if ((0, _elementTypes.isTab)(child) || (0, _elementTypes.isTabPanel)(child)) {
	      callback(child);
	    } else if (child.props && child.props.children && typeof child.props.children === 'object') {
	      if ((0, _elementTypes.isTabList)(child)) callback(child);
	      deepForEach(child.props.children, callback);
	    }
	  });
	}

/***/ },
/* 102 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	Object.defineProperty(exports, "__esModule", { value: true });
	exports.Decoder = exports.Encoder = exports.PacketType = exports.protocol = void 0;
	const Emitter = __webpack_require__(44);
	const binary_1 = __webpack_require__(429);
	const is_binary_1 = __webpack_require__(172);
	const debug = __webpack_require__(430)("socket.io-parser");
	/**
	 * Protocol version.
	 *
	 * @public
	 */
	exports.protocol = 5;
	var PacketType;
	(function (PacketType) {
	    PacketType[PacketType["CONNECT"] = 0] = "CONNECT";
	    PacketType[PacketType["DISCONNECT"] = 1] = "DISCONNECT";
	    PacketType[PacketType["EVENT"] = 2] = "EVENT";
	    PacketType[PacketType["ACK"] = 3] = "ACK";
	    PacketType[PacketType["CONNECT_ERROR"] = 4] = "CONNECT_ERROR";
	    PacketType[PacketType["BINARY_EVENT"] = 5] = "BINARY_EVENT";
	    PacketType[PacketType["BINARY_ACK"] = 6] = "BINARY_ACK";
	})(PacketType = exports.PacketType || (exports.PacketType = {}));
	/**
	 * A socket.io Encoder instance
	 */
	class Encoder {
	    /**
	     * Encode a packet as a single string if non-binary, or as a
	     * buffer sequence, depending on packet type.
	     *
	     * @param {Object} obj - packet object
	     */
	    encode(obj) {
	        debug("encoding packet %j", obj);
	        if (obj.type === PacketType.EVENT || obj.type === PacketType.ACK) {
	            if (is_binary_1.hasBinary(obj)) {
	                obj.type =
	                    obj.type === PacketType.EVENT
	                        ? PacketType.BINARY_EVENT
	                        : PacketType.BINARY_ACK;
	                return this.encodeAsBinary(obj);
	            }
	        }
	        return [this.encodeAsString(obj)];
	    }
	    /**
	     * Encode packet as string.
	     */
	    encodeAsString(obj) {
	        // first is type
	        let str = "" + obj.type;
	        // attachments if we have them
	        if (obj.type === PacketType.BINARY_EVENT ||
	            obj.type === PacketType.BINARY_ACK) {
	            str += obj.attachments + "-";
	        }
	        // if we have a namespace other than `/`
	        // we append it followed by a comma `,`
	        if (obj.nsp && "/" !== obj.nsp) {
	            str += obj.nsp + ",";
	        }
	        // immediately followed by the id
	        if (null != obj.id) {
	            str += obj.id;
	        }
	        // json data
	        if (null != obj.data) {
	            str += JSON.stringify(obj.data);
	        }
	        debug("encoded %j as %s", obj, str);
	        return str;
	    }
	    /**
	     * Encode packet as 'buffer sequence' by removing blobs, and
	     * deconstructing packet into object with placeholders and
	     * a list of buffers.
	     */
	    encodeAsBinary(obj) {
	        const deconstruction = binary_1.deconstructPacket(obj);
	        const pack = this.encodeAsString(deconstruction.packet);
	        const buffers = deconstruction.buffers;
	        buffers.unshift(pack); // add packet info to beginning of data list
	        return buffers; // write all the buffers
	    }
	}
	exports.Encoder = Encoder;
	/**
	 * A socket.io Decoder instance
	 *
	 * @return {Object} decoder
	 */
	class Decoder extends Emitter {
	    constructor() {
	        super();
	    }
	    /**
	     * Decodes an encoded packet string into packet JSON.
	     *
	     * @param {String} obj - encoded packet
	     */
	    add(obj) {
	        let packet;
	        if (typeof obj === "string") {
	            packet = this.decodeString(obj);
	            if (packet.type === PacketType.BINARY_EVENT ||
	                packet.type === PacketType.BINARY_ACK) {
	                // binary packet's json
	                this.reconstructor = new BinaryReconstructor(packet);
	                // no attachments, labeled binary but no binary data to follow
	                if (packet.attachments === 0) {
	                    super.emit("decoded", packet);
	                }
	            }
	            else {
	                // non-binary full packet
	                super.emit("decoded", packet);
	            }
	        }
	        else if (is_binary_1.isBinary(obj) || obj.base64) {
	            // raw binary data
	            if (!this.reconstructor) {
	                throw new Error("got binary data when not reconstructing a packet");
	            }
	            else {
	                packet = this.reconstructor.takeBinaryData(obj);
	                if (packet) {
	                    // received final buffer
	                    this.reconstructor = null;
	                    super.emit("decoded", packet);
	                }
	            }
	        }
	        else {
	            throw new Error("Unknown type: " + obj);
	        }
	    }
	    /**
	     * Decode a packet String (JSON data)
	     *
	     * @param {String} str
	     * @return {Object} packet
	     */
	    decodeString(str) {
	        let i = 0;
	        // look up type
	        const p = {
	            type: Number(str.charAt(0)),
	        };
	        if (PacketType[p.type] === undefined) {
	            throw new Error("unknown packet type " + p.type);
	        }
	        // look up attachments if type binary
	        if (p.type === PacketType.BINARY_EVENT ||
	            p.type === PacketType.BINARY_ACK) {
	            const start = i + 1;
	            while (str.charAt(++i) !== "-" && i != str.length) { }
	            const buf = str.substring(start, i);
	            if (buf != Number(buf) || str.charAt(i) !== "-") {
	                throw new Error("Illegal attachments");
	            }
	            p.attachments = Number(buf);
	        }
	        // look up namespace (if any)
	        if ("/" === str.charAt(i + 1)) {
	            const start = i + 1;
	            while (++i) {
	                const c = str.charAt(i);
	                if ("," === c)
	                    break;
	                if (i === str.length)
	                    break;
	            }
	            p.nsp = str.substring(start, i);
	        }
	        else {
	            p.nsp = "/";
	        }
	        // look up id
	        const next = str.charAt(i + 1);
	        if ("" !== next && Number(next) == next) {
	            const start = i + 1;
	            while (++i) {
	                const c = str.charAt(i);
	                if (null == c || Number(c) != c) {
	                    --i;
	                    break;
	                }
	                if (i === str.length)
	                    break;
	            }
	            p.id = Number(str.substring(start, i + 1));
	        }
	        // look up json data
	        if (str.charAt(++i)) {
	            const payload = tryParse(str.substr(i));
	            if (Decoder.isPayloadValid(p.type, payload)) {
	                p.data = payload;
	            }
	            else {
	                throw new Error("invalid payload");
	            }
	        }
	        debug("decoded %s as %j", str, p);
	        return p;
	    }
	    static isPayloadValid(type, payload) {
	        switch (type) {
	            case PacketType.CONNECT:
	                return typeof payload === "object";
	            case PacketType.DISCONNECT:
	                return payload === undefined;
	            case PacketType.CONNECT_ERROR:
	                return typeof payload === "string" || typeof payload === "object";
	            case PacketType.EVENT:
	            case PacketType.BINARY_EVENT:
	                return Array.isArray(payload) && payload.length > 0;
	            case PacketType.ACK:
	            case PacketType.BINARY_ACK:
	                return Array.isArray(payload);
	        }
	    }
	    /**
	     * Deallocates a parser's resources
	     */
	    destroy() {
	        if (this.reconstructor) {
	            this.reconstructor.finishedReconstruction();
	        }
	    }
	}
	exports.Decoder = Decoder;
	function tryParse(str) {
	    try {
	        return JSON.parse(str);
	    }
	    catch (e) {
	        return false;
	    }
	}
	/**
	 * A manager of a binary event's 'buffer sequence'. Should
	 * be constructed whenever a packet of type BINARY_EVENT is
	 * decoded.
	 *
	 * @param {Object} packet
	 * @return {BinaryReconstructor} initialized reconstructor
	 */
	class BinaryReconstructor {
	    constructor(packet) {
	        this.packet = packet;
	        this.buffers = [];
	        this.reconPack = packet;
	    }
	    /**
	     * Method to be called when binary data received from connection
	     * after a BINARY_EVENT packet.
	     *
	     * @param {Buffer | ArrayBuffer} binData - the raw binary data received
	     * @return {null | Object} returns null if more binary data is expected or
	     *   a reconstructed packet object if all buffers have been received.
	     */
	    takeBinaryData(binData) {
	        this.buffers.push(binData);
	        if (this.buffers.length === this.reconPack.attachments) {
	            // done with buffer list
	            const packet = binary_1.reconstructPacket(this.reconPack, this.buffers);
	            this.finishedReconstruction();
	            return packet;
	        }
	        return null;
	    }
	    /**
	     * Cleans up binary packet reconstruction variables.
	     */
	    finishedReconstruction() {
	        this.reconPack = null;
	        this.buffers = [];
	    }
	}


/***/ },
/* 103 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", { value: true });
	var isProduction = ("production") === 'production';
	var prefix = 'Invariant failed';
	function invariant(condition, message) {
	    if (condition) {
	        return;
	    }
	    if (isProduction) {
	        throw new Error(prefix);
	    }
	    throw new Error(prefix + ": " + (message || ''));
	}
	exports.default = invariant;


/***/ },
/* 104 */
/***/ function(module, exports, __webpack_require__) {

	module.exports = __webpack_require__.p + "static/media/blood_pressure.4814624f.png";

/***/ },
/* 105 */
/***/ function(module, exports, __webpack_require__) {

	module.exports = __webpack_require__.p + "static/media/heart_rate.fc1fda17.png";

/***/ },
/* 106 */
/***/ function(module, exports) {

	module.exports = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAASwAAAEsCAYAAAB5fY51AAAACXBIWXMAAUh+AAFIfgEXiq7wAAAFIGlUWHRYTUw6Y29tLmFkb2JlLnhtcAAAAAAAPD94cGFja2V0IGJlZ2luPSLvu78iIGlkPSJXNU0wTXBDZWhpSHpyZVN6TlRjemtjOWQiPz4gPHg6eG1wbWV0YSB4bWxuczp4PSJhZG9iZTpuczptZXRhLyIgeDp4bXB0az0iQWRvYmUgWE1QIENvcmUgNS42LWMxNDUgNzkuMTYzNDk5LCAyMDE4LzA4LzEzLTE2OjQwOjIyICAgICAgICAiPiA8cmRmOlJERiB4bWxuczpyZGY9Imh0dHA6Ly93d3cudzMub3JnLzE5OTkvMDIvMjItcmRmLXN5bnRheC1ucyMiPiA8cmRmOkRlc2NyaXB0aW9uIHJkZjphYm91dD0iIiB4bWxuczp4bXA9Imh0dHA6Ly9ucy5hZG9iZS5jb20veGFwLzEuMC8iIHhtbG5zOmRjPSJodHRwOi8vcHVybC5vcmcvZGMvZWxlbWVudHMvMS4xLyIgeG1sbnM6cGhvdG9zaG9wPSJodHRwOi8vbnMuYWRvYmUuY29tL3Bob3Rvc2hvcC8xLjAvIiB4bWxuczp4bXBNTT0iaHR0cDovL25zLmFkb2JlLmNvbS94YXAvMS4wL21tLyIgeG1sbnM6c3RFdnQ9Imh0dHA6Ly9ucy5hZG9iZS5jb20veGFwLzEuMC9zVHlwZS9SZXNvdXJjZUV2ZW50IyIgeG1wOkNyZWF0b3JUb29sPSJBZG9iZSBQaG90b3Nob3AgQ0MgMjAxOSAoTWFjaW50b3NoKSIgeG1wOkNyZWF0ZURhdGU9IjIwMjAtMTItMjdUMjI6MjM6NDErMDE6MDAiIHhtcDpNb2RpZnlEYXRlPSIyMDIxLTAxLTIxVDAyOjE0OjA0KzAxOjAwIiB4bXA6TWV0YWRhdGFEYXRlPSIyMDIxLTAxLTIxVDAyOjE0OjA0KzAxOjAwIiBkYzpmb3JtYXQ9ImltYWdlL3BuZyIgcGhvdG9zaG9wOkNvbG9yTW9kZT0iMyIgcGhvdG9zaG9wOklDQ1Byb2ZpbGU9InNSR0IgSUVDNjE5NjYtMi4xIiB4bXBNTTpJbnN0YW5jZUlEPSJ4bXAuaWlkOjY5MjNjY2RiLTQ3OWMtNDQ1Ni1iMzExLThlODI5YzJkYzI0NCIgeG1wTU06RG9jdW1lbnRJRD0ieG1wLmRpZDo2OTIzY2NkYi00NzljLTQ0NTYtYjMxMS04ZTgyOWMyZGMyNDQiIHhtcE1NOk9yaWdpbmFsRG9jdW1lbnRJRD0ieG1wLmRpZDo2OTIzY2NkYi00NzljLTQ0NTYtYjMxMS04ZTgyOWMyZGMyNDQiPiA8eG1wTU06SGlzdG9yeT4gPHJkZjpTZXE+IDxyZGY6bGkgc3RFdnQ6YWN0aW9uPSJjcmVhdGVkIiBzdEV2dDppbnN0YW5jZUlEPSJ4bXAuaWlkOjY5MjNjY2RiLTQ3OWMtNDQ1Ni1iMzExLThlODI5YzJkYzI0NCIgc3RFdnQ6d2hlbj0iMjAyMC0xMi0yN1QyMjoyMzo0MSswMTowMCIgc3RFdnQ6c29mdHdhcmVBZ2VudD0iQWRvYmUgUGhvdG9zaG9wIENDIDIwMTkgKE1hY2ludG9zaCkiLz4gPC9yZGY6U2VxPiA8L3htcE1NOkhpc3Rvcnk+IDwvcmRmOkRlc2NyaXB0aW9uPiA8L3JkZjpSREY+IDwveDp4bXBtZXRhPiA8P3hwYWNrZXQgZW5kPSJyIj8+S4PnqwAAG39JREFUeJzt3XlUU2feB/CbEJIgAi4FRJAlCFi0DJZVoKKWt3oQNWqZdloZpa1iB6G16qnjVHscsdqxy3G0i1rceK3VkSpSFeteQQHFhUWxQBTaogaRomVH8v7x1jk2JDfbvXnykO/nnO8/9/rc/JLbfJtcQhCoVCoGwFQ7d+4cf+LEiZMXL15kbt26xbS3tzODBw9mAgICmKioKGbixIl+EyZMqCY9J9BNgMICY9y8eVN48ODBGYcOHZpaWlo6urGxcXB3d7ebtn8vlUrrhg0b9lNUVNTZadOmfTt9+vQL5pwX+gYUFhiksLDQbf369YtzcnJebGtr8zTyMA3e3t6K5OTkLStWrMjkdEDo01BYoLe//vWvH2ZlZSUzDOPM0SEbXF1d7y5btuz99PT0bzk6JvRhKCzQaefOneMXLlz4+f379wcz3JXVkxrGjh17asuWLUn+/v6dPBwf+ggUFrBKT09fumHDhncYforqDwYOHPjjjh07XpoyZcoVvm8L6ITCAq1efPHFjdnZ2X9mzFBWT2jYunXrrOTk5O/NeJtACRQWaDRjxozP9+/f/yJj3rJ6rCErKytx1qxZZwjcNlgwFBb0kpqa+t7nn3+ezhhQVsOGDbsVGhqaP3LkyCtubm51Uqm07bfffnOsra0dXlZWFlJSUjLm/v37eh9PKBTePXnyZFRsbKzCqDsBfZNKpUKQ/2bHjh3jGYZRMgyj0idyuTzr0KFDwfoce/v27fGRkZGn9D22q6trGenHA7GsEB8Asaz079+/Rp8yCQsLO3vmzBmZMbeRlZX1P25ubj/pcTtKuVz+OenHBLGcEB8AsZzMmDFjoz6vrlJTU1dzcXsTJkzI1ae0cnNzg0g/NohlhPgAiGWkoKDAXZ+yev/999O5vN1p06bt0nWbgYGBJ0k/PohlhPgAiGUkPj7+K3O9slLPmDFjdF3XUu7bty+C9GOEkA9+SghMVVWVeMSIEXU9PT2u2v5NSEjI+YsXL0bxNcOAAQOampubB2jbHxsbu/f06dMv8XX7QAch6QGAvN27dyexlZVAIGA2bdo0nc8ZMjIy5rPtP3v2bGx1dbWIzxnA8qGwgMnNzZWz7Z85c+b2kJCQu3zOsGDBgj0ymeyGtv09PT2uhw8fnsrnDGD5UFjAlJWVjWbbn56evsocc8ybN+9jtv0nT558wRxzgOVCYVm5vLy8wI6ODrG2/TKZ7MZzzz1nlk+bz5gxY6eNjU2Ptv2lpaXB5pgDLBcKy8pVVlYGMiy/ghMTE3PMXLP4+fl1+Pn5lWvbX19f72GuWcAyobCsXF1dnTfb/qCgoBIzjcIwDMMEBgZe0bavo6NDXFJSQuKXscFCoLCsXFNT02C2/e7u7rfMNMrj26tj2e3c3NzsZLZhwOKgsKxcZ2cn60cF+vXr12KuWRiGYezt7X9j29/Z2an1ehv0fSgsYCUUCrVeBCdxeyqVCv/NWjGcfGBl7oLAb14AGxQWAFADhQUA1EBhAQA1UFgAQA0UFgBQA4UFANRAYQEANVBYAEANFBYAUAOFBQDUQGEBADVQWABADRQWAFADhQUA1EBhAQA1UFgAQA0UFgBQA4UFANRAYQEANVBYAEANFBYAUAOFBQDUQGEBADVQWABADRQWAFADhQUA1EBhAQA1UFgAQA0UFgBQA4UFANRAYQEANVBYAEANFBYAUAOFBQDUQGEBADVQWABADRQWUEUikbSTngHIEZEeAMAQtbW1MoVCoTBmrUwm6+F6HjAvFBZQZe7cuUeNXHo3MzPz1dmzZ5/gdCAwKxQWUOXRo0fGLnXt6emx4XIWMD9cwwKrIRAIjG47sAwoLACgBgoLrEZ7e7sd6RnANLiGBVSRy+VfeHt73zJ0nUqlYp599tkLPIwEZoTCAqosWbJkdVRU1C+k5wAy8JYQqNLc3DyQ9AxADgoLAKiBwgIAaqCwAIAaKCwAoAYKCwCogcICAGqgsACAGigsAKAGCgsAqIHCAgBqoLAAgBooLACgBgoLAKiBwgIAaqCwAIAaKCwAoAYKCwCogcICAGqgsACAGigsAKAGCgsAqIHCAgBqoLAAgBooLACgBgoLAKiBwgIAaqCwAIAaKCwAoAYKCwCogcICAGqgsACAGigsoIpAIOghPQOQg8ICqtjZ2bWTngHIEZEeAMAQS5YsWe/i4nLX0HU9PT3Cd955Z21cXNyPfMwF5oHCAqpcuHAhwdi1crl8H8MwKCyK4S0hWA2xWNxBegYwDQoLAKiBwgKr8ejRI1vSM4BpcA0LqDJo0KBKiUTSaeg6lUrFODg4NPMxE5gPCguokpmZOUsul5eQngPIwFtCoIq9vX0L6RmAHBQWUKW7uxvvCqwYCgsAqIHCAgBqoLAAgBooLACgBgoLAKiBwgIAaqCwAIAaKCwAoAYKCwCogcICAGqgsACAGigsAKAGCgsAqIHCAgBqoLAAgBooLACgBgoLAKiBwgIAaqCwAIAaKCwAoAa+0B+McvXq1UGmrBeLxR1PP/00/gIOGASFBQarqKhwDA4ObjTlGJ6enora2lpfrmYC64C3hGAwgUDwiINjcDEKWBkUFhAhFApNLj2wPigsAKAGCgsAqIHCAgBqoLAAgBooLACgBgoLAKiBwgIAaqCwgCoODg4PSM8A5OBXc4AqR44cmXLnzp2LKpXK4P/ZJiYmnudjJjAfFBZQ5YMPPtho5NKGTZs2zZk3b95hTgcCs8JbQrAWzmKxuIP0EGAaFBYAUAOFBQDUQGGB1ejo6LAjPQOYBhfdgSpLly59Kzg4uMSYteHh4fgpIeVQWECVyZMnH4iJiakjPQeQgbeEQJWHDx86kp4ByEFhAQA1UFgAQA0UFgBQA4UFANRAYQEANVBYAEANFBYAUAOFBQDUQGEBADVQWABADRQWAFADhQUA1EBhAQA1UFgAQA0UFgBQA4UFANRAYQEANVBYAEANFBYAUAOFBQDUQGEBADVQWABADRQWAFADhQUA1EBhAQA1UFgAQA0UFgBQA4UFANRAYQEANVBYAEANFBYAUAOFBVQRiUTdpGcAclBYQJXW1lZ70jMAOSLSAwAY4o033tiZlpbWplKpDF77ySefpCUmJp7nYSwwExQWUOXevXuBxq598OCBE5ezgPnhLSFYDRsbmy7SM4BpUFgAQA0UFliNzs5OCekZwDS4hgVUCQ0N/c7FxeWuSqUy+H+2Mpmsmo+ZwHxQWECVjz766K3Y2FgF6TmADLwlBKq0tbVJSc8A5KCwgCrGvBWEvgMnHwCogcICAGqgsACAGigsAKAGCgsAqIHCAgBqoLAAgBooLACgBgoLAKiBwgIAaqCwAIAaKCwAoAYKCwCogcICAGqgsACAGigsAKAGCgsAqIHCAgBqoLAAgBooLCsnFAp7SM9gCJFI1E16BiAHhWXlOjo6qPorNK2trfakZwByUFhWbMGCBctyc3PlpOcwREpKyvZPPvnkz6TnADJQWFYoJycnxNvbu/izzz57u7293ZP0PIa4e/fuqEWLFm2MiYnJvnr16kDS84B5obCsTHp6+lK5XH6ktrY2jGEYZ9LzGMm5oKBgRmRk5JWNGzfKSQ8D5oPCshI3b94URkVF7d+wYcM7jAFF1dnZKeFxrF7a29vtDPi3nmlpaZvnzJmzhs+ZwHKgsKxAfn6+Z1RU1OXz58/LGQPKytvbu8rf37+cv8l6GzVq1CUDf3LpvGPHjtfHjBmzn7ehwHKoVCqkD+fbb78Nk0gkPzMMo9I3Uqm0ddmyZUu0HbOiosLekONpio+Pz4/ajn/hwgXXiRMn7jfwmEofH5/CiooKe9KPOcJfiA+A8Jddu3Y9xzCM0pAn/vTp07N0PemvXbtmcmHJZLJKXfPv3r173PDhw68ZclxXV9eyK1euDCT92CP8hPgACD/55ptvog0pKx8fnx//85//xOhzbIVCIeTzFZZ6Fi9e/J4hx3Z2dq4oKytzIH0OEO5DfACE++Tl5QUKhcI7+j7BZ8+evUGf416/ft1u7dq1cyMiIs6YWlhisbh98uTJe7ds2TJVn9v+4YcfZAEBAWX6Ht/Dw+Mi6fOAcB/iAyDcprS01Kl///41+pZGZmZmgq5j5ubmhsTHx+8ViUSdphaVpjg5OTUlJyevLyoqctM1yyuvvPKlnsdVPvPMM8dJnw+E2xAfAOE2MpnsnD5PaHd399r8/HxvtmPl5OSERUZGnuKjpLRl+vTpWRcvXnRlm2vlypUL9C2tqVOnfkn6nCDchfgACHdJSEjYzOhx3crf379MoVAItR3n2rVr9lOmTPnGnEX1ZIRC4aO0tLRVbPf1q6++mqpvaWVkZCSTPjcINyE+AMJNPv744z/rU1YjR468zHac9evXv2Jvb/8bqbJ6Mj4+Pj8ePnw4WNusu3fvHqdvaeXn53uSPkeI6SE+AGJ6ysvLHWxtbev1KQC24yQmJm4jXVKasnz58oXaZt6+fXu8Psfw9fU9R/o8IaaH+ACI6fn9U96sT9gBAwY0VlZW2mlaX1NTI/zTn/5UTLqY2JKYmLhN2/3/6KOP5ujzKmvhwoWLSZ8rxLQQHwAxLZs3b45n9HgrmJeXF6RpfVlZmaO7u3st6ULSJ7GxsXnaHofXXnttva71AoFAefnyZXyolOIQHwAxLc7OzhW6nqirV69O0bT22rVr9q6urjrfSlpSoqOjtX5UITg4uFDX+vHjx39N+pwhxof4AIjxWbZsWaquV1fjxo07pG29l5eXXp/XsrRMmjRpn6b7U15e7iiVSlt1rFcePnx4FOlzhxgX4gMgxkfXB0Tt7OxatX18gYtPq5PMm2++uVbT/Vq3bt0cXWtDQ0NzSZ87xLgQHwAxLsuXL0/R9epqzZo1czWtTUlJ+RfpwuEi27dvj9d0//R4a6jMy8sLJH0OEcNDfADEuLi4uLD+Xp2vr6/Gb0PYv39/BOmi4Sr9+vX7TdMryFOnTvnpWhsXF7eT9DlEDA/xARDDs23btucZHa+uvv766+c1rR0yZMhPpIuGy8TFxeVoup+TJk3ax7ZOIBAo8d1Z9IX4AIjhiY6OzmZ7MgYGBl7WtC4tLW0V6YLhI3v37h2rfl8LCws9dK1bsmTJ26TPJWJYiA+AGJbKykqprq+O0fSVLTdu3JDw9W0LpKPtywDHjh2bx7bOy8urmPT5RAwL8QEQw7JmzZoktiehi4tLvaZ1SUlJn5EuFj6jqaSzs7PH6FinPHPmjDfpc4roH+IDIIYlKiqK9e1gamrqak3rxGJxO+lS4TMBAQFlmu63m5sb6zW7RYsWvUP6nCL6B381hzIlJSURbPtnzZr1hfq25cuXLzL3n+sytxs3bozKy8sLUt8+c+bMnWzrjh07NpG/qYBrKCyKZGdnR3R0dIi17ffx8amKjIz8WX37rl27UvidzDJs27YtXX3btGnT/pdtzfXr15/hbyLgGgqLIgUFBc8xLH9X8IUXXjigvu3s2bOymzdv+vE5l6U4evToTPVtcXFx111cXG5rW9PV1SXat28f66tWsBwoLIqUlJSEse2fMGHCd+rbDh48+Ap/E1mW5ubmAQcOHOhVPuHh4T+wLHO+cOHCGB7HAg6hsCiiUCh8te0TiURdISEh59W3nz592qqu0Rw/fnyq+rbo6OgTbGvKy8tH8TcRcAmFRYmCggLPe/fuaX076OnpqfD19e1S315RURHC72SWpbCwcLz6tmeffbZXkT+ptrZWxt9EwCUUFiUKCwujOzo6PLXt9/Pzu66+7fTp035tbW12/E5mWaqqqp5W3+br63tDJBL1KvPHGhsbB/M7FXAFhUWJ4uLicJVKpXW/n5/fNfVtlZWVvX7M39c9ePBgwKVLl/7wStTX17eL7cJ7S0tLf/4nAy6gsChRWlo6mm2/u7v7LfVtCoUigLeBLFhdXV2vt3hPPfXUXW3/vqurS8TvRMAVFBYlampq/Nn2u7m5/aK+7fbt2+78TWS5bt++3eutM9srrO7ublt+JwKuoLAooetVgKOjY5P6tl9//dUqr800NTUNUt/m4ODwQNu/V6lUeB5QAieqj5BIJG3q29ra2uxJzEJaW1tbr2tSUqm01+PzGNu1QbAsKKw+QiQSdZOewVJoKiAbGxutPyUEeqCw+oiurq5ev9wsFos7SMxCmkQi6XW/NT0+jwkEAn4HAs6gsCih60nV0tLS6+2fo6Pjr3zNY8mcnJzuq29j++iCQCDo4Xci4AoKixKenp632PY3Nja6qm9j+8lYX+bi4lKvvq2pqekpbf/exsYGhUUJFBYlnn766XK2/fX19b1+lO/p6VnD30SWy8PD45b6NqVSOVTbv2f7FDxYFhQWJcLCworY9mv6Chl/f/8K/iayTBKJpCMmJuaW+vY7d+5o/Uxav379WnkdCjiDwqJERETEeVtbW61v8TT9Dl1gYOAVa3u74+XlVaW+7dKlS84PHz501LbGycmp12fYwDKhsCgxefLk0gEDBmh9YlVXV/cqrOHDh3d5e3v3egL3ZaNHj+71SrSiouJZtjUeHh51/E0EXEJhUWTYsGG3tO27f/++8+9/i+8PoqOjj/E6lIXR9CWGmr5y5kkjRoyo5G8i4BIKiyJBQUGlbPsLCgri1LfFx8dn8zeRZbGxsemJi4s7qL69oKBgAtu6kJCQYv6mAi6hsCgSHR19hm3/0aNHp6tve+mll05by+exIiIiTslksj9cs1MoFMLy8nK2LzFsCA8PZ/2CP7AcKCyKREVFnRUIBA3a9p87d+55TdunTJmyh7+pLEdSUlKvP3F25MiRxEePHmn979zT0/NWUFBQM7+TAVdQWBQJDAxs8ff313q9paWlxX7r1q0J6tvnz5+/lt/JyHNycvp1/vz5vd7+7tmz53W2dbGxsaf4mwq4hsKizMSJEw+z7d++fXuvv80XExNzKyIigu0vx1Dvtdde+1R9W2VlpV1BQYHGV52/a0hISDjA31TAOdJ/ehoxLD/88IM3wzBKRsufXhcIBKrS0tIB6usOHToUrG0N7bGzs2vV9FgtWrToPbZ1Tk5OVaTPJ2JYiA+AGB5fX99zbE/E5OTk9ZrWxcbG5pEuFz7y97//fYmm+zto0CCtxc4wjOrll1/+mPS5RAwL8QEQw7Ny5crXGZZXWRKJpF3TusuXLw8SCATEC4bLeHh43NR0Xz/44IMUHWuVx48f9yd9LhHDQnwAxLiIxeKf2Z6Qc+bM2aBp3bvvvvsu6ZLhMjk5OWGa7ufgwYNZX12NGDHiNOlziBge4gMgxuUvf/nLx2xPSIFAoLp06ZKzprXBwcGFpIuGi7zxxhufaLp/b7/99koda5VffPFFAulziBge4gMgxuXy5csDGZa3hQzDqKKioo5rWnvjxg2Jg4NDM+nCMSXBwcGFmu7b1atXB4hEok62tUOGDLlK+vwhxoX4AIjxmTFjxkZdT+z169e/omntd999F0K6dIyNs7PzHYVCIdR0v8LCws7qenX16aefvkj63CHGhfgAiPGpqKiwt7GxucP2BJVIJO3l5eWOmtZv3rxZTrp8DI29vf1vRUVFbpruz/LlyxfqWu/l5VVM+rwhxof4AIhpWbBgwTJGx1vDkSNHXta2/t///vcrpEtI3/Tv37/51KlTfpruR15eXpAex1Du2bNnDOlzhhgf4gMgpsfV1bVM15M1MTFxm7b1mZmZCZb+cQdXV9f68+fPe2iav6qqylbXZ64YhlE9//zz/0v6XCGmhfgAiOnZu3fvGF2vshiGUS1evPg9bcc4evToqN//eAPxclJPaGjo2erqalttswcEBOgsbIlE8nNVVZWI9LlCTAvxARBu8vvHHHSW1qpVq/6m7RgKhUI4YcKEXNIF9WTmzZv3Edv9Dg8PP6PHcZQbNmyQkz5HiOkhPgDCXby8vIr1KYGVK1cuYDvOunXr5vTv35/oxx5kMllldnY26/WmyMjIU/qU1ZQpUzaTPjcINyE+AMJdiouLXUUikV5v6956662VbMeqqqqyTUpK+szcReXo6Nj0j3/8YxHbbDU1NcJnnnnmoj7H8/Hx0fh5LYTOEB8A4TZbt259gdHjrSHDMCq5XJ6l63hFRUVur7766pdSqbSVz6JycXGpZ7vG9jgnTpwIcHNz+0mfY/br1+/mpUuXBpM+Jwh3IT4Awn1WrFiRom9pBQQElOXn53vrOmZ1dbXtqlWr/sblr/WIxeL2cePGHdq0aZNcn/v14Ycfvm7ATzOVOTk5waTPBcJtiA+A8JPU1FSdn896HKFQ+Oj9999P1/fYV65cGfTpp5/Omjlz5g4/P79r+r76cnR0bAoKCiqeM2fOhq1btybU1NRo/LS6eq5fv243ceLE/QaUoTIzM/MF0ucA4T4ClUrFQN80d+7cVV999VUKwzDO+vz74ODgotWrV8+Pj4+/YuhtnTt3zvPOnTvujY2Nri0tLf27u7tFYrG408HB4cFTTz11183NrS40NPSuocfNyMj429q1a//V0tJir+eSho0bN85LTU09YOhtAQVINybCb9LS0pYyer7SepyEhIRv9HmbyGc2bdokHz58+DVD5mYYRrlly5ZJpB9zhL8QHwDhP//85z9Zv/BPWyZNmrTvwIEDEeacdd26dXP8/f11fhBUPXZ2drXZ2dkavxsL6TshPgBinuzcuXO8nZ1draFFwDCMys/P79rSpUvf1farMaZm3759MS+//PJmI7/yRimTyc4VFRW5kn6MEf6Da1hWpKSkxHn27Nl7KioqRjF6XtdSN3z48OvR0dEnoqKiTowePbooLCzstqHHOHbs2Kji4uKx+fn5E4qLi8fev3/fqFmY3//qTW5u7jwj1wNlUFhWKCUlZeXmzZvfZIwsrScNHDjw/tChQ+uGDh1a5+zsfHvgwIGNUqm0TSQSdXV0dPRrbW21v3fvnrNSqXSrr6/3rK+v92xvb7cz9XYlEskvGRkZSxYvXrzb1GMBRUi/xEPI5ODBg8F+fn75jBHXtghHOX78+K+vXr3qRPoxRMwf4gMgZLNixYoUe3v7mxZQRDqLysvLqxifr7LuEB8AIZ/q6mrR/PnzV0ilUqMuyvNdVEOGDLmakZGRTPpxQsgH17Dgv6qqqsRffvllelZWVnJDQ4Mzw8E1LhM0+Pv7V86bN++LRYsW4ToVMAyDi+6gxZYtW+J37do1Oz8/P/bRo0euZrrZBkdHx+a4uLijSUlJ2+RyeYmZbhcogcICVpWVldJDhw5N//777ydeuHBhTFNT00CG21deDe7u7r9ER0efnjRp0pHk5OTvOTw29DEoLDDIyZMnhxcXF48pLS0Nrqqq8lcqla4PHz50am9vl3Z3d9v29PQIGeb/r40KBAJGIBD0CIXCHltb2y6pVNru5OTUNHTo0F9GjBhRGRwcXBIWFnY+PDzc4N8xBOuEwgIAavwf5TycnH9gCGUAAAAASUVORK5CYII="

/***/ },
/* 107 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	exports.__esModule = true;
	var Clip_1 = __webpack_require__(445);
	var color = __webpack_require__(34);
	var util_1 = __webpack_require__(1);
	var arraySlice = Array.prototype.slice;
	function interpolateNumber(p0, p1, percent) {
	    return (p1 - p0) * percent + p0;
	}
	exports.interpolateNumber = interpolateNumber;
	function step(p0, p1, percent) {
	    return percent > 0.5 ? p1 : p0;
	}
	exports.step = step;
	function interpolate1DArray(out, p0, p1, percent) {
	    var len = p0.length;
	    for (var i = 0; i < len; i++) {
	        out[i] = interpolateNumber(p0[i], p1[i], percent);
	    }
	}
	exports.interpolate1DArray = interpolate1DArray;
	function interpolate2DArray(out, p0, p1, percent) {
	    var len = p0.length;
	    var len2 = len && p0[0].length;
	    for (var i = 0; i < len; i++) {
	        if (!out[i]) {
	            out[i] = [];
	        }
	        for (var j = 0; j < len2; j++) {
	            out[i][j] = interpolateNumber(p0[i][j], p1[i][j], percent);
	        }
	    }
	}
	exports.interpolate2DArray = interpolate2DArray;
	function add1DArray(out, p0, p1, sign) {
	    var len = p0.length;
	    for (var i = 0; i < len; i++) {
	        out[i] = p0[i] + p1[i] * sign;
	    }
	    return out;
	}
	function add2DArray(out, p0, p1, sign) {
	    var len = p0.length;
	    var len2 = len && p0[0].length;
	    for (var i = 0; i < len; i++) {
	        if (!out[i]) {
	            out[i] = [];
	        }
	        for (var j = 0; j < len2; j++) {
	            out[i][j] = p0[i][j] + p1[i][j] * sign;
	        }
	    }
	    return out;
	}
	function fillArray(val0, val1, arrDim) {
	    var arr0 = val0;
	    var arr1 = val1;
	    if (!arr0.push || !arr1.push) {
	        return;
	    }
	    var arr0Len = arr0.length;
	    var arr1Len = arr1.length;
	    if (arr0Len !== arr1Len) {
	        var isPreviousLarger = arr0Len > arr1Len;
	        if (isPreviousLarger) {
	            arr0.length = arr1Len;
	        }
	        else {
	            for (var i = arr0Len; i < arr1Len; i++) {
	                arr0.push(arrDim === 1 ? arr1[i] : arraySlice.call(arr1[i]));
	            }
	        }
	    }
	    var len2 = arr0[0] && arr0[0].length;
	    for (var i = 0; i < arr0.length; i++) {
	        if (arrDim === 1) {
	            if (isNaN(arr0[i])) {
	                arr0[i] = arr1[i];
	            }
	        }
	        else {
	            for (var j = 0; j < len2; j++) {
	                if (isNaN(arr0[i][j])) {
	                    arr0[i][j] = arr1[i][j];
	                }
	            }
	        }
	    }
	}
	function is1DArraySame(arr0, arr1) {
	    var len = arr0.length;
	    if (len !== arr1.length) {
	        return false;
	    }
	    for (var i = 0; i < len; i++) {
	        if (arr0[i] !== arr1[i]) {
	            return false;
	        }
	    }
	    return true;
	}
	function is2DArraySame(arr0, arr1) {
	    var len = arr0.length;
	    if (len !== arr1.length) {
	        return false;
	    }
	    var len2 = arr0[0].length;
	    for (var i = 0; i < len; i++) {
	        for (var j = 0; j < len2; j++) {
	            if (arr0[i][j] !== arr1[i][j]) {
	                return false;
	            }
	        }
	    }
	    return true;
	}
	function catmullRomInterpolate(p0, p1, p2, p3, t, t2, t3) {
	    var v0 = (p2 - p0) * 0.5;
	    var v1 = (p3 - p1) * 0.5;
	    return (2 * (p1 - p2) + v0 + v1) * t3
	        + (-3 * (p1 - p2) - 2 * v0 - v1) * t2
	        + v0 * t + p1;
	}
	function catmullRomInterpolate1DArray(out, p0, p1, p2, p3, t, t2, t3) {
	    var len = p0.length;
	    for (var i = 0; i < len; i++) {
	        out[i] = catmullRomInterpolate(p0[i], p1[i], p2[i], p3[i], t, t2, t3);
	    }
	}
	function catmullRomInterpolate2DArray(out, p0, p1, p2, p3, t, t2, t3) {
	    var len = p0.length;
	    var len2 = p0[0].length;
	    for (var i = 0; i < len; i++) {
	        if (!out[i]) {
	            out[1] = [];
	        }
	        for (var j = 0; j < len2; j++) {
	            out[i][j] = catmullRomInterpolate(p0[i][j], p1[i][j], p2[i][j], p3[i][j], t, t2, t3);
	        }
	    }
	}
	function cloneValue(value) {
	    if (util_1.isArrayLike(value)) {
	        var len = value.length;
	        if (util_1.isArrayLike(value[0])) {
	            var ret = [];
	            for (var i = 0; i < len; i++) {
	                ret.push(arraySlice.call(value[i]));
	            }
	            return ret;
	        }
	        return arraySlice.call(value);
	    }
	    return value;
	}
	exports.cloneValue = cloneValue;
	function rgba2String(rgba) {
	    rgba[0] = Math.floor(rgba[0]);
	    rgba[1] = Math.floor(rgba[1]);
	    rgba[2] = Math.floor(rgba[2]);
	    return 'rgba(' + rgba.join(',') + ')';
	}
	function guessArrayDim(value) {
	    return util_1.isArrayLike(value && value[0]) ? 2 : 1;
	}
	var tmpRgba = [0, 0, 0, 0];
	var Track = (function () {
	    function Track(propName) {
	        this.keyframes = [];
	        this.maxTime = 0;
	        this.arrDim = 0;
	        this.interpolable = true;
	        this._needsSort = false;
	        this._isAllValueEqual = true;
	        this._lastFrame = 0;
	        this._lastFramePercent = 0;
	        this.propName = propName;
	    }
	    Track.prototype.isFinished = function () {
	        return this._finished;
	    };
	    Track.prototype.setFinished = function () {
	        this._finished = true;
	        if (this._additiveTrack) {
	            this._additiveTrack.setFinished();
	        }
	    };
	    Track.prototype.needsAnimate = function () {
	        return !this._isAllValueEqual && this.keyframes.length >= 2 && this.interpolable;
	    };
	    Track.prototype.getAdditiveTrack = function () {
	        return this._additiveTrack;
	    };
	    Track.prototype.addKeyframe = function (time, value) {
	        if (time >= this.maxTime) {
	            this.maxTime = time;
	        }
	        else {
	            this._needsSort = true;
	        }
	        var keyframes = this.keyframes;
	        var len = keyframes.length;
	        if (this.interpolable) {
	            if (util_1.isArrayLike(value)) {
	                var arrayDim = guessArrayDim(value);
	                if (len > 0 && this.arrDim !== arrayDim) {
	                    this.interpolable = false;
	                    return;
	                }
	                if (arrayDim === 1 && typeof value[0] !== 'number'
	                    || arrayDim === 2 && typeof value[0][0] !== 'number') {
	                    this.interpolable = false;
	                    return;
	                }
	                if (len > 0) {
	                    var lastFrame = keyframes[len - 1];
	                    if (this._isAllValueEqual) {
	                        if (arrayDim === 1) {
	                            if (!is1DArraySame(value, lastFrame.value)) {
	                                this._isAllValueEqual = false;
	                            }
	                        }
	                        else {
	                            this._isAllValueEqual = false;
	                        }
	                    }
	                }
	                this.arrDim = arrayDim;
	            }
	            else {
	                if (this.arrDim > 0) {
	                    this.interpolable = false;
	                    return;
	                }
	                if (typeof value === 'string') {
	                    var colorArray = color.parse(value);
	                    if (colorArray) {
	                        value = colorArray;
	                        this.isValueColor = true;
	                    }
	                    else {
	                        this.interpolable = false;
	                    }
	                }
	                else if (typeof value !== 'number') {
	                    this.interpolable = false;
	                    return;
	                }
	                if (this._isAllValueEqual && len > 0) {
	                    var lastFrame = keyframes[len - 1];
	                    if (this.isValueColor && !is1DArraySame(lastFrame.value, value)) {
	                        this._isAllValueEqual = false;
	                    }
	                    else if (lastFrame.value !== value) {
	                        this._isAllValueEqual = false;
	                    }
	                }
	            }
	        }
	        var kf = {
	            time: time,
	            value: value,
	            percent: 0
	        };
	        this.keyframes.push(kf);
	        return kf;
	    };
	    Track.prototype.prepare = function (additiveTrack) {
	        var kfs = this.keyframes;
	        if (this._needsSort) {
	            kfs.sort(function (a, b) {
	                return a.time - b.time;
	            });
	        }
	        var arrDim = this.arrDim;
	        var kfsLen = kfs.length;
	        var lastKf = kfs[kfsLen - 1];
	        for (var i = 0; i < kfsLen; i++) {
	            kfs[i].percent = kfs[i].time / this.maxTime;
	            if (arrDim > 0 && i !== kfsLen - 1) {
	                fillArray(kfs[i].value, lastKf.value, arrDim);
	            }
	        }
	        if (additiveTrack
	            && this.needsAnimate()
	            && additiveTrack.needsAnimate()
	            && arrDim === additiveTrack.arrDim
	            && this.isValueColor === additiveTrack.isValueColor
	            && !additiveTrack._finished) {
	            this._additiveTrack = additiveTrack;
	            var startValue = kfs[0].value;
	            for (var i = 0; i < kfsLen; i++) {
	                if (arrDim === 0) {
	                    if (this.isValueColor) {
	                        kfs[i].additiveValue
	                            = add1DArray([], kfs[i].value, startValue, -1);
	                    }
	                    else {
	                        kfs[i].additiveValue = kfs[i].value - startValue;
	                    }
	                }
	                else if (arrDim === 1) {
	                    kfs[i].additiveValue = add1DArray([], kfs[i].value, startValue, -1);
	                }
	                else if (arrDim === 2) {
	                    kfs[i].additiveValue = add2DArray([], kfs[i].value, startValue, -1);
	                }
	            }
	        }
	    };
	    Track.prototype.step = function (target, percent) {
	        if (this._finished) {
	            return;
	        }
	        if (this._additiveTrack && this._additiveTrack._finished) {
	            this._additiveTrack = null;
	        }
	        var isAdditive = this._additiveTrack != null;
	        var valueKey = isAdditive ? 'additiveValue' : 'value';
	        var keyframes = this.keyframes;
	        var kfsNum = this.keyframes.length;
	        var propName = this.propName;
	        var arrDim = this.arrDim;
	        var isValueColor = this.isValueColor;
	        var frameIdx;
	        if (percent < 0) {
	            frameIdx = 0;
	        }
	        else if (percent < this._lastFramePercent) {
	            var start = Math.min(this._lastFrame + 1, kfsNum - 1);
	            for (frameIdx = start; frameIdx >= 0; frameIdx--) {
	                if (keyframes[frameIdx].percent <= percent) {
	                    break;
	                }
	            }
	            frameIdx = Math.min(frameIdx, kfsNum - 2);
	        }
	        else {
	            for (frameIdx = this._lastFrame; frameIdx < kfsNum; frameIdx++) {
	                if (keyframes[frameIdx].percent > percent) {
	                    break;
	                }
	            }
	            frameIdx = Math.min(frameIdx - 1, kfsNum - 2);
	        }
	        var nextFrame = keyframes[frameIdx + 1];
	        var frame = keyframes[frameIdx];
	        if (!(frame && nextFrame)) {
	            return;
	        }
	        this._lastFrame = frameIdx;
	        this._lastFramePercent = percent;
	        var range = (nextFrame.percent - frame.percent);
	        if (range === 0) {
	            return;
	        }
	        var w = (percent - frame.percent) / range;
	        var targetArr = isAdditive ? this._additiveValue
	            : (isValueColor ? tmpRgba : target[propName]);
	        if ((arrDim > 0 || isValueColor) && !targetArr) {
	            targetArr = this._additiveValue = [];
	        }
	        if (this.useSpline) {
	            var p1 = keyframes[frameIdx][valueKey];
	            var p0 = keyframes[frameIdx === 0 ? frameIdx : frameIdx - 1][valueKey];
	            var p2 = keyframes[frameIdx > kfsNum - 2 ? kfsNum - 1 : frameIdx + 1][valueKey];
	            var p3 = keyframes[frameIdx > kfsNum - 3 ? kfsNum - 1 : frameIdx + 2][valueKey];
	            if (arrDim > 0) {
	                arrDim === 1
	                    ? catmullRomInterpolate1DArray(targetArr, p0, p1, p2, p3, w, w * w, w * w * w)
	                    : catmullRomInterpolate2DArray(targetArr, p0, p1, p2, p3, w, w * w, w * w * w);
	            }
	            else if (isValueColor) {
	                catmullRomInterpolate1DArray(targetArr, p0, p1, p2, p3, w, w * w, w * w * w);
	                if (!isAdditive) {
	                    target[propName] = rgba2String(targetArr);
	                }
	            }
	            else {
	                var value = void 0;
	                if (!this.interpolable) {
	                    value = p2;
	                }
	                else {
	                    value = catmullRomInterpolate(p0, p1, p2, p3, w, w * w, w * w * w);
	                }
	                if (isAdditive) {
	                    this._additiveValue = value;
	                }
	                else {
	                    target[propName] = value;
	                }
	            }
	        }
	        else {
	            if (arrDim > 0) {
	                arrDim === 1
	                    ? interpolate1DArray(targetArr, frame[valueKey], nextFrame[valueKey], w)
	                    : interpolate2DArray(targetArr, frame[valueKey], nextFrame[valueKey], w);
	            }
	            else if (isValueColor) {
	                interpolate1DArray(targetArr, frame[valueKey], nextFrame[valueKey], w);
	                if (!isAdditive) {
	                    target[propName] = rgba2String(targetArr);
	                }
	            }
	            else {
	                var value = void 0;
	                if (!this.interpolable) {
	                    value = step(frame[valueKey], nextFrame[valueKey], w);
	                }
	                else {
	                    value = interpolateNumber(frame[valueKey], nextFrame[valueKey], w);
	                }
	                if (isAdditive) {
	                    this._additiveValue = value;
	                }
	                else {
	                    target[propName] = value;
	                }
	            }
	        }
	        if (isAdditive) {
	            this._addToTarget(target);
	        }
	    };
	    Track.prototype._addToTarget = function (target) {
	        var arrDim = this.arrDim;
	        var propName = this.propName;
	        var additiveValue = this._additiveValue;
	        if (arrDim === 0) {
	            if (this.isValueColor) {
	                color.parse(target[propName], tmpRgba);
	                add1DArray(tmpRgba, tmpRgba, additiveValue, 1);
	                target[propName] = rgba2String(tmpRgba);
	            }
	            else {
	                target[propName] = target[propName] + additiveValue;
	            }
	        }
	        else if (arrDim === 1) {
	            add1DArray(target[propName], target[propName], additiveValue, 1);
	        }
	        else if (arrDim === 2) {
	            add2DArray(target[propName], target[propName], additiveValue, 1);
	        }
	    };
	    return Track;
	}());
	var Animator = (function () {
	    function Animator(target, loop, additiveTo) {
	        this._tracks = {};
	        this._trackKeys = [];
	        this._delay = 0;
	        this._maxTime = 0;
	        this._paused = false;
	        this._started = 0;
	        this._clip = null;
	        this._target = target;
	        this._loop = loop;
	        if (loop && additiveTo) {
	            util_1.logError('Can\' use additive animation on looped animation.');
	            return;
	        }
	        this._additiveAnimators = additiveTo;
	    }
	    Animator.prototype.getTarget = function () {
	        return this._target;
	    };
	    Animator.prototype.changeTarget = function (target) {
	        this._target = target;
	    };
	    Animator.prototype.when = function (time, props) {
	        return this.whenWithKeys(time, props, util_1.keys(props));
	    };
	    Animator.prototype.whenWithKeys = function (time, props, propNames) {
	        var tracks = this._tracks;
	        for (var i = 0; i < propNames.length; i++) {
	            var propName = propNames[i];
	            var track = tracks[propName];
	            if (!track) {
	                track = tracks[propName] = new Track(propName);
	                var initialValue = void 0;
	                var additiveTrack = this._getAdditiveTrack(propName);
	                if (additiveTrack) {
	                    var lastFinalKf = additiveTrack.keyframes[additiveTrack.keyframes.length - 1];
	                    initialValue = lastFinalKf && lastFinalKf.value;
	                    if (additiveTrack.isValueColor && initialValue) {
	                        initialValue = rgba2String(initialValue);
	                    }
	                }
	                else {
	                    initialValue = this._target[propName];
	                }
	                if (initialValue == null) {
	                    continue;
	                }
	                if (time !== 0) {
	                    track.addKeyframe(0, cloneValue(initialValue));
	                }
	                this._trackKeys.push(propName);
	            }
	            track.addKeyframe(time, cloneValue(props[propName]));
	        }
	        this._maxTime = Math.max(this._maxTime, time);
	        return this;
	    };
	    Animator.prototype.pause = function () {
	        this._clip.pause();
	        this._paused = true;
	    };
	    Animator.prototype.resume = function () {
	        this._clip.resume();
	        this._paused = false;
	    };
	    Animator.prototype.isPaused = function () {
	        return !!this._paused;
	    };
	    Animator.prototype._doneCallback = function () {
	        this._setTracksFinished();
	        this._clip = null;
	        var doneList = this._doneList;
	        if (doneList) {
	            var len = doneList.length;
	            for (var i = 0; i < len; i++) {
	                doneList[i].call(this);
	            }
	        }
	    };
	    Animator.prototype._abortedCallback = function () {
	        this._setTracksFinished();
	        var animation = this.animation;
	        var abortedList = this._abortedList;
	        if (animation) {
	            animation.removeClip(this._clip);
	        }
	        this._clip = null;
	        if (abortedList) {
	            for (var i = 0; i < abortedList.length; i++) {
	                abortedList[i].call(this);
	            }
	        }
	    };
	    Animator.prototype._setTracksFinished = function () {
	        var tracks = this._tracks;
	        var tracksKeys = this._trackKeys;
	        for (var i = 0; i < tracksKeys.length; i++) {
	            tracks[tracksKeys[i]].setFinished();
	        }
	    };
	    Animator.prototype._getAdditiveTrack = function (trackName) {
	        var additiveTrack;
	        var additiveAnimators = this._additiveAnimators;
	        if (additiveAnimators) {
	            for (var i = 0; i < additiveAnimators.length; i++) {
	                var track = additiveAnimators[i].getTrack(trackName);
	                if (track) {
	                    additiveTrack = track;
	                }
	            }
	        }
	        return additiveTrack;
	    };
	    Animator.prototype.start = function (easing, forceAnimate) {
	        if (this._started > 0) {
	            return;
	        }
	        this._started = 1;
	        var self = this;
	        var tracks = [];
	        for (var i = 0; i < this._trackKeys.length; i++) {
	            var propName = this._trackKeys[i];
	            var track = this._tracks[propName];
	            var additiveTrack = this._getAdditiveTrack(propName);
	            var kfs = track.keyframes;
	            track.prepare(additiveTrack);
	            if (track.needsAnimate()) {
	                tracks.push(track);
	            }
	            else if (!track.interpolable) {
	                var lastKf = kfs[kfs.length - 1];
	                if (lastKf) {
	                    self._target[track.propName] = lastKf.value;
	                }
	            }
	        }
	        if (tracks.length || forceAnimate) {
	            var clip = new Clip_1["default"]({
	                life: this._maxTime,
	                loop: this._loop,
	                delay: this._delay,
	                onframe: function (percent) {
	                    self._started = 2;
	                    var additiveAnimators = self._additiveAnimators;
	                    if (additiveAnimators) {
	                        var stillHasAdditiveAnimator = false;
	                        for (var i = 0; i < additiveAnimators.length; i++) {
	                            if (additiveAnimators[i]._clip) {
	                                stillHasAdditiveAnimator = true;
	                                break;
	                            }
	                        }
	                        if (!stillHasAdditiveAnimator) {
	                            self._additiveAnimators = null;
	                        }
	                    }
	                    for (var i = 0; i < tracks.length; i++) {
	                        tracks[i].step(self._target, percent);
	                    }
	                    var onframeList = self._onframeList;
	                    if (onframeList) {
	                        for (var i = 0; i < onframeList.length; i++) {
	                            onframeList[i](self._target, percent);
	                        }
	                    }
	                },
	                ondestroy: function () {
	                    self._doneCallback();
	                }
	            });
	            this._clip = clip;
	            if (this.animation) {
	                this.animation.addClip(clip);
	            }
	            if (easing && easing !== 'spline') {
	                clip.easing = easing;
	            }
	        }
	        else {
	            this._doneCallback();
	        }
	        return this;
	    };
	    Animator.prototype.stop = function (forwardToLast) {
	        if (!this._clip) {
	            return;
	        }
	        var clip = this._clip;
	        if (forwardToLast) {
	            clip.onframe(1);
	        }
	        this._abortedCallback();
	    };
	    Animator.prototype.delay = function (time) {
	        this._delay = time;
	        return this;
	    };
	    Animator.prototype.during = function (cb) {
	        if (cb) {
	            if (!this._onframeList) {
	                this._onframeList = [];
	            }
	            this._onframeList.push(cb);
	        }
	        return this;
	    };
	    Animator.prototype.done = function (cb) {
	        if (cb) {
	            if (!this._doneList) {
	                this._doneList = [];
	            }
	            this._doneList.push(cb);
	        }
	        return this;
	    };
	    Animator.prototype.aborted = function (cb) {
	        if (cb) {
	            if (!this._abortedList) {
	                this._abortedList = [];
	            }
	            this._abortedList.push(cb);
	        }
	        return this;
	    };
	    Animator.prototype.getClip = function () {
	        return this._clip;
	    };
	    Animator.prototype.getTrack = function (propName) {
	        return this._tracks[propName];
	    };
	    Animator.prototype.stopTracks = function (propNames, forwardToLast) {
	        if (!propNames.length || !this._clip) {
	            return true;
	        }
	        var tracks = this._tracks;
	        var tracksKeys = this._trackKeys;
	        for (var i = 0; i < propNames.length; i++) {
	            var track = tracks[propNames[i]];
	            if (track) {
	                if (forwardToLast) {
	                    track.step(this._target, 1);
	                }
	                else if (this._started === 1) {
	                    track.step(this._target, 0);
	                }
	                track.setFinished();
	            }
	        }
	        var allAborted = true;
	        for (var i = 0; i < tracksKeys.length; i++) {
	            if (!tracks[tracksKeys[i]].isFinished()) {
	                allAborted = false;
	                break;
	            }
	        }
	        if (allAborted) {
	            this._abortedCallback();
	        }
	        return allAborted;
	    };
	    Animator.prototype.saveFinalToTarget = function (target, trackKeys) {
	        if (!target) {
	            return;
	        }
	        trackKeys = trackKeys || this._trackKeys;
	        for (var i = 0; i < trackKeys.length; i++) {
	            var propName = trackKeys[i];
	            var track = this._tracks[propName];
	            if (!track || track.isFinished()) {
	                continue;
	            }
	            var kfs = track.keyframes;
	            var lastKf = kfs[kfs.length - 1];
	            if (lastKf) {
	                var val = cloneValue(lastKf.value);
	                if (track.isValueColor) {
	                    val = rgba2String(val);
	                }
	                target[propName] = val;
	            }
	        }
	    };
	    Animator.prototype.__changeFinalValue = function (finalProps, trackKeys) {
	        trackKeys = trackKeys || util_1.keys(finalProps);
	        for (var i = 0; i < trackKeys.length; i++) {
	            var propName = trackKeys[i];
	            var track = this._tracks[propName];
	            if (!track) {
	                continue;
	            }
	            var kfs = track.keyframes;
	            if (kfs.length > 1) {
	                var lastKf = kfs.pop();
	                track.addKeyframe(lastKf.time, finalProps[propName]);
	                track.prepare(track.getAdditiveTrack());
	            }
	        }
	    };
	    return Animator;
	}());
	exports["default"] = Animator;


/***/ },
/* 108 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	exports.__esModule = true;
	var matrix = __webpack_require__(27);
	var vector = __webpack_require__(11);
	var mIdentity = matrix.identity;
	var EPSILON = 5e-5;
	function isNotAroundZero(val) {
	    return val > EPSILON || val < -EPSILON;
	}
	var scaleTmp = [];
	var tmpTransform = [];
	var originTransform = matrix.create();
	var abs = Math.abs;
	var Transformable = (function () {
	    function Transformable() {
	    }
	    Transformable.prototype.setPosition = function (arr) {
	        this.x = arr[0];
	        this.y = arr[1];
	    };
	    Transformable.prototype.setScale = function (arr) {
	        this.scaleX = arr[0];
	        this.scaleY = arr[1];
	    };
	    Transformable.prototype.setOrigin = function (arr) {
	        this.originX = arr[0];
	        this.originY = arr[1];
	    };
	    Transformable.prototype.needLocalTransform = function () {
	        return isNotAroundZero(this.rotation)
	            || isNotAroundZero(this.x)
	            || isNotAroundZero(this.y)
	            || isNotAroundZero(this.scaleX - 1)
	            || isNotAroundZero(this.scaleY - 1);
	    };
	    Transformable.prototype.updateTransform = function () {
	        var parent = this.parent;
	        var parentHasTransform = parent && parent.transform;
	        var needLocalTransform = this.needLocalTransform();
	        var m = this.transform;
	        if (!(needLocalTransform || parentHasTransform)) {
	            m && mIdentity(m);
	            return;
	        }
	        m = m || matrix.create();
	        if (needLocalTransform) {
	            this.getLocalTransform(m);
	        }
	        else {
	            mIdentity(m);
	        }
	        if (parentHasTransform) {
	            if (needLocalTransform) {
	                matrix.mul(m, parent.transform, m);
	            }
	            else {
	                matrix.copy(m, parent.transform);
	            }
	        }
	        this.transform = m;
	        this._resolveGlobalScaleRatio(m);
	    };
	    Transformable.prototype._resolveGlobalScaleRatio = function (m) {
	        var globalScaleRatio = this.globalScaleRatio;
	        if (globalScaleRatio != null && globalScaleRatio !== 1) {
	            this.getGlobalScale(scaleTmp);
	            var relX = scaleTmp[0] < 0 ? -1 : 1;
	            var relY = scaleTmp[1] < 0 ? -1 : 1;
	            var sx = ((scaleTmp[0] - relX) * globalScaleRatio + relX) / scaleTmp[0] || 0;
	            var sy = ((scaleTmp[1] - relY) * globalScaleRatio + relY) / scaleTmp[1] || 0;
	            m[0] *= sx;
	            m[1] *= sx;
	            m[2] *= sy;
	            m[3] *= sy;
	        }
	        this.invTransform = this.invTransform || matrix.create();
	        matrix.invert(this.invTransform, m);
	    };
	    Transformable.prototype.getLocalTransform = function (m) {
	        return Transformable.getLocalTransform(this, m);
	    };
	    Transformable.prototype.getComputedTransform = function () {
	        var transformNode = this;
	        var ancestors = [];
	        while (transformNode) {
	            ancestors.push(transformNode);
	            transformNode = transformNode.parent;
	        }
	        while (transformNode = ancestors.pop()) {
	            transformNode.updateTransform();
	        }
	        return this.transform;
	    };
	    Transformable.prototype.setLocalTransform = function (m) {
	        if (!m) {
	            return;
	        }
	        var sx = m[0] * m[0] + m[1] * m[1];
	        var sy = m[2] * m[2] + m[3] * m[3];
	        if (isNotAroundZero(sx - 1)) {
	            sx = Math.sqrt(sx);
	        }
	        if (isNotAroundZero(sy - 1)) {
	            sy = Math.sqrt(sy);
	        }
	        if (m[0] < 0) {
	            sx = -sx;
	        }
	        if (m[3] < 0) {
	            sy = -sy;
	        }
	        this.rotation = Math.atan2(-m[1] / sy, m[0] / sx);
	        if (sx < 0 && sy < 0) {
	            this.rotation += Math.PI;
	            sx = -sx;
	            sy = -sy;
	        }
	        this.x = m[4];
	        this.y = m[5];
	        this.scaleX = sx;
	        this.scaleY = sy;
	    };
	    Transformable.prototype.decomposeTransform = function () {
	        if (!this.transform) {
	            return;
	        }
	        var parent = this.parent;
	        var m = this.transform;
	        if (parent && parent.transform) {
	            matrix.mul(tmpTransform, parent.invTransform, m);
	            m = tmpTransform;
	        }
	        var ox = this.originX;
	        var oy = this.originY;
	        if (ox || oy) {
	            originTransform[4] = ox;
	            originTransform[5] = oy;
	            matrix.mul(tmpTransform, m, originTransform);
	            tmpTransform[4] -= ox;
	            tmpTransform[5] -= oy;
	            m = tmpTransform;
	        }
	        this.setLocalTransform(m);
	    };
	    Transformable.prototype.getGlobalScale = function (out) {
	        var m = this.transform;
	        out = out || [];
	        if (!m) {
	            out[0] = 1;
	            out[1] = 1;
	            return out;
	        }
	        out[0] = Math.sqrt(m[0] * m[0] + m[1] * m[1]);
	        out[1] = Math.sqrt(m[2] * m[2] + m[3] * m[3]);
	        if (m[0] < 0) {
	            out[0] = -out[0];
	        }
	        if (m[3] < 0) {
	            out[1] = -out[1];
	        }
	        return out;
	    };
	    Transformable.prototype.transformCoordToLocal = function (x, y) {
	        var v2 = [x, y];
	        var invTransform = this.invTransform;
	        if (invTransform) {
	            vector.applyTransform(v2, v2, invTransform);
	        }
	        return v2;
	    };
	    Transformable.prototype.transformCoordToGlobal = function (x, y) {
	        var v2 = [x, y];
	        var transform = this.transform;
	        if (transform) {
	            vector.applyTransform(v2, v2, transform);
	        }
	        return v2;
	    };
	    Transformable.prototype.getLineScale = function () {
	        var m = this.transform;
	        return m && abs(m[0] - 1) > 1e-10 && abs(m[3] - 1) > 1e-10
	            ? Math.sqrt(abs(m[0] * m[3] - m[2] * m[1]))
	            : 1;
	    };
	    Transformable.getLocalTransform = function (target, m) {
	        m = m || [];
	        mIdentity(m);
	        var ox = target.originX || 0;
	        var oy = target.originY || 0;
	        var sx = target.scaleX;
	        var sy = target.scaleY;
	        var rotation = target.rotation || 0;
	        var x = target.x;
	        var y = target.y;
	        m[4] -= ox;
	        m[5] -= oy;
	        m[0] *= sx;
	        m[1] *= sy;
	        m[2] *= sx;
	        m[3] *= sy;
	        m[4] *= sx;
	        m[5] *= sy;
	        if (rotation) {
	            matrix.rotate(m, m, rotation);
	        }
	        m[4] += ox;
	        m[5] += oy;
	        m[4] += x;
	        m[5] += y;
	        return m;
	    };
	    Transformable.initDefaultProps = (function () {
	        var proto = Transformable.prototype;
	        proto.x = 0;
	        proto.y = 0;
	        proto.scaleX = 1;
	        proto.scaleY = 1;
	        proto.originX = 0;
	        proto.originY = 0;
	        proto.rotation = 0;
	        proto.globalScaleRatio = 1;
	    })();
	    return Transformable;
	}());
	;
	exports["default"] = Transformable;


/***/ },
/* 109 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	exports.__esModule = true;
	var tslib_1 = __webpack_require__(5);
	var Gradient_1 = __webpack_require__(185);
	var LinearGradient = (function (_super) {
	    tslib_1.__extends(LinearGradient, _super);
	    function LinearGradient(x, y, x2, y2, colorStops, globalCoord) {
	        var _this = _super.call(this, colorStops) || this;
	        _this.x = x == null ? 0 : x;
	        _this.y = y == null ? 0 : y;
	        _this.x2 = x2 == null ? 1 : x2;
	        _this.y2 = y2 == null ? 0 : y2;
	        _this.type = 'linear';
	        _this.global = globalCoord || false;
	        return _this;
	    }
	    return LinearGradient;
	}(Gradient_1["default"]));
	exports["default"] = LinearGradient;
	;


/***/ },
/* 110 */
/***/ function(module, exports) {

	"use strict";
	exports.__esModule = true;
	var round = Math.round;
	function subPixelOptimizeLine(outputShape, inputShape, style) {
	    if (!inputShape) {
	        return;
	    }
	    var x1 = inputShape.x1;
	    var x2 = inputShape.x2;
	    var y1 = inputShape.y1;
	    var y2 = inputShape.y2;
	    outputShape.x1 = x1;
	    outputShape.x2 = x2;
	    outputShape.y1 = y1;
	    outputShape.y2 = y2;
	    var lineWidth = style && style.lineWidth;
	    if (!lineWidth) {
	        return outputShape;
	    }
	    if (round(x1 * 2) === round(x2 * 2)) {
	        outputShape.x1 = outputShape.x2 = subPixelOptimize(x1, lineWidth, true);
	    }
	    if (round(y1 * 2) === round(y2 * 2)) {
	        outputShape.y1 = outputShape.y2 = subPixelOptimize(y1, lineWidth, true);
	    }
	    return outputShape;
	}
	exports.subPixelOptimizeLine = subPixelOptimizeLine;
	function subPixelOptimizeRect(outputShape, inputShape, style) {
	    if (!inputShape) {
	        return;
	    }
	    var originX = inputShape.x;
	    var originY = inputShape.y;
	    var originWidth = inputShape.width;
	    var originHeight = inputShape.height;
	    outputShape.x = originX;
	    outputShape.y = originY;
	    outputShape.width = originWidth;
	    outputShape.height = originHeight;
	    var lineWidth = style && style.lineWidth;
	    if (!lineWidth) {
	        return outputShape;
	    }
	    outputShape.x = subPixelOptimize(originX, lineWidth, true);
	    outputShape.y = subPixelOptimize(originY, lineWidth, true);
	    outputShape.width = Math.max(subPixelOptimize(originX + originWidth, lineWidth, false) - outputShape.x, originWidth === 0 ? 0 : 1);
	    outputShape.height = Math.max(subPixelOptimize(originY + originHeight, lineWidth, false) - outputShape.y, originHeight === 0 ? 0 : 1);
	    return outputShape;
	}
	exports.subPixelOptimizeRect = subPixelOptimizeRect;
	function subPixelOptimize(position, lineWidth, positiveOrNegative) {
	    if (!lineWidth) {
	        return position;
	    }
	    var doubledPosition = round(position * 2);
	    return (doubledPosition + round(lineWidth)) % 2 === 0
	        ? doubledPosition / 2
	        : (doubledPosition + (positiveOrNegative ? 1 : -1)) / 2;
	}
	exports.subPixelOptimize = subPixelOptimize;


/***/ },
/* 111 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	exports.__esModule = true;
	var tslib_1 = __webpack_require__(5);
	var Path_1 = __webpack_require__(8);
	var CircleShape = (function () {
	    function CircleShape() {
	        this.cx = 0;
	        this.cy = 0;
	        this.r = 0;
	    }
	    return CircleShape;
	}());
	var Circle = (function (_super) {
	    tslib_1.__extends(Circle, _super);
	    function Circle(opts) {
	        return _super.call(this, opts) || this;
	    }
	    Circle.prototype.getDefaultShape = function () {
	        return new CircleShape();
	    };
	    Circle.prototype.buildPath = function (ctx, shape, inBundle) {
	        if (inBundle) {
	            ctx.moveTo(shape.cx + shape.r, shape.cy);
	        }
	        ctx.arc(shape.cx, shape.cy, shape.r, 0, Math.PI * 2);
	    };
	    return Circle;
	}(Path_1["default"]));
	;
	Circle.prototype.type = 'circle';
	exports["default"] = Circle;


/***/ },
/* 112 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	exports.__esModule = true;
	var tslib_1 = __webpack_require__(5);
	var Path_1 = __webpack_require__(8);
	var EllipseShape = (function () {
	    function EllipseShape() {
	        this.cx = 0;
	        this.cy = 0;
	        this.rx = 0;
	        this.ry = 0;
	    }
	    return EllipseShape;
	}());
	var Ellipse = (function (_super) {
	    tslib_1.__extends(Ellipse, _super);
	    function Ellipse(opts) {
	        return _super.call(this, opts) || this;
	    }
	    Ellipse.prototype.getDefaultShape = function () {
	        return new EllipseShape();
	    };
	    Ellipse.prototype.buildPath = function (ctx, shape) {
	        var k = 0.5522848;
	        var x = shape.cx;
	        var y = shape.cy;
	        var a = shape.rx;
	        var b = shape.ry;
	        var ox = a * k;
	        var oy = b * k;
	        ctx.moveTo(x - a, y);
	        ctx.bezierCurveTo(x - a, y - oy, x - ox, y - b, x, y - b);
	        ctx.bezierCurveTo(x + ox, y - b, x + a, y - oy, x + a, y);
	        ctx.bezierCurveTo(x + a, y + oy, x + ox, y + b, x, y + b);
	        ctx.bezierCurveTo(x - ox, y + b, x - a, y + oy, x - a, y);
	        ctx.closePath();
	    };
	    return Ellipse;
	}(Path_1["default"]));
	Ellipse.prototype.type = 'ellipse';
	exports["default"] = Ellipse;


/***/ },
/* 113 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	exports.__esModule = true;
	var tslib_1 = __webpack_require__(5);
	var Path_1 = __webpack_require__(8);
	var subPixelOptimize_1 = __webpack_require__(110);
	var subPixelOptimizeOutputShape = {};
	var LineShape = (function () {
	    function LineShape() {
	        this.x1 = 0;
	        this.y1 = 0;
	        this.x2 = 0;
	        this.y2 = 0;
	        this.percent = 1;
	    }
	    return LineShape;
	}());
	var Line = (function (_super) {
	    tslib_1.__extends(Line, _super);
	    function Line(opts) {
	        return _super.call(this, opts) || this;
	    }
	    Line.prototype.getDefaultStyle = function () {
	        return {
	            stroke: '#000',
	            fill: null
	        };
	    };
	    Line.prototype.getDefaultShape = function () {
	        return new LineShape();
	    };
	    Line.prototype.buildPath = function (ctx, shape) {
	        var x1;
	        var y1;
	        var x2;
	        var y2;
	        if (this.subPixelOptimize) {
	            var optimizedShape = subPixelOptimize_1.subPixelOptimizeLine(subPixelOptimizeOutputShape, shape, this.style);
	            x1 = optimizedShape.x1;
	            y1 = optimizedShape.y1;
	            x2 = optimizedShape.x2;
	            y2 = optimizedShape.y2;
	        }
	        else {
	            x1 = shape.x1;
	            y1 = shape.y1;
	            x2 = shape.x2;
	            y2 = shape.y2;
	        }
	        var percent = shape.percent;
	        if (percent === 0) {
	            return;
	        }
	        ctx.moveTo(x1, y1);
	        if (percent < 1) {
	            x2 = x1 * (1 - percent) + x2 * percent;
	            y2 = y1 * (1 - percent) + y2 * percent;
	        }
	        ctx.lineTo(x2, y2);
	    };
	    Line.prototype.pointAt = function (p) {
	        var shape = this.shape;
	        return [
	            shape.x1 * (1 - p) + shape.x2 * p,
	            shape.y1 * (1 - p) + shape.y2 * p
	        ];
	    };
	    return Line;
	}(Path_1["default"]));
	Line.prototype.type = 'line';
	exports["default"] = Line;


/***/ },
/* 114 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	exports.__esModule = true;
	var tslib_1 = __webpack_require__(5);
	var Path_1 = __webpack_require__(8);
	var polyHelper = __webpack_require__(190);
	var PolygonShape = (function () {
	    function PolygonShape() {
	        this.points = null;
	        this.smooth = 0;
	        this.smoothConstraint = null;
	    }
	    return PolygonShape;
	}());
	var Polygon = (function (_super) {
	    tslib_1.__extends(Polygon, _super);
	    function Polygon(opts) {
	        return _super.call(this, opts) || this;
	    }
	    Polygon.prototype.getDefaultShape = function () {
	        return new PolygonShape();
	    };
	    Polygon.prototype.buildPath = function (ctx, shape) {
	        polyHelper.buildPath(ctx, shape, true);
	    };
	    return Polygon;
	}(Path_1["default"]));
	;
	Polygon.prototype.type = 'polygon';
	exports["default"] = Polygon;


/***/ },
/* 115 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	exports.__esModule = true;
	var tslib_1 = __webpack_require__(5);
	var Path_1 = __webpack_require__(8);
	var polyHelper = __webpack_require__(190);
	var PolylineShape = (function () {
	    function PolylineShape() {
	        this.points = null;
	        this.percent = 1;
	        this.smooth = 0;
	        this.smoothConstraint = null;
	    }
	    return PolylineShape;
	}());
	var Polyline = (function (_super) {
	    tslib_1.__extends(Polyline, _super);
	    function Polyline(opts) {
	        return _super.call(this, opts) || this;
	    }
	    Polyline.prototype.getDefaultStyle = function () {
	        return {
	            stroke: '#000',
	            fill: null
	        };
	    };
	    Polyline.prototype.getDefaultShape = function () {
	        return new PolylineShape();
	    };
	    Polyline.prototype.buildPath = function (ctx, shape) {
	        polyHelper.buildPath(ctx, shape, false);
	    };
	    return Polyline;
	}(Path_1["default"]));
	Polyline.prototype.type = 'polyline';
	exports["default"] = Polyline;


/***/ },
/* 116 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	exports.__esModule = true;
	var tslib_1 = __webpack_require__(5);
	var Path_1 = __webpack_require__(8);
	var roundSectorHelper = __webpack_require__(465);
	var SectorShape = (function () {
	    function SectorShape() {
	        this.cx = 0;
	        this.cy = 0;
	        this.r0 = 0;
	        this.r = 0;
	        this.startAngle = 0;
	        this.endAngle = Math.PI * 2;
	        this.clockwise = true;
	        this.cornerRadius = 0;
	        this.innerCornerRadius = 0;
	    }
	    return SectorShape;
	}());
	var Sector = (function (_super) {
	    tslib_1.__extends(Sector, _super);
	    function Sector(opts) {
	        return _super.call(this, opts) || this;
	    }
	    Sector.prototype.getDefaultShape = function () {
	        return new SectorShape();
	    };
	    Sector.prototype.buildPath = function (ctx, shape) {
	        roundSectorHelper.buildPath(ctx, shape);
	    };
	    Sector.prototype.isZeroArea = function () {
	        return this.shape.startAngle === this.shape.endAngle
	            || this.shape.r === this.shape.r0;
	    };
	    return Sector;
	}(Path_1["default"]));
	Sector.prototype.type = 'sector';
	exports["default"] = Sector;


/***/ },
/* 117 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	exports.__esModule = true;
	var tslib_1 = __webpack_require__(5);
	var Path_1 = __webpack_require__(8);
	var PathProxy_1 = __webpack_require__(32);
	var transformPath_1 = __webpack_require__(476);
	var util_1 = __webpack_require__(1);
	var mathSqrt = Math.sqrt;
	var mathSin = Math.sin;
	var mathCos = Math.cos;
	var PI = Math.PI;
	function vMag(v) {
	    return Math.sqrt(v[0] * v[0] + v[1] * v[1]);
	}
	;
	function vRatio(u, v) {
	    return (u[0] * v[0] + u[1] * v[1]) / (vMag(u) * vMag(v));
	}
	;
	function vAngle(u, v) {
	    return (u[0] * v[1] < u[1] * v[0] ? -1 : 1)
	        * Math.acos(vRatio(u, v));
	}
	;
	function processArc(x1, y1, x2, y2, fa, fs, rx, ry, psiDeg, cmd, path) {
	    var psi = psiDeg * (PI / 180.0);
	    var xp = mathCos(psi) * (x1 - x2) / 2.0
	        + mathSin(psi) * (y1 - y2) / 2.0;
	    var yp = -1 * mathSin(psi) * (x1 - x2) / 2.0
	        + mathCos(psi) * (y1 - y2) / 2.0;
	    var lambda = (xp * xp) / (rx * rx) + (yp * yp) / (ry * ry);
	    if (lambda > 1) {
	        rx *= mathSqrt(lambda);
	        ry *= mathSqrt(lambda);
	    }
	    var f = (fa === fs ? -1 : 1)
	        * mathSqrt((((rx * rx) * (ry * ry))
	            - ((rx * rx) * (yp * yp))
	            - ((ry * ry) * (xp * xp))) / ((rx * rx) * (yp * yp)
	            + (ry * ry) * (xp * xp))) || 0;
	    var cxp = f * rx * yp / ry;
	    var cyp = f * -ry * xp / rx;
	    var cx = (x1 + x2) / 2.0
	        + mathCos(psi) * cxp
	        - mathSin(psi) * cyp;
	    var cy = (y1 + y2) / 2.0
	        + mathSin(psi) * cxp
	        + mathCos(psi) * cyp;
	    var theta = vAngle([1, 0], [(xp - cxp) / rx, (yp - cyp) / ry]);
	    var u = [(xp - cxp) / rx, (yp - cyp) / ry];
	    var v = [(-1 * xp - cxp) / rx, (-1 * yp - cyp) / ry];
	    var dTheta = vAngle(u, v);
	    if (vRatio(u, v) <= -1) {
	        dTheta = PI;
	    }
	    if (vRatio(u, v) >= 1) {
	        dTheta = 0;
	    }
	    if (dTheta < 0) {
	        var n = Math.round(dTheta / PI * 1e6) / 1e6;
	        dTheta = PI * 2 + (n % 2) * PI;
	    }
	    path.addData(cmd, cx, cy, rx, ry, theta, dTheta, psi, fs);
	}
	var commandReg = /([mlvhzcqtsa])([^mlvhzcqtsa]*)/ig;
	var numberReg = /-?([0-9]*\.)?[0-9]+([eE]-?[0-9]+)?/g;
	function createPathProxyFromString(data) {
	    if (!data) {
	        return new PathProxy_1["default"]();
	    }
	    var cpx = 0;
	    var cpy = 0;
	    var subpathX = cpx;
	    var subpathY = cpy;
	    var prevCmd;
	    var path = new PathProxy_1["default"]();
	    var CMD = PathProxy_1["default"].CMD;
	    var cmdList = data.match(commandReg);
	    for (var l = 0; l < cmdList.length; l++) {
	        var cmdText = cmdList[l];
	        var cmdStr = cmdText.charAt(0);
	        var cmd = void 0;
	        var p = cmdText.match(numberReg) || [];
	        var pLen = p.length;
	        for (var i = 0; i < pLen; i++) {
	            p[i] = parseFloat(p[i]);
	        }
	        var off = 0;
	        while (off < pLen) {
	            var ctlPtx = void 0;
	            var ctlPty = void 0;
	            var rx = void 0;
	            var ry = void 0;
	            var psi = void 0;
	            var fa = void 0;
	            var fs = void 0;
	            var x1 = cpx;
	            var y1 = cpy;
	            var len = void 0;
	            var pathData = void 0;
	            switch (cmdStr) {
	                case 'l':
	                    cpx += p[off++];
	                    cpy += p[off++];
	                    cmd = CMD.L;
	                    path.addData(cmd, cpx, cpy);
	                    break;
	                case 'L':
	                    cpx = p[off++];
	                    cpy = p[off++];
	                    cmd = CMD.L;
	                    path.addData(cmd, cpx, cpy);
	                    break;
	                case 'm':
	                    cpx += p[off++];
	                    cpy += p[off++];
	                    cmd = CMD.M;
	                    path.addData(cmd, cpx, cpy);
	                    subpathX = cpx;
	                    subpathY = cpy;
	                    cmdStr = 'l';
	                    break;
	                case 'M':
	                    cpx = p[off++];
	                    cpy = p[off++];
	                    cmd = CMD.M;
	                    path.addData(cmd, cpx, cpy);
	                    subpathX = cpx;
	                    subpathY = cpy;
	                    cmdStr = 'L';
	                    break;
	                case 'h':
	                    cpx += p[off++];
	                    cmd = CMD.L;
	                    path.addData(cmd, cpx, cpy);
	                    break;
	                case 'H':
	                    cpx = p[off++];
	                    cmd = CMD.L;
	                    path.addData(cmd, cpx, cpy);
	                    break;
	                case 'v':
	                    cpy += p[off++];
	                    cmd = CMD.L;
	                    path.addData(cmd, cpx, cpy);
	                    break;
	                case 'V':
	                    cpy = p[off++];
	                    cmd = CMD.L;
	                    path.addData(cmd, cpx, cpy);
	                    break;
	                case 'C':
	                    cmd = CMD.C;
	                    path.addData(cmd, p[off++], p[off++], p[off++], p[off++], p[off++], p[off++]);
	                    cpx = p[off - 2];
	                    cpy = p[off - 1];
	                    break;
	                case 'c':
	                    cmd = CMD.C;
	                    path.addData(cmd, p[off++] + cpx, p[off++] + cpy, p[off++] + cpx, p[off++] + cpy, p[off++] + cpx, p[off++] + cpy);
	                    cpx += p[off - 2];
	                    cpy += p[off - 1];
	                    break;
	                case 'S':
	                    ctlPtx = cpx;
	                    ctlPty = cpy;
	                    len = path.len();
	                    pathData = path.data;
	                    if (prevCmd === CMD.C) {
	                        ctlPtx += cpx - pathData[len - 4];
	                        ctlPty += cpy - pathData[len - 3];
	                    }
	                    cmd = CMD.C;
	                    x1 = p[off++];
	                    y1 = p[off++];
	                    cpx = p[off++];
	                    cpy = p[off++];
	                    path.addData(cmd, ctlPtx, ctlPty, x1, y1, cpx, cpy);
	                    break;
	                case 's':
	                    ctlPtx = cpx;
	                    ctlPty = cpy;
	                    len = path.len();
	                    pathData = path.data;
	                    if (prevCmd === CMD.C) {
	                        ctlPtx += cpx - pathData[len - 4];
	                        ctlPty += cpy - pathData[len - 3];
	                    }
	                    cmd = CMD.C;
	                    x1 = cpx + p[off++];
	                    y1 = cpy + p[off++];
	                    cpx += p[off++];
	                    cpy += p[off++];
	                    path.addData(cmd, ctlPtx, ctlPty, x1, y1, cpx, cpy);
	                    break;
	                case 'Q':
	                    x1 = p[off++];
	                    y1 = p[off++];
	                    cpx = p[off++];
	                    cpy = p[off++];
	                    cmd = CMD.Q;
	                    path.addData(cmd, x1, y1, cpx, cpy);
	                    break;
	                case 'q':
	                    x1 = p[off++] + cpx;
	                    y1 = p[off++] + cpy;
	                    cpx += p[off++];
	                    cpy += p[off++];
	                    cmd = CMD.Q;
	                    path.addData(cmd, x1, y1, cpx, cpy);
	                    break;
	                case 'T':
	                    ctlPtx = cpx;
	                    ctlPty = cpy;
	                    len = path.len();
	                    pathData = path.data;
	                    if (prevCmd === CMD.Q) {
	                        ctlPtx += cpx - pathData[len - 4];
	                        ctlPty += cpy - pathData[len - 3];
	                    }
	                    cpx = p[off++];
	                    cpy = p[off++];
	                    cmd = CMD.Q;
	                    path.addData(cmd, ctlPtx, ctlPty, cpx, cpy);
	                    break;
	                case 't':
	                    ctlPtx = cpx;
	                    ctlPty = cpy;
	                    len = path.len();
	                    pathData = path.data;
	                    if (prevCmd === CMD.Q) {
	                        ctlPtx += cpx - pathData[len - 4];
	                        ctlPty += cpy - pathData[len - 3];
	                    }
	                    cpx += p[off++];
	                    cpy += p[off++];
	                    cmd = CMD.Q;
	                    path.addData(cmd, ctlPtx, ctlPty, cpx, cpy);
	                    break;
	                case 'A':
	                    rx = p[off++];
	                    ry = p[off++];
	                    psi = p[off++];
	                    fa = p[off++];
	                    fs = p[off++];
	                    x1 = cpx, y1 = cpy;
	                    cpx = p[off++];
	                    cpy = p[off++];
	                    cmd = CMD.A;
	                    processArc(x1, y1, cpx, cpy, fa, fs, rx, ry, psi, cmd, path);
	                    break;
	                case 'a':
	                    rx = p[off++];
	                    ry = p[off++];
	                    psi = p[off++];
	                    fa = p[off++];
	                    fs = p[off++];
	                    x1 = cpx, y1 = cpy;
	                    cpx += p[off++];
	                    cpy += p[off++];
	                    cmd = CMD.A;
	                    processArc(x1, y1, cpx, cpy, fa, fs, rx, ry, psi, cmd, path);
	                    break;
	            }
	        }
	        if (cmdStr === 'z' || cmdStr === 'Z') {
	            cmd = CMD.Z;
	            path.addData(cmd);
	            cpx = subpathX;
	            cpy = subpathY;
	        }
	        prevCmd = cmd;
	    }
	    path.toStatic();
	    return path;
	}
	var SVGPath = (function (_super) {
	    tslib_1.__extends(SVGPath, _super);
	    function SVGPath() {
	        return _super !== null && _super.apply(this, arguments) || this;
	    }
	    SVGPath.prototype.applyTransform = function (m) { };
	    return SVGPath;
	}(Path_1["default"]));
	function isPathProxy(path) {
	    return path.setData != null;
	}
	function createPathOptions(str, opts) {
	    var pathProxy = createPathProxyFromString(str);
	    var innerOpts = util_1.extend({}, opts);
	    innerOpts.buildPath = function (path) {
	        if (isPathProxy(path)) {
	            path.setData(pathProxy.data);
	            var ctx = path.getContext();
	            if (ctx) {
	                path.rebuildPath(ctx, 1);
	            }
	        }
	        else {
	            var ctx = path;
	            pathProxy.rebuildPath(ctx, 1);
	        }
	    };
	    innerOpts.applyTransform = function (m) {
	        transformPath_1["default"](pathProxy, m);
	        this.dirtyShape();
	    };
	    return innerOpts;
	}
	function createFromString(str, opts) {
	    return new SVGPath(createPathOptions(str, opts));
	}
	exports.createFromString = createFromString;
	function extendFromString(str, defaultOpts) {
	    var innerOpts = createPathOptions(str, defaultOpts);
	    var Sub = (function (_super) {
	        tslib_1.__extends(Sub, _super);
	        function Sub(opts) {
	            var _this = _super.call(this, opts) || this;
	            _this.applyTransform = innerOpts.applyTransform;
	            _this.buildPath = innerOpts.buildPath;
	            return _this;
	        }
	        return Sub;
	    }(SVGPath));
	    return Sub;
	}
	exports.extendFromString = extendFromString;
	function mergePath(pathEls, opts) {
	    var pathList = [];
	    var len = pathEls.length;
	    for (var i = 0; i < len; i++) {
	        var pathEl = pathEls[i];
	        if (!pathEl.path) {
	            pathEl.createPathProxy();
	        }
	        if (pathEl.shapeChanged()) {
	            pathEl.buildPath(pathEl.path, pathEl.shape, true);
	        }
	        pathList.push(pathEl.path);
	    }
	    var pathBundle = new Path_1["default"](opts);
	    pathBundle.createPathProxy();
	    pathBundle.buildPath = function (path) {
	        if (isPathProxy(path)) {
	            path.appendPath(pathList);
	            var ctx = path.getContext();
	            if (ctx) {
	                path.rebuildPath(ctx, 1);
	            }
	        }
	    };
	    return pathBundle;
	}
	exports.mergePath = mergePath;


/***/ },
/* 118 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	/**
	 * Copyright (c) 2017-present, Ephox, Inc.
	 *
	 * This source code is licensed under the Apache 2 license found in the
	 * LICENSE file in the root directory of this source tree.
	 *
	 */
	Object.defineProperty(exports, "__esModule", { value: true });
	exports.mergePlugins = exports.isTextarea = exports.uuid = exports.bindHandlers = exports.isFunction = void 0;
	var EditorPropTypes_1 = __webpack_require__(119);
	exports.isFunction = function (x) { return typeof x === 'function'; };
	var isEventProp = function (name) {
	    return name in EditorPropTypes_1.eventPropTypes;
	};
	var findEventHandlers = function (props) {
	    return Object.keys(props)
	        .filter(isEventProp)
	        .filter(function (name) { return exports.isFunction(props[name]); })
	        .map(function (name) { return ({
	        handler: props[name],
	        eventName: name.substring(2)
	    }); });
	};
	exports.bindHandlers = function (editor, props, boundHandlers) {
	    findEventHandlers(props).forEach(function (found) {
	        // Unbind old handler
	        var oldHandler = boundHandlers[found.eventName];
	        if (exports.isFunction(oldHandler)) {
	            editor.off(found.eventName, oldHandler);
	        }
	        // Bind new handler
	        var newHandler = function (e) { return found.handler(e, editor); };
	        boundHandlers[found.eventName] = newHandler;
	        editor.on(found.eventName, newHandler);
	    });
	};
	var unique = 0;
	exports.uuid = function (prefix) {
	    var time = Date.now();
	    var random = Math.floor(Math.random() * 1000000000);
	    unique++;
	    return prefix + '_' + random + unique + String(time);
	};
	exports.isTextarea = function (element) {
	    return element !== null && element.tagName.toLowerCase() === 'textarea';
	};
	var normalizePluginArray = function (plugins) {
	    if (typeof plugins === 'undefined' || plugins === '') {
	        return [];
	    }
	    return Array.isArray(plugins) ? plugins : plugins.split(' ');
	};
	exports.mergePlugins = function (initPlugins, inputPlugins) {
	    return normalizePluginArray(initPlugins).concat(normalizePluginArray(inputPlugins));
	};


/***/ },
/* 119 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	/**
	 * Copyright (c) 2017-present, Ephox, Inc.
	 *
	 * This source code is licensed under the Apache 2 license found in the
	 * LICENSE file in the root directory of this source tree.
	 *
	 */
	var __assign = (this && this.__assign) || function () {
	    __assign = Object.assign || function(t) {
	        for (var s, i = 1, n = arguments.length; i < n; i++) {
	            s = arguments[i];
	            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
	                t[p] = s[p];
	        }
	        return t;
	    };
	    return __assign.apply(this, arguments);
	};
	Object.defineProperty(exports, "__esModule", { value: true });
	exports.EditorPropTypes = exports.eventPropTypes = void 0;
	var PropTypes = __webpack_require__(31);
	exports.eventPropTypes = {
	    onActivate: PropTypes.func,
	    onAddUndo: PropTypes.func,
	    onBeforeAddUndo: PropTypes.func,
	    onBeforeExecCommand: PropTypes.func,
	    onBeforeGetContent: PropTypes.func,
	    onBeforeRenderUI: PropTypes.func,
	    onBeforeSetContent: PropTypes.func,
	    onBeforePaste: PropTypes.func,
	    onBlur: PropTypes.func,
	    onChange: PropTypes.func,
	    onClearUndos: PropTypes.func,
	    onClick: PropTypes.func,
	    onContextMenu: PropTypes.func,
	    onCopy: PropTypes.func,
	    onCut: PropTypes.func,
	    onDblclick: PropTypes.func,
	    onDeactivate: PropTypes.func,
	    onDirty: PropTypes.func,
	    onDrag: PropTypes.func,
	    onDragDrop: PropTypes.func,
	    onDragEnd: PropTypes.func,
	    onDragGesture: PropTypes.func,
	    onDragOver: PropTypes.func,
	    onDrop: PropTypes.func,
	    onExecCommand: PropTypes.func,
	    onFocus: PropTypes.func,
	    onFocusIn: PropTypes.func,
	    onFocusOut: PropTypes.func,
	    onGetContent: PropTypes.func,
	    onHide: PropTypes.func,
	    onInit: PropTypes.func,
	    onKeyDown: PropTypes.func,
	    onKeyPress: PropTypes.func,
	    onKeyUp: PropTypes.func,
	    onLoadContent: PropTypes.func,
	    onMouseDown: PropTypes.func,
	    onMouseEnter: PropTypes.func,
	    onMouseLeave: PropTypes.func,
	    onMouseMove: PropTypes.func,
	    onMouseOut: PropTypes.func,
	    onMouseOver: PropTypes.func,
	    onMouseUp: PropTypes.func,
	    onNodeChange: PropTypes.func,
	    onObjectResizeStart: PropTypes.func,
	    onObjectResized: PropTypes.func,
	    onObjectSelected: PropTypes.func,
	    onPaste: PropTypes.func,
	    onPostProcess: PropTypes.func,
	    onPostRender: PropTypes.func,
	    onPreProcess: PropTypes.func,
	    onProgressState: PropTypes.func,
	    onRedo: PropTypes.func,
	    onRemove: PropTypes.func,
	    onReset: PropTypes.func,
	    onSaveContent: PropTypes.func,
	    onSelectionChange: PropTypes.func,
	    onSetAttrib: PropTypes.func,
	    onSetContent: PropTypes.func,
	    onShow: PropTypes.func,
	    onSubmit: PropTypes.func,
	    onUndo: PropTypes.func,
	    onVisualAid: PropTypes.func
	};
	exports.EditorPropTypes = __assign({ apiKey: PropTypes.string, id: PropTypes.string, inline: PropTypes.bool, init: PropTypes.object, initialValue: PropTypes.string, onEditorChange: PropTypes.func, outputFormat: PropTypes.oneOf(['html', 'text']), value: PropTypes.string, tagName: PropTypes.string, cloudChannel: PropTypes.string, plugins: PropTypes.oneOfType([PropTypes.string, PropTypes.array]), toolbar: PropTypes.oneOfType([PropTypes.string, PropTypes.array]), disabled: PropTypes.bool, textareaName: PropTypes.string, tinymceScriptSrc: PropTypes.string, scriptLoading: PropTypes.shape({
	        'async': PropTypes.bool,
	        'defer': PropTypes.bool,
	        'delay': PropTypes.number
	    }) }, exports.eventPropTypes);


/***/ },
/* 120 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	/**
	 * Copyright (c) 2017-present, Ephox, Inc.
	 *
	 * This source code is licensed under the Apache 2 license found in the
	 * LICENSE file in the root directory of this source tree.
	 *
	 */
	Object.defineProperty(exports, "__esModule", { value: true });
	exports.Editor = void 0;
	var Editor_1 = __webpack_require__(199);
	Object.defineProperty(exports, "Editor", { enumerable: true, get: function () { return Editor_1.Editor; } });


/***/ },
/* 121 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	
	var _PatientProfile = __webpack_require__(226);
	
	Object.defineProperty(exports, 'default', {
	  enumerable: true,
	  get: function get() {
	    return _interopRequireDefault(_PatientProfile).default;
	  }
	});

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/***/ },
/* 122 */
[481, 227],
/* 123 */
[478, 228],
/* 124 */
[479, 229],
/* 125 */
[480, 236],
/* 126 */
/***/ function(module, exports, __webpack_require__) {

	
	/*
	* Licensed to the Apache Software Foundation (ASF) under one
	* or more contributor license agreements.  See the NOTICE file
	* distributed with this work for additional information
	* regarding copyright ownership.  The ASF licenses this file
	* to you under the Apache License, Version 2.0 (the
	* "License"); you may not use this file except in compliance
	* with the License.  You may obtain a copy of the License at
	*
	*   http://www.apache.org/licenses/LICENSE-2.0
	*
	* Unless required by applicable law or agreed to in writing,
	* software distributed under the License is distributed on an
	* "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
	* KIND, either express or implied.  See the License for the
	* specific language governing permissions and limitations
	* under the License.
	*/
	
	
	
	/**
	 * AUTO-GENERATED FILE. DO NOT MODIFY.
	 */
	
	"use strict";
	
	exports.__esModule = true;
	
	var zrUtil = __webpack_require__(1);
	
	var availableMethods = ['getDom', 'getZr', 'getWidth', 'getHeight', 'getDevicePixelRatio', 'dispatchAction', 'isDisposed', 'on', 'off', 'getDataURL', 'getConnectedDataURL', 'getOption', 'getId', 'updateLabelLayout'];
	
	var ExtensionAPI = function () {
	  function ExtensionAPI(ecInstance) {
	    zrUtil.each(availableMethods, function (methodName) {
	      this[methodName] = zrUtil.bind(ecInstance[methodName], ecInstance);
	    }, this);
	  }
	
	  return ExtensionAPI;
	}();
	
	exports["default"] = ExtensionAPI;

/***/ },
/* 127 */
/***/ function(module, exports, __webpack_require__) {

	
	/*
	* Licensed to the Apache Software Foundation (ASF) under one
	* or more contributor license agreements.  See the NOTICE file
	* distributed with this work for additional information
	* regarding copyright ownership.  The ASF licenses this file
	* to you under the Apache License, Version 2.0 (the
	* "License"); you may not use this file except in compliance
	* with the License.  You may obtain a copy of the License at
	*
	*   http://www.apache.org/licenses/LICENSE-2.0
	*
	* Unless required by applicable law or agreed to in writing,
	* software distributed under the License is distributed on an
	* "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
	* KIND, either express or implied.  See the License for the
	* specific language governing permissions and limitations
	* under the License.
	*/
	
	
	
	/**
	 * AUTO-GENERATED FILE. DO NOT MODIFY.
	 */
	
	"use strict";
	
	exports.__esModule = true;
	
	var tslib_1 = __webpack_require__(3);
	
	var symbol_1 = __webpack_require__(48);
	
	var graphic = __webpack_require__(7);
	
	var innerStore_1 = __webpack_require__(21);
	
	var states_1 = __webpack_require__(22);
	
	var number_1 = __webpack_require__(9);
	
	var labelHelper_1 = __webpack_require__(83);
	
	var util_1 = __webpack_require__(1);
	
	var labelStyle_1 = __webpack_require__(20);
	
	var Image_1 = __webpack_require__(43);
	
	var Symbol = function (_super) {
	  tslib_1.__extends(Symbol, _super);
	
	  function Symbol(data, idx, seriesScope, opts) {
	    var _this = _super.call(this) || this;
	
	    _this.updateData(data, idx, seriesScope, opts);
	
	    return _this;
	  }
	
	  Symbol.prototype._createSymbol = function (symbolType, data, idx, symbolSize, keepAspect) {
	    this.removeAll();
	    var symbolPath = symbol_1.createSymbol(symbolType, -1, -1, 2, 2, null, keepAspect);
	    symbolPath.attr({
	      z2: 100,
	      culling: true,
	      scaleX: symbolSize[0] / 2,
	      scaleY: symbolSize[1] / 2
	    });
	    symbolPath.drift = driftSymbol;
	    this._symbolType = symbolType;
	    this.add(symbolPath);
	  };
	
	  Symbol.prototype.stopSymbolAnimation = function (toLastFrame) {
	    this.childAt(0).stopAnimation(null, toLastFrame);
	  };
	
	  Symbol.prototype.getSymbolPath = function () {
	    return this.childAt(0);
	  };
	
	  Symbol.prototype.highlight = function () {
	    states_1.enterEmphasis(this.childAt(0));
	  };
	
	  Symbol.prototype.downplay = function () {
	    states_1.leaveEmphasis(this.childAt(0));
	  };
	
	  Symbol.prototype.setZ = function (zlevel, z) {
	    var symbolPath = this.childAt(0);
	    symbolPath.zlevel = zlevel;
	    symbolPath.z = z;
	  };
	
	  Symbol.prototype.setDraggable = function (draggable) {
	    var symbolPath = this.childAt(0);
	    symbolPath.draggable = draggable;
	    symbolPath.cursor = draggable ? 'move' : symbolPath.cursor;
	  };
	
	  Symbol.prototype.updateData = function (data, idx, seriesScope, opts) {
	    this.silent = false;
	    var symbolType = data.getItemVisual(idx, 'symbol') || 'circle';
	    var seriesModel = data.hostModel;
	    var symbolSize = Symbol.getSymbolSize(data, idx);
	    var isInit = symbolType !== this._symbolType;
	    var disableAnimation = opts && opts.disableAnimation;
	
	    if (isInit) {
	      var keepAspect = data.getItemVisual(idx, 'symbolKeepAspect');
	
	      this._createSymbol(symbolType, data, idx, symbolSize, keepAspect);
	    } else {
	      var symbolPath = this.childAt(0);
	      symbolPath.silent = false;
	      var target = {
	        scaleX: symbolSize[0] / 2,
	        scaleY: symbolSize[1] / 2
	      };
	      disableAnimation ? symbolPath.attr(target) : graphic.updateProps(symbolPath, target, seriesModel, idx);
	    }
	
	    this._updateCommon(data, idx, symbolSize, seriesScope, opts);
	
	    if (isInit) {
	      var symbolPath = this.childAt(0);
	
	      if (!disableAnimation) {
	        var target = {
	          scaleX: this._sizeX,
	          scaleY: this._sizeY,
	          style: {
	            opacity: symbolPath.style.opacity
	          }
	        };
	        symbolPath.scaleX = symbolPath.scaleY = 0;
	        symbolPath.style.opacity = 0;
	        graphic.initProps(symbolPath, target, seriesModel, idx);
	      }
	    }
	
	    if (disableAnimation) {
	      this.childAt(0).stopAnimation('remove');
	    }
	
	    this._seriesModel = seriesModel;
	  };
	
	  Symbol.prototype._updateCommon = function (data, idx, symbolSize, seriesScope, opts) {
	    var symbolPath = this.childAt(0);
	    var seriesModel = data.hostModel;
	    var emphasisItemStyle;
	    var blurItemStyle;
	    var selectItemStyle;
	    var focus;
	    var blurScope;
	    var symbolOffset;
	    var labelStatesModels;
	    var hoverScale;
	    var cursorStyle;
	
	    if (seriesScope) {
	      emphasisItemStyle = seriesScope.emphasisItemStyle;
	      blurItemStyle = seriesScope.blurItemStyle;
	      selectItemStyle = seriesScope.selectItemStyle;
	      focus = seriesScope.focus;
	      blurScope = seriesScope.blurScope;
	      symbolOffset = seriesScope.symbolOffset;
	      labelStatesModels = seriesScope.labelStatesModels;
	      hoverScale = seriesScope.hoverScale;
	      cursorStyle = seriesScope.cursorStyle;
	    }
	
	    if (!seriesScope || data.hasItemOption) {
	      var itemModel = seriesScope && seriesScope.itemModel ? seriesScope.itemModel : data.getItemModel(idx);
	      var emphasisModel = itemModel.getModel('emphasis');
	      emphasisItemStyle = emphasisModel.getModel('itemStyle').getItemStyle();
	      selectItemStyle = itemModel.getModel(['select', 'itemStyle']).getItemStyle();
	      blurItemStyle = itemModel.getModel(['blur', 'itemStyle']).getItemStyle();
	      focus = emphasisModel.get('focus');
	      blurScope = emphasisModel.get('blurScope');
	      symbolOffset = itemModel.getShallow('symbolOffset');
	      labelStatesModels = labelStyle_1.getLabelStatesModels(itemModel);
	      hoverScale = emphasisModel.getShallow('scale');
	      cursorStyle = itemModel.getShallow('cursor');
	    }
	
	    var symbolRotate = data.getItemVisual(idx, 'symbolRotate');
	    symbolPath.attr('rotation', (symbolRotate || 0) * Math.PI / 180 || 0);
	
	    if (symbolOffset) {
	      symbolPath.x = number_1.parsePercent(symbolOffset[0], symbolSize[0]);
	      symbolPath.y = number_1.parsePercent(symbolOffset[1], symbolSize[1]);
	    }
	
	    cursorStyle && symbolPath.attr('cursor', cursorStyle);
	    var symbolStyle = data.getItemVisual(idx, 'style');
	    var visualColor = symbolStyle.fill;
	
	    if (symbolPath instanceof Image_1["default"]) {
	      var pathStyle = symbolPath.style;
	      symbolPath.useStyle(util_1.extend({
	        image: pathStyle.image,
	        x: pathStyle.x,
	        y: pathStyle.y,
	        width: pathStyle.width,
	        height: pathStyle.height
	      }, symbolStyle));
	    } else {
	      if (symbolPath.__isEmptyBrush) {
	        symbolPath.useStyle(util_1.extend({}, symbolStyle));
	      } else {
	        symbolPath.useStyle(symbolStyle);
	      }
	
	      symbolPath.style.decal = null;
	      symbolPath.setColor(visualColor, opts && opts.symbolInnerColor);
	      symbolPath.style.strokeNoScale = true;
	    }
	
	    var liftZ = data.getItemVisual(idx, 'liftZ');
	    var z2Origin = this._z2;
	
	    if (liftZ != null) {
	      if (z2Origin == null) {
	        this._z2 = symbolPath.z2;
	        symbolPath.z2 += liftZ;
	      }
	    } else if (z2Origin != null) {
	      symbolPath.z2 = z2Origin;
	      this._z2 = null;
	    }
	
	    var useNameLabel = opts && opts.useNameLabel;
	    labelStyle_1.setLabelStyle(symbolPath, labelStatesModels, {
	      labelFetcher: seriesModel,
	      labelDataIndex: idx,
	      defaultText: getLabelDefaultText,
	      inheritColor: visualColor,
	      defaultOpacity: symbolStyle.opacity
	    });
	
	    function getLabelDefaultText(idx) {
	      return useNameLabel ? data.getName(idx) : labelHelper_1.getDefaultLabel(data, idx);
	    }
	
	    this._sizeX = symbolSize[0] / 2;
	    this._sizeY = symbolSize[1] / 2;
	    var emphasisState = symbolPath.ensureState('emphasis');
	    emphasisState.style = emphasisItemStyle;
	    symbolPath.ensureState('select').style = selectItemStyle;
	    symbolPath.ensureState('blur').style = blurItemStyle;
	
	    if (hoverScale) {
	      var scaleRatio = Math.max(1.1, 3 / this._sizeY);
	      emphasisState.scaleX = this._sizeX * scaleRatio;
	      emphasisState.scaleY = this._sizeY * scaleRatio;
	    }
	
	    this.setSymbolScale(1);
	    states_1.enableHoverEmphasis(this, focus, blurScope);
	  };
	
	  Symbol.prototype.setSymbolScale = function (scale) {
	    this.scaleX = this.scaleY = scale;
	  };
	
	  Symbol.prototype.fadeOut = function (cb, opt) {
	    var symbolPath = this.childAt(0);
	    var seriesModel = this._seriesModel;
	    var dataIndex = innerStore_1.getECData(this).dataIndex;
	    var animationOpt = opt && opt.animation;
	    this.silent = symbolPath.silent = true;
	
	    if (opt && opt.fadeLabel) {
	      var textContent = symbolPath.getTextContent();
	
	      if (textContent) {
	        graphic.removeElement(textContent, {
	          style: {
	            opacity: 0
	          }
	        }, seriesModel, {
	          dataIndex: dataIndex,
	          removeOpt: animationOpt,
	          cb: function () {
	            symbolPath.removeTextContent();
	          }
	        });
	      }
	    } else {
	      symbolPath.removeTextContent();
	    }
	
	    graphic.removeElement(symbolPath, {
	      style: {
	        opacity: 0
	      },
	      scaleX: 0,
	      scaleY: 0
	    }, seriesModel, {
	      dataIndex: dataIndex,
	      cb: cb,
	      removeOpt: animationOpt
	    });
	  };
	
	  Symbol.getSymbolSize = function (data, idx) {
	    var symbolSize = data.getItemVisual(idx, 'symbolSize');
	    return symbolSize instanceof Array ? symbolSize.slice() : [+symbolSize, +symbolSize];
	  };
	
	  return Symbol;
	}(graphic.Group);
	
	function driftSymbol(dx, dy) {
	  this.parent.drift(dx, dy);
	}
	
	exports["default"] = Symbol;

/***/ },
/* 128 */
/***/ function(module, exports, __webpack_require__) {

	
	/*
	* Licensed to the Apache Software Foundation (ASF) under one
	* or more contributor license agreements.  See the NOTICE file
	* distributed with this work for additional information
	* regarding copyright ownership.  The ASF licenses this file
	* to you under the Apache License, Version 2.0 (the
	* "License"); you may not use this file except in compliance
	* with the License.  You may obtain a copy of the License at
	*
	*   http://www.apache.org/licenses/LICENSE-2.0
	*
	* Unless required by applicable law or agreed to in writing,
	* software distributed under the License is distributed on an
	* "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
	* KIND, either express or implied.  See the License for the
	* specific language governing permissions and limitations
	* under the License.
	*/
	
	
	
	/**
	 * AUTO-GENERATED FILE. DO NOT MODIFY.
	 */
	
	"use strict";
	
	exports.__esModule = true;
	
	var graphic = __webpack_require__(7);
	
	var number_1 = __webpack_require__(9);
	
	function createGridClipPath(cartesian, hasAnimation, seriesModel, done, during) {
	  var rect = cartesian.getArea();
	  var x = rect.x;
	  var y = rect.y;
	  var width = rect.width;
	  var height = rect.height;
	  var lineWidth = seriesModel.get(['lineStyle', 'width']) || 2;
	  x -= lineWidth / 2;
	  y -= lineWidth / 2;
	  width += lineWidth;
	  height += lineWidth;
	  x = Math.floor(x);
	  width = Math.round(width);
	  var clipPath = new graphic.Rect({
	    shape: {
	      x: x,
	      y: y,
	      width: width,
	      height: height
	    }
	  });
	
	  if (hasAnimation) {
	    var baseAxis = cartesian.getBaseAxis();
	    var isHorizontal = baseAxis.isHorizontal();
	    var isAxisInversed = baseAxis.inverse;
	
	    if (isHorizontal) {
	      if (isAxisInversed) {
	        clipPath.shape.x += width;
	      }
	
	      clipPath.shape.width = 0;
	    } else {
	      if (!isAxisInversed) {
	        clipPath.shape.y += height;
	      }
	
	      clipPath.shape.height = 0;
	    }
	
	    var duringCb = typeof during === 'function' ? function (percent) {
	      during(percent, clipPath);
	    } : null;
	    graphic.initProps(clipPath, {
	      shape: {
	        width: width,
	        height: height,
	        x: x,
	        y: y
	      }
	    }, seriesModel, null, done, duringCb);
	  }
	
	  return clipPath;
	}
	
	exports.createGridClipPath = createGridClipPath;
	
	function createPolarClipPath(polar, hasAnimation, seriesModel) {
	  var sectorArea = polar.getArea();
	  var r0 = number_1.round(sectorArea.r0, 1);
	  var r = number_1.round(sectorArea.r, 1);
	  var clipPath = new graphic.Sector({
	    shape: {
	      cx: number_1.round(polar.cx, 1),
	      cy: number_1.round(polar.cy, 1),
	      r0: r0,
	      r: r,
	      startAngle: sectorArea.startAngle,
	      endAngle: sectorArea.endAngle,
	      clockwise: sectorArea.clockwise
	    }
	  });
	
	  if (hasAnimation) {
	    var isRadial = polar.getBaseAxis().dim === 'angle';
	
	    if (isRadial) {
	      clipPath.shape.endAngle = sectorArea.startAngle;
	    } else {
	      clipPath.shape.r = r0;
	    }
	
	    graphic.initProps(clipPath, {
	      shape: {
	        endAngle: sectorArea.endAngle,
	        r: r
	      }
	    }, seriesModel);
	  }
	
	  return clipPath;
	}
	
	exports.createPolarClipPath = createPolarClipPath;
	
	function createClipPath(coordSys, hasAnimation, seriesModel, done, during) {
	  if (!coordSys) {
	    return null;
	  } else if (coordSys.type === 'polar') {
	    return createPolarClipPath(coordSys, hasAnimation, seriesModel);
	  } else if (coordSys.type === 'cartesian2d') {
	    return createGridClipPath(coordSys, hasAnimation, seriesModel, done, during);
	  }
	
	  return null;
	}
	
	exports.createClipPath = createClipPath;

/***/ },
/* 129 */
/***/ function(module, exports, __webpack_require__) {

	
	/*
	* Licensed to the Apache Software Foundation (ASF) under one
	* or more contributor license agreements.  See the NOTICE file
	* distributed with this work for additional information
	* regarding copyright ownership.  The ASF licenses this file
	* to you under the Apache License, Version 2.0 (the
	* "License"); you may not use this file except in compliance
	* with the License.  You may obtain a copy of the License at
	*
	*   http://www.apache.org/licenses/LICENSE-2.0
	*
	* Unless required by applicable law or agreed to in writing,
	* software distributed under the License is distributed on an
	* "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
	* KIND, either express or implied.  See the License for the
	* specific language governing permissions and limitations
	* under the License.
	*/
	
	
	
	/**
	 * AUTO-GENERATED FILE. DO NOT MODIFY.
	 */
	
	"use strict";
	
	exports.__esModule = true;
	
	var zrUtil = __webpack_require__(1);
	
	var List_1 = __webpack_require__(144);
	
	var createDimensions_1 = __webpack_require__(348);
	
	var dimensionHelper_1 = __webpack_require__(146);
	
	var model_1 = __webpack_require__(4);
	
	var CoordinateSystem_1 = __webpack_require__(81);
	
	var referHelper_1 = __webpack_require__(363);
	
	var Source_1 = __webpack_require__(47);
	
	var dataStackHelper_1 = __webpack_require__(40);
	
	var sourceHelper_1 = __webpack_require__(54);
	
	var types_1 = __webpack_require__(25);
	
	function createListFromArray(source, seriesModel, opt) {
	  opt = opt || {};
	
	  if (!Source_1.isSourceInstance(source)) {
	    source = Source_1.createSourceFromSeriesDataOption(source);
	  }
	
	  var coordSysName = seriesModel.get('coordinateSystem');
	  var registeredCoordSys = CoordinateSystem_1["default"].get(coordSysName);
	  var coordSysInfo = referHelper_1.getCoordSysInfoBySeries(seriesModel);
	  var coordSysDimDefs;
	
	  if (coordSysInfo && coordSysInfo.coordSysDims) {
	    coordSysDimDefs = zrUtil.map(coordSysInfo.coordSysDims, function (dim) {
	      var dimInfo = {
	        name: dim
	      };
	      var axisModel = coordSysInfo.axisMap.get(dim);
	
	      if (axisModel) {
	        var axisType = axisModel.get('type');
	        dimInfo.type = dimensionHelper_1.getDimensionTypeByAxis(axisType);
	      }
	
	      return dimInfo;
	    });
	  }
	
	  if (!coordSysDimDefs) {
	    coordSysDimDefs = registeredCoordSys && (registeredCoordSys.getDimensionsInfo ? registeredCoordSys.getDimensionsInfo() : registeredCoordSys.dimensions.slice()) || ['x', 'y'];
	  }
	
	  var useEncodeDefaulter = opt.useEncodeDefaulter;
	  var dimInfoList = createDimensions_1["default"](source, {
	    coordDimensions: coordSysDimDefs,
	    generateCoord: opt.generateCoord,
	    encodeDefaulter: zrUtil.isFunction(useEncodeDefaulter) ? useEncodeDefaulter : useEncodeDefaulter ? zrUtil.curry(sourceHelper_1.makeSeriesEncodeForAxisCoordSys, coordSysDimDefs, seriesModel) : null
	  });
	  var firstCategoryDimIndex;
	  var hasNameEncode;
	  coordSysInfo && zrUtil.each(dimInfoList, function (dimInfo, dimIndex) {
	    var coordDim = dimInfo.coordDim;
	    var categoryAxisModel = coordSysInfo.categoryAxisMap.get(coordDim);
	
	    if (categoryAxisModel) {
	      if (firstCategoryDimIndex == null) {
	        firstCategoryDimIndex = dimIndex;
	      }
	
	      dimInfo.ordinalMeta = categoryAxisModel.getOrdinalMeta();
	    }
	
	    if (dimInfo.otherDims.itemName != null) {
	      hasNameEncode = true;
	    }
	  });
	
	  if (!hasNameEncode && firstCategoryDimIndex != null) {
	    dimInfoList[firstCategoryDimIndex].otherDims.itemName = 0;
	  }
	
	  var stackCalculationInfo = dataStackHelper_1.enableDataStack(seriesModel, dimInfoList);
	  var list = new List_1["default"](dimInfoList, seriesModel);
	  list.setCalculationInfo(stackCalculationInfo);
	  var dimValueGetter = firstCategoryDimIndex != null && isNeedCompleteOrdinalData(source) ? function (itemOpt, dimName, dataIndex, dimIndex) {
	    return dimIndex === firstCategoryDimIndex ? dataIndex : this.defaultDimValueGetter(itemOpt, dimName, dataIndex, dimIndex);
	  } : null;
	  list.hasItemOption = false;
	  list.initData(source, null, dimValueGetter);
	  return list;
	}
	
	function isNeedCompleteOrdinalData(source) {
	  if (source.sourceFormat === types_1.SOURCE_FORMAT_ORIGINAL) {
	    var sampleItem = firstDataNotNull(source.data || []);
	    return sampleItem != null && !zrUtil.isArray(model_1.getDataItemValue(sampleItem));
	  }
	}
	
	function firstDataNotNull(data) {
	  var i = 0;
	
	  while (i < data.length && data[i] == null) {
	    i++;
	  }
	
	  return data[i];
	}
	
	exports["default"] = createListFromArray;

/***/ },
/* 130 */
/***/ function(module, exports, __webpack_require__) {

	
	/*
	* Licensed to the Apache Software Foundation (ASF) under one
	* or more contributor license agreements.  See the NOTICE file
	* distributed with this work for additional information
	* regarding copyright ownership.  The ASF licenses this file
	* to you under the Apache License, Version 2.0 (the
	* "License"); you may not use this file except in compliance
	* with the License.  You may obtain a copy of the License at
	*
	*   http://www.apache.org/licenses/LICENSE-2.0
	*
	* Unless required by applicable law or agreed to in writing,
	* software distributed under the License is distributed on an
	* "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
	* KIND, either express or implied.  See the License for the
	* specific language governing permissions and limitations
	* under the License.
	*/
	
	
	
	/**
	 * AUTO-GENERATED FILE. DO NOT MODIFY.
	 */
	
	"use strict";
	
	exports.__esModule = true;
	
	var dataStackHelper_1 = __webpack_require__(40);
	
	var util_1 = __webpack_require__(1);
	
	function prepareDataCoordInfo(coordSys, data, valueOrigin) {
	  var baseAxis = coordSys.getBaseAxis();
	  var valueAxis = coordSys.getOtherAxis(baseAxis);
	  var valueStart = getValueStart(valueAxis, valueOrigin);
	  var baseAxisDim = baseAxis.dim;
	  var valueAxisDim = valueAxis.dim;
	  var valueDim = data.mapDimension(valueAxisDim);
	  var baseDim = data.mapDimension(baseAxisDim);
	  var baseDataOffset = valueAxisDim === 'x' || valueAxisDim === 'radius' ? 1 : 0;
	  var dims = util_1.map(coordSys.dimensions, function (coordDim) {
	    return data.mapDimension(coordDim);
	  });
	  var stacked = false;
	  var stackResultDim = data.getCalculationInfo('stackResultDimension');
	
	  if (dataStackHelper_1.isDimensionStacked(data, dims[0])) {
	    stacked = true;
	    dims[0] = stackResultDim;
	  }
	
	  if (dataStackHelper_1.isDimensionStacked(data, dims[1])) {
	    stacked = true;
	    dims[1] = stackResultDim;
	  }
	
	  return {
	    dataDimsForPoint: dims,
	    valueStart: valueStart,
	    valueAxisDim: valueAxisDim,
	    baseAxisDim: baseAxisDim,
	    stacked: !!stacked,
	    valueDim: valueDim,
	    baseDim: baseDim,
	    baseDataOffset: baseDataOffset,
	    stackedOverDimension: data.getCalculationInfo('stackedOverDimension')
	  };
	}
	
	exports.prepareDataCoordInfo = prepareDataCoordInfo;
	
	function getValueStart(valueAxis, valueOrigin) {
	  var valueStart = 0;
	  var extent = valueAxis.scale.getExtent();
	
	  if (valueOrigin === 'start') {
	    valueStart = extent[0];
	  } else if (valueOrigin === 'end') {
	    valueStart = extent[1];
	  } else {
	    if (extent[0] > 0) {
	      valueStart = extent[0];
	    } else if (extent[1] < 0) {
	      valueStart = extent[1];
	    }
	  }
	
	  return valueStart;
	}
	
	function getStackedOnPoint(dataCoordInfo, coordSys, data, idx) {
	  var value = NaN;
	
	  if (dataCoordInfo.stacked) {
	    value = data.get(data.getCalculationInfo('stackedOverDimension'), idx);
	  }
	
	  if (isNaN(value)) {
	    value = dataCoordInfo.valueStart;
	  }
	
	  var baseDataOffset = dataCoordInfo.baseDataOffset;
	  var stackedData = [];
	  stackedData[baseDataOffset] = data.get(dataCoordInfo.baseDim, idx);
	  stackedData[1 - baseDataOffset] = value;
	  return coordSys.dataToPoint(stackedData);
	}
	
	exports.getStackedOnPoint = getStackedOnPoint;

/***/ },
/* 131 */
/***/ function(module, exports, __webpack_require__) {

	
	/*
	* Licensed to the Apache Software Foundation (ASF) under one
	* or more contributor license agreements.  See the NOTICE file
	* distributed with this work for additional information
	* regarding copyright ownership.  The ASF licenses this file
	* to you under the Apache License, Version 2.0 (the
	* "License"); you may not use this file except in compliance
	* with the License.  You may obtain a copy of the License at
	*
	*   http://www.apache.org/licenses/LICENSE-2.0
	*
	* Unless required by applicable law or agreed to in writing,
	* software distributed under the License is distributed on an
	* "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
	* KIND, either express or implied.  See the License for the
	* specific language governing permissions and limitations
	* under the License.
	*/
	
	
	
	/**
	 * AUTO-GENERATED FILE. DO NOT MODIFY.
	 */
	
	"use strict";
	
	exports.__esModule = true;
	
	var util_1 = __webpack_require__(1);
	
	var graphic = __webpack_require__(7);
	
	var innerStore_1 = __webpack_require__(21);
	
	var labelStyle_1 = __webpack_require__(20);
	
	var Model_1 = __webpack_require__(24);
	
	var number_1 = __webpack_require__(9);
	
	var symbol_1 = __webpack_require__(48);
	
	var matrixUtil = __webpack_require__(27);
	
	var vector_1 = __webpack_require__(11);
	
	var axisHelper_1 = __webpack_require__(39);
	
	var PI = Math.PI;
	
	var AxisBuilder = function () {
	  function AxisBuilder(axisModel, opt) {
	    this.group = new graphic.Group();
	    this.opt = opt;
	    this.axisModel = axisModel;
	    util_1.defaults(opt, {
	      labelOffset: 0,
	      nameDirection: 1,
	      tickDirection: 1,
	      labelDirection: 1,
	      silent: true,
	      handleAutoShown: function () {
	        return true;
	      }
	    });
	    var transformGroup = new graphic.Group({
	      x: opt.position[0],
	      y: opt.position[1],
	      rotation: opt.rotation
	    });
	    transformGroup.updateTransform();
	    this._transformGroup = transformGroup;
	  }
	
	  AxisBuilder.prototype.hasBuilder = function (name) {
	    return !!builders[name];
	  };
	
	  AxisBuilder.prototype.add = function (name) {
	    builders[name](this.opt, this.axisModel, this.group, this._transformGroup);
	  };
	
	  AxisBuilder.prototype.getGroup = function () {
	    return this.group;
	  };
	
	  AxisBuilder.innerTextLayout = function (axisRotation, textRotation, direction) {
	    var rotationDiff = number_1.remRadian(textRotation - axisRotation);
	    var textAlign;
	    var textVerticalAlign;
	
	    if (number_1.isRadianAroundZero(rotationDiff)) {
	      textVerticalAlign = direction > 0 ? 'top' : 'bottom';
	      textAlign = 'center';
	    } else if (number_1.isRadianAroundZero(rotationDiff - PI)) {
	      textVerticalAlign = direction > 0 ? 'bottom' : 'top';
	      textAlign = 'center';
	    } else {
	      textVerticalAlign = 'middle';
	
	      if (rotationDiff > 0 && rotationDiff < PI) {
	        textAlign = direction > 0 ? 'right' : 'left';
	      } else {
	        textAlign = direction > 0 ? 'left' : 'right';
	      }
	    }
	
	    return {
	      rotation: rotationDiff,
	      textAlign: textAlign,
	      textVerticalAlign: textVerticalAlign
	    };
	  };
	
	  AxisBuilder.makeAxisEventDataBase = function (axisModel) {
	    var eventData = {
	      componentType: axisModel.mainType,
	      componentIndex: axisModel.componentIndex
	    };
	    eventData[axisModel.mainType + 'Index'] = axisModel.componentIndex;
	    return eventData;
	  };
	
	  AxisBuilder.isLabelSilent = function (axisModel) {
	    var tooltipOpt = axisModel.get('tooltip');
	    return axisModel.get('silent') || !(axisModel.get('triggerEvent') || tooltipOpt && tooltipOpt.show);
	  };
	
	  return AxisBuilder;
	}();
	
	;
	var builders = {
	  axisLine: function (opt, axisModel, group, transformGroup) {
	    var shown = axisModel.get(['axisLine', 'show']);
	
	    if (shown === 'auto' && opt.handleAutoShown) {
	      shown = opt.handleAutoShown('axisLine');
	    }
	
	    if (!shown) {
	      return;
	    }
	
	    var extent = axisModel.axis.getExtent();
	    var matrix = transformGroup.transform;
	    var pt1 = [extent[0], 0];
	    var pt2 = [extent[1], 0];
	
	    if (matrix) {
	      vector_1.applyTransform(pt1, pt1, matrix);
	      vector_1.applyTransform(pt2, pt2, matrix);
	    }
	
	    var lineStyle = util_1.extend({
	      lineCap: 'round'
	    }, axisModel.getModel(['axisLine', 'lineStyle']).getLineStyle());
	    var line = new graphic.Line({
	      subPixelOptimize: true,
	      shape: {
	        x1: pt1[0],
	        y1: pt1[1],
	        x2: pt2[0],
	        y2: pt2[1]
	      },
	      style: lineStyle,
	      strokeContainThreshold: opt.strokeContainThreshold || 5,
	      silent: true,
	      z2: 1
	    });
	    line.anid = 'line';
	    group.add(line);
	    var arrows = axisModel.get(['axisLine', 'symbol']);
	    var arrowSize = axisModel.get(['axisLine', 'symbolSize']);
	    var arrowOffset = axisModel.get(['axisLine', 'symbolOffset']) || 0;
	
	    if (typeof arrowOffset === 'number') {
	      arrowOffset = [arrowOffset, arrowOffset];
	    }
	
	    if (arrows != null) {
	      if (typeof arrows === 'string') {
	        arrows = [arrows, arrows];
	      }
	
	      if (typeof arrowSize === 'string' || typeof arrowSize === 'number') {
	        arrowSize = [arrowSize, arrowSize];
	      }
	
	      var symbolWidth_1 = arrowSize[0];
	      var symbolHeight_1 = arrowSize[1];
	      util_1.each([{
	        rotate: opt.rotation + Math.PI / 2,
	        offset: arrowOffset[0],
	        r: 0
	      }, {
	        rotate: opt.rotation - Math.PI / 2,
	        offset: arrowOffset[1],
	        r: Math.sqrt((pt1[0] - pt2[0]) * (pt1[0] - pt2[0]) + (pt1[1] - pt2[1]) * (pt1[1] - pt2[1]))
	      }], function (point, index) {
	        if (arrows[index] !== 'none' && arrows[index] != null) {
	          var symbol = symbol_1.createSymbol(arrows[index], -symbolWidth_1 / 2, -symbolHeight_1 / 2, symbolWidth_1, symbolHeight_1, lineStyle.stroke, true);
	          var r = point.r + point.offset;
	          symbol.attr({
	            rotation: point.rotate,
	            x: pt1[0] + r * Math.cos(opt.rotation),
	            y: pt1[1] - r * Math.sin(opt.rotation),
	            silent: true,
	            z2: 11
	          });
	          group.add(symbol);
	        }
	      });
	    }
	  },
	  axisTickLabel: function (opt, axisModel, group, transformGroup) {
	    var ticksEls = buildAxisMajorTicks(group, transformGroup, axisModel, opt);
	    var labelEls = buildAxisLabel(group, transformGroup, axisModel, opt);
	    fixMinMaxLabelShow(axisModel, labelEls, ticksEls);
	    buildAxisMinorTicks(group, transformGroup, axisModel, opt.tickDirection);
	  },
	  axisName: function (opt, axisModel, group, transformGroup) {
	    var name = util_1.retrieve(opt.axisName, axisModel.get('name'));
	
	    if (!name) {
	      return;
	    }
	
	    var nameLocation = axisModel.get('nameLocation');
	    var nameDirection = opt.nameDirection;
	    var textStyleModel = axisModel.getModel('nameTextStyle');
	    var gap = axisModel.get('nameGap') || 0;
	    var extent = axisModel.axis.getExtent();
	    var gapSignal = extent[0] > extent[1] ? -1 : 1;
	    var pos = [nameLocation === 'start' ? extent[0] - gapSignal * gap : nameLocation === 'end' ? extent[1] + gapSignal * gap : (extent[0] + extent[1]) / 2, isNameLocationCenter(nameLocation) ? opt.labelOffset + nameDirection * gap : 0];
	    var labelLayout;
	    var nameRotation = axisModel.get('nameRotate');
	
	    if (nameRotation != null) {
	      nameRotation = nameRotation * PI / 180;
	    }
	
	    var axisNameAvailableWidth;
	
	    if (isNameLocationCenter(nameLocation)) {
	      labelLayout = AxisBuilder.innerTextLayout(opt.rotation, nameRotation != null ? nameRotation : opt.rotation, nameDirection);
	    } else {
	      labelLayout = endTextLayout(opt.rotation, nameLocation, nameRotation || 0, extent);
	      axisNameAvailableWidth = opt.axisNameAvailableWidth;
	
	      if (axisNameAvailableWidth != null) {
	        axisNameAvailableWidth = Math.abs(axisNameAvailableWidth / Math.sin(labelLayout.rotation));
	        !isFinite(axisNameAvailableWidth) && (axisNameAvailableWidth = null);
	      }
	    }
	
	    var textFont = textStyleModel.getFont();
	    var truncateOpt = axisModel.get('nameTruncate', true) || {};
	    var ellipsis = truncateOpt.ellipsis;
	    var maxWidth = util_1.retrieve(opt.nameTruncateMaxWidth, truncateOpt.maxWidth, axisNameAvailableWidth);
	    var tooltipOpt = axisModel.get('tooltip', true);
	    var mainType = axisModel.mainType;
	    var formatterParams = {
	      componentType: mainType,
	      name: name,
	      $vars: ['name']
	    };
	    formatterParams[mainType + 'Index'] = axisModel.componentIndex;
	    var textEl = new graphic.Text({
	      x: pos[0],
	      y: pos[1],
	      rotation: labelLayout.rotation,
	      silent: AxisBuilder.isLabelSilent(axisModel),
	      style: labelStyle_1.createTextStyle(textStyleModel, {
	        text: name,
	        font: textFont,
	        overflow: 'truncate',
	        width: maxWidth,
	        ellipsis: ellipsis,
	        fill: textStyleModel.getTextColor() || axisModel.get(['axisLine', 'lineStyle', 'color']),
	        align: textStyleModel.get('align') || labelLayout.textAlign,
	        verticalAlign: textStyleModel.get('verticalAlign') || labelLayout.textVerticalAlign
	      }),
	      z2: 1
	    });
	    textEl.tooltip = tooltipOpt && tooltipOpt.show ? util_1.extend({
	      content: name,
	      formatter: function () {
	        return name;
	      },
	      formatterParams: formatterParams
	    }, tooltipOpt) : null;
	    textEl.__fullText = name;
	    textEl.anid = 'name';
	
	    if (axisModel.get('triggerEvent')) {
	      var eventData = AxisBuilder.makeAxisEventDataBase(axisModel);
	      eventData.targetType = 'axisName';
	      eventData.name = name;
	      innerStore_1.getECData(textEl).eventData = eventData;
	    }
	
	    transformGroup.add(textEl);
	    textEl.updateTransform();
	    group.add(textEl);
	    textEl.decomposeTransform();
	  }
	};
	
	function endTextLayout(rotation, textPosition, textRotate, extent) {
	  var rotationDiff = number_1.remRadian(textRotate - rotation);
	  var textAlign;
	  var textVerticalAlign;
	  var inverse = extent[0] > extent[1];
	  var onLeft = textPosition === 'start' && !inverse || textPosition !== 'start' && inverse;
	
	  if (number_1.isRadianAroundZero(rotationDiff - PI / 2)) {
	    textVerticalAlign = onLeft ? 'bottom' : 'top';
	    textAlign = 'center';
	  } else if (number_1.isRadianAroundZero(rotationDiff - PI * 1.5)) {
	    textVerticalAlign = onLeft ? 'top' : 'bottom';
	    textAlign = 'center';
	  } else {
	    textVerticalAlign = 'middle';
	
	    if (rotationDiff < PI * 1.5 && rotationDiff > PI / 2) {
	      textAlign = onLeft ? 'left' : 'right';
	    } else {
	      textAlign = onLeft ? 'right' : 'left';
	    }
	  }
	
	  return {
	    rotation: rotationDiff,
	    textAlign: textAlign,
	    textVerticalAlign: textVerticalAlign
	  };
	}
	
	function fixMinMaxLabelShow(axisModel, labelEls, tickEls) {
	  if (axisHelper_1.shouldShowAllLabels(axisModel.axis)) {
	    return;
	  }
	
	  var showMinLabel = axisModel.get(['axisLabel', 'showMinLabel']);
	  var showMaxLabel = axisModel.get(['axisLabel', 'showMaxLabel']);
	  labelEls = labelEls || [];
	  tickEls = tickEls || [];
	  var firstLabel = labelEls[0];
	  var nextLabel = labelEls[1];
	  var lastLabel = labelEls[labelEls.length - 1];
	  var prevLabel = labelEls[labelEls.length - 2];
	  var firstTick = tickEls[0];
	  var nextTick = tickEls[1];
	  var lastTick = tickEls[tickEls.length - 1];
	  var prevTick = tickEls[tickEls.length - 2];
	
	  if (showMinLabel === false) {
	    ignoreEl(firstLabel);
	    ignoreEl(firstTick);
	  } else if (isTwoLabelOverlapped(firstLabel, nextLabel)) {
	    if (showMinLabel) {
	      ignoreEl(nextLabel);
	      ignoreEl(nextTick);
	    } else {
	      ignoreEl(firstLabel);
	      ignoreEl(firstTick);
	    }
	  }
	
	  if (showMaxLabel === false) {
	    ignoreEl(lastLabel);
	    ignoreEl(lastTick);
	  } else if (isTwoLabelOverlapped(prevLabel, lastLabel)) {
	    if (showMaxLabel) {
	      ignoreEl(prevLabel);
	      ignoreEl(prevTick);
	    } else {
	      ignoreEl(lastLabel);
	      ignoreEl(lastTick);
	    }
	  }
	}
	
	function ignoreEl(el) {
	  el && (el.ignore = true);
	}
	
	function isTwoLabelOverlapped(current, next) {
	  var firstRect = current && current.getBoundingRect().clone();
	  var nextRect = next && next.getBoundingRect().clone();
	
	  if (!firstRect || !nextRect) {
	    return;
	  }
	
	  var mRotationBack = matrixUtil.identity([]);
	  matrixUtil.rotate(mRotationBack, mRotationBack, -current.rotation);
	  firstRect.applyTransform(matrixUtil.mul([], mRotationBack, current.getLocalTransform()));
	  nextRect.applyTransform(matrixUtil.mul([], mRotationBack, next.getLocalTransform()));
	  return firstRect.intersect(nextRect);
	}
	
	function isNameLocationCenter(nameLocation) {
	  return nameLocation === 'middle' || nameLocation === 'center';
	}
	
	function createTicks(ticksCoords, tickTransform, tickEndCoord, tickLineStyle, anidPrefix) {
	  var tickEls = [];
	  var pt1 = [];
	  var pt2 = [];
	
	  for (var i = 0; i < ticksCoords.length; i++) {
	    var tickCoord = ticksCoords[i].coord;
	    pt1[0] = tickCoord;
	    pt1[1] = 0;
	    pt2[0] = tickCoord;
	    pt2[1] = tickEndCoord;
	
	    if (tickTransform) {
	      vector_1.applyTransform(pt1, pt1, tickTransform);
	      vector_1.applyTransform(pt2, pt2, tickTransform);
	    }
	
	    var tickEl = new graphic.Line({
	      subPixelOptimize: true,
	      shape: {
	        x1: pt1[0],
	        y1: pt1[1],
	        x2: pt2[0],
	        y2: pt2[1]
	      },
	      style: tickLineStyle,
	      z2: 2,
	      autoBatch: true,
	      silent: true
	    });
	    tickEl.anid = anidPrefix + '_' + ticksCoords[i].tickValue;
	    tickEls.push(tickEl);
	  }
	
	  return tickEls;
	}
	
	function buildAxisMajorTicks(group, transformGroup, axisModel, opt) {
	  var axis = axisModel.axis;
	  var tickModel = axisModel.getModel('axisTick');
	  var shown = tickModel.get('show');
	
	  if (shown === 'auto' && opt.handleAutoShown) {
	    shown = opt.handleAutoShown('axisTick');
	  }
	
	  if (!shown || axis.scale.isBlank()) {
	    return;
	  }
	
	  var lineStyleModel = tickModel.getModel('lineStyle');
	  var tickEndCoord = opt.tickDirection * tickModel.get('length');
	  var ticksCoords = axis.getTicksCoords();
	  var ticksEls = createTicks(ticksCoords, transformGroup.transform, tickEndCoord, util_1.defaults(lineStyleModel.getLineStyle(), {
	    stroke: axisModel.get(['axisLine', 'lineStyle', 'color'])
	  }), 'ticks');
	
	  for (var i = 0; i < ticksEls.length; i++) {
	    group.add(ticksEls[i]);
	  }
	
	  return ticksEls;
	}
	
	function buildAxisMinorTicks(group, transformGroup, axisModel, tickDirection) {
	  var axis = axisModel.axis;
	  var minorTickModel = axisModel.getModel('minorTick');
	
	  if (!minorTickModel.get('show') || axis.scale.isBlank()) {
	    return;
	  }
	
	  var minorTicksCoords = axis.getMinorTicksCoords();
	
	  if (!minorTicksCoords.length) {
	    return;
	  }
	
	  var lineStyleModel = minorTickModel.getModel('lineStyle');
	  var tickEndCoord = tickDirection * minorTickModel.get('length');
	  var minorTickLineStyle = util_1.defaults(lineStyleModel.getLineStyle(), util_1.defaults(axisModel.getModel('axisTick').getLineStyle(), {
	    stroke: axisModel.get(['axisLine', 'lineStyle', 'color'])
	  }));
	
	  for (var i = 0; i < minorTicksCoords.length; i++) {
	    var minorTicksEls = createTicks(minorTicksCoords[i], transformGroup.transform, tickEndCoord, minorTickLineStyle, 'minorticks_' + i);
	
	    for (var k = 0; k < minorTicksEls.length; k++) {
	      group.add(minorTicksEls[k]);
	    }
	  }
	}
	
	function buildAxisLabel(group, transformGroup, axisModel, opt) {
	  var axis = axisModel.axis;
	  var show = util_1.retrieve(opt.axisLabelShow, axisModel.get(['axisLabel', 'show']));
	
	  if (!show || axis.scale.isBlank()) {
	    return;
	  }
	
	  var labelModel = axisModel.getModel('axisLabel');
	  var labelMargin = labelModel.get('margin');
	  var labels = axis.getViewLabels();
	  var labelRotation = (util_1.retrieve(opt.labelRotate, labelModel.get('rotate')) || 0) * PI / 180;
	  var labelLayout = AxisBuilder.innerTextLayout(opt.rotation, labelRotation, opt.labelDirection);
	  var rawCategoryData = axisModel.getCategories && axisModel.getCategories(true);
	  var labelEls = [];
	  var silent = AxisBuilder.isLabelSilent(axisModel);
	  var triggerEvent = axisModel.get('triggerEvent');
	  util_1.each(labels, function (labelItem, index) {
	    var tickValue = axis.scale.type === 'ordinal' ? axis.scale.getRawIndex(labelItem.tickValue) : labelItem.tickValue;
	    var formattedLabel = labelItem.formattedLabel;
	    var rawLabel = labelItem.rawLabel;
	    var itemLabelModel = labelModel;
	
	    if (rawCategoryData && rawCategoryData[tickValue]) {
	      var rawCategoryItem = rawCategoryData[tickValue];
	
	      if (util_1.isObject(rawCategoryItem) && rawCategoryItem.textStyle) {
	        itemLabelModel = new Model_1["default"](rawCategoryItem.textStyle, labelModel, axisModel.ecModel);
	      }
	    }
	
	    var textColor = itemLabelModel.getTextColor() || axisModel.get(['axisLine', 'lineStyle', 'color']);
	    var tickCoord = axis.dataToCoord(tickValue);
	    var textEl = new graphic.Text({
	      x: tickCoord,
	      y: opt.labelOffset + opt.labelDirection * labelMargin,
	      rotation: labelLayout.rotation,
	      silent: silent,
	      z2: 10,
	      style: labelStyle_1.createTextStyle(itemLabelModel, {
	        text: formattedLabel,
	        align: itemLabelModel.getShallow('align', true) || labelLayout.textAlign,
	        verticalAlign: itemLabelModel.getShallow('verticalAlign', true) || itemLabelModel.getShallow('baseline', true) || labelLayout.textVerticalAlign,
	        fill: typeof textColor === 'function' ? textColor(axis.type === 'category' ? rawLabel : axis.type === 'value' ? tickValue + '' : tickValue, index) : textColor
	      })
	    });
	    textEl.anid = 'label_' + tickValue;
	
	    if (triggerEvent) {
	      var eventData = AxisBuilder.makeAxisEventDataBase(axisModel);
	      eventData.targetType = 'axisLabel';
	      eventData.value = rawLabel;
	      innerStore_1.getECData(textEl).eventData = eventData;
	    }
	
	    transformGroup.add(textEl);
	    textEl.updateTransform();
	    labelEls.push(textEl);
	    group.add(textEl);
	    textEl.decomposeTransform();
	  });
	  return labelEls;
	}
	
	exports["default"] = AxisBuilder;

/***/ },
/* 132 */
/***/ function(module, exports, __webpack_require__) {

	
	/*
	* Licensed to the Apache Software Foundation (ASF) under one
	* or more contributor license agreements.  See the NOTICE file
	* distributed with this work for additional information
	* regarding copyright ownership.  The ASF licenses this file
	* to you under the Apache License, Version 2.0 (the
	* "License"); you may not use this file except in compliance
	* with the License.  You may obtain a copy of the License at
	*
	*   http://www.apache.org/licenses/LICENSE-2.0
	*
	* Unless required by applicable law or agreed to in writing,
	* software distributed under the License is distributed on an
	* "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
	* KIND, either express or implied.  See the License for the
	* specific language governing permissions and limitations
	* under the License.
	*/
	
	
	
	/**
	 * AUTO-GENERATED FILE. DO NOT MODIFY.
	 */
	
	"use strict";
	
	exports.__esModule = true;
	
	var tslib_1 = __webpack_require__(3);
	
	var axisPointerModelHelper = __webpack_require__(63);
	
	var Component_1 = __webpack_require__(18);
	
	var axisPointerClazz = {};
	
	var AxisView = function (_super) {
	  tslib_1.__extends(AxisView, _super);
	
	  function AxisView() {
	    var _this = _super !== null && _super.apply(this, arguments) || this;
	
	    _this.type = AxisView.type;
	    return _this;
	  }
	
	  AxisView.prototype.render = function (axisModel, ecModel, api, payload) {
	    this.axisPointerClass && axisPointerModelHelper.fixValue(axisModel);
	
	    _super.prototype.render.apply(this, arguments);
	
	    this._doUpdateAxisPointerClass(axisModel, api, true);
	  };
	
	  AxisView.prototype.updateAxisPointer = function (axisModel, ecModel, api, payload) {
	    this._doUpdateAxisPointerClass(axisModel, api, false);
	  };
	
	  AxisView.prototype.remove = function (ecModel, api) {
	    var axisPointer = this._axisPointer;
	    axisPointer && axisPointer.remove(api);
	  };
	
	  AxisView.prototype.dispose = function (ecModel, api) {
	    this._disposeAxisPointer(api);
	
	    _super.prototype.dispose.apply(this, arguments);
	  };
	
	  AxisView.prototype._doUpdateAxisPointerClass = function (axisModel, api, forceRender) {
	    var Clazz = AxisView.getAxisPointerClass(this.axisPointerClass);
	
	    if (!Clazz) {
	      return;
	    }
	
	    var axisPointerModel = axisPointerModelHelper.getAxisPointerModel(axisModel);
	    axisPointerModel ? (this._axisPointer || (this._axisPointer = new Clazz())).render(axisModel, axisPointerModel, api, forceRender) : this._disposeAxisPointer(api);
	  };
	
	  AxisView.prototype._disposeAxisPointer = function (api) {
	    this._axisPointer && this._axisPointer.dispose(api);
	    this._axisPointer = null;
	  };
	
	  AxisView.registerAxisPointerClass = function (type, clazz) {
	    if (false) {
	      if (axisPointerClazz[type]) {
	        throw new Error('axisPointer ' + type + ' exists');
	      }
	    }
	
	    axisPointerClazz[type] = clazz;
	  };
	
	  ;
	
	  AxisView.getAxisPointerClass = function (type) {
	    return type && axisPointerClazz[type];
	  };
	
	  ;
	  AxisView.type = 'axis';
	  return AxisView;
	}(Component_1["default"]);
	
	exports["default"] = AxisView;

/***/ },
/* 133 */
/***/ function(module, exports, __webpack_require__) {

	
	/*
	* Licensed to the Apache Software Foundation (ASF) under one
	* or more contributor license agreements.  See the NOTICE file
	* distributed with this work for additional information
	* regarding copyright ownership.  The ASF licenses this file
	* to you under the Apache License, Version 2.0 (the
	* "License"); you may not use this file except in compliance
	* with the License.  You may obtain a copy of the License at
	*
	*   http://www.apache.org/licenses/LICENSE-2.0
	*
	* Unless required by applicable law or agreed to in writing,
	* software distributed under the License is distributed on an
	* "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
	* KIND, either express or implied.  See the License for the
	* specific language governing permissions and limitations
	* under the License.
	*/
	
	
	
	/**
	 * AUTO-GENERATED FILE. DO NOT MODIFY.
	 */
	
	"use strict";
	
	exports.__esModule = true;
	
	var echarts = __webpack_require__(6);
	
	var zrUtil = __webpack_require__(1);
	
	var axisPointerModelHelper = __webpack_require__(63);
	
	var axisTrigger_1 = __webpack_require__(307);
	
	__webpack_require__(305);
	
	__webpack_require__(134);
	
	var AxisPointerModel_1 = __webpack_require__(304);
	
	var Component_1 = __webpack_require__(10);
	
	Component_1["default"].registerClass(AxisPointerModel_1["default"]);
	echarts.registerPreprocessor(function (option) {
	  if (option) {
	    (!option.axisPointer || option.axisPointer.length === 0) && (option.axisPointer = {});
	    var link = option.axisPointer.link;
	
	    if (link && !zrUtil.isArray(link)) {
	      option.axisPointer.link = [link];
	    }
	  }
	});
	echarts.registerProcessor(echarts.PRIORITY.PROCESSOR.STATISTIC, function (ecModel, api) {
	  ecModel.getComponent('axisPointer').coordSysAxesInfo = axisPointerModelHelper.collect(ecModel, api);
	});
	echarts.registerAction({
	  type: 'updateAxisPointer',
	  event: 'updateAxisPointer',
	  update: ':updateAxisPointer'
	}, axisTrigger_1["default"]);

/***/ },
/* 134 */
/***/ function(module, exports, __webpack_require__) {

	
	/*
	* Licensed to the Apache Software Foundation (ASF) under one
	* or more contributor license agreements.  See the NOTICE file
	* distributed with this work for additional information
	* regarding copyright ownership.  The ASF licenses this file
	* to you under the Apache License, Version 2.0 (the
	* "License"); you may not use this file except in compliance
	* with the License.  You may obtain a copy of the License at
	*
	*   http://www.apache.org/licenses/LICENSE-2.0
	*
	* Unless required by applicable law or agreed to in writing,
	* software distributed under the License is distributed on an
	* "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
	* KIND, either express or implied.  See the License for the
	* specific language governing permissions and limitations
	* under the License.
	*/
	
	
	
	/**
	 * AUTO-GENERATED FILE. DO NOT MODIFY.
	 */
	
	"use strict";
	
	exports.__esModule = true;
	
	var tslib_1 = __webpack_require__(3);
	
	var BaseAxisPointer_1 = __webpack_require__(306);
	
	var viewHelper = __webpack_require__(137);
	
	var cartesianAxisHelper = __webpack_require__(67);
	
	var AxisView_1 = __webpack_require__(132);
	
	var CartesianAxisPointer = function (_super) {
	  tslib_1.__extends(CartesianAxisPointer, _super);
	
	  function CartesianAxisPointer() {
	    return _super !== null && _super.apply(this, arguments) || this;
	  }
	
	  CartesianAxisPointer.prototype.makeElOption = function (elOption, value, axisModel, axisPointerModel, api) {
	    var axis = axisModel.axis;
	    var grid = axis.grid;
	    var axisPointerType = axisPointerModel.get('type');
	    var otherExtent = getCartesian(grid, axis).getOtherAxis(axis).getGlobalExtent();
	    var pixelValue = axis.toGlobalCoord(axis.dataToCoord(value, true));
	
	    if (axisPointerType && axisPointerType !== 'none') {
	      var elStyle = viewHelper.buildElStyle(axisPointerModel);
	      var pointerOption = pointerShapeBuilder[axisPointerType](axis, pixelValue, otherExtent);
	      pointerOption.style = elStyle;
	      elOption.graphicKey = pointerOption.type;
	      elOption.pointer = pointerOption;
	    }
	
	    var layoutInfo = cartesianAxisHelper.layout(grid.model, axisModel);
	    viewHelper.buildCartesianSingleLabelElOption(value, elOption, layoutInfo, axisModel, axisPointerModel, api);
	  };
	
	  CartesianAxisPointer.prototype.getHandleTransform = function (value, axisModel, axisPointerModel) {
	    var layoutInfo = cartesianAxisHelper.layout(axisModel.axis.grid.model, axisModel, {
	      labelInside: false
	    });
	    layoutInfo.labelMargin = axisPointerModel.get(['handle', 'margin']);
	    var pos = viewHelper.getTransformedPosition(axisModel.axis, value, layoutInfo);
	    return {
	      x: pos[0],
	      y: pos[1],
	      rotation: layoutInfo.rotation + (layoutInfo.labelDirection < 0 ? Math.PI : 0)
	    };
	  };
	
	  CartesianAxisPointer.prototype.updateHandleTransform = function (transform, delta, axisModel, axisPointerModel) {
	    var axis = axisModel.axis;
	    var grid = axis.grid;
	    var axisExtent = axis.getGlobalExtent(true);
	    var otherExtent = getCartesian(grid, axis).getOtherAxis(axis).getGlobalExtent();
	    var dimIndex = axis.dim === 'x' ? 0 : 1;
	    var currPosition = [transform.x, transform.y];
	    currPosition[dimIndex] += delta[dimIndex];
	    currPosition[dimIndex] = Math.min(axisExtent[1], currPosition[dimIndex]);
	    currPosition[dimIndex] = Math.max(axisExtent[0], currPosition[dimIndex]);
	    var cursorOtherValue = (otherExtent[1] + otherExtent[0]) / 2;
	    var cursorPoint = [cursorOtherValue, cursorOtherValue];
	    cursorPoint[dimIndex] = currPosition[dimIndex];
	    var tooltipOptions = [{
	      verticalAlign: 'middle'
	    }, {
	      align: 'center'
	    }];
	    return {
	      x: currPosition[0],
	      y: currPosition[1],
	      rotation: transform.rotation,
	      cursorPoint: cursorPoint,
	      tooltipOption: tooltipOptions[dimIndex]
	    };
	  };
	
	  return CartesianAxisPointer;
	}(BaseAxisPointer_1["default"]);
	
	function getCartesian(grid, axis) {
	  var opt = {};
	  opt[axis.dim + 'AxisIndex'] = axis.index;
	  return grid.getCartesian(opt);
	}
	
	var pointerShapeBuilder = {
	  line: function (axis, pixelValue, otherExtent) {
	    var targetShape = viewHelper.makeLineShape([pixelValue, otherExtent[0]], [pixelValue, otherExtent[1]], getAxisDimIndex(axis));
	    return {
	      type: 'Line',
	      subPixelOptimize: true,
	      shape: targetShape
	    };
	  },
	  shadow: function (axis, pixelValue, otherExtent) {
	    var bandWidth = Math.max(1, axis.getBandWidth());
	    var span = otherExtent[1] - otherExtent[0];
	    return {
	      type: 'Rect',
	      shape: viewHelper.makeRectShape([pixelValue - bandWidth / 2, otherExtent[0]], [bandWidth, span], getAxisDimIndex(axis))
	    };
	  }
	};
	
	function getAxisDimIndex(axis) {
	  return axis.dim === 'x' ? 0 : 1;
	}
	
	AxisView_1["default"].registerAxisPointerClass('CartesianAxisPointer', CartesianAxisPointer);
	exports["default"] = CartesianAxisPointer;

/***/ },
/* 135 */
/***/ function(module, exports, __webpack_require__) {

	
	/*
	* Licensed to the Apache Software Foundation (ASF) under one
	* or more contributor license agreements.  See the NOTICE file
	* distributed with this work for additional information
	* regarding copyright ownership.  The ASF licenses this file
	* to you under the Apache License, Version 2.0 (the
	* "License"); you may not use this file except in compliance
	* with the License.  You may obtain a copy of the License at
	*
	*   http://www.apache.org/licenses/LICENSE-2.0
	*
	* Unless required by applicable law or agreed to in writing,
	* software distributed under the License is distributed on an
	* "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
	* KIND, either express or implied.  See the License for the
	* specific language governing permissions and limitations
	* under the License.
	*/
	
	
	
	/**
	 * AUTO-GENERATED FILE. DO NOT MODIFY.
	 */
	
	"use strict";
	
	exports.__esModule = true;
	
	var zrUtil = __webpack_require__(1);
	
	var modelUtil = __webpack_require__(4);
	
	function findPointFromSeries(finder, ecModel) {
	  var point = [];
	  var seriesIndex = finder.seriesIndex;
	  var seriesModel;
	
	  if (seriesIndex == null || !(seriesModel = ecModel.getSeriesByIndex(seriesIndex))) {
	    return {
	      point: []
	    };
	  }
	
	  var data = seriesModel.getData();
	  var dataIndex = modelUtil.queryDataIndex(data, finder);
	
	  if (dataIndex == null || dataIndex < 0 || zrUtil.isArray(dataIndex)) {
	    return {
	      point: []
	    };
	  }
	
	  var el = data.getItemGraphicEl(dataIndex);
	  var coordSys = seriesModel.coordinateSystem;
	
	  if (seriesModel.getTooltipPosition) {
	    point = seriesModel.getTooltipPosition(dataIndex) || [];
	  } else if (coordSys && coordSys.dataToPoint) {
	    if (finder.isStacked) {
	      var baseAxis = coordSys.getBaseAxis();
	      var valueAxis = coordSys.getOtherAxis(baseAxis);
	      var valueAxisDim = valueAxis.dim;
	      var baseAxisDim = baseAxis.dim;
	      var baseDataOffset = valueAxisDim === 'x' || valueAxisDim === 'radius' ? 1 : 0;
	      var baseDim = data.mapDimension(baseAxisDim);
	      var stackedData = [];
	      stackedData[baseDataOffset] = data.get(baseDim, dataIndex);
	      stackedData[1 - baseDataOffset] = data.get(data.getCalculationInfo('stackResultDimension'), dataIndex);
	      point = coordSys.dataToPoint(stackedData) || [];
	    } else {
	      point = coordSys.dataToPoint(data.getValues(zrUtil.map(coordSys.dimensions, function (dim) {
	        return data.mapDimension(dim);
	      }), dataIndex)) || [];
	    }
	  } else if (el) {
	    var rect = el.getBoundingRect().clone();
	    rect.applyTransform(el.transform);
	    point = [rect.x + rect.width / 2, rect.y + rect.height / 2];
	  }
	
	  return {
	    point: point,
	    el: el
	  };
	}
	
	exports["default"] = findPointFromSeries;

/***/ },
/* 136 */
/***/ function(module, exports, __webpack_require__) {

	
	/*
	* Licensed to the Apache Software Foundation (ASF) under one
	* or more contributor license agreements.  See the NOTICE file
	* distributed with this work for additional information
	* regarding copyright ownership.  The ASF licenses this file
	* to you under the Apache License, Version 2.0 (the
	* "License"); you may not use this file except in compliance
	* with the License.  You may obtain a copy of the License at
	*
	*   http://www.apache.org/licenses/LICENSE-2.0
	*
	* Unless required by applicable law or agreed to in writing,
	* software distributed under the License is distributed on an
	* "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
	* KIND, either express or implied.  See the License for the
	* specific language governing permissions and limitations
	* under the License.
	*/
	
	
	
	/**
	 * AUTO-GENERATED FILE. DO NOT MODIFY.
	 */
	
	"use strict";
	
	exports.__esModule = true;
	
	var zrUtil = __webpack_require__(1);
	
	var env_1 = __webpack_require__(13);
	
	var model_1 = __webpack_require__(4);
	
	var inner = model_1.makeInner();
	var each = zrUtil.each;
	
	function register(key, api, handler) {
	  if (env_1["default"].node) {
	    return;
	  }
	
	  var zr = api.getZr();
	  inner(zr).records || (inner(zr).records = {});
	  initGlobalListeners(zr, api);
	  var record = inner(zr).records[key] || (inner(zr).records[key] = {});
	  record.handler = handler;
	}
	
	exports.register = register;
	
	function initGlobalListeners(zr, api) {
	  if (inner(zr).initialized) {
	    return;
	  }
	
	  inner(zr).initialized = true;
	  useHandler('click', zrUtil.curry(doEnter, 'click'));
	  useHandler('mousemove', zrUtil.curry(doEnter, 'mousemove'));
	  useHandler('globalout', onLeave);
	
	  function useHandler(eventType, cb) {
	    zr.on(eventType, function (e) {
	      var dis = makeDispatchAction(api);
	      each(inner(zr).records, function (record) {
	        record && cb(record, e, dis.dispatchAction);
	      });
	      dispatchTooltipFinally(dis.pendings, api);
	    });
	  }
	}
	
	function dispatchTooltipFinally(pendings, api) {
	  var showLen = pendings.showTip.length;
	  var hideLen = pendings.hideTip.length;
	  var actuallyPayload;
	
	  if (showLen) {
	    actuallyPayload = pendings.showTip[showLen - 1];
	  } else if (hideLen) {
	    actuallyPayload = pendings.hideTip[hideLen - 1];
	  }
	
	  if (actuallyPayload) {
	    actuallyPayload.dispatchAction = null;
	    api.dispatchAction(actuallyPayload);
	  }
	}
	
	function onLeave(record, e, dispatchAction) {
	  record.handler('leave', null, dispatchAction);
	}
	
	function doEnter(currTrigger, record, e, dispatchAction) {
	  record.handler(currTrigger, e, dispatchAction);
	}
	
	function makeDispatchAction(api) {
	  var pendings = {
	    showTip: [],
	    hideTip: []
	  };
	
	  var dispatchAction = function (payload) {
	    var pendingList = pendings[payload.type];
	
	    if (pendingList) {
	      pendingList.push(payload);
	    } else {
	      payload.dispatchAction = dispatchAction;
	      api.dispatchAction(payload);
	    }
	  };
	
	  return {
	    dispatchAction: dispatchAction,
	    pendings: pendings
	  };
	}
	
	function unregister(key, api) {
	  if (env_1["default"].node) {
	    return;
	  }
	
	  var zr = api.getZr();
	  var record = (inner(zr).records || {})[key];
	
	  if (record) {
	    inner(zr).records[key] = null;
	  }
	}
	
	exports.unregister = unregister;

/***/ },
/* 137 */
/***/ function(module, exports, __webpack_require__) {

	
	/*
	* Licensed to the Apache Software Foundation (ASF) under one
	* or more contributor license agreements.  See the NOTICE file
	* distributed with this work for additional information
	* regarding copyright ownership.  The ASF licenses this file
	* to you under the Apache License, Version 2.0 (the
	* "License"); you may not use this file except in compliance
	* with the License.  You may obtain a copy of the License at
	*
	*   http://www.apache.org/licenses/LICENSE-2.0
	*
	* Unless required by applicable law or agreed to in writing,
	* software distributed under the License is distributed on an
	* "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
	* KIND, either express or implied.  See the License for the
	* specific language governing permissions and limitations
	* under the License.
	*/
	
	
	
	/**
	 * AUTO-GENERATED FILE. DO NOT MODIFY.
	 */
	
	"use strict";
	
	exports.__esModule = true;
	
	var zrUtil = __webpack_require__(1);
	
	var graphic = __webpack_require__(7);
	
	var textContain = __webpack_require__(26);
	
	var formatUtil = __webpack_require__(29);
	
	var matrix = __webpack_require__(27);
	
	var axisHelper = __webpack_require__(39);
	
	var AxisBuilder_1 = __webpack_require__(131);
	
	var labelStyle_1 = __webpack_require__(20);
	
	function buildElStyle(axisPointerModel) {
	  var axisPointerType = axisPointerModel.get('type');
	  var styleModel = axisPointerModel.getModel(axisPointerType + 'Style');
	  var style;
	
	  if (axisPointerType === 'line') {
	    style = styleModel.getLineStyle();
	    style.fill = null;
	  } else if (axisPointerType === 'shadow') {
	    style = styleModel.getAreaStyle();
	    style.stroke = null;
	  }
	
	  return style;
	}
	
	exports.buildElStyle = buildElStyle;
	
	function buildLabelElOption(elOption, axisModel, axisPointerModel, api, labelPos) {
	  var value = axisPointerModel.get('value');
	  var text = getValueLabel(value, axisModel.axis, axisModel.ecModel, axisPointerModel.get('seriesDataIndices'), {
	    precision: axisPointerModel.get(['label', 'precision']),
	    formatter: axisPointerModel.get(['label', 'formatter'])
	  });
	  var labelModel = axisPointerModel.getModel('label');
	  var paddings = formatUtil.normalizeCssArray(labelModel.get('padding') || 0);
	  var font = labelModel.getFont();
	  var textRect = textContain.getBoundingRect(text, font);
	  var position = labelPos.position;
	  var width = textRect.width + paddings[1] + paddings[3];
	  var height = textRect.height + paddings[0] + paddings[2];
	  var align = labelPos.align;
	  align === 'right' && (position[0] -= width);
	  align === 'center' && (position[0] -= width / 2);
	  var verticalAlign = labelPos.verticalAlign;
	  verticalAlign === 'bottom' && (position[1] -= height);
	  verticalAlign === 'middle' && (position[1] -= height / 2);
	  confineInContainer(position, width, height, api);
	  var bgColor = labelModel.get('backgroundColor');
	
	  if (!bgColor || bgColor === 'auto') {
	    bgColor = axisModel.get(['axisLine', 'lineStyle', 'color']);
	  }
	
	  elOption.label = {
	    x: position[0],
	    y: position[1],
	    style: labelStyle_1.createTextStyle(labelModel, {
	      text: text,
	      font: font,
	      fill: labelModel.getTextColor(),
	      padding: paddings,
	      backgroundColor: bgColor
	    }),
	    z2: 10
	  };
	}
	
	exports.buildLabelElOption = buildLabelElOption;
	
	function confineInContainer(position, width, height, api) {
	  var viewWidth = api.getWidth();
	  var viewHeight = api.getHeight();
	  position[0] = Math.min(position[0] + width, viewWidth) - width;
	  position[1] = Math.min(position[1] + height, viewHeight) - height;
	  position[0] = Math.max(position[0], 0);
	  position[1] = Math.max(position[1], 0);
	}
	
	function getValueLabel(value, axis, ecModel, seriesDataIndices, opt) {
	  value = axis.scale.parse(value);
	  var text = axis.scale.getLabel({
	    value: value
	  }, {
	    precision: opt.precision
	  });
	  var formatter = opt.formatter;
	
	  if (formatter) {
	    var params_1 = {
	      value: axisHelper.getAxisRawValue(axis, {
	        value: value
	      }),
	      axisDimension: axis.dim,
	      axisIndex: axis.index,
	      seriesData: []
	    };
	    zrUtil.each(seriesDataIndices, function (idxItem) {
	      var series = ecModel.getSeriesByIndex(idxItem.seriesIndex);
	      var dataIndex = idxItem.dataIndexInside;
	      var dataParams = series && series.getDataParams(dataIndex);
	      dataParams && params_1.seriesData.push(dataParams);
	    });
	
	    if (zrUtil.isString(formatter)) {
	      text = formatter.replace('{value}', text);
	    } else if (zrUtil.isFunction(formatter)) {
	      text = formatter(params_1);
	    }
	  }
	
	  return text;
	}
	
	exports.getValueLabel = getValueLabel;
	
	function getTransformedPosition(axis, value, layoutInfo) {
	  var transform = matrix.create();
	  matrix.rotate(transform, transform, layoutInfo.rotation);
	  matrix.translate(transform, transform, layoutInfo.position);
	  return graphic.applyTransform([axis.dataToCoord(value), (layoutInfo.labelOffset || 0) + (layoutInfo.labelDirection || 1) * (layoutInfo.labelMargin || 0)], transform);
	}
	
	exports.getTransformedPosition = getTransformedPosition;
	
	function buildCartesianSingleLabelElOption(value, elOption, layoutInfo, axisModel, axisPointerModel, api) {
	  var textLayout = AxisBuilder_1["default"].innerTextLayout(layoutInfo.rotation, 0, layoutInfo.labelDirection);
	  layoutInfo.labelMargin = axisPointerModel.get(['label', 'margin']);
	  buildLabelElOption(elOption, axisModel, axisPointerModel, api, {
	    position: getTransformedPosition(axisModel.axis, value, layoutInfo),
	    align: textLayout.textAlign,
	    verticalAlign: textLayout.textVerticalAlign
	  });
	}
	
	exports.buildCartesianSingleLabelElOption = buildCartesianSingleLabelElOption;
	
	function makeLineShape(p1, p2, xDimIndex) {
	  xDimIndex = xDimIndex || 0;
	  return {
	    x1: p1[xDimIndex],
	    y1: p1[1 - xDimIndex],
	    x2: p2[xDimIndex],
	    y2: p2[1 - xDimIndex]
	  };
	}
	
	exports.makeLineShape = makeLineShape;
	
	function makeRectShape(xy, wh, xDimIndex) {
	  xDimIndex = xDimIndex || 0;
	  return {
	    x: xy[xDimIndex],
	    y: xy[1 - xDimIndex],
	    width: wh[xDimIndex],
	    height: wh[1 - xDimIndex]
	  };
	}
	
	exports.makeRectShape = makeRectShape;
	
	function makeSectorShape(cx, cy, r0, r, startAngle, endAngle) {
	  return {
	    cx: cx,
	    cy: cy,
	    r0: r0,
	    r: r,
	    startAngle: startAngle,
	    endAngle: endAngle,
	    clockwise: true
	  };
	}
	
	exports.makeSectorShape = makeSectorShape;

/***/ },
/* 138 */
/***/ function(module, exports, __webpack_require__) {

	
	/*
	* Licensed to the Apache Software Foundation (ASF) under one
	* or more contributor license agreements.  See the NOTICE file
	* distributed with this work for additional information
	* regarding copyright ownership.  The ASF licenses this file
	* to you under the Apache License, Version 2.0 (the
	* "License"); you may not use this file except in compliance
	* with the License.  You may obtain a copy of the License at
	*
	*   http://www.apache.org/licenses/LICENSE-2.0
	*
	* Unless required by applicable law or agreed to in writing,
	* software distributed under the License is distributed on an
	* "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
	* KIND, either express or implied.  See the License for the
	* specific language governing permissions and limitations
	* under the License.
	*/
	
	
	
	/**
	 * AUTO-GENERATED FILE. DO NOT MODIFY.
	 */
	
	"use strict";
	
	exports.__esModule = true;
	
	var echarts = __webpack_require__(6);
	
	var zrUtil = __webpack_require__(1);
	
	var helper_1 = __webpack_require__(45);
	
	echarts.registerAction('dataZoom', function (payload, ecModel) {
	  var effectedModels = helper_1.findEffectedDataZooms(ecModel, payload);
	  zrUtil.each(effectedModels, function (dataZoomModel) {
	    dataZoomModel.setRawRange({
	      start: payload.start,
	      end: payload.end,
	      startValue: payload.startValue,
	      endValue: payload.endValue
	    });
	  });
	});

/***/ },
/* 139 */
/***/ function(module, exports, __webpack_require__) {

	
	/*
	* Licensed to the Apache Software Foundation (ASF) under one
	* or more contributor license agreements.  See the NOTICE file
	* distributed with this work for additional information
	* regarding copyright ownership.  The ASF licenses this file
	* to you under the Apache License, Version 2.0 (the
	* "License"); you may not use this file except in compliance
	* with the License.  You may obtain a copy of the License at
	*
	*   http://www.apache.org/licenses/LICENSE-2.0
	*
	* Unless required by applicable law or agreed to in writing,
	* software distributed under the License is distributed on an
	* "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
	* KIND, either express or implied.  See the License for the
	* specific language governing permissions and limitations
	* under the License.
	*/
	
	
	
	/**
	 * AUTO-GENERATED FILE. DO NOT MODIFY.
	 */
	
	"use strict";
	
	exports.__esModule = true;
	
	var echarts = __webpack_require__(6);
	
	var util_1 = __webpack_require__(1);
	
	var helper_1 = __webpack_require__(45);
	
	var AxisProxy_1 = __webpack_require__(308);
	
	echarts.registerProcessor(echarts.PRIORITY.PROCESSOR.FILTER, {
	  getTargetSeries: function (ecModel) {
	    function eachAxisModel(cb) {
	      ecModel.eachComponent('dataZoom', function (dataZoomModel) {
	        dataZoomModel.eachTargetAxis(function (axisDim, axisIndex) {
	          var axisModel = ecModel.getComponent(helper_1.getAxisMainType(axisDim), axisIndex);
	          cb(axisDim, axisIndex, axisModel, dataZoomModel);
	        });
	      });
	    }
	
	    eachAxisModel(function (axisDim, axisIndex, axisModel, dataZoomModel) {
	      axisModel.__dzAxisProxy = null;
	    });
	    var proxyList = [];
	    eachAxisModel(function (axisDim, axisIndex, axisModel, dataZoomModel) {
	      if (!axisModel.__dzAxisProxy) {
	        axisModel.__dzAxisProxy = new AxisProxy_1["default"](axisDim, axisIndex, dataZoomModel, ecModel);
	        proxyList.push(axisModel.__dzAxisProxy);
	      }
	    });
	    var seriesModelMap = util_1.createHashMap();
	    util_1.each(proxyList, function (axisProxy) {
	      util_1.each(axisProxy.getTargetSeriesModels(), function (seriesModel) {
	        seriesModelMap.set(seriesModel.uid, seriesModel);
	      });
	    });
	    return seriesModelMap;
	  },
	  overallReset: function (ecModel, api) {
	    ecModel.eachComponent('dataZoom', function (dataZoomModel) {
	      dataZoomModel.eachTargetAxis(function (axisDim, axisIndex) {
	        dataZoomModel.getAxisProxy(axisDim, axisIndex).reset(dataZoomModel);
	      });
	      dataZoomModel.eachTargetAxis(function (axisDim, axisIndex) {
	        dataZoomModel.getAxisProxy(axisDim, axisIndex).filterData(dataZoomModel, api);
	      });
	    });
	    ecModel.eachComponent('dataZoom', function (dataZoomModel) {
	      var axisProxy = dataZoomModel.findRepresentativeAxisProxy();
	
	      if (axisProxy) {
	        var percentRange = axisProxy.getDataPercentWindow();
	        var valueRange = axisProxy.getDataValueWindow();
	        dataZoomModel.setCalculatedRange({
	          start: percentRange[0],
	          end: percentRange[1],
	          startValue: valueRange[0],
	          endValue: valueRange[1]
	        });
	      }
	    });
	  }
	});

/***/ },
/* 140 */
/***/ function(module, exports, __webpack_require__) {

	
	/*
	* Licensed to the Apache Software Foundation (ASF) under one
	* or more contributor license agreements.  See the NOTICE file
	* distributed with this work for additional information
	* regarding copyright ownership.  The ASF licenses this file
	* to you under the Apache License, Version 2.0 (the
	* "License"); you may not use this file except in compliance
	* with the License.  You may obtain a copy of the License at
	*
	*   http://www.apache.org/licenses/LICENSE-2.0
	*
	* Unless required by applicable law or agreed to in writing,
	* software distributed under the License is distributed on an
	* "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
	* KIND, either express or implied.  See the License for the
	* specific language governing permissions and limitations
	* under the License.
	*/
	
	
	
	/**
	 * AUTO-GENERATED FILE. DO NOT MODIFY.
	 */
	
	"use strict";
	
	exports.__esModule = true;
	
	var Component_1 = __webpack_require__(10);
	
	Component_1["default"].registerSubTypeDefaulter('dataZoom', function () {
	  return 'slider';
	});

/***/ },
/* 141 */
/***/ function(module, exports) {

	
	/*
	* Licensed to the Apache Software Foundation (ASF) under one
	* or more contributor license agreements.  See the NOTICE file
	* distributed with this work for additional information
	* regarding copyright ownership.  The ASF licenses this file
	* to you under the Apache License, Version 2.0 (the
	* "License"); you may not use this file except in compliance
	* with the License.  You may obtain a copy of the License at
	*
	*   http://www.apache.org/licenses/LICENSE-2.0
	*
	* Unless required by applicable law or agreed to in writing,
	* software distributed under the License is distributed on an
	* "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
	* KIND, either express or implied.  See the License for the
	* specific language governing permissions and limitations
	* under the License.
	*/
	
	
	
	/**
	 * AUTO-GENERATED FILE. DO NOT MODIFY.
	 */
	
	"use strict";
	
	exports.__esModule = true;
	
	function shouldTooltipConfine(tooltipModel) {
	  var confineOption = tooltipModel.get('confine');
	  return confineOption != null ? !!confineOption : tooltipModel.get('renderMode') === 'richText';
	}
	
	exports.shouldTooltipConfine = shouldTooltipConfine;

/***/ },
/* 142 */
/***/ function(module, exports, __webpack_require__) {

	
	/*
	* Licensed to the Apache Software Foundation (ASF) under one
	* or more contributor license agreements.  See the NOTICE file
	* distributed with this work for additional information
	* regarding copyright ownership.  The ASF licenses this file
	* to you under the Apache License, Version 2.0 (the
	* "License"); you may not use this file except in compliance
	* with the License.  You may obtain a copy of the License at
	*
	*   http://www.apache.org/licenses/LICENSE-2.0
	*
	* Unless required by applicable law or agreed to in writing,
	* software distributed under the License is distributed on an
	* "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
	* KIND, either express or implied.  See the License for the
	* specific language governing permissions and limitations
	* under the License.
	*/
	
	
	
	/**
	 * AUTO-GENERATED FILE. DO NOT MODIFY.
	 */
	
	"use strict";
	
	exports.__esModule = true;
	
	var tslib_1 = __webpack_require__(3);
	
	var zrUtil = __webpack_require__(1);
	
	var Component_1 = __webpack_require__(10);
	
	var axisModelCreator_1 = __webpack_require__(337);
	
	var axisModelCommonMixin_1 = __webpack_require__(336);
	
	var model_1 = __webpack_require__(4);
	
	var CartesianAxisModel = function (_super) {
	  tslib_1.__extends(CartesianAxisModel, _super);
	
	  function CartesianAxisModel() {
	    return _super !== null && _super.apply(this, arguments) || this;
	  }
	
	  CartesianAxisModel.prototype.getCoordSysModel = function () {
	    return this.getReferringComponents('grid', model_1.SINGLE_REFERRING).models[0];
	  };
	
	  CartesianAxisModel.type = 'cartesian2dAxis';
	  return CartesianAxisModel;
	}(Component_1["default"]);
	
	zrUtil.mixin(CartesianAxisModel, axisModelCommonMixin_1.AxisModelCommonMixin);
	var extraOption = {
	  offset: 0,
	  categorySortInfo: []
	};
	axisModelCreator_1["default"]('x', CartesianAxisModel, extraOption);
	axisModelCreator_1["default"]('y', CartesianAxisModel, extraOption);
	exports["default"] = CartesianAxisModel;

/***/ },
/* 143 */
/***/ function(module, exports, __webpack_require__) {

	
	/*
	* Licensed to the Apache Software Foundation (ASF) under one
	* or more contributor license agreements.  See the NOTICE file
	* distributed with this work for additional information
	* regarding copyright ownership.  The ASF licenses this file
	* to you under the Apache License, Version 2.0 (the
	* "License"); you may not use this file except in compliance
	* with the License.  You may obtain a copy of the License at
	*
	*   http://www.apache.org/licenses/LICENSE-2.0
	*
	* Unless required by applicable law or agreed to in writing,
	* software distributed under the License is distributed on an
	* "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
	* KIND, either express or implied.  See the License for the
	* specific language governing permissions and limitations
	* under the License.
	*/
	
	
	
	/**
	 * AUTO-GENERATED FILE. DO NOT MODIFY.
	 */
	
	"use strict";
	
	exports.__esModule = true;
	
	var zrUtil = __webpack_require__(1);
	
	var DataDimensionInfo = function () {
	  function DataDimensionInfo(opt) {
	    this.otherDims = {};
	
	    if (opt != null) {
	      zrUtil.extend(this, opt);
	    }
	  }
	
	  return DataDimensionInfo;
	}();
	
	;
	exports["default"] = DataDimensionInfo;

/***/ },
/* 144 */
/***/ function(module, exports, __webpack_require__) {

	
	/*
	* Licensed to the Apache Software Foundation (ASF) under one
	* or more contributor license agreements.  See the NOTICE file
	* distributed with this work for additional information
	* regarding copyright ownership.  The ASF licenses this file
	* to you under the Apache License, Version 2.0 (the
	* "License"); you may not use this file except in compliance
	* with the License.  You may obtain a copy of the License at
	*
	*   http://www.apache.org/licenses/LICENSE-2.0
	*
	* Unless required by applicable law or agreed to in writing,
	* software distributed under the License is distributed on an
	* "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
	* KIND, either express or implied.  See the License for the
	* specific language governing permissions and limitations
	* under the License.
	*/
	
	
	
	/**
	 * AUTO-GENERATED FILE. DO NOT MODIFY.
	 */
	
	"use strict";
	
	exports.__esModule = true;
	
	var zrUtil = __webpack_require__(1);
	
	var Model_1 = __webpack_require__(24);
	
	var DataDiffer_1 = __webpack_require__(346);
	
	var dataProvider_1 = __webpack_require__(53);
	
	var dimensionHelper_1 = __webpack_require__(146);
	
	var DataDimensionInfo_1 = __webpack_require__(143);
	
	var types_1 = __webpack_require__(25);
	
	var model_1 = __webpack_require__(4);
	
	var innerStore_1 = __webpack_require__(21);
	
	var dataValueHelper_1 = __webpack_require__(89);
	
	var Source_1 = __webpack_require__(47);
	
	var mathFloor = Math.floor;
	var isObject = zrUtil.isObject;
	var map = zrUtil.map;
	var UNDEFINED = 'undefined';
	var INDEX_NOT_FOUND = -1;
	var ID_PREFIX = 'e\0\0';
	var dataCtors = {
	  'float': typeof Float64Array === UNDEFINED ? Array : Float64Array,
	  'int': typeof Int32Array === UNDEFINED ? Array : Int32Array,
	  'ordinal': Array,
	  'number': Array,
	  'time': Array
	};
	var CtorUint32Array = typeof Uint32Array === UNDEFINED ? Array : Uint32Array;
	var CtorInt32Array = typeof Int32Array === UNDEFINED ? Array : Int32Array;
	var CtorUint16Array = typeof Uint16Array === UNDEFINED ? Array : Uint16Array;
	var TRANSFERABLE_PROPERTIES = ['hasItemOption', '_nameList', '_idList', '_invertedIndicesMap', '_rawData', '_dimValueGetter', '_count', '_rawCount', '_nameDimIdx', '_idDimIdx', '_nameRepeatCount'];
	var CLONE_PROPERTIES = ['_extent', '_approximateExtent', '_rawExtent'];
	var defaultDimValueGetters;
	var prepareInvertedIndex;
	var getIndicesCtor;
	var prepareStorage;
	var getRawIndexWithoutIndices;
	var getRawIndexWithIndices;
	var getId;
	var getIdNameFromStore;
	var makeIdFromName;
	var normalizeDimensions;
	var validateDimensions;
	var cloneListForMapAndSample;
	var getInitialExtent;
	var setItemDataAndSeriesIndex;
	var transferProperties;
	
	var List = function () {
	  function List(dimensions, hostModel) {
	    this.type = 'list';
	    this._count = 0;
	    this._rawCount = 0;
	    this._storage = {};
	    this._storageArr = [];
	    this._nameList = [];
	    this._idList = [];
	    this._visual = {};
	    this._layout = {};
	    this._itemVisuals = [];
	    this._itemLayouts = [];
	    this._graphicEls = [];
	    this._rawExtent = {};
	    this._extent = {};
	    this._approximateExtent = {};
	    this._calculationInfo = {};
	    this.hasItemOption = true;
	    this.TRANSFERABLE_METHODS = ['cloneShallow', 'downSample', 'lttbDownSample', 'map'];
	    this.CHANGABLE_METHODS = ['filterSelf', 'selectRange'];
	    this.DOWNSAMPLE_METHODS = ['downSample', 'lttbDownSample'];
	    this.getRawIndex = getRawIndexWithoutIndices;
	    dimensions = dimensions || ['x', 'y'];
	    var dimensionInfos = {};
	    var dimensionNames = [];
	    var invertedIndicesMap = {};
	
	    for (var i = 0; i < dimensions.length; i++) {
	      var dimInfoInput = dimensions[i];
	      var dimensionInfo = zrUtil.isString(dimInfoInput) ? new DataDimensionInfo_1["default"]({
	        name: dimInfoInput
	      }) : !(dimInfoInput instanceof DataDimensionInfo_1["default"]) ? new DataDimensionInfo_1["default"](dimInfoInput) : dimInfoInput;
	      var dimensionName = dimensionInfo.name;
	      dimensionInfo.type = dimensionInfo.type || 'float';
	
	      if (!dimensionInfo.coordDim) {
	        dimensionInfo.coordDim = dimensionName;
	        dimensionInfo.coordDimIndex = 0;
	      }
	
	      var otherDims = dimensionInfo.otherDims = dimensionInfo.otherDims || {};
	      dimensionNames.push(dimensionName);
	      dimensionInfos[dimensionName] = dimensionInfo;
	      dimensionInfo.index = i;
	
	      if (dimensionInfo.createInvertedIndices) {
	        invertedIndicesMap[dimensionName] = [];
	      }
	
	      if (otherDims.itemName === 0) {
	        this._nameDimIdx = i;
	        this._nameOrdinalMeta = dimensionInfo.ordinalMeta;
	      }
	
	      if (otherDims.itemId === 0) {
	        this._idDimIdx = i;
	        this._idOrdinalMeta = dimensionInfo.ordinalMeta;
	      }
	    }
	
	    this.dimensions = dimensionNames;
	    this._dimensionInfos = dimensionInfos;
	    this.hostModel = hostModel;
	    this._dimensionsSummary = dimensionHelper_1.summarizeDimensions(this);
	    this._invertedIndicesMap = invertedIndicesMap;
	    this.userOutput = this._dimensionsSummary.userOutput;
	  }
	
	  List.prototype.getDimension = function (dim) {
	    if (typeof dim === 'number' || !isNaN(dim) && !this._dimensionInfos.hasOwnProperty(dim)) {
	      dim = this.dimensions[dim];
	    }
	
	    return dim;
	  };
	
	  List.prototype.getDimensionInfo = function (dim) {
	    return this._dimensionInfos[this.getDimension(dim)];
	  };
	
	  List.prototype.getDimensionsOnCoord = function () {
	    return this._dimensionsSummary.dataDimsOnCoord.slice();
	  };
	
	  List.prototype.mapDimension = function (coordDim, idx) {
	    var dimensionsSummary = this._dimensionsSummary;
	
	    if (idx == null) {
	      return dimensionsSummary.encodeFirstDimNotExtra[coordDim];
	    }
	
	    var dims = dimensionsSummary.encode[coordDim];
	    return dims ? dims[idx] : null;
	  };
	
	  List.prototype.mapDimensionsAll = function (coordDim) {
	    var dimensionsSummary = this._dimensionsSummary;
	    var dims = dimensionsSummary.encode[coordDim];
	    return (dims || []).slice();
	  };
	
	  List.prototype.initData = function (data, nameList, dimValueGetter) {
	    var notProvider = Source_1.isSourceInstance(data) || zrUtil.isArrayLike(data);
	    var provider = notProvider ? new dataProvider_1.DefaultDataProvider(data, this.dimensions.length) : data;
	
	    if (false) {
	      zrUtil.assert(notProvider || zrUtil.isFunction(provider.getItem) && zrUtil.isFunction(provider.count), 'Inavlid data provider.');
	    }
	
	    this._rawData = provider;
	    var sourceFormat = provider.getSource().sourceFormat;
	    this._storage = {};
	    this._indices = null;
	    this._dontMakeIdFromName = this._idDimIdx != null || sourceFormat === types_1.SOURCE_FORMAT_TYPED_ARRAY || !!provider.fillStorage;
	    this._nameList = (nameList || []).slice();
	    this._idList = [];
	    this._nameRepeatCount = {};
	
	    if (!dimValueGetter) {
	      this.hasItemOption = false;
	    }
	
	    this.defaultDimValueGetter = defaultDimValueGetters[sourceFormat];
	    this._dimValueGetter = dimValueGetter = dimValueGetter || this.defaultDimValueGetter;
	    this._dimValueGetterArrayRows = defaultDimValueGetters.arrayRows;
	    this._rawExtent = {};
	
	    this._initDataFromProvider(0, provider.count());
	
	    if (provider.pure) {
	      this.hasItemOption = false;
	    }
	  };
	
	  List.prototype.getProvider = function () {
	    return this._rawData;
	  };
	
	  List.prototype.appendData = function (data) {
	    if (false) {
	      zrUtil.assert(!this._indices, 'appendData can only be called on raw data.');
	    }
	
	    var rawData = this._rawData;
	    var start = this.count();
	    rawData.appendData(data);
	    var end = rawData.count();
	
	    if (!rawData.persistent) {
	      end += start;
	    }
	
	    this._initDataFromProvider(start, end, true);
	  };
	
	  List.prototype.appendValues = function (values, names) {
	    var storage = this._storage;
	    var dimensions = this.dimensions;
	    var dimLen = dimensions.length;
	    var rawExtent = this._rawExtent;
	    var start = this.count();
	    var end = start + Math.max(values.length, names ? names.length : 0);
	
	    for (var i = 0; i < dimLen; i++) {
	      var dim = dimensions[i];
	
	      if (!rawExtent[dim]) {
	        rawExtent[dim] = getInitialExtent();
	      }
	
	      prepareStorage(storage, this._dimensionInfos[dim], end, true);
	    }
	
	    var rawExtentArr = map(dimensions, function (dim) {
	      return rawExtent[dim];
	    });
	    var storageArr = this._storageArr = map(dimensions, function (dim) {
	      return storage[dim];
	    });
	    var emptyDataItem = [];
	
	    for (var idx = start; idx < end; idx++) {
	      var sourceIdx = idx - start;
	
	      for (var dimIdx = 0; dimIdx < dimLen; dimIdx++) {
	        var dim = dimensions[dimIdx];
	
	        var val = this._dimValueGetterArrayRows(values[sourceIdx] || emptyDataItem, dim, sourceIdx, dimIdx);
	
	        storageArr[dimIdx][idx] = val;
	        var dimRawExtent = rawExtentArr[dimIdx];
	        val < dimRawExtent[0] && (dimRawExtent[0] = val);
	        val > dimRawExtent[1] && (dimRawExtent[1] = val);
	      }
	
	      if (names) {
	        this._nameList[idx] = names[sourceIdx];
	
	        if (!this._dontMakeIdFromName) {
	          makeIdFromName(this, idx);
	        }
	      }
	    }
	
	    this._rawCount = this._count = end;
	    this._extent = {};
	    prepareInvertedIndex(this);
	  };
	
	  List.prototype._initDataFromProvider = function (start, end, append) {
	    if (start >= end) {
	      return;
	    }
	
	    var rawData = this._rawData;
	    var storage = this._storage;
	    var dimensions = this.dimensions;
	    var dimLen = dimensions.length;
	    var dimensionInfoMap = this._dimensionInfos;
	    var nameList = this._nameList;
	    var idList = this._idList;
	    var rawExtent = this._rawExtent;
	    var sourceFormat = rawData.getSource().sourceFormat;
	    var isFormatOriginal = sourceFormat === types_1.SOURCE_FORMAT_ORIGINAL;
	
	    for (var i = 0; i < dimLen; i++) {
	      var dim = dimensions[i];
	
	      if (!rawExtent[dim]) {
	        rawExtent[dim] = getInitialExtent();
	      }
	
	      prepareStorage(storage, dimensionInfoMap[dim], end, append);
	    }
	
	    var storageArr = this._storageArr = map(dimensions, function (dim) {
	      return storage[dim];
	    });
	    var rawExtentArr = map(dimensions, function (dim) {
	      return rawExtent[dim];
	    });
	
	    if (rawData.fillStorage) {
	      rawData.fillStorage(start, end, storageArr, rawExtentArr);
	    } else {
	      var dataItem = [];
	
	      for (var idx = start; idx < end; idx++) {
	        dataItem = rawData.getItem(idx, dataItem);
	
	        for (var dimIdx = 0; dimIdx < dimLen; dimIdx++) {
	          var dim = dimensions[dimIdx];
	          var dimStorage = storageArr[dimIdx];
	
	          var val = this._dimValueGetter(dataItem, dim, idx, dimIdx);
	
	          dimStorage[idx] = val;
	          var dimRawExtent = rawExtentArr[dimIdx];
	          val < dimRawExtent[0] && (dimRawExtent[0] = val);
	          val > dimRawExtent[1] && (dimRawExtent[1] = val);
	        }
	
	        if (isFormatOriginal && !rawData.pure && dataItem) {
	          var itemName = dataItem.name;
	
	          if (nameList[idx] == null && itemName != null) {
	            nameList[idx] = model_1.convertOptionIdName(itemName, null);
	          }
	
	          var itemId = dataItem.id;
	
	          if (idList[idx] == null && itemId != null) {
	            idList[idx] = model_1.convertOptionIdName(itemId, null);
	          }
	        }
	
	        if (!this._dontMakeIdFromName) {
	          makeIdFromName(this, idx);
	        }
	      }
	    }
	
	    if (!rawData.persistent && rawData.clean) {
	      rawData.clean();
	    }
	
	    this._rawCount = this._count = end;
	    this._extent = {};
	    prepareInvertedIndex(this);
	  };
	
	  List.prototype.count = function () {
	    return this._count;
	  };
	
	  List.prototype.getIndices = function () {
	    var newIndices;
	    var indices = this._indices;
	
	    if (indices) {
	      var Ctor = indices.constructor;
	      var thisCount = this._count;
	
	      if (Ctor === Array) {
	        newIndices = new Ctor(thisCount);
	
	        for (var i = 0; i < thisCount; i++) {
	          newIndices[i] = indices[i];
	        }
	      } else {
	        newIndices = new Ctor(indices.buffer, 0, thisCount);
	      }
	    } else {
	      var Ctor = getIndicesCtor(this);
	      newIndices = new Ctor(this.count());
	
	      for (var i = 0; i < newIndices.length; i++) {
	        newIndices[i] = i;
	      }
	    }
	
	    return newIndices;
	  };
	
	  List.prototype.getByDimIdx = function (dimIdx, idx) {
	    if (!(idx >= 0 && idx < this._count)) {
	      return NaN;
	    }
	
	    var dimStore = this._storageArr[dimIdx];
	    return dimStore ? dimStore[this.getRawIndex(idx)] : NaN;
	  };
	
	  List.prototype.get = function (dim, idx) {
	    if (!(idx >= 0 && idx < this._count)) {
	      return NaN;
	    }
	
	    var dimStore = this._storage[dim];
	    return dimStore ? dimStore[this.getRawIndex(idx)] : NaN;
	  };
	
	  List.prototype.getByRawIndex = function (dim, rawIdx) {
	    if (!(rawIdx >= 0 && rawIdx < this._rawCount)) {
	      return NaN;
	    }
	
	    var dimStore = this._storage[dim];
	    return dimStore ? dimStore[rawIdx] : NaN;
	  };
	
	  List.prototype.getValues = function (dimensions, idx) {
	    var values = [];
	
	    if (!zrUtil.isArray(dimensions)) {
	      idx = dimensions;
	      dimensions = this.dimensions;
	    }
	
	    for (var i = 0, len = dimensions.length; i < len; i++) {
	      values.push(this.get(dimensions[i], idx));
	    }
	
	    return values;
	  };
	
	  List.prototype.hasValue = function (idx) {
	    var dataDimsOnCoord = this._dimensionsSummary.dataDimsOnCoord;
	
	    for (var i = 0, len = dataDimsOnCoord.length; i < len; i++) {
	      if (isNaN(this.get(dataDimsOnCoord[i], idx))) {
	        return false;
	      }
	    }
	
	    return true;
	  };
	
	  List.prototype.getDataExtent = function (dim) {
	    dim = this.getDimension(dim);
	    var dimData = this._storage[dim];
	    var initialExtent = getInitialExtent();
	
	    if (!dimData) {
	      return initialExtent;
	    }
	
	    var currEnd = this.count();
	    var useRaw = !this._indices;
	    var dimExtent;
	
	    if (useRaw) {
	      return this._rawExtent[dim].slice();
	    }
	
	    dimExtent = this._extent[dim];
	
	    if (dimExtent) {
	      return dimExtent.slice();
	    }
	
	    dimExtent = initialExtent;
	    var min = dimExtent[0];
	    var max = dimExtent[1];
	
	    for (var i = 0; i < currEnd; i++) {
	      var rawIdx = this.getRawIndex(i);
	      var value = dimData[rawIdx];
	      value < min && (min = value);
	      value > max && (max = value);
	    }
	
	    dimExtent = [min, max];
	    this._extent[dim] = dimExtent;
	    return dimExtent;
	  };
	
	  List.prototype.getApproximateExtent = function (dim) {
	    dim = this.getDimension(dim);
	    return this._approximateExtent[dim] || this.getDataExtent(dim);
	  };
	
	  List.prototype.setApproximateExtent = function (extent, dim) {
	    dim = this.getDimension(dim);
	    this._approximateExtent[dim] = extent.slice();
	  };
	
	  List.prototype.getCalculationInfo = function (key) {
	    return this._calculationInfo[key];
	  };
	
	  List.prototype.setCalculationInfo = function (key, value) {
	    isObject(key) ? zrUtil.extend(this._calculationInfo, key) : this._calculationInfo[key] = value;
	  };
	
	  List.prototype.getSum = function (dim) {
	    var dimData = this._storage[dim];
	    var sum = 0;
	
	    if (dimData) {
	      for (var i = 0, len = this.count(); i < len; i++) {
	        var value = this.get(dim, i);
	
	        if (!isNaN(value)) {
	          sum += value;
	        }
	      }
	    }
	
	    return sum;
	  };
	
	  List.prototype.getMedian = function (dim) {
	    var dimDataArray = [];
	    this.each(dim, function (val) {
	      if (!isNaN(val)) {
	        dimDataArray.push(val);
	      }
	    });
	    var sortedDimDataArray = dimDataArray.sort(function (a, b) {
	      return a - b;
	    });
	    var len = this.count();
	    return len === 0 ? 0 : len % 2 === 1 ? sortedDimDataArray[(len - 1) / 2] : (sortedDimDataArray[len / 2] + sortedDimDataArray[len / 2 - 1]) / 2;
	  };
	
	  List.prototype.rawIndexOf = function (dim, value) {
	    var invertedIndices = dim && this._invertedIndicesMap[dim];
	
	    if (false) {
	      if (!invertedIndices) {
	        throw new Error('Do not supported yet');
	      }
	    }
	
	    var rawIndex = invertedIndices[value];
	
	    if (rawIndex == null || isNaN(rawIndex)) {
	      return INDEX_NOT_FOUND;
	    }
	
	    return rawIndex;
	  };
	
	  List.prototype.indexOfName = function (name) {
	    for (var i = 0, len = this.count(); i < len; i++) {
	      if (this.getName(i) === name) {
	        return i;
	      }
	    }
	
	    return -1;
	  };
	
	  List.prototype.indexOfRawIndex = function (rawIndex) {
	    if (rawIndex >= this._rawCount || rawIndex < 0) {
	      return -1;
	    }
	
	    if (!this._indices) {
	      return rawIndex;
	    }
	
	    var indices = this._indices;
	    var rawDataIndex = indices[rawIndex];
	
	    if (rawDataIndex != null && rawDataIndex < this._count && rawDataIndex === rawIndex) {
	      return rawIndex;
	    }
	
	    var left = 0;
	    var right = this._count - 1;
	
	    while (left <= right) {
	      var mid = (left + right) / 2 | 0;
	
	      if (indices[mid] < rawIndex) {
	        left = mid + 1;
	      } else if (indices[mid] > rawIndex) {
	        right = mid - 1;
	      } else {
	        return mid;
	      }
	    }
	
	    return -1;
	  };
	
	  List.prototype.indicesOfNearest = function (dim, value, maxDistance) {
	    var storage = this._storage;
	    var dimData = storage[dim];
	    var nearestIndices = [];
	
	    if (!dimData) {
	      return nearestIndices;
	    }
	
	    if (maxDistance == null) {
	      maxDistance = Infinity;
	    }
	
	    var minDist = Infinity;
	    var minDiff = -1;
	    var nearestIndicesLen = 0;
	
	    for (var i = 0, len = this.count(); i < len; i++) {
	      var dataIndex = this.getRawIndex(i);
	      var diff = value - dimData[dataIndex];
	      var dist = Math.abs(diff);
	
	      if (dist <= maxDistance) {
	        if (dist < minDist || dist === minDist && diff >= 0 && minDiff < 0) {
	          minDist = dist;
	          minDiff = diff;
	          nearestIndicesLen = 0;
	        }
	
	        if (diff === minDiff) {
	          nearestIndices[nearestIndicesLen++] = i;
	        }
	      }
	    }
	
	    nearestIndices.length = nearestIndicesLen;
	    return nearestIndices;
	  };
	
	  List.prototype.getRawDataItem = function (idx) {
	    if (!this._rawData.persistent) {
	      var val = [];
	
	      for (var i = 0; i < this.dimensions.length; i++) {
	        var dim = this.dimensions[i];
	        val.push(this.get(dim, idx));
	      }
	
	      return val;
	    } else {
	      return this._rawData.getItem(this.getRawIndex(idx));
	    }
	  };
	
	  List.prototype.getName = function (idx) {
	    var rawIndex = this.getRawIndex(idx);
	    var name = this._nameList[rawIndex];
	
	    if (name == null && this._nameDimIdx != null) {
	      name = getIdNameFromStore(this, this._nameDimIdx, this._nameOrdinalMeta, rawIndex);
	    }
	
	    if (name == null) {
	      name = '';
	    }
	
	    return name;
	  };
	
	  List.prototype.getId = function (idx) {
	    return getId(this, this.getRawIndex(idx));
	  };
	
	  List.prototype.each = function (dims, cb, ctx, ctxCompat) {
	    'use strict';
	
	    var _this = this;
	
	    if (!this._count) {
	      return;
	    }
	
	    if (typeof dims === 'function') {
	      ctxCompat = ctx;
	      ctx = cb;
	      cb = dims;
	      dims = [];
	    }
	
	    var fCtx = ctx || ctxCompat || this;
	    var dimNames = map(normalizeDimensions(dims), this.getDimension, this);
	
	    if (false) {
	      validateDimensions(this, dimNames);
	    }
	
	    var dimSize = dimNames.length;
	    var dimIndices = map(dimNames, function (dimName) {
	      return _this._dimensionInfos[dimName].index;
	    });
	    var storageArr = this._storageArr;
	
	    for (var i = 0, len = this.count(); i < len; i++) {
	      var rawIdx = this.getRawIndex(i);
	
	      switch (dimSize) {
	        case 0:
	          cb.call(fCtx, i);
	          break;
	
	        case 1:
	          cb.call(fCtx, storageArr[dimIndices[0]][rawIdx], i);
	          break;
	
	        case 2:
	          cb.call(fCtx, storageArr[dimIndices[0]][rawIdx], storageArr[dimIndices[1]][rawIdx], i);
	          break;
	
	        default:
	          var k = 0;
	          var value = [];
	
	          for (; k < dimSize; k++) {
	            value[k] = storageArr[dimIndices[k]][rawIdx];
	          }
	
	          value[k] = i;
	          cb.apply(fCtx, value);
	      }
	    }
	  };
	
	  List.prototype.filterSelf = function (dims, cb, ctx, ctxCompat) {
	    'use strict';
	
	    var _this = this;
	
	    if (!this._count) {
	      return;
	    }
	
	    if (typeof dims === 'function') {
	      ctxCompat = ctx;
	      ctx = cb;
	      cb = dims;
	      dims = [];
	    }
	
	    var fCtx = ctx || ctxCompat || this;
	    var dimNames = map(normalizeDimensions(dims), this.getDimension, this);
	
	    if (false) {
	      validateDimensions(this, dimNames);
	    }
	
	    var count = this.count();
	    var Ctor = getIndicesCtor(this);
	    var newIndices = new Ctor(count);
	    var value = [];
	    var dimSize = dimNames.length;
	    var offset = 0;
	    var dimIndices = map(dimNames, function (dimName) {
	      return _this._dimensionInfos[dimName].index;
	    });
	    var dim0 = dimIndices[0];
	    var storageArr = this._storageArr;
	
	    for (var i = 0; i < count; i++) {
	      var keep = void 0;
	      var rawIdx = this.getRawIndex(i);
	
	      if (dimSize === 0) {
	        keep = cb.call(fCtx, i);
	      } else if (dimSize === 1) {
	        var val = storageArr[dim0][rawIdx];
	        keep = cb.call(fCtx, val, i);
	      } else {
	        var k = 0;
	
	        for (; k < dimSize; k++) {
	          value[k] = storageArr[dimIndices[k]][rawIdx];
	        }
	
	        value[k] = i;
	        keep = cb.apply(fCtx, value);
	      }
	
	      if (keep) {
	        newIndices[offset++] = rawIdx;
	      }
	    }
	
	    if (offset < count) {
	      this._indices = newIndices;
	    }
	
	    this._count = offset;
	    this._extent = {};
	    this.getRawIndex = this._indices ? getRawIndexWithIndices : getRawIndexWithoutIndices;
	    return this;
	  };
	
	  List.prototype.selectRange = function (range) {
	    'use strict';
	
	    var _this = this;
	
	    var len = this._count;
	
	    if (!len) {
	      return;
	    }
	
	    var dimensions = [];
	
	    for (var dim in range) {
	      if (range.hasOwnProperty(dim)) {
	        dimensions.push(dim);
	      }
	    }
	
	    if (false) {
	      validateDimensions(this, dimensions);
	    }
	
	    var dimSize = dimensions.length;
	
	    if (!dimSize) {
	      return;
	    }
	
	    var originalCount = this.count();
	    var Ctor = getIndicesCtor(this);
	    var newIndices = new Ctor(originalCount);
	    var offset = 0;
	    var dim0 = dimensions[0];
	    var dimIndices = map(dimensions, function (dimName) {
	      return _this._dimensionInfos[dimName].index;
	    });
	    var min = range[dim0][0];
	    var max = range[dim0][1];
	    var storageArr = this._storageArr;
	    var quickFinished = false;
	
	    if (!this._indices) {
	      var idx = 0;
	
	      if (dimSize === 1) {
	        var dimStorage = storageArr[dimIndices[0]];
	
	        for (var i = 0; i < len; i++) {
	          var val = dimStorage[i];
	
	          if (val >= min && val <= max || isNaN(val)) {
	            newIndices[offset++] = idx;
	          }
	
	          idx++;
	        }
	
	        quickFinished = true;
	      } else if (dimSize === 2) {
	        var dimStorage = storageArr[dimIndices[0]];
	        var dimStorage2 = storageArr[dimIndices[1]];
	        var min2 = range[dimensions[1]][0];
	        var max2 = range[dimensions[1]][1];
	
	        for (var i = 0; i < len; i++) {
	          var val = dimStorage[i];
	          var val2 = dimStorage2[i];
	
	          if ((val >= min && val <= max || isNaN(val)) && (val2 >= min2 && val2 <= max2 || isNaN(val2))) {
	            newIndices[offset++] = idx;
	          }
	
	          idx++;
	        }
	
	        quickFinished = true;
	      }
	    }
	
	    if (!quickFinished) {
	      if (dimSize === 1) {
	        for (var i = 0; i < originalCount; i++) {
	          var rawIndex = this.getRawIndex(i);
	          var val = storageArr[dimIndices[0]][rawIndex];
	
	          if (val >= min && val <= max || isNaN(val)) {
	            newIndices[offset++] = rawIndex;
	          }
	        }
	      } else {
	        for (var i = 0; i < originalCount; i++) {
	          var keep = true;
	          var rawIndex = this.getRawIndex(i);
	
	          for (var k = 0; k < dimSize; k++) {
	            var dimk = dimensions[k];
	            var val = storageArr[dimIndices[k]][rawIndex];
	
	            if (val < range[dimk][0] || val > range[dimk][1]) {
	              keep = false;
	            }
	          }
	
	          if (keep) {
	            newIndices[offset++] = this.getRawIndex(i);
	          }
	        }
	      }
	    }
	
	    if (offset < originalCount) {
	      this._indices = newIndices;
	    }
	
	    this._count = offset;
	    this._extent = {};
	    this.getRawIndex = this._indices ? getRawIndexWithIndices : getRawIndexWithoutIndices;
	    return this;
	  };
	
	  List.prototype.mapArray = function (dims, cb, ctx, ctxCompat) {
	    'use strict';
	
	    if (typeof dims === 'function') {
	      ctxCompat = ctx;
	      ctx = cb;
	      cb = dims;
	      dims = [];
	    }
	
	    ctx = ctx || ctxCompat || this;
	    var result = [];
	    this.each(dims, function () {
	      result.push(cb && cb.apply(this, arguments));
	    }, ctx);
	    return result;
	  };
	
	  List.prototype.map = function (dims, cb, ctx, ctxCompat) {
	    'use strict';
	
	    var fCtx = ctx || ctxCompat || this;
	    var dimNames = map(normalizeDimensions(dims), this.getDimension, this);
	
	    if (false) {
	      validateDimensions(this, dimNames);
	    }
	
	    var list = cloneListForMapAndSample(this, dimNames);
	    var storage = list._storage;
	    list._indices = this._indices;
	    list.getRawIndex = list._indices ? getRawIndexWithIndices : getRawIndexWithoutIndices;
	    var tmpRetValue = [];
	    var dimSize = dimNames.length;
	    var dataCount = this.count();
	    var values = [];
	    var rawExtent = list._rawExtent;
	
	    for (var dataIndex = 0; dataIndex < dataCount; dataIndex++) {
	      for (var dimIndex = 0; dimIndex < dimSize; dimIndex++) {
	        values[dimIndex] = this.get(dimNames[dimIndex], dataIndex);
	      }
	
	      values[dimSize] = dataIndex;
	      var retValue = cb && cb.apply(fCtx, values);
	
	      if (retValue != null) {
	        if (typeof retValue !== 'object') {
	          tmpRetValue[0] = retValue;
	          retValue = tmpRetValue;
	        }
	
	        var rawIndex = this.getRawIndex(dataIndex);
	
	        for (var i = 0; i < retValue.length; i++) {
	          var dim = dimNames[i];
	          var val = retValue[i];
	          var rawExtentOnDim = rawExtent[dim];
	          var dimStore = storage[dim];
	
	          if (dimStore) {
	            dimStore[rawIndex] = val;
	          }
	
	          if (val < rawExtentOnDim[0]) {
	            rawExtentOnDim[0] = val;
	          }
	
	          if (val > rawExtentOnDim[1]) {
	            rawExtentOnDim[1] = val;
	          }
	        }
	      }
	    }
	
	    return list;
	  };
	
	  List.prototype.downSample = function (dimension, rate, sampleValue, sampleIndex) {
	    var list = cloneListForMapAndSample(this, [dimension]);
	    var targetStorage = list._storage;
	    var frameValues = [];
	    var frameSize = mathFloor(1 / rate);
	    var dimStore = targetStorage[dimension];
	    var len = this.count();
	    var rawExtentOnDim = list._rawExtent[dimension];
	    var newIndices = new (getIndicesCtor(this))(len);
	    var offset = 0;
	
	    for (var i = 0; i < len; i += frameSize) {
	      if (frameSize > len - i) {
	        frameSize = len - i;
	        frameValues.length = frameSize;
	      }
	
	      for (var k = 0; k < frameSize; k++) {
	        var dataIdx = this.getRawIndex(i + k);
	        frameValues[k] = dimStore[dataIdx];
	      }
	
	      var value = sampleValue(frameValues);
	      var sampleFrameIdx = this.getRawIndex(Math.min(i + sampleIndex(frameValues, value) || 0, len - 1));
	      dimStore[sampleFrameIdx] = value;
	
	      if (value < rawExtentOnDim[0]) {
	        rawExtentOnDim[0] = value;
	      }
	
	      if (value > rawExtentOnDim[1]) {
	        rawExtentOnDim[1] = value;
	      }
	
	      newIndices[offset++] = sampleFrameIdx;
	    }
	
	    list._count = offset;
	    list._indices = newIndices;
	    list.getRawIndex = getRawIndexWithIndices;
	    return list;
	  };
	
	  List.prototype.lttbDownSample = function (valueDimension, rate) {
	    var list = cloneListForMapAndSample(this, []);
	    var targetStorage = list._storage;
	    var dimStore = targetStorage[valueDimension];
	    var len = this.count();
	    var newIndices = new (getIndicesCtor(this))(len);
	    var sampledIndex = 0;
	    var frameSize = mathFloor(1 / rate);
	    var currentRawIndex = this.getRawIndex(0);
	    var maxArea;
	    var area;
	    var nextRawIndex;
	    newIndices[sampledIndex++] = currentRawIndex;
	
	    for (var i = 1; i < len - 1; i += frameSize) {
	      var nextFrameStart = Math.min(i + frameSize, len - 1);
	      var nextFrameEnd = Math.min(i + frameSize * 2, len);
	      var avgX = (nextFrameEnd + nextFrameStart) / 2;
	      var avgY = 0;
	
	      for (var idx = nextFrameStart; idx < nextFrameEnd; idx++) {
	        var rawIndex = this.getRawIndex(idx);
	        var y = dimStore[rawIndex];
	
	        if (isNaN(y)) {
	          continue;
	        }
	
	        avgY += y;
	      }
	
	      avgY /= nextFrameEnd - nextFrameStart;
	      var frameStart = i;
	      var frameEnd = Math.min(i + frameSize, len);
	      var pointAX = i - 1;
	      var pointAY = dimStore[currentRawIndex];
	      maxArea = -1;
	      nextRawIndex = frameStart;
	
	      for (var idx = frameStart; idx < frameEnd; idx++) {
	        var rawIndex = this.getRawIndex(idx);
	        var y = dimStore[rawIndex];
	
	        if (isNaN(y)) {
	          continue;
	        }
	
	        area = Math.abs((pointAX - avgX) * (y - pointAY) - (pointAX - idx) * (avgY - pointAY));
	
	        if (area > maxArea) {
	          maxArea = area;
	          nextRawIndex = rawIndex;
	        }
	      }
	
	      newIndices[sampledIndex++] = nextRawIndex;
	      currentRawIndex = nextRawIndex;
	    }
	
	    newIndices[sampledIndex++] = this.getRawIndex(len - 1);
	    list._count = sampledIndex;
	    list._indices = newIndices;
	    list.getRawIndex = getRawIndexWithIndices;
	    return list;
	  };
	
	  List.prototype.getItemModel = function (idx) {
	    var hostModel = this.hostModel;
	    var dataItem = this.getRawDataItem(idx);
	    return new Model_1["default"](dataItem, hostModel, hostModel && hostModel.ecModel);
	  };
	
	  List.prototype.diff = function (otherList) {
	    var thisList = this;
	    return new DataDiffer_1["default"](otherList ? otherList.getIndices() : [], this.getIndices(), function (idx) {
	      return getId(otherList, idx);
	    }, function (idx) {
	      return getId(thisList, idx);
	    });
	  };
	
	  List.prototype.getVisual = function (key) {
	    var visual = this._visual;
	    return visual && visual[key];
	  };
	
	  List.prototype.setVisual = function (kvObj, val) {
	    this._visual = this._visual || {};
	
	    if (isObject(kvObj)) {
	      zrUtil.extend(this._visual, kvObj);
	    } else {
	      this._visual[kvObj] = val;
	    }
	  };
	
	  List.prototype.getItemVisual = function (idx, key) {
	    var itemVisual = this._itemVisuals[idx];
	    var val = itemVisual && itemVisual[key];
	
	    if (val == null) {
	      return this.getVisual(key);
	    }
	
	    return val;
	  };
	
	  List.prototype.hasItemVisual = function () {
	    return this._itemVisuals.length > 0;
	  };
	
	  List.prototype.ensureUniqueItemVisual = function (idx, key) {
	    var itemVisuals = this._itemVisuals;
	    var itemVisual = itemVisuals[idx];
	
	    if (!itemVisual) {
	      itemVisual = itemVisuals[idx] = {};
	    }
	
	    var val = itemVisual[key];
	
	    if (val == null) {
	      val = this.getVisual(key);
	
	      if (zrUtil.isArray(val)) {
	        val = val.slice();
	      } else if (isObject(val)) {
	        val = zrUtil.extend({}, val);
	      }
	
	      itemVisual[key] = val;
	    }
	
	    return val;
	  };
	
	  List.prototype.setItemVisual = function (idx, key, value) {
	    var itemVisual = this._itemVisuals[idx] || {};
	    this._itemVisuals[idx] = itemVisual;
	
	    if (isObject(key)) {
	      zrUtil.extend(itemVisual, key);
	    } else {
	      itemVisual[key] = value;
	    }
	  };
	
	  List.prototype.clearAllVisual = function () {
	    this._visual = {};
	    this._itemVisuals = [];
	  };
	
	  List.prototype.setLayout = function (key, val) {
	    if (isObject(key)) {
	      for (var name_1 in key) {
	        if (key.hasOwnProperty(name_1)) {
	          this.setLayout(name_1, key[name_1]);
	        }
	      }
	
	      return;
	    }
	
	    this._layout[key] = val;
	  };
	
	  List.prototype.getLayout = function (key) {
	    return this._layout[key];
	  };
	
	  List.prototype.getItemLayout = function (idx) {
	    return this._itemLayouts[idx];
	  };
	
	  List.prototype.setItemLayout = function (idx, layout, merge) {
	    this._itemLayouts[idx] = merge ? zrUtil.extend(this._itemLayouts[idx] || {}, layout) : layout;
	  };
	
	  List.prototype.clearItemLayouts = function () {
	    this._itemLayouts.length = 0;
	  };
	
	  List.prototype.setItemGraphicEl = function (idx, el) {
	    var hostModel = this.hostModel;
	
	    if (el) {
	      var ecData = innerStore_1.getECData(el);
	      ecData.dataIndex = idx;
	      ecData.dataType = this.dataType;
	      ecData.seriesIndex = hostModel && hostModel.seriesIndex;
	
	      if (el.type === 'group') {
	        el.traverse(setItemDataAndSeriesIndex, el);
	      }
	    }
	
	    this._graphicEls[idx] = el;
	  };
	
	  List.prototype.getItemGraphicEl = function (idx) {
	    return this._graphicEls[idx];
	  };
	
	  List.prototype.eachItemGraphicEl = function (cb, context) {
	    zrUtil.each(this._graphicEls, function (el, idx) {
	      if (el) {
	        cb && cb.call(context, el, idx);
	      }
	    });
	  };
	
	  List.prototype.cloneShallow = function (list) {
	    if (!list) {
	      var dimensionInfoList = map(this.dimensions, this.getDimensionInfo, this);
	      list = new List(dimensionInfoList, this.hostModel);
	    }
	
	    list._storage = this._storage;
	    list._storageArr = this._storageArr;
	    transferProperties(list, this);
	
	    if (this._indices) {
	      var Ctor = this._indices.constructor;
	
	      if (Ctor === Array) {
	        var thisCount = this._indices.length;
	        list._indices = new Ctor(thisCount);
	
	        for (var i = 0; i < thisCount; i++) {
	          list._indices[i] = this._indices[i];
	        }
	      } else {
	        list._indices = new Ctor(this._indices);
	      }
	    } else {
	      list._indices = null;
	    }
	
	    list.getRawIndex = list._indices ? getRawIndexWithIndices : getRawIndexWithoutIndices;
	    return list;
	  };
	
	  List.prototype.wrapMethod = function (methodName, injectFunction) {
	    var originalMethod = this[methodName];
	
	    if (typeof originalMethod !== 'function') {
	      return;
	    }
	
	    this.__wrappedMethods = this.__wrappedMethods || [];
	
	    this.__wrappedMethods.push(methodName);
	
	    this[methodName] = function () {
	      var res = originalMethod.apply(this, arguments);
	      return injectFunction.apply(this, [res].concat(zrUtil.slice(arguments)));
	    };
	  };
	
	  List.internalField = function () {
	    defaultDimValueGetters = {
	      arrayRows: getDimValueSimply,
	      objectRows: function (dataItem, dimName, dataIndex, dimIndex) {
	        return dataValueHelper_1.parseDataValue(dataItem[dimName], this._dimensionInfos[dimName]);
	      },
	      keyedColumns: getDimValueSimply,
	      original: function (dataItem, dimName, dataIndex, dimIndex) {
	        var value = dataItem && (dataItem.value == null ? dataItem : dataItem.value);
	
	        if (!this._rawData.pure && model_1.isDataItemOption(dataItem)) {
	          this.hasItemOption = true;
	        }
	
	        return dataValueHelper_1.parseDataValue(value instanceof Array ? value[dimIndex] : value, this._dimensionInfos[dimName]);
	      },
	      typedArray: function (dataItem, dimName, dataIndex, dimIndex) {
	        return dataItem[dimIndex];
	      }
	    };
	
	    function getDimValueSimply(dataItem, dimName, dataIndex, dimIndex) {
	      return dataValueHelper_1.parseDataValue(dataItem[dimIndex], this._dimensionInfos[dimName]);
	    }
	
	    prepareInvertedIndex = function (list) {
	      var invertedIndicesMap = list._invertedIndicesMap;
	      zrUtil.each(invertedIndicesMap, function (invertedIndices, dim) {
	        var dimInfo = list._dimensionInfos[dim];
	        var ordinalMeta = dimInfo.ordinalMeta;
	
	        if (ordinalMeta) {
	          invertedIndices = invertedIndicesMap[dim] = new CtorInt32Array(ordinalMeta.categories.length);
	
	          for (var i = 0; i < invertedIndices.length; i++) {
	            invertedIndices[i] = INDEX_NOT_FOUND;
	          }
	
	          for (var i = 0; i < list._count; i++) {
	            invertedIndices[list.get(dim, i)] = i;
	          }
	        }
	      });
	    };
	
	    getIdNameFromStore = function (list, dimIdx, ordinalMeta, rawIndex) {
	      var val;
	      var chunk = list._storageArr[dimIdx];
	
	      if (chunk) {
	        val = chunk[rawIndex];
	
	        if (ordinalMeta && ordinalMeta.categories.length) {
	          val = ordinalMeta.categories[val];
	        }
	      }
	
	      return model_1.convertOptionIdName(val, null);
	    };
	
	    getIndicesCtor = function (list) {
	      return list._rawCount > 65535 ? CtorUint32Array : CtorUint16Array;
	    };
	
	    prepareStorage = function (storage, dimInfo, end, append) {
	      var DataCtor = dataCtors[dimInfo.type];
	      var dim = dimInfo.name;
	
	      if (append) {
	        var oldStore = storage[dim];
	        var oldLen = oldStore && oldStore.length;
	
	        if (!(oldLen === end)) {
	          var newStore = new DataCtor(end);
	
	          for (var j = 0; j < oldLen; j++) {
	            newStore[j] = oldStore[j];
	          }
	
	          storage[dim] = newStore;
	        }
	      } else {
	        storage[dim] = new DataCtor(end);
	      }
	    };
	
	    getRawIndexWithoutIndices = function (idx) {
	      return idx;
	    };
	
	    getRawIndexWithIndices = function (idx) {
	      if (idx < this._count && idx >= 0) {
	        return this._indices[idx];
	      }
	
	      return -1;
	    };
	
	    getId = function (list, rawIndex) {
	      var id = list._idList[rawIndex];
	
	      if (id == null && list._idDimIdx != null) {
	        id = getIdNameFromStore(list, list._idDimIdx, list._idOrdinalMeta, rawIndex);
	      }
	
	      if (id == null) {
	        id = ID_PREFIX + rawIndex;
	      }
	
	      return id;
	    };
	
	    normalizeDimensions = function (dimensions) {
	      if (!zrUtil.isArray(dimensions)) {
	        dimensions = dimensions != null ? [dimensions] : [];
	      }
	
	      return dimensions;
	    };
	
	    validateDimensions = function (list, dims) {
	      for (var i = 0; i < dims.length; i++) {
	        if (!list._dimensionInfos[dims[i]]) {
	          console.error('Unkown dimension ' + dims[i]);
	        }
	      }
	    };
	
	    cloneListForMapAndSample = function (original, excludeDimensions) {
	      var allDimensions = original.dimensions;
	      var list = new List(map(allDimensions, original.getDimensionInfo, original), original.hostModel);
	      transferProperties(list, original);
	      var storage = list._storage = {};
	      var originalStorage = original._storage;
	      var storageArr = list._storageArr = [];
	
	      for (var i = 0; i < allDimensions.length; i++) {
	        var dim = allDimensions[i];
	
	        if (originalStorage[dim]) {
	          if (zrUtil.indexOf(excludeDimensions, dim) >= 0) {
	            storage[dim] = cloneChunk(originalStorage[dim]);
	            list._rawExtent[dim] = getInitialExtent();
	            list._extent[dim] = null;
	          } else {
	            storage[dim] = originalStorage[dim];
	          }
	
	          storageArr.push(storage[dim]);
	        }
	      }
	
	      return list;
	    };
	
	    function cloneChunk(originalChunk) {
	      var Ctor = originalChunk.constructor;
	      return Ctor === Array ? originalChunk.slice() : new Ctor(originalChunk);
	    }
	
	    getInitialExtent = function () {
	      return [Infinity, -Infinity];
	    };
	
	    setItemDataAndSeriesIndex = function (child) {
	      var childECData = innerStore_1.getECData(child);
	      var thisECData = innerStore_1.getECData(this);
	      childECData.seriesIndex = thisECData.seriesIndex;
	      childECData.dataIndex = thisECData.dataIndex;
	      childECData.dataType = thisECData.dataType;
	    };
	
	    transferProperties = function (target, source) {
	      zrUtil.each(TRANSFERABLE_PROPERTIES.concat(source.__wrappedMethods || []), function (propName) {
	        if (source.hasOwnProperty(propName)) {
	          target[propName] = source[propName];
	        }
	      });
	      target.__wrappedMethods = source.__wrappedMethods;
	      zrUtil.each(CLONE_PROPERTIES, function (propName) {
	        target[propName] = zrUtil.clone(source[propName]);
	      });
	      target._calculationInfo = zrUtil.extend({}, source._calculationInfo);
	    };
	
	    makeIdFromName = function (list, idx) {
	      var nameList = list._nameList;
	      var idList = list._idList;
	      var nameDimIdx = list._nameDimIdx;
	      var idDimIdx = list._idDimIdx;
	      var name = nameList[idx];
	      var id = idList[idx];
	
	      if (name == null && nameDimIdx != null) {
	        nameList[idx] = name = getIdNameFromStore(list, nameDimIdx, list._nameOrdinalMeta, idx);
	      }
	
	      if (id == null && idDimIdx != null) {
	        idList[idx] = id = getIdNameFromStore(list, idDimIdx, list._idOrdinalMeta, idx);
	      }
	
	      if (id == null && name != null) {
	        var nameRepeatCount = list._nameRepeatCount;
	        var nmCnt = nameRepeatCount[name] = (nameRepeatCount[name] || 0) + 1;
	        id = name;
	
	        if (nmCnt > 1) {
	          id += '__ec__' + nmCnt;
	        }
	
	        idList[idx] = id;
	      }
	    };
	  }();
	
	  return List;
	}();
	
	exports["default"] = List;

/***/ },
/* 145 */
/***/ function(module, exports, __webpack_require__) {

	
	/*
	* Licensed to the Apache Software Foundation (ASF) under one
	* or more contributor license agreements.  See the NOTICE file
	* distributed with this work for additional information
	* regarding copyright ownership.  The ASF licenses this file
	* to you under the Apache License, Version 2.0 (the
	* "License"); you may not use this file except in compliance
	* with the License.  You may obtain a copy of the License at
	*
	*   http://www.apache.org/licenses/LICENSE-2.0
	*
	* Unless required by applicable law or agreed to in writing,
	* software distributed under the License is distributed on an
	* "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
	* KIND, either express or implied.  See the License for the
	* specific language governing permissions and limitations
	* under the License.
	*/
	
	
	
	/**
	 * AUTO-GENERATED FILE. DO NOT MODIFY.
	 */
	
	"use strict";
	
	exports.__esModule = true;
	
	var util_1 = __webpack_require__(1);
	
	var OrdinalMeta = function () {
	  function OrdinalMeta(opt) {
	    this.categories = opt.categories || [];
	    this._needCollect = opt.needCollect;
	    this._deduplication = opt.deduplication;
	  }
	
	  OrdinalMeta.createByAxisModel = function (axisModel) {
	    var option = axisModel.option;
	    var data = option.data;
	    var categories = data && util_1.map(data, getName);
	    return new OrdinalMeta({
	      categories: categories,
	      needCollect: !categories,
	      deduplication: option.dedplication !== false
	    });
	  };
	
	  ;
	
	  OrdinalMeta.prototype.getOrdinal = function (category) {
	    return this._getOrCreateMap().get(category);
	  };
	
	  OrdinalMeta.prototype.parseAndCollect = function (category) {
	    var index;
	    var needCollect = this._needCollect;
	
	    if (typeof category !== 'string' && !needCollect) {
	      return category;
	    }
	
	    if (needCollect && !this._deduplication) {
	      index = this.categories.length;
	      this.categories[index] = category;
	      return index;
	    }
	
	    var map = this._getOrCreateMap();
	
	    index = map.get(category);
	
	    if (index == null) {
	      if (needCollect) {
	        index = this.categories.length;
	        this.categories[index] = category;
	        map.set(category, index);
	      } else {
	        index = NaN;
	      }
	    }
	
	    return index;
	  };
	
	  OrdinalMeta.prototype._getOrCreateMap = function () {
	    return this._map || (this._map = util_1.createHashMap(this.categories));
	  };
	
	  return OrdinalMeta;
	}();
	
	function getName(obj) {
	  if (util_1.isObject(obj) && obj.value != null) {
	    return obj.value;
	  } else {
	    return obj + '';
	  }
	}
	
	exports["default"] = OrdinalMeta;

/***/ },
/* 146 */
/***/ function(module, exports, __webpack_require__) {

	
	/*
	* Licensed to the Apache Software Foundation (ASF) under one
	* or more contributor license agreements.  See the NOTICE file
	* distributed with this work for additional information
	* regarding copyright ownership.  The ASF licenses this file
	* to you under the Apache License, Version 2.0 (the
	* "License"); you may not use this file except in compliance
	* with the License.  You may obtain a copy of the License at
	*
	*   http://www.apache.org/licenses/LICENSE-2.0
	*
	* Unless required by applicable law or agreed to in writing,
	* software distributed under the License is distributed on an
	* "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
	* KIND, either express or implied.  See the License for the
	* specific language governing permissions and limitations
	* under the License.
	*/
	
	
	
	/**
	 * AUTO-GENERATED FILE. DO NOT MODIFY.
	 */
	
	"use strict";
	
	exports.__esModule = true;
	
	var util_1 = __webpack_require__(1);
	
	var types_1 = __webpack_require__(25);
	
	function summarizeDimensions(data) {
	  var summary = {};
	  var encode = summary.encode = {};
	  var notExtraCoordDimMap = util_1.createHashMap();
	  var defaultedLabel = [];
	  var defaultedTooltip = [];
	  var userOutput = summary.userOutput = {
	    dimensionNames: data.dimensions.slice(),
	    encode: {}
	  };
	  util_1.each(data.dimensions, function (dimName) {
	    var dimItem = data.getDimensionInfo(dimName);
	    var coordDim = dimItem.coordDim;
	
	    if (coordDim) {
	      if (false) {
	        util_1.assert(types_1.VISUAL_DIMENSIONS.get(coordDim) == null);
	      }
	
	      var coordDimIndex = dimItem.coordDimIndex;
	      getOrCreateEncodeArr(encode, coordDim)[coordDimIndex] = dimName;
	
	      if (!dimItem.isExtraCoord) {
	        notExtraCoordDimMap.set(coordDim, 1);
	
	        if (mayLabelDimType(dimItem.type)) {
	          defaultedLabel[0] = dimName;
	        }
	
	        getOrCreateEncodeArr(userOutput.encode, coordDim)[coordDimIndex] = dimItem.index;
	      }
	
	      if (dimItem.defaultTooltip) {
	        defaultedTooltip.push(dimName);
	      }
	    }
	
	    types_1.VISUAL_DIMENSIONS.each(function (v, otherDim) {
	      var encodeArr = getOrCreateEncodeArr(encode, otherDim);
	      var dimIndex = dimItem.otherDims[otherDim];
	
	      if (dimIndex != null && dimIndex !== false) {
	        encodeArr[dimIndex] = dimItem.name;
	      }
	    });
	  });
	  var dataDimsOnCoord = [];
	  var encodeFirstDimNotExtra = {};
	  notExtraCoordDimMap.each(function (v, coordDim) {
	    var dimArr = encode[coordDim];
	    encodeFirstDimNotExtra[coordDim] = dimArr[0];
	    dataDimsOnCoord = dataDimsOnCoord.concat(dimArr);
	  });
	  summary.dataDimsOnCoord = dataDimsOnCoord;
	  summary.encodeFirstDimNotExtra = encodeFirstDimNotExtra;
	  var encodeLabel = encode.label;
	
	  if (encodeLabel && encodeLabel.length) {
	    defaultedLabel = encodeLabel.slice();
	  }
	
	  var encodeTooltip = encode.tooltip;
	
	  if (encodeTooltip && encodeTooltip.length) {
	    defaultedTooltip = encodeTooltip.slice();
	  } else if (!defaultedTooltip.length) {
	    defaultedTooltip = defaultedLabel.slice();
	  }
	
	  encode.defaultedLabel = defaultedLabel;
	  encode.defaultedTooltip = defaultedTooltip;
	  return summary;
	}
	
	exports.summarizeDimensions = summarizeDimensions;
	
	function getOrCreateEncodeArr(encode, dim) {
	  if (!encode.hasOwnProperty(dim)) {
	    encode[dim] = [];
	  }
	
	  return encode[dim];
	}
	
	function getDimensionTypeByAxis(axisType) {
	  return axisType === 'category' ? 'ordinal' : axisType === 'time' ? 'time' : 'float';
	}
	
	exports.getDimensionTypeByAxis = getDimensionTypeByAxis;
	
	function mayLabelDimType(dimType) {
	  return !(dimType === 'ordinal' || dimType === 'time');
	}

/***/ },
/* 147 */
/***/ function(module, exports, __webpack_require__) {

	
	/*
	* Licensed to the Apache Software Foundation (ASF) under one
	* or more contributor license agreements.  See the NOTICE file
	* distributed with this work for additional information
	* regarding copyright ownership.  The ASF licenses this file
	* to you under the Apache License, Version 2.0 (the
	* "License"); you may not use this file except in compliance
	* with the License.  You may obtain a copy of the License at
	*
	*   http://www.apache.org/licenses/LICENSE-2.0
	*
	* Unless required by applicable law or agreed to in writing,
	* software distributed under the License is distributed on an
	* "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
	* KIND, either express or implied.  See the License for the
	* specific language governing permissions and limitations
	* under the License.
	*/
	
	
	
	/**
	 * AUTO-GENERATED FILE. DO NOT MODIFY.
	 */
	
	"use strict";
	
	exports.__esModule = true;
	
	var util_1 = __webpack_require__(1);
	
	var Source_1 = __webpack_require__(47);
	
	var types_1 = __webpack_require__(25);
	
	var sourceHelper_1 = __webpack_require__(54);
	
	var transform_1 = __webpack_require__(148);
	
	var SourceManager = function () {
	  function SourceManager(sourceHost) {
	    this._sourceList = [];
	    this._upstreamSignList = [];
	    this._versionSignBase = 0;
	    this._sourceHost = sourceHost;
	  }
	
	  SourceManager.prototype.dirty = function () {
	    this._setLocalSource([], []);
	  };
	
	  SourceManager.prototype._setLocalSource = function (sourceList, upstreamSignList) {
	    this._sourceList = sourceList;
	    this._upstreamSignList = upstreamSignList;
	    this._versionSignBase++;
	
	    if (this._versionSignBase > 9e10) {
	      this._versionSignBase = 0;
	    }
	  };
	
	  SourceManager.prototype._getVersionSign = function () {
	    return this._sourceHost.uid + '_' + this._versionSignBase;
	  };
	
	  SourceManager.prototype.prepareSource = function () {
	    if (this._isDirty()) {
	      this._createSource();
	    }
	  };
	
	  SourceManager.prototype._createSource = function () {
	    this._setLocalSource([], []);
	
	    var sourceHost = this._sourceHost;
	
	    var upSourceMgrList = this._getUpstreamSourceManagers();
	
	    var hasUpstream = !!upSourceMgrList.length;
	    var resultSourceList;
	    var upstreamSignList;
	
	    if (isSeries(sourceHost)) {
	      var seriesModel = sourceHost;
	      var data = void 0;
	      var sourceFormat = void 0;
	      var upSource = void 0;
	
	      if (hasUpstream) {
	        var upSourceMgr = upSourceMgrList[0];
	        upSourceMgr.prepareSource();
	        upSource = upSourceMgr.getSource();
	        data = upSource.data;
	        sourceFormat = upSource.sourceFormat;
	        upstreamSignList = [upSourceMgr._getVersionSign()];
	      } else {
	        data = seriesModel.get('data', true);
	        sourceFormat = util_1.isTypedArray(data) ? types_1.SOURCE_FORMAT_TYPED_ARRAY : types_1.SOURCE_FORMAT_ORIGINAL;
	        upstreamSignList = [];
	      }
	
	      var thisMetaRawOption = sourceHelper_1.inheritSourceMetaRawOption(upSource, this._getSourceMetaRawOption());
	      resultSourceList = [Source_1.createSource(data, thisMetaRawOption, sourceFormat, seriesModel.get('encode', true))];
	    } else {
	      var datasetModel = sourceHost;
	
	      if (hasUpstream) {
	        var result = this._applyTransform(upSourceMgrList);
	
	        resultSourceList = result.sourceList;
	        upstreamSignList = result.upstreamSignList;
	      } else {
	        var sourceData = datasetModel.get('source', true);
	        resultSourceList = [Source_1.createSource(sourceData, this._getSourceMetaRawOption(), null, null)];
	        upstreamSignList = [];
	      }
	    }
	
	    if (false) {
	      util_1.assert(resultSourceList && upstreamSignList);
	    }
	
	    this._setLocalSource(resultSourceList, upstreamSignList);
	  };
	
	  SourceManager.prototype._applyTransform = function (upMgrList) {
	    var datasetModel = this._sourceHost;
	    var transformOption = datasetModel.get('transform', true);
	    var fromTransformResult = datasetModel.get('fromTransformResult', true);
	
	    if (false) {
	      util_1.assert(fromTransformResult != null || transformOption != null);
	    }
	
	    if (fromTransformResult != null) {
	      var errMsg = '';
	
	      if (upMgrList.length !== 1) {
	        if (false) {
	          errMsg = 'When using `fromTransformResult`, there should be only one upstream dataset';
	        }
	
	        doThrow(errMsg);
	      }
	    }
	
	    var sourceList;
	    var upSourceList = [];
	    var upstreamSignList = [];
	    util_1.each(upMgrList, function (upMgr) {
	      upMgr.prepareSource();
	      var upSource = upMgr.getSource(fromTransformResult || 0);
	      var errMsg = '';
	
	      if (fromTransformResult != null && !upSource) {
	        if (false) {
	          errMsg = 'Can not retrieve result by `fromTransformResult`: ' + fromTransformResult;
	        }
	
	        doThrow(errMsg);
	      }
	
	      upSourceList.push(upSource);
	      upstreamSignList.push(upMgr._getVersionSign());
	    });
	
	    if (transformOption) {
	      sourceList = transform_1.applyDataTransform(transformOption, upSourceList, {
	        datasetIndex: datasetModel.componentIndex
	      });
	    } else if (fromTransformResult != null) {
	      sourceList = [Source_1.cloneSourceShallow(upSourceList[0])];
	    }
	
	    return {
	      sourceList: sourceList,
	      upstreamSignList: upstreamSignList
	    };
	  };
	
	  SourceManager.prototype._isDirty = function () {
	    var sourceList = this._sourceList;
	
	    if (!sourceList.length) {
	      return true;
	    }
	
	    var upSourceMgrList = this._getUpstreamSourceManagers();
	
	    for (var i = 0; i < upSourceMgrList.length; i++) {
	      var upSrcMgr = upSourceMgrList[i];
	
	      if (upSrcMgr._isDirty() || this._upstreamSignList[i] !== upSrcMgr._getVersionSign()) {
	        return true;
	      }
	    }
	  };
	
	  SourceManager.prototype.getSource = function (sourceIndex) {
	    return this._sourceList[sourceIndex || 0];
	  };
	
	  SourceManager.prototype._getUpstreamSourceManagers = function () {
	    var sourceHost = this._sourceHost;
	
	    if (isSeries(sourceHost)) {
	      var datasetModel = sourceHelper_1.querySeriesUpstreamDatasetModel(sourceHost);
	      return !datasetModel ? [] : [datasetModel.getSourceManager()];
	    } else {
	      return util_1.map(sourceHelper_1.queryDatasetUpstreamDatasetModels(sourceHost), function (datasetModel) {
	        return datasetModel.getSourceManager();
	      });
	    }
	  };
	
	  SourceManager.prototype._getSourceMetaRawOption = function () {
	    var sourceHost = this._sourceHost;
	    var seriesLayoutBy;
	    var sourceHeader;
	    var dimensions;
	
	    if (isSeries(sourceHost)) {
	      seriesLayoutBy = sourceHost.get('seriesLayoutBy', true);
	      sourceHeader = sourceHost.get('sourceHeader', true);
	      dimensions = sourceHost.get('dimensions', true);
	    } else if (!this._getUpstreamSourceManagers().length) {
	      var model = sourceHost;
	      seriesLayoutBy = model.get('seriesLayoutBy', true);
	      sourceHeader = model.get('sourceHeader', true);
	      dimensions = model.get('dimensions', true);
	    }
	
	    return {
	      seriesLayoutBy: seriesLayoutBy,
	      sourceHeader: sourceHeader,
	      dimensions: dimensions
	    };
	  };
	
	  return SourceManager;
	}();
	
	exports.SourceManager = SourceManager;
	
	function disableTransformOptionMerge(datasetModel) {
	  var transformOption = datasetModel.option.transform;
	  transformOption && util_1.setAsPrimitive(datasetModel.option.transform);
	}
	
	exports.disableTransformOptionMerge = disableTransformOptionMerge;
	
	function isSeries(sourceHost) {
	  return sourceHost.mainType === 'series';
	}
	
	function doThrow(errMsg) {
	  throw new Error(errMsg);
	}

/***/ },
/* 148 */
/***/ function(module, exports, __webpack_require__) {

	
	/*
	* Licensed to the Apache Software Foundation (ASF) under one
	* or more contributor license agreements.  See the NOTICE file
	* distributed with this work for additional information
	* regarding copyright ownership.  The ASF licenses this file
	* to you under the Apache License, Version 2.0 (the
	* "License"); you may not use this file except in compliance
	* with the License.  You may obtain a copy of the License at
	*
	*   http://www.apache.org/licenses/LICENSE-2.0
	*
	* Unless required by applicable law or agreed to in writing,
	* software distributed under the License is distributed on an
	* "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
	* KIND, either express or implied.  See the License for the
	* specific language governing permissions and limitations
	* under the License.
	*/
	
	
	
	/**
	 * AUTO-GENERATED FILE. DO NOT MODIFY.
	 */
	
	"use strict";
	
	exports.__esModule = true;
	
	var types_1 = __webpack_require__(25);
	
	var model_1 = __webpack_require__(4);
	
	var util_1 = __webpack_require__(1);
	
	var dataProvider_1 = __webpack_require__(53);
	
	var dataValueHelper_1 = __webpack_require__(89);
	
	var sourceHelper_1 = __webpack_require__(54);
	
	var log_1 = __webpack_require__(12);
	
	var Source_1 = __webpack_require__(47);
	
	var ExternalSource = function () {
	  function ExternalSource() {}
	
	  ExternalSource.prototype.getRawData = function () {
	    throw new Error('not supported');
	  };
	
	  ExternalSource.prototype.getRawDataItem = function (dataIndex) {
	    throw new Error('not supported');
	  };
	
	  ExternalSource.prototype.cloneRawData = function () {
	    return;
	  };
	
	  ExternalSource.prototype.getDimensionInfo = function (dim) {
	    return;
	  };
	
	  ExternalSource.prototype.cloneAllDimensionInfo = function () {
	    return;
	  };
	
	  ExternalSource.prototype.count = function () {
	    return;
	  };
	
	  ExternalSource.prototype.retrieveValue = function (dataIndex, dimIndex) {
	    return;
	  };
	
	  ExternalSource.prototype.retrieveValueFromItem = function (dataItem, dimIndex) {
	    return;
	  };
	
	  ExternalSource.prototype.convertValue = function (rawVal, dimInfo) {
	    return dataValueHelper_1.parseDataValue(rawVal, dimInfo);
	  };
	
	  return ExternalSource;
	}();
	
	exports.ExternalSource = ExternalSource;
	
	function createExternalSource(internalSource, externalTransform) {
	  var extSource = new ExternalSource();
	  var data = internalSource.data;
	  var sourceFormat = extSource.sourceFormat = internalSource.sourceFormat;
	  var sourceHeaderCount = internalSource.startIndex;
	  var dimensions = [];
	  var dimsByName = {};
	  var dimsDef = internalSource.dimensionsDefine;
	
	  if (dimsDef) {
	    util_1.each(dimsDef, function (dimDef, idx) {
	      var name = dimDef.name;
	      var dimDefExt = {
	        index: idx,
	        name: name,
	        displayName: dimDef.displayName
	      };
	      dimensions.push(dimDefExt);
	
	      if (name != null) {
	        var errMsg = '';
	
	        if (util_1.hasOwn(dimsByName, name)) {
	          if (false) {
	            errMsg = 'dimension name "' + name + '" duplicated.';
	          }
	
	          log_1.throwError(errMsg);
	        }
	
	        dimsByName[name] = dimDefExt;
	      }
	    });
	  } else {
	    for (var i = 0; i < internalSource.dimensionsDetectedCount || 0; i++) {
	      dimensions.push({
	        index: i
	      });
	    }
	  }
	
	  var rawItemGetter = dataProvider_1.getRawSourceItemGetter(sourceFormat, types_1.SERIES_LAYOUT_BY_COLUMN);
	
	  if (externalTransform.__isBuiltIn) {
	    extSource.getRawDataItem = function (dataIndex) {
	      return rawItemGetter(data, sourceHeaderCount, dimensions, dataIndex);
	    };
	
	    extSource.getRawData = util_1.bind(getRawData, null, internalSource);
	  }
	
	  extSource.cloneRawData = util_1.bind(cloneRawData, null, internalSource);
	  var rawCounter = dataProvider_1.getRawSourceDataCounter(sourceFormat, types_1.SERIES_LAYOUT_BY_COLUMN);
	  extSource.count = util_1.bind(rawCounter, null, data, sourceHeaderCount, dimensions);
	  var rawValueGetter = dataProvider_1.getRawSourceValueGetter(sourceFormat);
	
	  extSource.retrieveValue = function (dataIndex, dimIndex) {
	    var rawItem = rawItemGetter(data, sourceHeaderCount, dimensions, dataIndex);
	    return retrieveValueFromItem(rawItem, dimIndex);
	  };
	
	  var retrieveValueFromItem = extSource.retrieveValueFromItem = function (dataItem, dimIndex) {
	    if (dataItem == null) {
	      return;
	    }
	
	    var dimDef = dimensions[dimIndex];
	
	    if (dimDef) {
	      return rawValueGetter(dataItem, dimIndex, dimDef.name);
	    }
	  };
	
	  extSource.getDimensionInfo = util_1.bind(getDimensionInfo, null, dimensions, dimsByName);
	  extSource.cloneAllDimensionInfo = util_1.bind(cloneAllDimensionInfo, null, dimensions);
	  return extSource;
	}
	
	function getRawData(upstream) {
	  var sourceFormat = upstream.sourceFormat;
	  var data = upstream.data;
	
	  if (sourceFormat === types_1.SOURCE_FORMAT_ARRAY_ROWS || sourceFormat === types_1.SOURCE_FORMAT_OBJECT_ROWS || !data || util_1.isArray(data) && !data.length) {
	    return upstream.data;
	  }
	
	  var errMsg = '';
	
	  if (false) {
	    errMsg = '`getRawData` is not supported in source format ' + sourceFormat;
	  }
	
	  log_1.throwError(errMsg);
	}
	
	function cloneRawData(upstream) {
	  var sourceFormat = upstream.sourceFormat;
	  var data = upstream.data;
	
	  if (!data) {
	    return data;
	  } else if (util_1.isArray(data) && !data.length) {
	    return [];
	  } else if (sourceFormat === types_1.SOURCE_FORMAT_ARRAY_ROWS) {
	    var result = [];
	
	    for (var i = 0, len = data.length; i < len; i++) {
	      result.push(data[i].slice());
	    }
	
	    return result;
	  } else if (sourceFormat === types_1.SOURCE_FORMAT_OBJECT_ROWS) {
	    var result = [];
	
	    for (var i = 0, len = data.length; i < len; i++) {
	      result.push(util_1.extend({}, data[i]));
	    }
	
	    return result;
	  }
	}
	
	function getDimensionInfo(dimensions, dimsByName, dim) {
	  if (dim == null) {
	    return;
	  }
	
	  if (typeof dim === 'number' || !isNaN(dim) && !util_1.hasOwn(dimsByName, dim)) {
	    return dimensions[dim];
	  } else if (util_1.hasOwn(dimsByName, dim)) {
	    return dimsByName[dim];
	  }
	}
	
	function cloneAllDimensionInfo(dimensions) {
	  return util_1.clone(dimensions);
	}
	
	var externalTransformMap = util_1.createHashMap();
	
	function registerExternalTransform(externalTransform) {
	  externalTransform = util_1.clone(externalTransform);
	  var type = externalTransform.type;
	  var errMsg = '';
	
	  if (!type) {
	    if (false) {
	      errMsg = 'Must have a `type` when `registerTransform`.';
	    }
	
	    log_1.throwError(errMsg);
	  }
	
	  var typeParsed = type.split(':');
	
	  if (typeParsed.length !== 2) {
	    if (false) {
	      errMsg = 'Name must include namespace like "ns:regression".';
	    }
	
	    log_1.throwError(errMsg);
	  }
	
	  var isBuiltIn = false;
	
	  if (typeParsed[0] === 'echarts') {
	    type = typeParsed[1];
	    isBuiltIn = true;
	  }
	
	  externalTransform.__isBuiltIn = isBuiltIn;
	  externalTransformMap.set(type, externalTransform);
	}
	
	exports.registerExternalTransform = registerExternalTransform;
	
	function applyDataTransform(rawTransOption, sourceList, infoForPrint) {
	  var pipedTransOption = model_1.normalizeToArray(rawTransOption);
	  var pipeLen = pipedTransOption.length;
	  var errMsg = '';
	
	  if (!pipeLen) {
	    if (false) {
	      errMsg = 'If `transform` declared, it should at least contain one transform.';
	    }
	
	    log_1.throwError(errMsg);
	  }
	
	  for (var i = 0, len = pipeLen; i < len; i++) {
	    var transOption = pipedTransOption[i];
	    sourceList = applySingleDataTransform(transOption, sourceList, infoForPrint, pipeLen === 1 ? null : i);
	
	    if (i !== len - 1) {
	      sourceList.length = Math.max(sourceList.length, 1);
	    }
	  }
	
	  return sourceList;
	}
	
	exports.applyDataTransform = applyDataTransform;
	
	function applySingleDataTransform(transOption, upSourceList, infoForPrint, pipeIndex) {
	  var errMsg = '';
	
	  if (!upSourceList.length) {
	    if (false) {
	      errMsg = 'Must have at least one upstream dataset.';
	    }
	
	    log_1.throwError(errMsg);
	  }
	
	  if (!util_1.isObject(transOption)) {
	    if (false) {
	      errMsg = 'transform declaration must be an object rather than ' + typeof transOption + '.';
	    }
	
	    log_1.throwError(errMsg);
	  }
	
	  var transType = transOption.type;
	  var externalTransform = externalTransformMap.get(transType);
	
	  if (!externalTransform) {
	    if (false) {
	      errMsg = 'Can not find transform on type "' + transType + '".';
	    }
	
	    log_1.throwError(errMsg);
	  }
	
	  var extUpSourceList = util_1.map(upSourceList, function (upSource) {
	    return createExternalSource(upSource, externalTransform);
	  });
	  var resultList = model_1.normalizeToArray(externalTransform.transform({
	    upstream: extUpSourceList[0],
	    upstreamList: extUpSourceList,
	    config: util_1.clone(transOption.config)
	  }));
	
	  if (false) {
	    if (transOption.print) {
	      var printStrArr = util_1.map(resultList, function (extSource) {
	        var pipeIndexStr = pipeIndex != null ? ' === pipe index: ' + pipeIndex : '';
	        return ['=== dataset index: ' + infoForPrint.datasetIndex + pipeIndexStr + ' ===', '- transform result data:', log_1.makePrintable(extSource.data), '- transform result dimensions:', log_1.makePrintable(extSource.dimensions)].join('\n');
	      }).join('\n');
	      log_1.consoleLog(printStrArr);
	    }
	  }
	
	  return util_1.map(resultList, function (result) {
	    var errMsg = '';
	
	    if (!util_1.isObject(result)) {
	      if (false) {
	        errMsg = 'A transform should not return some empty results.';
	      }
	
	      log_1.throwError(errMsg);
	    }
	
	    var resultData = result.data;
	
	    if (resultData != null) {
	      if (!util_1.isObject(resultData) && !util_1.isArrayLike(resultData)) {
	        if (false) {
	          errMsg = 'Result data should be object or array in data transform.';
	        }
	
	        log_1.throwError(errMsg);
	      }
	    } else {
	      resultData = upSourceList[0].data;
	    }
	
	    var resultMetaRawOption = sourceHelper_1.inheritSourceMetaRawOption(upSourceList[0], {
	      seriesLayoutBy: types_1.SERIES_LAYOUT_BY_COLUMN,
	      sourceHeader: 0,
	      dimensions: result.dimensions
	    });
	    return Source_1.createSource(resultData, resultMetaRawOption, null, null);
	  });
	}

/***/ },
/* 149 */
/***/ function(module, exports, __webpack_require__) {

	
	/*
	* Licensed to the Apache Software Foundation (ASF) under one
	* or more contributor license agreements.  See the NOTICE file
	* distributed with this work for additional information
	* regarding copyright ownership.  The ASF licenses this file
	* to you under the Apache License, Version 2.0 (the
	* "License"); you may not use this file except in compliance
	* with the License.  You may obtain a copy of the License at
	*
	*   http://www.apache.org/licenses/LICENSE-2.0
	*
	* Unless required by applicable law or agreed to in writing,
	* software distributed under the License is distributed on an
	* "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
	* KIND, either express or implied.  See the License for the
	* specific language governing permissions and limitations
	* under the License.
	*/
	
	
	
	/**
	 * AUTO-GENERATED FILE. DO NOT MODIFY.
	 */
	
	"use strict";
	
	exports.__esModule = true;
	
	var zrUtil = __webpack_require__(1);
	
	var number_1 = __webpack_require__(9);
	
	var dataStackHelper_1 = __webpack_require__(40);
	
	var createRenderPlanner_1 = __webpack_require__(82);
	
	var STACK_PREFIX = '__ec_stack_';
	var LARGE_BAR_MIN_WIDTH = 0.5;
	var LargeArr = typeof Float32Array !== 'undefined' ? Float32Array : Array;
	
	function getSeriesStackId(seriesModel) {
	  return seriesModel.get('stack') || STACK_PREFIX + seriesModel.seriesIndex;
	}
	
	function getAxisKey(axis) {
	  return axis.dim + axis.index;
	}
	
	function getLayoutOnAxis(opt) {
	  var params = [];
	  var baseAxis = opt.axis;
	  var axisKey = 'axis0';
	
	  if (baseAxis.type !== 'category') {
	    return;
	  }
	
	  var bandWidth = baseAxis.getBandWidth();
	
	  for (var i = 0; i < opt.count || 0; i++) {
	    params.push(zrUtil.defaults({
	      bandWidth: bandWidth,
	      axisKey: axisKey,
	      stackId: STACK_PREFIX + i
	    }, opt));
	  }
	
	  var widthAndOffsets = doCalBarWidthAndOffset(params);
	  var result = [];
	
	  for (var i = 0; i < opt.count; i++) {
	    var item = widthAndOffsets[axisKey][STACK_PREFIX + i];
	    item.offsetCenter = item.offset + item.width / 2;
	    result.push(item);
	  }
	
	  return result;
	}
	
	exports.getLayoutOnAxis = getLayoutOnAxis;
	
	function prepareLayoutBarSeries(seriesType, ecModel) {
	  var seriesModels = [];
	  ecModel.eachSeriesByType(seriesType, function (seriesModel) {
	    if (isOnCartesian(seriesModel) && !isInLargeMode(seriesModel)) {
	      seriesModels.push(seriesModel);
	    }
	  });
	  return seriesModels;
	}
	
	exports.prepareLayoutBarSeries = prepareLayoutBarSeries;
	
	function getValueAxesMinGaps(barSeries) {
	  var axisValues = {};
	  zrUtil.each(barSeries, function (seriesModel) {
	    var cartesian = seriesModel.coordinateSystem;
	    var baseAxis = cartesian.getBaseAxis();
	
	    if (baseAxis.type !== 'time' && baseAxis.type !== 'value') {
	      return;
	    }
	
	    var data = seriesModel.getData();
	    var key = baseAxis.dim + '_' + baseAxis.index;
	    var dim = data.mapDimension(baseAxis.dim);
	
	    for (var i = 0, cnt = data.count(); i < cnt; ++i) {
	      var value = data.get(dim, i);
	
	      if (!axisValues[key]) {
	        axisValues[key] = [value];
	      } else {
	        axisValues[key].push(value);
	      }
	    }
	  });
	  var axisMinGaps = {};
	
	  for (var key in axisValues) {
	    if (axisValues.hasOwnProperty(key)) {
	      var valuesInAxis = axisValues[key];
	
	      if (valuesInAxis) {
	        valuesInAxis.sort(function (a, b) {
	          return a - b;
	        });
	        var min = null;
	
	        for (var j = 1; j < valuesInAxis.length; ++j) {
	          var delta = valuesInAxis[j] - valuesInAxis[j - 1];
	
	          if (delta > 0) {
	            min = min === null ? delta : Math.min(min, delta);
	          }
	        }
	
	        axisMinGaps[key] = min;
	      }
	    }
	  }
	
	  return axisMinGaps;
	}
	
	function makeColumnLayout(barSeries) {
	  var axisMinGaps = getValueAxesMinGaps(barSeries);
	  var seriesInfoList = [];
	  zrUtil.each(barSeries, function (seriesModel) {
	    var cartesian = seriesModel.coordinateSystem;
	    var baseAxis = cartesian.getBaseAxis();
	    var axisExtent = baseAxis.getExtent();
	    var bandWidth;
	
	    if (baseAxis.type === 'category') {
	      bandWidth = baseAxis.getBandWidth();
	    } else if (baseAxis.type === 'value' || baseAxis.type === 'time') {
	      var key = baseAxis.dim + '_' + baseAxis.index;
	      var minGap = axisMinGaps[key];
	      var extentSpan = Math.abs(axisExtent[1] - axisExtent[0]);
	      var scale = baseAxis.scale.getExtent();
	      var scaleSpan = Math.abs(scale[1] - scale[0]);
	      bandWidth = minGap ? extentSpan / scaleSpan * minGap : extentSpan;
	    } else {
	      var data = seriesModel.getData();
	      bandWidth = Math.abs(axisExtent[1] - axisExtent[0]) / data.count();
	    }
	
	    var barWidth = number_1.parsePercent(seriesModel.get('barWidth'), bandWidth);
	    var barMaxWidth = number_1.parsePercent(seriesModel.get('barMaxWidth'), bandWidth);
	    var barMinWidth = number_1.parsePercent(seriesModel.get('barMinWidth') || 1, bandWidth);
	    var barGap = seriesModel.get('barGap');
	    var barCategoryGap = seriesModel.get('barCategoryGap');
	    seriesInfoList.push({
	      bandWidth: bandWidth,
	      barWidth: barWidth,
	      barMaxWidth: barMaxWidth,
	      barMinWidth: barMinWidth,
	      barGap: barGap,
	      barCategoryGap: barCategoryGap,
	      axisKey: getAxisKey(baseAxis),
	      stackId: getSeriesStackId(seriesModel)
	    });
	  });
	  return doCalBarWidthAndOffset(seriesInfoList);
	}
	
	exports.makeColumnLayout = makeColumnLayout;
	
	function doCalBarWidthAndOffset(seriesInfoList) {
	  var columnsMap = {};
	  zrUtil.each(seriesInfoList, function (seriesInfo, idx) {
	    var axisKey = seriesInfo.axisKey;
	    var bandWidth = seriesInfo.bandWidth;
	    var columnsOnAxis = columnsMap[axisKey] || {
	      bandWidth: bandWidth,
	      remainedWidth: bandWidth,
	      autoWidthCount: 0,
	      categoryGap: null,
	      gap: '20%',
	      stacks: {}
	    };
	    var stacks = columnsOnAxis.stacks;
	    columnsMap[axisKey] = columnsOnAxis;
	    var stackId = seriesInfo.stackId;
	
	    if (!stacks[stackId]) {
	      columnsOnAxis.autoWidthCount++;
	    }
	
	    stacks[stackId] = stacks[stackId] || {
	      width: 0,
	      maxWidth: 0
	    };
	    var barWidth = seriesInfo.barWidth;
	
	    if (barWidth && !stacks[stackId].width) {
	      stacks[stackId].width = barWidth;
	      barWidth = Math.min(columnsOnAxis.remainedWidth, barWidth);
	      columnsOnAxis.remainedWidth -= barWidth;
	    }
	
	    var barMaxWidth = seriesInfo.barMaxWidth;
	    barMaxWidth && (stacks[stackId].maxWidth = barMaxWidth);
	    var barMinWidth = seriesInfo.barMinWidth;
	    barMinWidth && (stacks[stackId].minWidth = barMinWidth);
	    var barGap = seriesInfo.barGap;
	    barGap != null && (columnsOnAxis.gap = barGap);
	    var barCategoryGap = seriesInfo.barCategoryGap;
	    barCategoryGap != null && (columnsOnAxis.categoryGap = barCategoryGap);
	  });
	  var result = {};
	  zrUtil.each(columnsMap, function (columnsOnAxis, coordSysName) {
	    result[coordSysName] = {};
	    var stacks = columnsOnAxis.stacks;
	    var bandWidth = columnsOnAxis.bandWidth;
	    var categoryGapPercent = columnsOnAxis.categoryGap;
	
	    if (categoryGapPercent == null) {
	      var columnCount = zrUtil.keys(stacks).length;
	      categoryGapPercent = Math.max(35 - columnCount * 4, 15) + '%';
	    }
	
	    var categoryGap = number_1.parsePercent(categoryGapPercent, bandWidth);
	    var barGapPercent = number_1.parsePercent(columnsOnAxis.gap, 1);
	    var remainedWidth = columnsOnAxis.remainedWidth;
	    var autoWidthCount = columnsOnAxis.autoWidthCount;
	    var autoWidth = (remainedWidth - categoryGap) / (autoWidthCount + (autoWidthCount - 1) * barGapPercent);
	    autoWidth = Math.max(autoWidth, 0);
	    zrUtil.each(stacks, function (column) {
	      var maxWidth = column.maxWidth;
	      var minWidth = column.minWidth;
	
	      if (!column.width) {
	        var finalWidth = autoWidth;
	
	        if (maxWidth && maxWidth < finalWidth) {
	          finalWidth = Math.min(maxWidth, remainedWidth);
	        }
	
	        if (minWidth && minWidth > finalWidth) {
	          finalWidth = minWidth;
	        }
	
	        if (finalWidth !== autoWidth) {
	          column.width = finalWidth;
	          remainedWidth -= finalWidth + barGapPercent * finalWidth;
	          autoWidthCount--;
	        }
	      } else {
	        var finalWidth = column.width;
	
	        if (maxWidth) {
	          finalWidth = Math.min(finalWidth, maxWidth);
	        }
	
	        if (minWidth) {
	          finalWidth = Math.max(finalWidth, minWidth);
	        }
	
	        column.width = finalWidth;
	        remainedWidth -= finalWidth + barGapPercent * finalWidth;
	        autoWidthCount--;
	      }
	    });
	    autoWidth = (remainedWidth - categoryGap) / (autoWidthCount + (autoWidthCount - 1) * barGapPercent);
	    autoWidth = Math.max(autoWidth, 0);
	    var widthSum = 0;
	    var lastColumn;
	    zrUtil.each(stacks, function (column, idx) {
	      if (!column.width) {
	        column.width = autoWidth;
	      }
	
	      lastColumn = column;
	      widthSum += column.width * (1 + barGapPercent);
	    });
	
	    if (lastColumn) {
	      widthSum -= lastColumn.width * barGapPercent;
	    }
	
	    var offset = -widthSum / 2;
	    zrUtil.each(stacks, function (column, stackId) {
	      result[coordSysName][stackId] = result[coordSysName][stackId] || {
	        bandWidth: bandWidth,
	        offset: offset,
	        width: column.width
	      };
	      offset += column.width * (1 + barGapPercent);
	    });
	  });
	  return result;
	}
	
	function retrieveColumnLayout(barWidthAndOffset, axis, seriesModel) {
	  if (barWidthAndOffset && axis) {
	    var result = barWidthAndOffset[getAxisKey(axis)];
	
	    if (result != null && seriesModel != null) {
	      return result[getSeriesStackId(seriesModel)];
	    }
	
	    return result;
	  }
	}
	
	exports.retrieveColumnLayout = retrieveColumnLayout;
	
	function layout(seriesType, ecModel) {
	  var seriesModels = prepareLayoutBarSeries(seriesType, ecModel);
	  var barWidthAndOffset = makeColumnLayout(seriesModels);
	  var lastStackCoords = {};
	  zrUtil.each(seriesModels, function (seriesModel) {
	    var data = seriesModel.getData();
	    var cartesian = seriesModel.coordinateSystem;
	    var baseAxis = cartesian.getBaseAxis();
	    var stackId = getSeriesStackId(seriesModel);
	    var columnLayoutInfo = barWidthAndOffset[getAxisKey(baseAxis)][stackId];
	    var columnOffset = columnLayoutInfo.offset;
	    var columnWidth = columnLayoutInfo.width;
	    var valueAxis = cartesian.getOtherAxis(baseAxis);
	    var barMinHeight = seriesModel.get('barMinHeight') || 0;
	    lastStackCoords[stackId] = lastStackCoords[stackId] || [];
	    data.setLayout({
	      bandWidth: columnLayoutInfo.bandWidth,
	      offset: columnOffset,
	      size: columnWidth
	    });
	    var valueDim = data.mapDimension(valueAxis.dim);
	    var baseDim = data.mapDimension(baseAxis.dim);
	    var stacked = dataStackHelper_1.isDimensionStacked(data, valueDim);
	    var isValueAxisH = valueAxis.isHorizontal();
	    var valueAxisStart = getValueAxisStart(baseAxis, valueAxis, stacked);
	
	    for (var idx = 0, len = data.count(); idx < len; idx++) {
	      var value = data.get(valueDim, idx);
	      var baseValue = data.get(baseDim, idx);
	      var sign = value >= 0 ? 'p' : 'n';
	      var baseCoord = valueAxisStart;
	
	      if (stacked) {
	        if (!lastStackCoords[stackId][baseValue]) {
	          lastStackCoords[stackId][baseValue] = {
	            p: valueAxisStart,
	            n: valueAxisStart
	          };
	        }
	
	        baseCoord = lastStackCoords[stackId][baseValue][sign];
	      }
	
	      var x = void 0;
	      var y = void 0;
	      var width = void 0;
	      var height = void 0;
	
	      if (isValueAxisH) {
	        var coord = cartesian.dataToPoint([value, baseValue]);
	        x = baseCoord;
	        y = coord[1] + columnOffset;
	        width = coord[0] - valueAxisStart;
	        height = columnWidth;
	
	        if (Math.abs(width) < barMinHeight) {
	          width = (width < 0 ? -1 : 1) * barMinHeight;
	        }
	
	        if (!isNaN(width)) {
	          stacked && (lastStackCoords[stackId][baseValue][sign] += width);
	        }
	      } else {
	        var coord = cartesian.dataToPoint([baseValue, value]);
	        x = coord[0] + columnOffset;
	        y = baseCoord;
	        width = columnWidth;
	        height = coord[1] - valueAxisStart;
	
	        if (Math.abs(height) < barMinHeight) {
	          height = (height <= 0 ? -1 : 1) * barMinHeight;
	        }
	
	        if (!isNaN(height)) {
	          stacked && (lastStackCoords[stackId][baseValue][sign] += height);
	        }
	      }
	
	      data.setItemLayout(idx, {
	        x: x,
	        y: y,
	        width: width,
	        height: height
	      });
	    }
	  });
	}
	
	exports.layout = layout;
	exports.largeLayout = {
	  seriesType: 'bar',
	  plan: createRenderPlanner_1["default"](),
	  reset: function (seriesModel) {
	    if (!isOnCartesian(seriesModel) || !isInLargeMode(seriesModel)) {
	      return;
	    }
	
	    var data = seriesModel.getData();
	    var cartesian = seriesModel.coordinateSystem;
	    var coordLayout = cartesian.master.getRect();
	    var baseAxis = cartesian.getBaseAxis();
	    var valueAxis = cartesian.getOtherAxis(baseAxis);
	    var valueDim = data.mapDimension(valueAxis.dim);
	    var baseDim = data.mapDimension(baseAxis.dim);
	    var valueAxisHorizontal = valueAxis.isHorizontal();
	    var valueDimIdx = valueAxisHorizontal ? 0 : 1;
	    var barWidth = retrieveColumnLayout(makeColumnLayout([seriesModel]), baseAxis, seriesModel).width;
	
	    if (!(barWidth > LARGE_BAR_MIN_WIDTH)) {
	      barWidth = LARGE_BAR_MIN_WIDTH;
	    }
	
	    return {
	      progress: function (params, data) {
	        var count = params.count;
	        var largePoints = new LargeArr(count * 2);
	        var largeBackgroundPoints = new LargeArr(count * 2);
	        var largeDataIndices = new LargeArr(count);
	        var dataIndex;
	        var coord = [];
	        var valuePair = [];
	        var pointsOffset = 0;
	        var idxOffset = 0;
	
	        while ((dataIndex = params.next()) != null) {
	          valuePair[valueDimIdx] = data.get(valueDim, dataIndex);
	          valuePair[1 - valueDimIdx] = data.get(baseDim, dataIndex);
	          coord = cartesian.dataToPoint(valuePair, null, coord);
	          largeBackgroundPoints[pointsOffset] = valueAxisHorizontal ? coordLayout.x + coordLayout.width : coord[0];
	          largePoints[pointsOffset++] = coord[0];
	          largeBackgroundPoints[pointsOffset] = valueAxisHorizontal ? coord[1] : coordLayout.y + coordLayout.height;
	          largePoints[pointsOffset++] = coord[1];
	          largeDataIndices[idxOffset++] = dataIndex;
	        }
	
	        data.setLayout({
	          largePoints: largePoints,
	          largeDataIndices: largeDataIndices,
	          largeBackgroundPoints: largeBackgroundPoints,
	          barWidth: barWidth,
	          valueAxisStart: getValueAxisStart(baseAxis, valueAxis, false),
	          backgroundStart: valueAxisHorizontal ? coordLayout.x : coordLayout.y,
	          valueAxisHorizontal: valueAxisHorizontal
	        });
	      }
	    };
	  }
	};
	
	function isOnCartesian(seriesModel) {
	  return seriesModel.coordinateSystem && seriesModel.coordinateSystem.type === 'cartesian2d';
	}
	
	function isInLargeMode(seriesModel) {
	  return seriesModel.pipelineContext && seriesModel.pipelineContext.large;
	}
	
	function getValueAxisStart(baseAxis, valueAxis, stacked) {
	  return valueAxis.toGlobalCoord(valueAxis.dataToCoord(valueAxis.type === 'log' ? 1 : 0));
	}

/***/ },
/* 150 */
/***/ function(module, exports, __webpack_require__) {

	
	/*
	* Licensed to the Apache Software Foundation (ASF) under one
	* or more contributor license agreements.  See the NOTICE file
	* distributed with this work for additional information
	* regarding copyright ownership.  The ASF licenses this file
	* to you under the Apache License, Version 2.0 (the
	* "License"); you may not use this file except in compliance
	* with the License.  You may obtain a copy of the License at
	*
	*   http://www.apache.org/licenses/LICENSE-2.0
	*
	* Unless required by applicable law or agreed to in writing,
	* software distributed under the License is distributed on an
	* "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
	* KIND, either express or implied.  See the License for the
	* specific language governing permissions and limitations
	* under the License.
	*/
	
	
	
	/**
	 * AUTO-GENERATED FILE. DO NOT MODIFY.
	 */
	
	"use strict";
	
	exports.__esModule = true;
	
	var tslib_1 = __webpack_require__(3);
	
	var util_1 = __webpack_require__(1);
	
	var modelUtil = __webpack_require__(4);
	
	var Model_1 = __webpack_require__(24);
	
	var Component_1 = __webpack_require__(10);
	
	var globalDefault_1 = __webpack_require__(359);
	
	var sourceHelper_1 = __webpack_require__(54);
	
	var internalComponentCreator_1 = __webpack_require__(360);
	
	var palette_1 = __webpack_require__(153);
	
	var reCreateSeriesIndices;
	var assertSeriesInitialized;
	var initBase;
	var OPTION_INNER_KEY = '\0_ec_inner';
	
	var GlobalModel = function (_super) {
	  tslib_1.__extends(GlobalModel, _super);
	
	  function GlobalModel() {
	    return _super !== null && _super.apply(this, arguments) || this;
	  }
	
	  GlobalModel.prototype.init = function (option, parentModel, ecModel, theme, locale, optionManager) {
	    theme = theme || {};
	    this.option = null;
	    this._theme = new Model_1["default"](theme);
	    this._locale = new Model_1["default"](locale);
	    this._optionManager = optionManager;
	  };
	
	  GlobalModel.prototype.setOption = function (option, opts, optionPreprocessorFuncs) {
	    util_1.assert(!(OPTION_INNER_KEY in option), 'please use chart.getOption()');
	    var innerOpt = normalizeSetOptionInput(opts);
	
	    this._optionManager.setOption(option, optionPreprocessorFuncs, innerOpt);
	
	    this._resetOption(null, innerOpt);
	  };
	
	  GlobalModel.prototype.resetOption = function (type, opt) {
	    return this._resetOption(type, normalizeSetOptionInput(opt));
	  };
	
	  GlobalModel.prototype._resetOption = function (type, opt) {
	    var optionChanged = false;
	    var optionManager = this._optionManager;
	
	    if (!type || type === 'recreate') {
	      var baseOption = optionManager.mountOption(type === 'recreate');
	
	      if (!this.option || type === 'recreate') {
	        initBase(this, baseOption);
	      } else {
	        this.restoreData();
	
	        this._mergeOption(baseOption, opt);
	      }
	
	      optionChanged = true;
	    }
	
	    if (type === 'timeline' || type === 'media') {
	      this.restoreData();
	    }
	
	    if (!type || type === 'recreate' || type === 'timeline') {
	      var timelineOption = optionManager.getTimelineOption(this);
	
	      if (timelineOption) {
	        optionChanged = true;
	
	        this._mergeOption(timelineOption, opt);
	      }
	    }
	
	    if (!type || type === 'recreate' || type === 'media') {
	      var mediaOptions = optionManager.getMediaOption(this);
	
	      if (mediaOptions.length) {
	        util_1.each(mediaOptions, function (mediaOption) {
	          optionChanged = true;
	
	          this._mergeOption(mediaOption, opt);
	        }, this);
	      }
	    }
	
	    return optionChanged;
	  };
	
	  GlobalModel.prototype.mergeOption = function (option) {
	    this._mergeOption(option, null);
	  };
	
	  GlobalModel.prototype._mergeOption = function (newOption, opt) {
	    var option = this.option;
	    var componentsMap = this._componentsMap;
	    var componentsCount = this._componentsCount;
	    var newCmptTypes = [];
	    var newCmptTypeMap = util_1.createHashMap();
	    var replaceMergeMainTypeMap = opt && opt.replaceMergeMainTypeMap;
	    sourceHelper_1.resetSourceDefaulter(this);
	    util_1.each(newOption, function (componentOption, mainType) {
	      if (componentOption == null) {
	        return;
	      }
	
	      if (!Component_1["default"].hasClass(mainType)) {
	        option[mainType] = option[mainType] == null ? util_1.clone(componentOption) : util_1.merge(option[mainType], componentOption, true);
	      } else if (mainType) {
	        newCmptTypes.push(mainType);
	        newCmptTypeMap.set(mainType, true);
	      }
	    });
	
	    if (replaceMergeMainTypeMap) {
	      replaceMergeMainTypeMap.each(function (val, mainTypeInReplaceMerge) {
	        if (Component_1["default"].hasClass(mainTypeInReplaceMerge) && !newCmptTypeMap.get(mainTypeInReplaceMerge)) {
	          newCmptTypes.push(mainTypeInReplaceMerge);
	          newCmptTypeMap.set(mainTypeInReplaceMerge, true);
	        }
	      });
	    }
	
	    Component_1["default"].topologicalTravel(newCmptTypes, Component_1["default"].getAllClassMainTypes(), visitComponent, this);
	
	    function visitComponent(mainType) {
	      var newCmptOptionList = internalComponentCreator_1.concatInternalOptions(this, mainType, modelUtil.normalizeToArray(newOption[mainType]));
	      var oldCmptList = componentsMap.get(mainType);
	      var mergeMode = !oldCmptList ? 'replaceAll' : replaceMergeMainTypeMap && replaceMergeMainTypeMap.get(mainType) ? 'replaceMerge' : 'normalMerge';
	      var mappingResult = modelUtil.mappingToExists(oldCmptList, newCmptOptionList, mergeMode);
	      modelUtil.setComponentTypeToKeyInfo(mappingResult, mainType, Component_1["default"]);
	      option[mainType] = null;
	      componentsMap.set(mainType, null);
	      componentsCount.set(mainType, 0);
	      var optionsByMainType = [];
	      var cmptsByMainType = [];
	      var cmptsCountByMainType = 0;
	      util_1.each(mappingResult, function (resultItem, index) {
	        var componentModel = resultItem.existing;
	        var newCmptOption = resultItem.newOption;
	
	        if (!newCmptOption) {
	          if (componentModel) {
	            componentModel.mergeOption({}, this);
	            componentModel.optionUpdated({}, false);
	          }
	        } else {
	          var ComponentModelClass = Component_1["default"].getClass(mainType, resultItem.keyInfo.subType, true);
	
	          if (componentModel && componentModel.constructor === ComponentModelClass) {
	            componentModel.name = resultItem.keyInfo.name;
	            componentModel.mergeOption(newCmptOption, this);
	            componentModel.optionUpdated(newCmptOption, false);
	          } else {
	            var extraOpt = util_1.extend({
	              componentIndex: index
	            }, resultItem.keyInfo);
	            componentModel = new ComponentModelClass(newCmptOption, this, this, extraOpt);
	            util_1.extend(componentModel, extraOpt);
	
	            if (resultItem.brandNew) {
	              componentModel.__requireNewView = true;
	            }
	
	            componentModel.init(newCmptOption, this, this);
	            componentModel.optionUpdated(null, true);
	          }
	        }
	
	        if (componentModel) {
	          optionsByMainType.push(componentModel.option);
	          cmptsByMainType.push(componentModel);
	          cmptsCountByMainType++;
	        } else {
	          optionsByMainType.push(void 0);
	          cmptsByMainType.push(void 0);
	        }
	      }, this);
	      option[mainType] = optionsByMainType;
	      componentsMap.set(mainType, cmptsByMainType);
	      componentsCount.set(mainType, cmptsCountByMainType);
	
	      if (mainType === 'series') {
	        reCreateSeriesIndices(this);
	      }
	    }
	
	    if (!this._seriesIndices) {
	      reCreateSeriesIndices(this);
	    }
	  };
	
	  GlobalModel.prototype.getOption = function () {
	    var option = util_1.clone(this.option);
	    util_1.each(option, function (optInMainType, mainType) {
	      if (Component_1["default"].hasClass(mainType)) {
	        var opts = modelUtil.normalizeToArray(optInMainType);
	        var realLen = opts.length;
	        var metNonInner = false;
	
	        for (var i = realLen - 1; i >= 0; i--) {
	          if (opts[i] && !modelUtil.isComponentIdInternal(opts[i])) {
	            metNonInner = true;
	          } else {
	            opts[i] = null;
	            !metNonInner && realLen--;
	          }
	        }
	
	        opts.length = realLen;
	        option[mainType] = opts;
	      }
	    });
	    delete option[OPTION_INNER_KEY];
	    return option;
	  };
	
	  GlobalModel.prototype.getTheme = function () {
	    return this._theme;
	  };
	
	  GlobalModel.prototype.getLocaleModel = function () {
	    return this._locale;
	  };
	
	  GlobalModel.prototype.getLocale = function (localePosition) {
	    var locale = this.getLocaleModel();
	    return locale.get(localePosition);
	  };
	
	  GlobalModel.prototype.setUpdatePayload = function (payload) {
	    this._payload = payload;
	  };
	
	  GlobalModel.prototype.getUpdatePayload = function () {
	    return this._payload;
	  };
	
	  GlobalModel.prototype.getComponent = function (mainType, idx) {
	    var list = this._componentsMap.get(mainType);
	
	    if (list) {
	      var cmpt = list[idx || 0];
	
	      if (cmpt) {
	        return cmpt;
	      } else if (idx == null) {
	        for (var i = 0; i < list.length; i++) {
	          if (list[i]) {
	            return list[i];
	          }
	        }
	      }
	    }
	  };
	
	  GlobalModel.prototype.queryComponents = function (condition) {
	    var mainType = condition.mainType;
	
	    if (!mainType) {
	      return [];
	    }
	
	    var index = condition.index;
	    var id = condition.id;
	    var name = condition.name;
	
	    var cmpts = this._componentsMap.get(mainType);
	
	    if (!cmpts || !cmpts.length) {
	      return [];
	    }
	
	    var result;
	
	    if (index != null) {
	      result = [];
	      util_1.each(modelUtil.normalizeToArray(index), function (idx) {
	        cmpts[idx] && result.push(cmpts[idx]);
	      });
	    } else if (id != null) {
	      result = queryByIdOrName('id', id, cmpts);
	    } else if (name != null) {
	      result = queryByIdOrName('name', name, cmpts);
	    } else {
	      result = util_1.filter(cmpts, function (cmpt) {
	        return !!cmpt;
	      });
	    }
	
	    return filterBySubType(result, condition);
	  };
	
	  GlobalModel.prototype.findComponents = function (condition) {
	    var query = condition.query;
	    var mainType = condition.mainType;
	    var queryCond = getQueryCond(query);
	    var result = queryCond ? this.queryComponents(queryCond) : util_1.filter(this._componentsMap.get(mainType), function (cmpt) {
	      return !!cmpt;
	    });
	    return doFilter(filterBySubType(result, condition));
	
	    function getQueryCond(q) {
	      var indexAttr = mainType + 'Index';
	      var idAttr = mainType + 'Id';
	      var nameAttr = mainType + 'Name';
	      return q && (q[indexAttr] != null || q[idAttr] != null || q[nameAttr] != null) ? {
	        mainType: mainType,
	        index: q[indexAttr],
	        id: q[idAttr],
	        name: q[nameAttr]
	      } : null;
	    }
	
	    function doFilter(res) {
	      return condition.filter ? util_1.filter(res, condition.filter) : res;
	    }
	  };
	
	  GlobalModel.prototype.eachComponent = function (mainType, cb, context) {
	    var componentsMap = this._componentsMap;
	
	    if (util_1.isFunction(mainType)) {
	      var ctxForAll_1 = cb;
	      var cbForAll_1 = mainType;
	      componentsMap.each(function (cmpts, componentType) {
	        for (var i = 0; cmpts && i < cmpts.length; i++) {
	          var cmpt = cmpts[i];
	          cmpt && cbForAll_1.call(ctxForAll_1, componentType, cmpt, cmpt.componentIndex);
	        }
	      });
	    } else {
	      var cmpts = util_1.isString(mainType) ? componentsMap.get(mainType) : util_1.isObject(mainType) ? this.findComponents(mainType) : null;
	
	      for (var i = 0; cmpts && i < cmpts.length; i++) {
	        var cmpt = cmpts[i];
	        cmpt && cb.call(context, cmpt, cmpt.componentIndex);
	      }
	    }
	  };
	
	  GlobalModel.prototype.getSeriesByName = function (name) {
	    var nameStr = modelUtil.convertOptionIdName(name, null);
	    return util_1.filter(this._componentsMap.get('series'), function (oneSeries) {
	      return !!oneSeries && nameStr != null && oneSeries.name === nameStr;
	    });
	  };
	
	  GlobalModel.prototype.getSeriesByIndex = function (seriesIndex) {
	    return this._componentsMap.get('series')[seriesIndex];
	  };
	
	  GlobalModel.prototype.getSeriesByType = function (subType) {
	    return util_1.filter(this._componentsMap.get('series'), function (oneSeries) {
	      return !!oneSeries && oneSeries.subType === subType;
	    });
	  };
	
	  GlobalModel.prototype.getSeries = function () {
	    return util_1.filter(this._componentsMap.get('series').slice(), function (oneSeries) {
	      return !!oneSeries;
	    });
	  };
	
	  GlobalModel.prototype.getSeriesCount = function () {
	    return this._componentsCount.get('series');
	  };
	
	  GlobalModel.prototype.eachSeries = function (cb, context) {
	    assertSeriesInitialized(this);
	    util_1.each(this._seriesIndices, function (rawSeriesIndex) {
	      var series = this._componentsMap.get('series')[rawSeriesIndex];
	
	      cb.call(context, series, rawSeriesIndex);
	    }, this);
	  };
	
	  GlobalModel.prototype.eachRawSeries = function (cb, context) {
	    util_1.each(this._componentsMap.get('series'), function (series) {
	      series && cb.call(context, series, series.componentIndex);
	    });
	  };
	
	  GlobalModel.prototype.eachSeriesByType = function (subType, cb, context) {
	    assertSeriesInitialized(this);
	    util_1.each(this._seriesIndices, function (rawSeriesIndex) {
	      var series = this._componentsMap.get('series')[rawSeriesIndex];
	
	      if (series.subType === subType) {
	        cb.call(context, series, rawSeriesIndex);
	      }
	    }, this);
	  };
	
	  GlobalModel.prototype.eachRawSeriesByType = function (subType, cb, context) {
	    return util_1.each(this.getSeriesByType(subType), cb, context);
	  };
	
	  GlobalModel.prototype.isSeriesFiltered = function (seriesModel) {
	    assertSeriesInitialized(this);
	    return this._seriesIndicesMap.get(seriesModel.componentIndex) == null;
	  };
	
	  GlobalModel.prototype.getCurrentSeriesIndices = function () {
	    return (this._seriesIndices || []).slice();
	  };
	
	  GlobalModel.prototype.filterSeries = function (cb, context) {
	    assertSeriesInitialized(this);
	    var newSeriesIndices = [];
	    util_1.each(this._seriesIndices, function (seriesRawIdx) {
	      var series = this._componentsMap.get('series')[seriesRawIdx];
	
	      cb.call(context, series, seriesRawIdx) && newSeriesIndices.push(seriesRawIdx);
	    }, this);
	    this._seriesIndices = newSeriesIndices;
	    this._seriesIndicesMap = util_1.createHashMap(newSeriesIndices);
	  };
	
	  GlobalModel.prototype.restoreData = function (payload) {
	    reCreateSeriesIndices(this);
	    var componentsMap = this._componentsMap;
	    var componentTypes = [];
	    componentsMap.each(function (components, componentType) {
	      if (Component_1["default"].hasClass(componentType)) {
	        componentTypes.push(componentType);
	      }
	    });
	    Component_1["default"].topologicalTravel(componentTypes, Component_1["default"].getAllClassMainTypes(), function (componentType) {
	      util_1.each(componentsMap.get(componentType), function (component) {
	        if (component && (componentType !== 'series' || !isNotTargetSeries(component, payload))) {
	          component.restoreData();
	        }
	      });
	    });
	  };
	
	  GlobalModel.internalField = function () {
	    reCreateSeriesIndices = function (ecModel) {
	      var seriesIndices = ecModel._seriesIndices = [];
	      util_1.each(ecModel._componentsMap.get('series'), function (series) {
	        series && seriesIndices.push(series.componentIndex);
	      });
	      ecModel._seriesIndicesMap = util_1.createHashMap(seriesIndices);
	    };
	
	    assertSeriesInitialized = function (ecModel) {
	      if (false) {
	        if (!ecModel._seriesIndices) {
	          throw new Error('Option should contains series.');
	        }
	      }
	    };
	
	    initBase = function (ecModel, baseOption) {
	      ecModel.option = {};
	      ecModel.option[OPTION_INNER_KEY] = 1;
	      ecModel._componentsMap = util_1.createHashMap({
	        series: []
	      });
	      ecModel._componentsCount = util_1.createHashMap();
	      var airaOption = baseOption.aria;
	
	      if (util_1.isObject(airaOption) && airaOption.enabled == null) {
	        airaOption.enabled = true;
	      }
	
	      mergeTheme(baseOption, ecModel._theme.option);
	      util_1.merge(baseOption, globalDefault_1["default"], false);
	
	      ecModel._mergeOption(baseOption, null);
	    };
	  }();
	
	  return GlobalModel;
	}(Model_1["default"]);
	
	function isNotTargetSeries(seriesModel, payload) {
	  if (payload) {
	    var index = payload.seriesIndex;
	    var id = payload.seriesId;
	    var name_1 = payload.seriesName;
	    return index != null && seriesModel.componentIndex !== index || id != null && seriesModel.id !== id || name_1 != null && seriesModel.name !== name_1;
	  }
	}
	
	function mergeTheme(option, theme) {
	  var notMergeColorLayer = option.color && !option.colorLayer;
	  util_1.each(theme, function (themeItem, name) {
	    if (name === 'colorLayer' && notMergeColorLayer) {
	      return;
	    }
	
	    if (!Component_1["default"].hasClass(name)) {
	      if (typeof themeItem === 'object') {
	        option[name] = !option[name] ? util_1.clone(themeItem) : util_1.merge(option[name], themeItem, false);
	      } else {
	        if (option[name] == null) {
	          option[name] = themeItem;
	        }
	      }
	    }
	  });
	}
	
	function queryByIdOrName(attr, idOrName, cmpts) {
	  if (util_1.isArray(idOrName)) {
	    var keyMap_1 = util_1.createHashMap();
	    util_1.each(idOrName, function (idOrNameItem) {
	      if (idOrNameItem != null) {
	        var idName = modelUtil.convertOptionIdName(idOrNameItem, null);
	        idName != null && keyMap_1.set(idOrNameItem, true);
	      }
	    });
	    return util_1.filter(cmpts, function (cmpt) {
	      return cmpt && keyMap_1.get(cmpt[attr]);
	    });
	  } else {
	    var idName_1 = modelUtil.convertOptionIdName(idOrName, null);
	    return util_1.filter(cmpts, function (cmpt) {
	      return cmpt && idName_1 != null && cmpt[attr] === idName_1;
	    });
	  }
	}
	
	function filterBySubType(components, condition) {
	  return condition.hasOwnProperty('subType') ? util_1.filter(components, function (cmpt) {
	    return cmpt && cmpt.subType === condition.subType;
	  }) : components;
	}
	
	function normalizeSetOptionInput(opts) {
	  var replaceMergeMainTypeMap = util_1.createHashMap();
	  opts && util_1.each(modelUtil.normalizeToArray(opts.replaceMerge), function (mainType) {
	    if (false) {
	      util_1.assert(Component_1["default"].hasClass(mainType), '"' + mainType + '" is not valid component main type in "replaceMerge"');
	    }
	
	    replaceMergeMainTypeMap.set(mainType, true);
	  });
	  return {
	    replaceMergeMainTypeMap: replaceMergeMainTypeMap
	  };
	}
	
	util_1.mixin(GlobalModel, palette_1.PaletteMixin);
	exports["default"] = GlobalModel;

/***/ },
/* 151 */
/***/ function(module, exports, __webpack_require__) {

	
	/*
	* Licensed to the Apache Software Foundation (ASF) under one
	* or more contributor license agreements.  See the NOTICE file
	* distributed with this work for additional information
	* regarding copyright ownership.  The ASF licenses this file
	* to you under the Apache License, Version 2.0 (the
	* "License"); you may not use this file except in compliance
	* with the License.  You may obtain a copy of the License at
	*
	*   http://www.apache.org/licenses/LICENSE-2.0
	*
	* Unless required by applicable law or agreed to in writing,
	* software distributed under the License is distributed on an
	* "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
	* KIND, either express or implied.  See the License for the
	* specific language governing permissions and limitations
	* under the License.
	*/
	
	
	
	/**
	 * AUTO-GENERATED FILE. DO NOT MODIFY.
	 */
	
	"use strict";
	
	exports.__esModule = true;
	
	var makeStyleMapper_1 = __webpack_require__(69);
	
	exports.ITEM_STYLE_KEY_MAP = [['fill', 'color'], ['stroke', 'borderColor'], ['lineWidth', 'borderWidth'], ['opacity'], ['shadowBlur'], ['shadowOffsetX'], ['shadowOffsetY'], ['shadowColor'], ['lineDash', 'borderType'], ['lineDashOffset', 'borderDashOffset'], ['lineCap', 'borderCap'], ['lineJoin', 'borderJoin'], ['miterLimit', 'borderMiterLimit']];
	var getItemStyle = makeStyleMapper_1["default"](exports.ITEM_STYLE_KEY_MAP);
	
	var ItemStyleMixin = function () {
	  function ItemStyleMixin() {}
	
	  ItemStyleMixin.prototype.getItemStyle = function (excludes, includes) {
	    return getItemStyle(this, excludes, includes);
	  };
	
	  return ItemStyleMixin;
	}();
	
	exports.ItemStyleMixin = ItemStyleMixin;

/***/ },
/* 152 */
/***/ function(module, exports, __webpack_require__) {

	
	/*
	* Licensed to the Apache Software Foundation (ASF) under one
	* or more contributor license agreements.  See the NOTICE file
	* distributed with this work for additional information
	* regarding copyright ownership.  The ASF licenses this file
	* to you under the Apache License, Version 2.0 (the
	* "License"); you may not use this file except in compliance
	* with the License.  You may obtain a copy of the License at
	*
	*   http://www.apache.org/licenses/LICENSE-2.0
	*
	* Unless required by applicable law or agreed to in writing,
	* software distributed under the License is distributed on an
	* "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
	* KIND, either express or implied.  See the License for the
	* specific language governing permissions and limitations
	* under the License.
	*/
	
	
	
	/**
	 * AUTO-GENERATED FILE. DO NOT MODIFY.
	 */
	
	"use strict";
	
	exports.__esModule = true;
	
	var makeStyleMapper_1 = __webpack_require__(69);
	
	exports.LINE_STYLE_KEY_MAP = [['lineWidth', 'width'], ['stroke', 'color'], ['opacity'], ['shadowBlur'], ['shadowOffsetX'], ['shadowOffsetY'], ['shadowColor'], ['lineDash', 'type'], ['lineDashOffset', 'dashOffset'], ['lineCap', 'cap'], ['lineJoin', 'join'], ['miterLimit']];
	var getLineStyle = makeStyleMapper_1["default"](exports.LINE_STYLE_KEY_MAP);
	
	var LineStyleMixin = function () {
	  function LineStyleMixin() {}
	
	  LineStyleMixin.prototype.getLineStyle = function (excludes) {
	    return getLineStyle(this, excludes);
	  };
	
	  return LineStyleMixin;
	}();
	
	exports.LineStyleMixin = LineStyleMixin;
	;

/***/ },
/* 153 */
/***/ function(module, exports, __webpack_require__) {

	
	/*
	* Licensed to the Apache Software Foundation (ASF) under one
	* or more contributor license agreements.  See the NOTICE file
	* distributed with this work for additional information
	* regarding copyright ownership.  The ASF licenses this file
	* to you under the Apache License, Version 2.0 (the
	* "License"); you may not use this file except in compliance
	* with the License.  You may obtain a copy of the License at
	*
	*   http://www.apache.org/licenses/LICENSE-2.0
	*
	* Unless required by applicable law or agreed to in writing,
	* software distributed under the License is distributed on an
	* "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
	* KIND, either express or implied.  See the License for the
	* specific language governing permissions and limitations
	* under the License.
	*/
	
	
	
	/**
	 * AUTO-GENERATED FILE. DO NOT MODIFY.
	 */
	
	"use strict";
	
	exports.__esModule = true;
	
	var model_1 = __webpack_require__(4);
	
	var innerColor = model_1.makeInner();
	var innerDecal = model_1.makeInner();
	
	var PaletteMixin = function () {
	  function PaletteMixin() {}
	
	  PaletteMixin.prototype.getColorFromPalette = function (name, scope, requestNum) {
	    var defaultPalette = model_1.normalizeToArray(this.get('color', true));
	    var layeredPalette = this.get('colorLayer', true);
	    return getFromPalette(this, innerColor, defaultPalette, layeredPalette, name, scope, requestNum);
	  };
	
	  PaletteMixin.prototype.clearColorPalette = function () {
	    clearPalette(this, innerColor);
	  };
	
	  return PaletteMixin;
	}();
	
	exports.PaletteMixin = PaletteMixin;
	
	function getDecalFromPalette(ecModel, name, scope, requestNum) {
	  var defaultDecals = model_1.normalizeToArray(ecModel.get(['aria', 'decal', 'decals']));
	  return getFromPalette(ecModel, innerDecal, defaultDecals, null, name, scope, requestNum);
	}
	
	exports.getDecalFromPalette = getDecalFromPalette;
	
	function getNearestPalette(palettes, requestColorNum) {
	  var paletteNum = palettes.length;
	
	  for (var i = 0; i < paletteNum; i++) {
	    if (palettes[i].length > requestColorNum) {
	      return palettes[i];
	    }
	  }
	
	  return palettes[paletteNum - 1];
	}
	
	function getFromPalette(that, inner, defaultPalette, layeredPalette, name, scope, requestNum) {
	  scope = scope || that;
	  var scopeFields = inner(scope);
	  var paletteIdx = scopeFields.paletteIdx || 0;
	  var paletteNameMap = scopeFields.paletteNameMap = scopeFields.paletteNameMap || {};
	
	  if (paletteNameMap.hasOwnProperty(name)) {
	    return paletteNameMap[name];
	  }
	
	  var palette = requestNum == null || !layeredPalette ? defaultPalette : getNearestPalette(layeredPalette, requestNum);
	  palette = palette || defaultPalette;
	
	  if (!palette || !palette.length) {
	    return;
	  }
	
	  var pickedPaletteItem = palette[paletteIdx];
	
	  if (name) {
	    paletteNameMap[name] = pickedPaletteItem;
	  }
	
	  scopeFields.paletteIdx = (paletteIdx + 1) % palette.length;
	  return pickedPaletteItem;
	}
	
	function clearPalette(that, inner) {
	  inner(that).paletteIdx = 0;
	  inner(that).paletteNameMap = {};
	}

/***/ },
/* 154 */
/***/ function(module, exports) {

	
	/*
	* Licensed to the Apache Software Foundation (ASF) under one
	* or more contributor license agreements.  See the NOTICE file
	* distributed with this work for additional information
	* regarding copyright ownership.  The ASF licenses this file
	* to you under the Apache License, Version 2.0 (the
	* "License"); you may not use this file except in compliance
	* with the License.  You may obtain a copy of the License at
	*
	*   http://www.apache.org/licenses/LICENSE-2.0
	*
	* Unless required by applicable law or agreed to in writing,
	* software distributed under the License is distributed on an
	* "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
	* KIND, either express or implied.  See the License for the
	* specific language governing permissions and limitations
	* under the License.
	*/
	
	
	
	/**
	 * AUTO-GENERATED FILE. DO NOT MODIFY.
	 */
	
	"use strict";
	
	exports.__esModule = true;
	var samplers = {
	  average: function (frame) {
	    var sum = 0;
	    var count = 0;
	
	    for (var i = 0; i < frame.length; i++) {
	      if (!isNaN(frame[i])) {
	        sum += frame[i];
	        count++;
	      }
	    }
	
	    return count === 0 ? NaN : sum / count;
	  },
	  sum: function (frame) {
	    var sum = 0;
	
	    for (var i = 0; i < frame.length; i++) {
	      sum += frame[i] || 0;
	    }
	
	    return sum;
	  },
	  max: function (frame) {
	    var max = -Infinity;
	
	    for (var i = 0; i < frame.length; i++) {
	      frame[i] > max && (max = frame[i]);
	    }
	
	    return isFinite(max) ? max : NaN;
	  },
	  min: function (frame) {
	    var min = Infinity;
	
	    for (var i = 0; i < frame.length; i++) {
	      frame[i] < min && (min = frame[i]);
	    }
	
	    return isFinite(min) ? min : NaN;
	  },
	  nearest: function (frame) {
	    return frame[0];
	  }
	};
	
	var indexSampler = function (frame) {
	  return Math.round(frame.length / 2);
	};
	
	function dataSample(seriesType) {
	  return {
	    seriesType: seriesType,
	    reset: function (seriesModel, ecModel, api) {
	      var data = seriesModel.getData();
	      var sampling = seriesModel.get('sampling');
	      var coordSys = seriesModel.coordinateSystem;
	      var count = data.count();
	
	      if (count > 10 && coordSys.type === 'cartesian2d' && sampling) {
	        var baseAxis = coordSys.getBaseAxis();
	        var valueAxis = coordSys.getOtherAxis(baseAxis);
	        var extent = baseAxis.getExtent();
	        var dpr = api.getDevicePixelRatio();
	        var size = Math.abs(extent[1] - extent[0]) * (dpr || 1);
	        var rate = Math.round(count / size);
	
	        if (rate > 1) {
	          if (sampling === 'lttb') {
	            seriesModel.setData(data.lttbDownSample(data.mapDimension(valueAxis.dim), 1 / rate));
	          }
	
	          var sampler = void 0;
	
	          if (typeof sampling === 'string') {
	            sampler = samplers[sampling];
	          } else if (typeof sampling === 'function') {
	            sampler = sampling;
	          }
	
	          if (sampler) {
	            seriesModel.setData(data.downSample(data.mapDimension(valueAxis.dim), 1 / rate, sampler, indexSampler));
	          }
	        }
	      }
	    }
	  };
	}
	
	exports["default"] = dataSample;

/***/ },
/* 155 */
/***/ function(module, exports) {

	
	/*
	* Licensed to the Apache Software Foundation (ASF) under one
	* or more contributor license agreements.  See the NOTICE file
	* distributed with this work for additional information
	* regarding copyright ownership.  The ASF licenses this file
	* to you under the Apache License, Version 2.0 (the
	* "License"); you may not use this file except in compliance
	* with the License.  You may obtain a copy of the License at
	*
	*   http://www.apache.org/licenses/LICENSE-2.0
	*
	* Unless required by applicable law or agreed to in writing,
	* software distributed under the License is distributed on an
	* "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
	* KIND, either express or implied.  See the License for the
	* specific language governing permissions and limitations
	* under the License.
	*/
	
	
	
	/**
	 * AUTO-GENERATED FILE. DO NOT MODIFY.
	 */
	
	"use strict";
	
	exports.__esModule = true;
	
	function findEventDispatcher(target, det, returnFirstMatch) {
	  var found;
	
	  while (target) {
	    if (det(target)) {
	      found = target;
	
	      if (returnFirstMatch) {
	        break;
	      }
	    }
	
	    target = target.__hostTarget || target.parent;
	  }
	
	  return found;
	}
	
	exports.findEventDispatcher = findEventDispatcher;

/***/ },
/* 156 */
/***/ function(module, exports, __webpack_require__) {

	
	/*
	* Licensed to the Apache Software Foundation (ASF) under one
	* or more contributor license agreements.  See the NOTICE file
	* distributed with this work for additional information
	* regarding copyright ownership.  The ASF licenses this file
	* to you under the Apache License, Version 2.0 (the
	* "License"); you may not use this file except in compliance
	* with the License.  You may obtain a copy of the License at
	*
	*   http://www.apache.org/licenses/LICENSE-2.0
	*
	* Unless required by applicable law or agreed to in writing,
	* software distributed under the License is distributed on an
	* "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
	* KIND, either express or implied.  See the License for the
	* specific language governing permissions and limitations
	* under the License.
	*/
	
	
	
	/**
	 * AUTO-GENERATED FILE. DO NOT MODIFY.
	 */
	
	"use strict";
	
	exports.__esModule = true;
	
	function getItemVisualFromData(data, dataIndex, key) {
	  switch (key) {
	    case 'color':
	      var style = data.getItemVisual(dataIndex, 'style');
	      return style[data.getVisual('drawType')];
	
	    case 'opacity':
	      return data.getItemVisual(dataIndex, 'style').opacity;
	
	    case 'symbol':
	    case 'symbolSize':
	    case 'liftZ':
	      return data.getItemVisual(dataIndex, key);
	
	    default:
	      if (false) {
	        console.warn("Unknown visual type " + key);
	      }
	
	  }
	}
	
	exports.getItemVisualFromData = getItemVisualFromData;
	
	function getVisualFromData(data, key) {
	  switch (key) {
	    case 'color':
	      var style = data.getVisual('style');
	      return style[data.getVisual('drawType')];
	
	    case 'opacity':
	      return data.getVisual('style').opacity;
	
	    case 'symbol':
	    case 'symbolSize':
	    case 'liftZ':
	      return data.getVisual(key);
	
	    default:
	      if (false) {
	        console.warn("Unknown visual type " + key);
	      }
	
	  }
	}
	
	exports.getVisualFromData = getVisualFromData;
	
	function setItemVisualFromData(data, dataIndex, key, value) {
	  switch (key) {
	    case 'color':
	      var style = data.ensureUniqueItemVisual(dataIndex, 'style');
	      style[data.getVisual('drawType')] = value;
	      data.setItemVisual(dataIndex, 'colorFromPalette', false);
	      break;
	
	    case 'opacity':
	      data.ensureUniqueItemVisual(dataIndex, 'style').opacity = value;
	      break;
	
	    case 'symbol':
	    case 'symbolSize':
	    case 'liftZ':
	      data.setItemVisual(dataIndex, key, value);
	      break;
	
	    default:
	      if (false) {
	        console.warn("Unknown visual type " + key);
	      }
	
	  }
	}
	
	exports.setItemVisualFromData = setItemVisualFromData;

/***/ },
/* 157 */
/***/ function(module, exports, __webpack_require__) {

	const XMLHttpRequest = __webpack_require__(160);
	const XHR = __webpack_require__(382);
	const JSONP = __webpack_require__(381);
	const websocket = __webpack_require__(384);
	
	exports.polling = polling;
	exports.websocket = websocket;
	
	/**
	 * Polling transport polymorphic constructor.
	 * Decides on xhr vs jsonp based on feature detection.
	 *
	 * @api private
	 */
	
	function polling(opts) {
	  let xhr;
	  let xd = false;
	  let xs = false;
	  const jsonp = false !== opts.jsonp;
	
	  if (typeof location !== "undefined") {
	    const isSSL = "https:" === location.protocol;
	    let port = location.port;
	
	    // some user agents have empty `location.port`
	    if (!port) {
	      port = isSSL ? 443 : 80;
	    }
	
	    xd = opts.hostname !== location.hostname || port !== opts.port;
	    xs = opts.secure !== isSSL;
	  }
	
	  opts.xdomain = xd;
	  opts.xscheme = xs;
	  xhr = new XMLHttpRequest(opts);
	
	  if ("open" in xhr && !opts.forceJSONP) {
	    return new XHR(opts);
	  } else {
	    if (!jsonp) throw new Error("JSONP disabled");
	    return new JSONP(opts);
	  }
	}


/***/ },
/* 158 */
/***/ function(module, exports, __webpack_require__) {

	const Transport = __webpack_require__(97);
	const parseqs = __webpack_require__(99);
	const parser = __webpack_require__(57);
	const yeast = __webpack_require__(176);
	
	const debug = __webpack_require__(72)("engine.io-client:polling");
	
	class Polling extends Transport {
	  /**
	   * Transport name.
	   */
	  get name() {
	    return "polling";
	  }
	
	  /**
	   * Opens the socket (triggers polling). We write a PING message to determine
	   * when the transport is open.
	   *
	   * @api private
	   */
	  doOpen() {
	    this.poll();
	  }
	
	  /**
	   * Pauses polling.
	   *
	   * @param {Function} callback upon buffers are flushed and transport is paused
	   * @api private
	   */
	  pause(onPause) {
	    const self = this;
	
	    this.readyState = "pausing";
	
	    function pause() {
	      debug("paused");
	      self.readyState = "paused";
	      onPause();
	    }
	
	    if (this.polling || !this.writable) {
	      let total = 0;
	
	      if (this.polling) {
	        debug("we are currently polling - waiting to pause");
	        total++;
	        this.once("pollComplete", function() {
	          debug("pre-pause polling complete");
	          --total || pause();
	        });
	      }
	
	      if (!this.writable) {
	        debug("we are currently writing - waiting to pause");
	        total++;
	        this.once("drain", function() {
	          debug("pre-pause writing complete");
	          --total || pause();
	        });
	      }
	    } else {
	      pause();
	    }
	  }
	
	  /**
	   * Starts polling cycle.
	   *
	   * @api public
	   */
	  poll() {
	    debug("polling");
	    this.polling = true;
	    this.doPoll();
	    this.emit("poll");
	  }
	
	  /**
	   * Overloads onData to detect payloads.
	   *
	   * @api private
	   */
	  onData(data) {
	    const self = this;
	    debug("polling got data %s", data);
	    const callback = function(packet, index, total) {
	      // if its the first message we consider the transport open
	      if ("opening" === self.readyState && packet.type === "open") {
	        self.onOpen();
	      }
	
	      // if its a close packet, we close the ongoing requests
	      if ("close" === packet.type) {
	        self.onClose();
	        return false;
	      }
	
	      // otherwise bypass onData and handle the message
	      self.onPacket(packet);
	    };
	
	    // decode payload
	    parser.decodePayload(data, this.socket.binaryType).forEach(callback);
	
	    // if an event did not trigger closing
	    if ("closed" !== this.readyState) {
	      // if we got data we're not polling
	      this.polling = false;
	      this.emit("pollComplete");
	
	      if ("open" === this.readyState) {
	        this.poll();
	      } else {
	        debug('ignoring poll - transport state "%s"', this.readyState);
	      }
	    }
	  }
	
	  /**
	   * For polling, send a close packet.
	   *
	   * @api private
	   */
	  doClose() {
	    const self = this;
	
	    function close() {
	      debug("writing close packet");
	      self.write([{ type: "close" }]);
	    }
	
	    if ("open" === this.readyState) {
	      debug("transport open - closing");
	      close();
	    } else {
	      // in case we're trying to close while
	      // handshaking is in progress (GH-164)
	      debug("transport not open - deferring close");
	      this.once("open", close);
	    }
	  }
	
	  /**
	   * Writes a packets payload.
	   *
	   * @param {Array} data packets
	   * @param {Function} drain callback
	   * @api private
	   */
	  write(packets) {
	    this.writable = false;
	
	    parser.encodePayload(packets, data => {
	      this.doWrite(data, () => {
	        this.writable = true;
	        this.emit("drain");
	      });
	    });
	  }
	
	  /**
	   * Generates uri for connection.
	   *
	   * @api private
	   */
	  uri() {
	    let query = this.query || {};
	    const schema = this.opts.secure ? "https" : "http";
	    let port = "";
	
	    // cache busting is forced
	    if (false !== this.opts.timestampRequests) {
	      query[this.opts.timestampParam] = yeast();
	    }
	
	    if (!this.supportsBinary && !query.sid) {
	      query.b64 = 1;
	    }
	
	    query = parseqs.encode(query);
	
	    // avoid port if default for schema
	    if (
	      this.opts.port &&
	      (("https" === schema && Number(this.opts.port) !== 443) ||
	        ("http" === schema && Number(this.opts.port) !== 80))
	    ) {
	      port = ":" + this.opts.port;
	    }
	
	    // prepend ? to query
	    if (query.length) {
	      query = "?" + query;
	    }
	
	    const ipv6 = this.opts.hostname.indexOf(":") !== -1;
	    return (
	      schema +
	      "://" +
	      (ipv6 ? "[" + this.opts.hostname + "]" : this.opts.hostname) +
	      port +
	      this.opts.path +
	      query
	    );
	  }
	}
	
	module.exports = Polling;


/***/ },
/* 159 */
/***/ function(module, exports) {

	module.exports.pick = (obj, ...attr) => {
	  return attr.reduce((acc, k) => {
	    if (obj.hasOwnProperty(k)) {
	      acc[k] = obj[k];
	    }
	    return acc;
	  }, {});
	};


/***/ },
/* 160 */
/***/ function(module, exports, __webpack_require__) {

	// browser shim for xmlhttprequest module
	
	const hasCORS = __webpack_require__(395);
	const globalThis = __webpack_require__(71);
	
	module.exports = function(opts) {
	  const xdomain = opts.xdomain;
	
	  // scheme must be same when usign XDomainRequest
	  // http://blogs.msdn.com/b/ieinternals/archive/2010/05/13/xdomainrequest-restrictions-limitations-and-workarounds.aspx
	  const xscheme = opts.xscheme;
	
	  // XDomainRequest has a flow of not sending cookie, therefore it should be disabled as a default.
	  // https://github.com/Automattic/engine.io-client/pull/217
	  const enablesXDR = opts.enablesXDR;
	
	  // XMLHttpRequest can be disabled on IE
	  try {
	    if ("undefined" !== typeof XMLHttpRequest && (!xdomain || hasCORS)) {
	      return new XMLHttpRequest();
	    }
	  } catch (e) {}
	
	  // Use XDomainRequest for IE8 if enablesXDR is true
	  // because loading bar keeps flashing when using jsonp-polling
	  // https://github.com/yujiosaka/socke.io-ie8-loading-example
	  try {
	    if ("undefined" !== typeof XDomainRequest && !xscheme && enablesXDR) {
	      return new XDomainRequest();
	    }
	  } catch (e) {}
	
	  if (!xdomain) {
	    try {
	      return new globalThis[["Active"].concat("Object").join("X")](
	        "Microsoft.XMLHTTP"
	      );
	    } catch (e) {}
	  }
	};


/***/ },
/* 161 */
/***/ function(module, exports) {

	const PACKET_TYPES = Object.create(null); // no Map = no polyfill
	PACKET_TYPES["open"] = "0";
	PACKET_TYPES["close"] = "1";
	PACKET_TYPES["ping"] = "2";
	PACKET_TYPES["pong"] = "3";
	PACKET_TYPES["message"] = "4";
	PACKET_TYPES["upgrade"] = "5";
	PACKET_TYPES["noop"] = "6";
	
	const PACKET_TYPES_REVERSE = Object.create(null);
	Object.keys(PACKET_TYPES).forEach(key => {
	  PACKET_TYPES_REVERSE[PACKET_TYPES[key]] = key;
	});
	
	const ERROR_PACKET = { type: "error", data: "parser error" };
	
	module.exports = {
	  PACKET_TYPES,
	  PACKET_TYPES_REVERSE,
	  ERROR_PACKET
	};


/***/ },
/* 162 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	if (true) {
	  module.exports = __webpack_require__(396);
	} else {
	  module.exports = require('./cjs/history.js');
	}


/***/ },
/* 163 */
/***/ function(module, exports) {

	/**
	 * Parses an URI
	 *
	 * @author Steven Levithan <stevenlevithan.com> (MIT license)
	 * @api private
	 */
	
	var re = /^(?:(?![^:@]+:[^:@\/]*@)(http|https|ws|wss):\/\/)?((?:(([^:@]*)(?::([^:@]*))?)?@)?((?:[a-f0-9]{0,4}:){2,7}[a-f0-9]{0,4}|[^:\/?#]*)(?::(\d*))?)(((\/(?:[^?#](?![^?#\/]*\.[^?#\/.]+(?:[?#]|$)))*\/?)?([^?#\/]*))(?:\?([^#]*))?(?:#(.*))?)/;
	
	var parts = [
	    'source', 'protocol', 'authority', 'userInfo', 'user', 'password', 'host', 'port', 'relative', 'path', 'directory', 'file', 'query', 'anchor'
	];
	
	module.exports = function parseuri(str) {
	    var src = str,
	        b = str.indexOf('['),
	        e = str.indexOf(']');
	
	    if (b != -1 && e != -1) {
	        str = str.substring(0, b) + str.substring(b, e).replace(/:/g, ';') + str.substring(e, str.length);
	    }
	
	    var m = re.exec(str || ''),
	        uri = {},
	        i = 14;
	
	    while (i--) {
	        uri[parts[i]] = m[i] || '';
	    }
	
	    if (b != -1 && e != -1) {
	        uri.source = src;
	        uri.host = uri.host.substring(1, uri.host.length - 1).replace(/;/g, ':');
	        uri.authority = uri.authority.replace('[', '').replace(']', '').replace(/;/g, ':');
	        uri.ipv6uri = true;
	    }
	
	    uri.pathNames = pathNames(uri, uri['path']);
	    uri.queryKey = queryKey(uri, uri['query']);
	
	    return uri;
	};
	
	function pathNames(obj, path) {
	    var regx = /\/{2,9}/g,
	        names = path.replace(regx, "/").split("/");
	
	    if (path.substr(0, 1) == '/' || path.length === 0) {
	        names.splice(0, 1);
	    }
	    if (path.substr(path.length - 1, 1) == '/') {
	        names.splice(names.length - 1, 1);
	    }
	
	    return names;
	}
	
	function queryKey(uri, query) {
	    var data = {};
	
	    query.replace(/(?:^|&)([^&=]*)=?([^&]*)/g, function ($0, $1, $2) {
	        if ($1) {
	            data[$1] = $2;
	        }
	    });
	
	    return data;
	}


/***/ },
/* 164 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	var asap = __webpack_require__(200);
	
	function noop() {}
	
	// States:
	//
	// 0 - pending
	// 1 - fulfilled with _value
	// 2 - rejected with _value
	// 3 - adopted the state of another promise, _value
	//
	// once the state is no longer pending (0) it is immutable
	
	// All `_` prefixed properties will be reduced to `_{random number}`
	// at build time to obfuscate them and discourage their use.
	// We don't use symbols or Object.defineProperty to fully hide them
	// because the performance isn't good enough.
	
	
	// to avoid using try/catch inside critical functions, we
	// extract them to here.
	var LAST_ERROR = null;
	var IS_ERROR = {};
	function getThen(obj) {
	  try {
	    return obj.then;
	  } catch (ex) {
	    LAST_ERROR = ex;
	    return IS_ERROR;
	  }
	}
	
	function tryCallOne(fn, a) {
	  try {
	    return fn(a);
	  } catch (ex) {
	    LAST_ERROR = ex;
	    return IS_ERROR;
	  }
	}
	function tryCallTwo(fn, a, b) {
	  try {
	    fn(a, b);
	  } catch (ex) {
	    LAST_ERROR = ex;
	    return IS_ERROR;
	  }
	}
	
	module.exports = Promise;
	
	function Promise(fn) {
	  if (typeof this !== 'object') {
	    throw new TypeError('Promises must be constructed via new');
	  }
	  if (typeof fn !== 'function') {
	    throw new TypeError('not a function');
	  }
	  this._45 = 0;
	  this._81 = 0;
	  this._65 = null;
	  this._54 = null;
	  if (fn === noop) return;
	  doResolve(fn, this);
	}
	Promise._10 = null;
	Promise._97 = null;
	Promise._61 = noop;
	
	Promise.prototype.then = function(onFulfilled, onRejected) {
	  if (this.constructor !== Promise) {
	    return safeThen(this, onFulfilled, onRejected);
	  }
	  var res = new Promise(noop);
	  handle(this, new Handler(onFulfilled, onRejected, res));
	  return res;
	};
	
	function safeThen(self, onFulfilled, onRejected) {
	  return new self.constructor(function (resolve, reject) {
	    var res = new Promise(noop);
	    res.then(resolve, reject);
	    handle(self, new Handler(onFulfilled, onRejected, res));
	  });
	};
	function handle(self, deferred) {
	  while (self._81 === 3) {
	    self = self._65;
	  }
	  if (Promise._10) {
	    Promise._10(self);
	  }
	  if (self._81 === 0) {
	    if (self._45 === 0) {
	      self._45 = 1;
	      self._54 = deferred;
	      return;
	    }
	    if (self._45 === 1) {
	      self._45 = 2;
	      self._54 = [self._54, deferred];
	      return;
	    }
	    self._54.push(deferred);
	    return;
	  }
	  handleResolved(self, deferred);
	}
	
	function handleResolved(self, deferred) {
	  asap(function() {
	    var cb = self._81 === 1 ? deferred.onFulfilled : deferred.onRejected;
	    if (cb === null) {
	      if (self._81 === 1) {
	        resolve(deferred.promise, self._65);
	      } else {
	        reject(deferred.promise, self._65);
	      }
	      return;
	    }
	    var ret = tryCallOne(cb, self._65);
	    if (ret === IS_ERROR) {
	      reject(deferred.promise, LAST_ERROR);
	    } else {
	      resolve(deferred.promise, ret);
	    }
	  });
	}
	function resolve(self, newValue) {
	  // Promise Resolution Procedure: https://github.com/promises-aplus/promises-spec#the-promise-resolution-procedure
	  if (newValue === self) {
	    return reject(
	      self,
	      new TypeError('A promise cannot be resolved with itself.')
	    );
	  }
	  if (
	    newValue &&
	    (typeof newValue === 'object' || typeof newValue === 'function')
	  ) {
	    var then = getThen(newValue);
	    if (then === IS_ERROR) {
	      return reject(self, LAST_ERROR);
	    }
	    if (
	      then === self.then &&
	      newValue instanceof Promise
	    ) {
	      self._81 = 3;
	      self._65 = newValue;
	      finale(self);
	      return;
	    } else if (typeof then === 'function') {
	      doResolve(then.bind(newValue), self);
	      return;
	    }
	  }
	  self._81 = 1;
	  self._65 = newValue;
	  finale(self);
	}
	
	function reject(self, newValue) {
	  self._81 = 2;
	  self._65 = newValue;
	  if (Promise._97) {
	    Promise._97(self, newValue);
	  }
	  finale(self);
	}
	function finale(self) {
	  if (self._45 === 1) {
	    handle(self, self._54);
	    self._54 = null;
	  }
	  if (self._45 === 2) {
	    for (var i = 0; i < self._54.length; i++) {
	      handle(self, self._54[i]);
	    }
	    self._54 = null;
	  }
	}
	
	function Handler(onFulfilled, onRejected, promise){
	  this.onFulfilled = typeof onFulfilled === 'function' ? onFulfilled : null;
	  this.onRejected = typeof onRejected === 'function' ? onRejected : null;
	  this.promise = promise;
	}
	
	/**
	 * Take a potentially misbehaving resolver function and make sure
	 * onFulfilled and onRejected are only called once.
	 *
	 * Makes no guarantees about asynchrony.
	 */
	function doResolve(fn, promise) {
	  var done = false;
	  var res = tryCallTwo(fn, function (value) {
	    if (done) return;
	    done = true;
	    resolve(promise, value);
	  }, function (reason) {
	    if (done) return;
	    done = true;
	    reject(promise, reason);
	  })
	  if (!done && res === IS_ERROR) {
	    done = true;
	    reject(promise, LAST_ERROR);
	  }
	}


/***/ },
/* 165 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	if (true) {
	  module.exports = __webpack_require__(407);
	} else {
	  module.exports = require('./cjs/react-is.development.js');
	}


/***/ },
/* 166 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	
	exports.__esModule = true;
	exports.getTabsCount = getTabsCount;
	exports.getPanelsCount = getPanelsCount;
	
	var _childrenDeepMap = __webpack_require__(101);
	
	var _elementTypes = __webpack_require__(73);
	
	function getTabsCount(children) {
	  var tabCount = 0;
	  (0, _childrenDeepMap.deepForEach)(children, function (child) {
	    if ((0, _elementTypes.isTab)(child)) tabCount++;
	  });
	  return tabCount;
	}
	
	function getPanelsCount(children) {
	  var panelCount = 0;
	  (0, _childrenDeepMap.deepForEach)(children, function (child) {
	    if ((0, _elementTypes.isTabPanel)(child)) panelCount++;
	  });
	  return panelCount;
	}

/***/ },
/* 167 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	
	exports.__esModule = true;
	exports.childrenPropType = childrenPropType;
	exports.onSelectPropType = onSelectPropType;
	exports.selectedIndexPropType = selectedIndexPropType;
	
	var _childrenDeepMap = __webpack_require__(101);
	
	var _elementTypes = __webpack_require__(73);
	
	function childrenPropType(props, propName, componentName) {
	  var error;
	  var tabsCount = 0;
	  var panelsCount = 0;
	  var tabListFound = false;
	  var listTabs = [];
	  var children = props[propName];
	  (0, _childrenDeepMap.deepForEach)(children, function (child) {
	    if ((0, _elementTypes.isTabList)(child)) {
	      if (child.props && child.props.children && typeof child.props.children === 'object') {
	        (0, _childrenDeepMap.deepForEach)(child.props.children, function (listChild) {
	          return listTabs.push(listChild);
	        });
	      }
	
	      if (tabListFound) {
	        error = new Error("Found multiple 'TabList' components inside 'Tabs'. Only one is allowed.");
	      }
	
	      tabListFound = true;
	    }
	
	    if ((0, _elementTypes.isTab)(child)) {
	      if (!tabListFound || listTabs.indexOf(child) === -1) {
	        error = new Error("Found a 'Tab' component outside of the 'TabList' component. 'Tab' components " + "have to be inside the 'TabList' component.");
	      }
	
	      tabsCount++;
	    } else if ((0, _elementTypes.isTabPanel)(child)) {
	      panelsCount++;
	    }
	  });
	
	  if (!error && tabsCount !== panelsCount) {
	    error = new Error("There should be an equal number of 'Tab' and 'TabPanel' in `" + componentName + "`. " + ("Received " + tabsCount + " 'Tab' and " + panelsCount + " 'TabPanel'."));
	  }
	
	  return error;
	}
	
	function onSelectPropType(props, propName, componentName, location, propFullName) {
	  var prop = props[propName];
	  var name = propFullName || propName;
	  var error = null;
	
	  if (prop && typeof prop !== 'function') {
	    error = new Error("Invalid " + location + " `" + name + "` of type `" + typeof prop + "` supplied " + ("to `" + componentName + "`, expected `function`."));
	  } else if (props.selectedIndex != null && prop == null) {
	    error = new Error("The " + location + " `" + name + "` is marked as required in `" + componentName + "`, but " + "its value is `undefined` or `null`.\n" + "`onSelect` is required when `selectedIndex` is also set. Not doing so will " + "make the tabs not do anything, as `selectedIndex` indicates that you want to " + "handle the selected tab yourself.\n" + "If you only want to set the inital tab replace `selectedIndex` with `defaultIndex`.");
	  }
	
	  return error;
	}
	
	function selectedIndexPropType(props, propName, componentName, location, propFullName) {
	  var prop = props[propName];
	  var name = propFullName || propName;
	  var error = null;
	
	  if (prop != null && typeof prop !== 'number') {
	    error = new Error("Invalid " + location + " `" + name + "` of type `" + typeof prop + "` supplied to " + ("`" + componentName + "`, expected `number`."));
	  } else if (props.defaultIndex != null && prop != null) {
	    return new Error("The " + location + " `" + name + "` cannot be used together with `defaultIndex` " + ("in `" + componentName + "`.\n") + ("Either remove `" + name + "` to let `" + componentName + "` handle the selected ") + "tab internally or remove `defaultIndex` to handle it yourself.");
	  }
	
	  return error;
	}

/***/ },
/* 168 */
/***/ function(module, exports) {

	"use strict";
	
	exports.__esModule = true;
	exports["default"] = uuid;
	exports.reset = reset;
	// Get a universally unique identifier
	var count = 0;
	
	function uuid() {
	  return "react-tabs-" + count++;
	}
	
	function reset() {
	  count = 0;
	}

/***/ },
/* 169 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	Object.defineProperty(exports, "__esModule", { value: true });
	exports.Manager = void 0;
	const eio = __webpack_require__(379);
	const socket_1 = __webpack_require__(171);
	const Emitter = __webpack_require__(44);
	const parser = __webpack_require__(102);
	const on_1 = __webpack_require__(170);
	const Backoff = __webpack_require__(285);
	const debug = __webpack_require__(75)("socket.io-client:manager");
	class Manager extends Emitter {
	    constructor(uri, opts) {
	        super();
	        this.nsps = {};
	        this.subs = [];
	        if (uri && "object" === typeof uri) {
	            opts = uri;
	            uri = undefined;
	        }
	        opts = opts || {};
	        opts.path = opts.path || "/socket.io";
	        this.opts = opts;
	        this.reconnection(opts.reconnection !== false);
	        this.reconnectionAttempts(opts.reconnectionAttempts || Infinity);
	        this.reconnectionDelay(opts.reconnectionDelay || 1000);
	        this.reconnectionDelayMax(opts.reconnectionDelayMax || 5000);
	        this.randomizationFactor(opts.randomizationFactor || 0.5);
	        this.backoff = new Backoff({
	            min: this.reconnectionDelay(),
	            max: this.reconnectionDelayMax(),
	            jitter: this.randomizationFactor(),
	        });
	        this.timeout(null == opts.timeout ? 20000 : opts.timeout);
	        this._readyState = "closed";
	        this.uri = uri;
	        const _parser = opts.parser || parser;
	        this.encoder = new _parser.Encoder();
	        this.decoder = new _parser.Decoder();
	        this._autoConnect = opts.autoConnect !== false;
	        if (this._autoConnect)
	            this.open();
	    }
	    reconnection(v) {
	        if (!arguments.length)
	            return this._reconnection;
	        this._reconnection = !!v;
	        return this;
	    }
	    reconnectionAttempts(v) {
	        if (v === undefined)
	            return this._reconnectionAttempts;
	        this._reconnectionAttempts = v;
	        return this;
	    }
	    reconnectionDelay(v) {
	        var _a;
	        if (v === undefined)
	            return this._reconnectionDelay;
	        this._reconnectionDelay = v;
	        (_a = this.backoff) === null || _a === void 0 ? void 0 : _a.setMin(v);
	        return this;
	    }
	    randomizationFactor(v) {
	        var _a;
	        if (v === undefined)
	            return this._randomizationFactor;
	        this._randomizationFactor = v;
	        (_a = this.backoff) === null || _a === void 0 ? void 0 : _a.setJitter(v);
	        return this;
	    }
	    reconnectionDelayMax(v) {
	        var _a;
	        if (v === undefined)
	            return this._reconnectionDelayMax;
	        this._reconnectionDelayMax = v;
	        (_a = this.backoff) === null || _a === void 0 ? void 0 : _a.setMax(v);
	        return this;
	    }
	    timeout(v) {
	        if (!arguments.length)
	            return this._timeout;
	        this._timeout = v;
	        return this;
	    }
	    /**
	     * Starts trying to reconnect if reconnection is enabled and we have not
	     * started reconnecting yet
	     *
	     * @private
	     */
	    maybeReconnectOnOpen() {
	        // Only try to reconnect if it's the first time we're connecting
	        if (!this._reconnecting &&
	            this._reconnection &&
	            this.backoff.attempts === 0) {
	            // keeps reconnection from firing twice for the same reconnection loop
	            this.reconnect();
	        }
	    }
	    /**
	     * Sets the current transport `socket`.
	     *
	     * @param {Function} fn - optional, callback
	     * @return self
	     * @public
	     */
	    open(fn) {
	        debug("readyState %s", this._readyState);
	        if (~this._readyState.indexOf("open"))
	            return this;
	        debug("opening %s", this.uri);
	        this.engine = eio(this.uri, this.opts);
	        const socket = this.engine;
	        const self = this;
	        this._readyState = "opening";
	        this.skipReconnect = false;
	        // emit `open`
	        const openSubDestroy = on_1.on(socket, "open", function () {
	            self.onopen();
	            fn && fn();
	        });
	        // emit `error`
	        const errorSub = on_1.on(socket, "error", (err) => {
	            debug("error");
	            self.cleanup();
	            self._readyState = "closed";
	            super.emit("error", err);
	            if (fn) {
	                fn(err);
	            }
	            else {
	                // Only do this if there is no fn to handle the error
	                self.maybeReconnectOnOpen();
	            }
	        });
	        if (false !== this._timeout) {
	            const timeout = this._timeout;
	            debug("connect attempt will timeout after %d", timeout);
	            if (timeout === 0) {
	                openSubDestroy(); // prevents a race condition with the 'open' event
	            }
	            // set timer
	            const timer = setTimeout(() => {
	                debug("connect attempt timed out after %d", timeout);
	                openSubDestroy();
	                socket.close();
	                socket.emit("error", new Error("timeout"));
	            }, timeout);
	            this.subs.push(function subDestroy() {
	                clearTimeout(timer);
	            });
	        }
	        this.subs.push(openSubDestroy);
	        this.subs.push(errorSub);
	        return this;
	    }
	    /**
	     * Alias for open()
	     *
	     * @return self
	     * @public
	     */
	    connect(fn) {
	        return this.open(fn);
	    }
	    /**
	     * Called upon transport open.
	     *
	     * @private
	     */
	    onopen() {
	        debug("open");
	        // clear old subs
	        this.cleanup();
	        // mark as open
	        this._readyState = "open";
	        super.emit("open");
	        // add new subs
	        const socket = this.engine;
	        this.subs.push(on_1.on(socket, "ping", this.onping.bind(this)), on_1.on(socket, "data", this.ondata.bind(this)), on_1.on(socket, "error", this.onerror.bind(this)), on_1.on(socket, "close", this.onclose.bind(this)), on_1.on(this.decoder, "decoded", this.ondecoded.bind(this)));
	    }
	    /**
	     * Called upon a ping.
	     *
	     * @private
	     */
	    onping() {
	        super.emit("ping");
	    }
	    /**
	     * Called with data.
	     *
	     * @private
	     */
	    ondata(data) {
	        this.decoder.add(data);
	    }
	    /**
	     * Called when parser fully decodes a packet.
	     *
	     * @private
	     */
	    ondecoded(packet) {
	        super.emit("packet", packet);
	    }
	    /**
	     * Called upon socket error.
	     *
	     * @private
	     */
	    onerror(err) {
	        debug("error", err);
	        super.emit("error", err);
	    }
	    /**
	     * Creates a new socket for the given `nsp`.
	     *
	     * @return {Socket}
	     * @public
	     */
	    socket(nsp, opts) {
	        let socket = this.nsps[nsp];
	        if (!socket) {
	            socket = new socket_1.Socket(this, nsp, opts);
	            this.nsps[nsp] = socket;
	        }
	        return socket;
	    }
	    /**
	     * Called upon a socket close.
	     *
	     * @param socket
	     * @private
	     */
	    _destroy(socket) {
	        const nsps = Object.keys(this.nsps);
	        for (const nsp of nsps) {
	            const socket = this.nsps[nsp];
	            if (socket.active) {
	                debug("socket %s is still active, skipping close", nsp);
	                return;
	            }
	        }
	        this._close();
	    }
	    /**
	     * Writes a packet.
	     *
	     * @param packet
	     * @private
	     */
	    _packet(packet) {
	        debug("writing packet %j", packet);
	        if (packet.query && packet.type === 0)
	            packet.nsp += "?" + packet.query;
	        const encodedPackets = this.encoder.encode(packet);
	        for (let i = 0; i < encodedPackets.length; i++) {
	            this.engine.write(encodedPackets[i], packet.options);
	        }
	    }
	    /**
	     * Clean up transport subscriptions and packet buffer.
	     *
	     * @private
	     */
	    cleanup() {
	        debug("cleanup");
	        this.subs.forEach((subDestroy) => subDestroy());
	        this.subs.length = 0;
	        this.decoder.destroy();
	    }
	    /**
	     * Close the current socket.
	     *
	     * @private
	     */
	    _close() {
	        debug("disconnect");
	        this.skipReconnect = true;
	        this._reconnecting = false;
	        if ("opening" === this._readyState) {
	            // `onclose` will not fire because
	            // an open event never happened
	            this.cleanup();
	        }
	        this.backoff.reset();
	        this._readyState = "closed";
	        if (this.engine)
	            this.engine.close();
	    }
	    /**
	     * Alias for close()
	     *
	     * @private
	     */
	    disconnect() {
	        return this._close();
	    }
	    /**
	     * Called upon engine close.
	     *
	     * @private
	     */
	    onclose(reason) {
	        debug("onclose");
	        this.cleanup();
	        this.backoff.reset();
	        this._readyState = "closed";
	        super.emit("close", reason);
	        if (this._reconnection && !this.skipReconnect) {
	            this.reconnect();
	        }
	    }
	    /**
	     * Attempt a reconnection.
	     *
	     * @private
	     */
	    reconnect() {
	        if (this._reconnecting || this.skipReconnect)
	            return this;
	        const self = this;
	        if (this.backoff.attempts >= this._reconnectionAttempts) {
	            debug("reconnect failed");
	            this.backoff.reset();
	            super.emit("reconnect_failed");
	            this._reconnecting = false;
	        }
	        else {
	            const delay = this.backoff.duration();
	            debug("will wait %dms before reconnect attempt", delay);
	            this._reconnecting = true;
	            const timer = setTimeout(() => {
	                if (self.skipReconnect)
	                    return;
	                debug("attempting reconnect");
	                super.emit("reconnect_attempt", self.backoff.attempts);
	                // check again for the case socket closed in above events
	                if (self.skipReconnect)
	                    return;
	                self.open((err) => {
	                    if (err) {
	                        debug("reconnect attempt error");
	                        self._reconnecting = false;
	                        self.reconnect();
	                        super.emit("reconnect_error", err);
	                    }
	                    else {
	                        debug("reconnect success");
	                        self.onreconnect();
	                    }
	                });
	            }, delay);
	            this.subs.push(function subDestroy() {
	                clearTimeout(timer);
	            });
	        }
	    }
	    /**
	     * Called upon successful reconnect.
	     *
	     * @private
	     */
	    onreconnect() {
	        const attempt = this.backoff.attempts;
	        this._reconnecting = false;
	        this.backoff.reset();
	        super.emit("reconnect", attempt);
	    }
	}
	exports.Manager = Manager;


/***/ },
/* 170 */
/***/ function(module, exports) {

	"use strict";
	Object.defineProperty(exports, "__esModule", { value: true });
	exports.on = void 0;
	function on(obj, ev, fn) {
	    obj.on(ev, fn);
	    return function subDestroy() {
	        obj.off(ev, fn);
	    };
	}
	exports.on = on;


/***/ },
/* 171 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	Object.defineProperty(exports, "__esModule", { value: true });
	exports.Socket = void 0;
	const socket_io_parser_1 = __webpack_require__(102);
	const Emitter = __webpack_require__(44);
	const on_1 = __webpack_require__(170);
	const debug = __webpack_require__(75)("socket.io-client:socket");
	/**
	 * Internal events.
	 * These events can't be emitted by the user.
	 */
	const RESERVED_EVENTS = Object.freeze({
	    connect: 1,
	    connect_error: 1,
	    disconnect: 1,
	    disconnecting: 1,
	    // EventEmitter reserved events: https://nodejs.org/api/events.html#events_event_newlistener
	    newListener: 1,
	    removeListener: 1,
	});
	class Socket extends Emitter {
	    /**
	     * `Socket` constructor.
	     *
	     * @public
	     */
	    constructor(io, nsp, opts) {
	        super();
	        this.receiveBuffer = [];
	        this.sendBuffer = [];
	        this.ids = 0;
	        this.acks = {};
	        this.flags = {};
	        this.io = io;
	        this.nsp = nsp;
	        this.ids = 0;
	        this.acks = {};
	        this.receiveBuffer = [];
	        this.sendBuffer = [];
	        this.connected = false;
	        this.disconnected = true;
	        this.flags = {};
	        if (opts && opts.auth) {
	            this.auth = opts.auth;
	        }
	        if (this.io._autoConnect)
	            this.open();
	    }
	    /**
	     * Subscribe to open, close and packet events
	     *
	     * @private
	     */
	    subEvents() {
	        if (this.subs)
	            return;
	        const io = this.io;
	        this.subs = [
	            on_1.on(io, "open", this.onopen.bind(this)),
	            on_1.on(io, "packet", this.onpacket.bind(this)),
	            on_1.on(io, "error", this.onerror.bind(this)),
	            on_1.on(io, "close", this.onclose.bind(this)),
	        ];
	    }
	    /**
	     * Whether the Socket will try to reconnect when its Manager connects or reconnects
	     */
	    get active() {
	        return !!this.subs;
	    }
	    /**
	     * "Opens" the socket.
	     *
	     * @public
	     */
	    connect() {
	        if (this.connected)
	            return this;
	        this.subEvents();
	        if (!this.io["_reconnecting"])
	            this.io.open(); // ensure open
	        if ("open" === this.io._readyState)
	            this.onopen();
	        return this;
	    }
	    /**
	     * Alias for connect()
	     */
	    open() {
	        return this.connect();
	    }
	    /**
	     * Sends a `message` event.
	     *
	     * @return self
	     * @public
	     */
	    send(...args) {
	        args.unshift("message");
	        this.emit.apply(this, args);
	        return this;
	    }
	    /**
	     * Override `emit`.
	     * If the event is in `events`, it's emitted normally.
	     *
	     * @param ev - event name
	     * @return self
	     * @public
	     */
	    emit(ev, ...args) {
	        if (RESERVED_EVENTS.hasOwnProperty(ev)) {
	            throw new Error('"' + ev + '" is a reserved event name');
	        }
	        args.unshift(ev);
	        const packet = {
	            type: socket_io_parser_1.PacketType.EVENT,
	            data: args,
	        };
	        packet.options = {};
	        packet.options.compress = this.flags.compress !== false;
	        // event ack callback
	        if ("function" === typeof args[args.length - 1]) {
	            debug("emitting packet with ack id %d", this.ids);
	            this.acks[this.ids] = args.pop();
	            packet.id = this.ids++;
	        }
	        const isTransportWritable = this.io.engine &&
	            this.io.engine.transport &&
	            this.io.engine.transport.writable;
	        const discardPacket = this.flags.volatile && (!isTransportWritable || !this.connected);
	        if (discardPacket) {
	            debug("discard packet as the transport is not currently writable");
	        }
	        else if (this.connected) {
	            this.packet(packet);
	        }
	        else {
	            this.sendBuffer.push(packet);
	        }
	        this.flags = {};
	        return this;
	    }
	    /**
	     * Sends a packet.
	     *
	     * @param packet
	     * @private
	     */
	    packet(packet) {
	        packet.nsp = this.nsp;
	        this.io._packet(packet);
	    }
	    /**
	     * Called upon engine `open`.
	     *
	     * @private
	     */
	    onopen() {
	        debug("transport is open - connecting");
	        if (typeof this.auth == "function") {
	            this.auth((data) => {
	                this.packet({ type: socket_io_parser_1.PacketType.CONNECT, data });
	            });
	        }
	        else {
	            this.packet({ type: socket_io_parser_1.PacketType.CONNECT, data: this.auth });
	        }
	    }
	    /**
	     * Called upon engine or manager `error`.
	     *
	     * @param err
	     * @private
	     */
	    onerror(err) {
	        if (!this.connected) {
	            super.emit("connect_error", err);
	        }
	    }
	    /**
	     * Called upon engine `close`.
	     *
	     * @param reason
	     * @private
	     */
	    onclose(reason) {
	        debug("close (%s)", reason);
	        this.connected = false;
	        this.disconnected = true;
	        delete this.id;
	        super.emit("disconnect", reason);
	    }
	    /**
	     * Called with socket packet.
	     *
	     * @param packet
	     * @private
	     */
	    onpacket(packet) {
	        const sameNamespace = packet.nsp === this.nsp;
	        if (!sameNamespace)
	            return;
	        switch (packet.type) {
	            case socket_io_parser_1.PacketType.CONNECT:
	                if (packet.data && packet.data.sid) {
	                    const id = packet.data.sid;
	                    this.onconnect(id);
	                }
	                else {
	                    super.emit("connect_error", new Error("It seems you are trying to reach a Socket.IO server in v2.x with a v3.x client, but they are not compatible (more information here: https://socket.io/docs/v3/migrating-from-2-x-to-3-0/)"));
	                }
	                break;
	            case socket_io_parser_1.PacketType.EVENT:
	                this.onevent(packet);
	                break;
	            case socket_io_parser_1.PacketType.BINARY_EVENT:
	                this.onevent(packet);
	                break;
	            case socket_io_parser_1.PacketType.ACK:
	                this.onack(packet);
	                break;
	            case socket_io_parser_1.PacketType.BINARY_ACK:
	                this.onack(packet);
	                break;
	            case socket_io_parser_1.PacketType.DISCONNECT:
	                this.ondisconnect();
	                break;
	            case socket_io_parser_1.PacketType.CONNECT_ERROR:
	                const err = new Error(packet.data.message);
	                // @ts-ignore
	                err.data = packet.data.data;
	                super.emit("connect_error", err);
	                break;
	        }
	    }
	    /**
	     * Called upon a server event.
	     *
	     * @param packet
	     * @private
	     */
	    onevent(packet) {
	        const args = packet.data || [];
	        debug("emitting event %j", args);
	        if (null != packet.id) {
	            debug("attaching ack callback to event");
	            args.push(this.ack(packet.id));
	        }
	        if (this.connected) {
	            this.emitEvent(args);
	        }
	        else {
	            this.receiveBuffer.push(Object.freeze(args));
	        }
	    }
	    emitEvent(args) {
	        if (this._anyListeners && this._anyListeners.length) {
	            const listeners = this._anyListeners.slice();
	            for (const listener of listeners) {
	                listener.apply(this, args);
	            }
	        }
	        super.emit.apply(this, args);
	    }
	    /**
	     * Produces an ack callback to emit with an event.
	     *
	     * @private
	     */
	    ack(id) {
	        const self = this;
	        let sent = false;
	        return function (...args) {
	            // prevent double callbacks
	            if (sent)
	                return;
	            sent = true;
	            debug("sending ack %j", args);
	            self.packet({
	                type: socket_io_parser_1.PacketType.ACK,
	                id: id,
	                data: args,
	            });
	        };
	    }
	    /**
	     * Called upon a server acknowlegement.
	     *
	     * @param packet
	     * @private
	     */
	    onack(packet) {
	        const ack = this.acks[packet.id];
	        if ("function" === typeof ack) {
	            debug("calling ack %s with %j", packet.id, packet.data);
	            ack.apply(this, packet.data);
	            delete this.acks[packet.id];
	        }
	        else {
	            debug("bad ack %s", packet.id);
	        }
	    }
	    /**
	     * Called upon server connect.
	     *
	     * @private
	     */
	    onconnect(id) {
	        debug("socket connected with id %s", id);
	        this.id = id;
	        this.connected = true;
	        this.disconnected = false;
	        super.emit("connect");
	        this.emitBuffered();
	    }
	    /**
	     * Emit buffered events (received and emitted).
	     *
	     * @private
	     */
	    emitBuffered() {
	        this.receiveBuffer.forEach((args) => this.emitEvent(args));
	        this.receiveBuffer = [];
	        this.sendBuffer.forEach((packet) => this.packet(packet));
	        this.sendBuffer = [];
	    }
	    /**
	     * Called upon server disconnect.
	     *
	     * @private
	     */
	    ondisconnect() {
	        debug("server disconnect (%s)", this.nsp);
	        this.destroy();
	        this.onclose("io server disconnect");
	    }
	    /**
	     * Called upon forced client/server side disconnections,
	     * this method ensures the manager stops tracking us and
	     * that reconnections don't get triggered for this.
	     *
	     * @private
	     */
	    destroy() {
	        if (this.subs) {
	            // clean subscriptions to avoid reconnections
	            this.subs.forEach((subDestroy) => subDestroy());
	            this.subs = undefined;
	        }
	        this.io["_destroy"](this);
	    }
	    /**
	     * Disconnects the socket manually.
	     *
	     * @return self
	     * @public
	     */
	    disconnect() {
	        if (this.connected) {
	            debug("performing disconnect (%s)", this.nsp);
	            this.packet({ type: socket_io_parser_1.PacketType.DISCONNECT });
	        }
	        // remove socket from pool
	        this.destroy();
	        if (this.connected) {
	            // fire events
	            this.onclose("io client disconnect");
	        }
	        return this;
	    }
	    /**
	     * Alias for disconnect()
	     *
	     * @return self
	     * @public
	     */
	    close() {
	        return this.disconnect();
	    }
	    /**
	     * Sets the compress flag.
	     *
	     * @param compress - if `true`, compresses the sending data
	     * @return self
	     * @public
	     */
	    compress(compress) {
	        this.flags.compress = compress;
	        return this;
	    }
	    /**
	     * Sets a modifier for a subsequent event emission that the event message will be dropped when this socket is not
	     * ready to send messages.
	     *
	     * @returns self
	     * @public
	     */
	    get volatile() {
	        this.flags.volatile = true;
	        return this;
	    }
	    /**
	     * Adds a listener that will be fired when any event is emitted. The event name is passed as the first argument to the
	     * callback.
	     *
	     * @param listener
	     * @public
	     */
	    onAny(listener) {
	        this._anyListeners = this._anyListeners || [];
	        this._anyListeners.push(listener);
	        return this;
	    }
	    /**
	     * Adds a listener that will be fired when any event is emitted. The event name is passed as the first argument to the
	     * callback. The listener is added to the beginning of the listeners array.
	     *
	     * @param listener
	     * @public
	     */
	    prependAny(listener) {
	        this._anyListeners = this._anyListeners || [];
	        this._anyListeners.unshift(listener);
	        return this;
	    }
	    /**
	     * Removes the listener that will be fired when any event is emitted.
	     *
	     * @param listener
	     * @public
	     */
	    offAny(listener) {
	        if (!this._anyListeners) {
	            return this;
	        }
	        if (listener) {
	            const listeners = this._anyListeners;
	            for (let i = 0; i < listeners.length; i++) {
	                if (listener === listeners[i]) {
	                    listeners.splice(i, 1);
	                    return this;
	                }
	            }
	        }
	        else {
	            this._anyListeners = [];
	        }
	        return this;
	    }
	    /**
	     * Returns an array of listeners that are listening for any event that is specified. This array can be manipulated,
	     * e.g. to remove listeners.
	     *
	     * @public
	     */
	    listenersAny() {
	        return this._anyListeners || [];
	    }
	}
	exports.Socket = Socket;


/***/ },
/* 172 */
/***/ function(module, exports) {

	"use strict";
	Object.defineProperty(exports, "__esModule", { value: true });
	exports.hasBinary = exports.isBinary = void 0;
	const withNativeArrayBuffer = typeof ArrayBuffer === "function";
	const isView = (obj) => {
	    return typeof ArrayBuffer.isView === "function"
	        ? ArrayBuffer.isView(obj)
	        : obj.buffer instanceof ArrayBuffer;
	};
	const toString = Object.prototype.toString;
	const withNativeBlob = typeof Blob === "function" ||
	    (typeof Blob !== "undefined" &&
	        toString.call(Blob) === "[object BlobConstructor]");
	const withNativeFile = typeof File === "function" ||
	    (typeof File !== "undefined" &&
	        toString.call(File) === "[object FileConstructor]");
	/**
	 * Returns true if obj is a Buffer, an ArrayBuffer, a Blob or a File.
	 *
	 * @private
	 */
	function isBinary(obj) {
	    return ((withNativeArrayBuffer && (obj instanceof ArrayBuffer || isView(obj))) ||
	        (withNativeBlob && obj instanceof Blob) ||
	        (withNativeFile && obj instanceof File));
	}
	exports.isBinary = isBinary;
	function hasBinary(obj, toJSON) {
	    if (!obj || typeof obj !== "object") {
	        return false;
	    }
	    if (Array.isArray(obj)) {
	        for (let i = 0, l = obj.length; i < l; i++) {
	            if (hasBinary(obj[i])) {
	                return true;
	            }
	        }
	        return false;
	    }
	    if (isBinary(obj)) {
	        return true;
	    }
	    if (obj.toJSON &&
	        typeof obj.toJSON === "function" &&
	        arguments.length === 1) {
	        return hasBinary(obj.toJSON(), true);
	    }
	    for (const key in obj) {
	        if (Object.prototype.hasOwnProperty.call(obj, key) && hasBinary(obj[key])) {
	            return true;
	        }
	    }
	    return false;
	}
	exports.hasBinary = hasBinary;


/***/ },
/* 173 */
/***/ function(module, exports) {

	module.exports = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAATcAAAEUCAYAAABOGnGqAAAACXBIWXMAABcSAAAXEgFnn9JSAAAAGXRFWHRTb2Z0d2FyZQBBZG9iZSBJbWFnZVJlYWR5ccllPAAADA5JREFUeNrs3SF0HMcZB/BxTAIvLCwnVhaZlXnNUhSZtSgKa1EUWBQFFapBhUpQX5Fs1iCdWJlkFqYLC5PCEuTu5FaxbEun03nvbueb3++9eXLz8hprdvd/3zc7u5cSAAAAAAAAAAAAAAAAAAAAAAAAAAB0HpgCNqi55c83uWzH2Q1/BuHGRozasd2F10ftGC8QZIu6CrlpO150fz7r/jnCDXp1FV6Pu5/jDfwdcsBN2nHS/RR2wFJyZXbQjtN2vBzgyH+vvQ0FLVBghbbfjvOBBtpdQTdyCIHrdtpxXFig3TaOUn/rf0CBRl21U1qVtujIv9euwwx1hVpuPS+ChpqQgwrtVRRqQg4q0ARuP+87jpM1OSjeOM0W2IXa2+MgubsKWtCgI8/PjlMFyjBKcbZ1rGscquJg2HZUa+90w2HbKQTDsy+gehl7TiXQhkZuU4ENym3UqTBa2fOq1uFgQ8FmfW31ATd2qoFgi7pdxI0GWAN3RAUchNMIGgEHWlFDwAXjOxRiBlve7uHu3ebl727YSr7DQbjxznKgnQu2QclfVvNEwK3fe6YgVLCp2IZZSdvouwEPTUEY/2rHJ6ZhkP7Qfeh8byrgfvIzjhbxhz+8MmmNrLnFaHtOTUMR8rrbo3ZMTYVwY75R8thPac66gGPFrLmVLa+zNaahKB92RcXEVMDN8vqNdaxyhw2+2lK0o9pTtKW1+Eey7SNCe/pzO/5nKlRuzLg7GofHs1RuXPNv7WgY73cV3HNToXKrXZNmj1gRS67epqZB5Vazo+6TnlhGqjdqtptsn4g8LDX0zFtByvGZKQjtK1PQL2tuZWiStbYaWHtTuVXnC1OgekPlFs04zd6uS3z2vancVG2ElO+aeuebyq0aF8mrw2vimVOVWxV2BFt18uN1Y9Mg3KL71BRUyVKEtlRLSkjTNLuxgMpNS0ooY62pcNOSEvnDDeEWUmMKfLixPGtuw21LbNzF9alyU7XhPEC4leCxKUC4CbeIfO0b2cemQE8fzUtTQLLfTeWmFSGocbLXUbgFO6HhiiUK4SbcEG4ItyGziMx12lLh5mTGhx3CTVuKDzvhhnCD8tjnNjz2uOE6VbkBCLcSNKYAhBuAcAOEG4BwAxBuAGti/8yw5N3oF6YB16lJi8gmXlyn2lIIb2oKhFsUl6YA4SbcIjozBSDcILoTUyDcnMyAcBswa25cNzEFwi0Ka25cNzUFy7F/Znhs5MU1qnIL25b6tEZLKty0pjgPEG6lcMcU54Fw047gPEC4ldSO2BLiHHAOCDef2jj+CLdSPDcFjj/Ls4dmuOx3q1duRz8wDSq3yCf4M9NQJcdduGlNcNzRlmpNKcG0HVumQeVWQ2v6rWnQkqJyi6hpx7FpqMZW8myxyq0SEyd7VVWbY92Th6agCD+3Y8c0hPc34aYtrVG+sTAyDWHlx60emQZtaY2+MQWOLyq3iHLVdq56Cym3orZ/9MyaWzl+acev7fjEVITzeTt+MA0qt9rl6m1sGsKYtOOJaeifNbfyfGkKQvnaFMAreVPvS6P4cehU1pbyunHXnlKu/GjdVvK23ZVxQ6HcCyN/MDWmolh/Sb7dCm51qrUrchw5dbWlzLfdBRzaUbSlofyUZs+d2vumHYWQjrR6RYwDpyrczyhZfxv6sHwAS8rrbxdCZJDDM8HwjhpBMrhx0X3wAO9oV6AManjJKPRoT6gMYuw6FaF/h8JFsIGAMwQbCDhDsMEw7AodwQZDkbcP7Au4YrZ7NE5ZmG/Uhdr1Fxr2tQHURt/VbNC1jw3u0HQXy02P7vQVcOPkUa2+xnEPx+WwOx4CkrAO0t3PJm6v8b9nzB99LBm8ebNnz2VAtLW1RSupvtd2drSpS7WhzQqCrc9qEDZu2ScJ+vyEHyVfOHOfN+iOVhhs1z/EPLZFkfoIlL4uNFXc+qq1+x5373+jKE2PIdL3OtzIWtyNa2ujnub2dMljPHbZELUNvauF6Xshelur+lvrOO5xPi+SfXQEbUNX/SrwvtvUqyqztpA77jlIdnus1N1NZVDuczd0KGtDNYbc0QrmbhUtfp+bumEQ62v3/SKS0YqCOtKD+Bc9t59Xxiv+QDsVcGzSbopxh++2Nnsvlfukw3F3fFYREOu66+z15WzEfhrWwvgqP+XH3e879KA77QJ5vKJ5GG2gqr1I3kTCGg2xbVvXRTDuAuQobX7P3Hl3LFZVob25/HC+wd9VwFFlsL3Zjq2zldnuLryDtNobEhfd//9B998br+n3W8ddcBt+l/TAFPR6kjeF/H2/bceX7bjc0FxtdwF0FUIfL1hd5b/vi+7PZ93/PtvQ75Er1K/SsBb283H93OVInxdriQvrF6m/3fc1aQZ+vA8dImoOtlU/4RDReEAtqIBj5Y5SnD1f58nC9G2hVuLePgHH0qJ+q5R2texQE3AItrSZ3fslrKlFetRMwLGwvQqC7aYtJJFfnnj1xMV50OMn4LjTToXB9mY1l/dTbQc6nrV8afW+y5fb+Fq8t29A7BUYdFeBVuOx3HUZc1Pb4uvw5gfdwUBb13F3UR8lH04vU0UvvfSEwmKOki/suI9JO07S7OmB/Od1PkHQdNXk4/TqSQheycfiSXdshFvl9pLn9t7VtBsn1/58NZZdIhilV49wfdz99AqgxZx1AXcZ+ZcUbne3NF4MuJ6L7a4Lbdtx6NWzdjwVbvXq+9ulYEjyyxP+GfWXe8/xnduOCjYiO4h8jqvctKPUbdqORyng+ttDx/ZGh6o2KpE/wN9vx/cqt/iaNHvcCGqS755OhFtsbiKgPdWWhrPbjr+aBiptT3+NVL2p3F6XHyMamwYqtpWW31w9KLaCvF61CTZqF+b1SCq3V6y1wUyImwsqt5lGsMHvvtKWxvGZKYDXPuwbbWn58l2iC9MAr5l07anKrWDe0wYBqzfhltKnpgBu9IW2VEsKURW77632yk1LCvPtakvL9Ni5C3MVu5Og9nBrnLsw1zgVugf0vcoP2ti5CzGrt5rDzRMJsJgi16aFGxCyNa053NxMgMU1wq0cvvwFAhcDNW/ifel8hYXl149/oHIDInY6Y+E2fI1zFe5NuAGKAuEGlOIj4QZoS4UbUIiitk8JN2BRRT2lINyAkIQbINwAhBsQUTHrbrWG28Q5Cksp5o6pB+eBkJlRc1t65jyFuGoOt0uHH4Sbyg0QboX40eGHe5kKN5UbCDfhtjET5yrcS1Hr1LVv4lW9weJeCDfVG2hLhdtGnThfIWa4Paj8YOVHSS6csxAvL2qv3PICqXU3CFa1CbeZ56YA7jQRbuV5ZgrgTi9K+wsLt1lbOjUNoHJTvUFdilybFm4z35kCiFO1CTetKSyiyP2gwk31BncpctnmgeP2u3E7zk0DvCZ3NFsqt/IP4sQ0QPlVm3DTmkLYa0Jb+rb8rOnINMBvW0A+ULnF8Y0pgLJbUuF2s29NAZTdkgq3m00FHJR/g024aU0hXEuauaFwu+N2NKaBSm2lwp/aUbnd7mtTQKUmKcDjiMJt/gGemAYqFGJZRls6X9O1p1CLaSr0cSuVm+oN5gmzHKNyu9s4eaAeVVtxHjqed8qPoOTHsf5oKgjuaQr0XkOV22JyuJ12VRxE9KwLtzBUbov5pR0/tuPPpoKg3cnT7qdwq9APXeW2bSoI5u/t+G+0X0pbqj1FO/o04i8m3O5vuws4KN20HY+itaPa0uX9lGbrbzumgoLlQPtTCvytb8JtOWfJ+htl+1sKuM6mLe2PN4dQos9TBe8sFG7vZtQFnAoOwSbcBBwINuEm4ECwLcUNhX7kJxj+044PBRwDc3VX9Fltv7hw6zfgnicP2TMc+a7+k+4n9CLvgctf7vzSMDY0DlyGrMo4zdbhXGjGOkd+92Dj8mMd9lRxxprGfrcsAmut4g5dfMaKxmHyMgc2bFuragg1ooecSs5YZlwINUppV/e7RWAXrjFv5Nds7VpTW5wnFIZVzX2WZttIfCqT5f1p36XZBtyp6RBuUYKuacfj7qdP6zrkAJu046T7KdCEWxXta9P9fNz9VN2V7bKrzPJ4IcyEG29XeKNrP1MXfjf9O6w/uK6cXGszL6/9BAAAAAAAAAAAAAAAAAAAAAAAAAAAAFjS/wUYAImn6FFWzuAVAAAAAElFTkSuQmCC"

/***/ },
/* 174 */
/***/ function(module, exports, __webpack_require__) {

	module.exports = __webpack_require__.p + "static/media/tasks_pill.d5a12752.png";

/***/ },
/* 175 */
/***/ function(module, exports, __webpack_require__) {

	module.exports = __webpack_require__.p + "static/media/weight-clipart-black-and-white-3.d9ae7fa2.png";

/***/ },
/* 176 */
/***/ function(module, exports) {

	'use strict';
	
	var alphabet = '0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz-_'.split('')
	  , length = 64
	  , map = {}
	  , seed = 0
	  , i = 0
	  , prev;
	
	/**
	 * Return a string representing the specified number.
	 *
	 * @param {Number} num The number to convert.
	 * @returns {String} The string representation of the number.
	 * @api public
	 */
	function encode(num) {
	  var encoded = '';
	
	  do {
	    encoded = alphabet[num % length] + encoded;
	    num = Math.floor(num / length);
	  } while (num > 0);
	
	  return encoded;
	}
	
	/**
	 * Return the integer value specified by the given string.
	 *
	 * @param {String} str The string to convert.
	 * @returns {Number} The integer value represented by the string.
	 * @api public
	 */
	function decode(str) {
	  var decoded = 0;
	
	  for (i = 0; i < str.length; i++) {
	    decoded = decoded * length + map[str.charAt(i)];
	  }
	
	  return decoded;
	}
	
	/**
	 * Yeast: A tiny growing id generator.
	 *
	 * @returns {String} A unique id.
	 * @api public
	 */
	function yeast() {
	  var now = encode(+new Date());
	
	  if (now !== prev) return seed = 0, prev = now;
	  return now +'.'+ encode(seed++);
	}
	
	//
	// Map each character to its index.
	//
	for (; i < length; i++) map[alphabet[i]] = i;
	
	//
	// Expose the `yeast`, `encode` and `decode` functions.
	//
	yeast.encode = encode;
	yeast.decode = decode;
	module.exports = yeast;


/***/ },
/* 177 */
/***/ function(module, exports) {

	"use strict";
	exports.__esModule = true;
	var requestAnimationFrame;
	requestAnimationFrame = (typeof window !== 'undefined'
	    && ((window.requestAnimationFrame && window.requestAnimationFrame.bind(window))
	        || (window.msRequestAnimationFrame && window.msRequestAnimationFrame.bind(window))
	        || window.mozRequestAnimationFrame
	        || window.webkitRequestAnimationFrame)) || function (func) {
	    return setTimeout(func, 16);
	};
	exports["default"] = requestAnimationFrame;


/***/ },
/* 178 */
/***/ function(module, exports) {

	"use strict";
	exports.__esModule = true;
	function createLinearGradient(ctx, obj, rect) {
	    var x = obj.x == null ? 0 : obj.x;
	    var x2 = obj.x2 == null ? 1 : obj.x2;
	    var y = obj.y == null ? 0 : obj.y;
	    var y2 = obj.y2 == null ? 0 : obj.y2;
	    if (!obj.global) {
	        x = x * rect.width + rect.x;
	        x2 = x2 * rect.width + rect.x;
	        y = y * rect.height + rect.y;
	        y2 = y2 * rect.height + rect.y;
	    }
	    x = isNaN(x) ? 0 : x;
	    x2 = isNaN(x2) ? 1 : x2;
	    y = isNaN(y) ? 0 : y;
	    y2 = isNaN(y2) ? 0 : y2;
	    var canvasGradient = ctx.createLinearGradient(x, y, x2, y2);
	    return canvasGradient;
	}
	exports.createLinearGradient = createLinearGradient;
	function createRadialGradient(ctx, obj, rect) {
	    var width = rect.width;
	    var height = rect.height;
	    var min = Math.min(width, height);
	    var x = obj.x == null ? 0.5 : obj.x;
	    var y = obj.y == null ? 0.5 : obj.y;
	    var r = obj.r == null ? 0.5 : obj.r;
	    if (!obj.global) {
	        x = x * width + rect.x;
	        y = y * height + rect.y;
	        r = r * min;
	    }
	    var canvasGradient = ctx.createRadialGradient(x, y, 0, x, y, r);
	    return canvasGradient;
	}
	exports.createRadialGradient = createRadialGradient;
	function getCanvasGradient(ctx, obj, rect) {
	    var canvasGradient = obj.type === 'radial'
	        ? createRadialGradient(ctx, obj, rect)
	        : createLinearGradient(ctx, obj, rect);
	    var colorStops = obj.colorStops;
	    for (var i = 0; i < colorStops.length; i++) {
	        canvasGradient.addColorStop(colorStops[i].offset, colorStops[i].color);
	    }
	    return canvasGradient;
	}
	exports.getCanvasGradient = getCanvasGradient;
	function isClipPathChanged(clipPaths, prevClipPaths) {
	    if (clipPaths === prevClipPaths || (!clipPaths && !prevClipPaths)) {
	        return false;
	    }
	    if (!clipPaths || !prevClipPaths || (clipPaths.length !== prevClipPaths.length)) {
	        return true;
	    }
	    for (var i = 0; i < clipPaths.length; i++) {
	        if (clipPaths[i] !== prevClipPaths[i]) {
	            return true;
	        }
	    }
	    return false;
	}
	exports.isClipPathChanged = isClipPathChanged;


/***/ },
/* 179 */
/***/ function(module, exports) {

	"use strict";
	exports.__esModule = true;
	var PI2 = Math.PI * 2;
	function normalizeRadian(angle) {
	    angle %= PI2;
	    if (angle < 0) {
	        angle += PI2;
	    }
	    return angle;
	}
	exports.normalizeRadian = normalizeRadian;


/***/ },
/* 180 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	exports.__esModule = true;
	var Point_1 = __webpack_require__(79);
	var extent = [0, 0];
	var extent2 = [0, 0];
	var minTv = new Point_1["default"]();
	var maxTv = new Point_1["default"]();
	var OrientedBoundingRect = (function () {
	    function OrientedBoundingRect(rect, transform) {
	        this._corners = [];
	        this._axes = [];
	        this._origin = [0, 0];
	        for (var i = 0; i < 4; i++) {
	            this._corners[i] = new Point_1["default"]();
	        }
	        for (var i = 0; i < 2; i++) {
	            this._axes[i] = new Point_1["default"]();
	        }
	        if (rect) {
	            this.fromBoundingRect(rect, transform);
	        }
	    }
	    OrientedBoundingRect.prototype.fromBoundingRect = function (rect, transform) {
	        var corners = this._corners;
	        var axes = this._axes;
	        var x = rect.x;
	        var y = rect.y;
	        var x2 = x + rect.width;
	        var y2 = y + rect.height;
	        corners[0].set(x, y);
	        corners[1].set(x2, y);
	        corners[2].set(x2, y2);
	        corners[3].set(x, y2);
	        if (transform) {
	            for (var i = 0; i < 4; i++) {
	                corners[i].transform(transform);
	            }
	        }
	        Point_1["default"].sub(axes[0], corners[1], corners[0]);
	        Point_1["default"].sub(axes[1], corners[3], corners[0]);
	        axes[0].normalize();
	        axes[1].normalize();
	        for (var i = 0; i < 2; i++) {
	            this._origin[i] = axes[i].dot(corners[0]);
	        }
	    };
	    OrientedBoundingRect.prototype.intersect = function (other, mtv) {
	        var overlapped = true;
	        var noMtv = !mtv;
	        minTv.set(Infinity, Infinity);
	        maxTv.set(0, 0);
	        if (!this._intersectCheckOneSide(this, other, minTv, maxTv, noMtv, 1)) {
	            overlapped = false;
	            if (noMtv) {
	                return overlapped;
	            }
	        }
	        if (!this._intersectCheckOneSide(other, this, minTv, maxTv, noMtv, -1)) {
	            overlapped = false;
	            if (noMtv) {
	                return overlapped;
	            }
	        }
	        if (!noMtv) {
	            Point_1["default"].copy(mtv, overlapped ? minTv : maxTv);
	        }
	        return overlapped;
	    };
	    OrientedBoundingRect.prototype._intersectCheckOneSide = function (self, other, minTv, maxTv, noMtv, inverse) {
	        var overlapped = true;
	        for (var i = 0; i < 2; i++) {
	            var axis = this._axes[i];
	            this._getProjMinMaxOnAxis(i, self._corners, extent);
	            this._getProjMinMaxOnAxis(i, other._corners, extent2);
	            if (extent[1] < extent2[0] || extent[0] > extent2[1]) {
	                overlapped = false;
	                if (noMtv) {
	                    return overlapped;
	                }
	                var dist0 = Math.abs(extent2[0] - extent[1]);
	                var dist1 = Math.abs(extent[0] - extent2[1]);
	                if (Math.min(dist0, dist1) > maxTv.len()) {
	                    if (dist0 < dist1) {
	                        Point_1["default"].scale(maxTv, axis, -dist0 * inverse);
	                    }
	                    else {
	                        Point_1["default"].scale(maxTv, axis, dist1 * inverse);
	                    }
	                }
	            }
	            else if (minTv) {
	                var dist0 = Math.abs(extent2[0] - extent[1]);
	                var dist1 = Math.abs(extent[0] - extent2[1]);
	                if (Math.min(dist0, dist1) < minTv.len()) {
	                    if (dist0 < dist1) {
	                        Point_1["default"].scale(minTv, axis, dist0 * inverse);
	                    }
	                    else {
	                        Point_1["default"].scale(minTv, axis, -dist1 * inverse);
	                    }
	                }
	            }
	        }
	        return overlapped;
	    };
	    OrientedBoundingRect.prototype._getProjMinMaxOnAxis = function (dim, corners, out) {
	        var axis = this._axes[dim];
	        var origin = this._origin;
	        var proj = corners[0].dot(axis) + origin[dim];
	        var min = proj;
	        var max = proj;
	        for (var i = 1; i < corners.length; i++) {
	            var proj_1 = corners[i].dot(axis) + origin[dim];
	            min = Math.min(proj_1, min);
	            max = Math.max(proj_1, max);
	        }
	        out[0] = min;
	        out[1] = max;
	    };
	    return OrientedBoundingRect;
	}());
	exports["default"] = OrientedBoundingRect;


/***/ },
/* 181 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	exports.__esModule = true;
	var env_1 = __webpack_require__(13);
	var fourPointsTransform_1 = __webpack_require__(459);
	var EVENT_SAVED_PROP = '___zrEVENTSAVED';
	var _calcOut = [];
	function transformLocalCoord(out, elFrom, elTarget, inX, inY) {
	    return transformCoordWithViewport(_calcOut, elFrom, inX, inY, true)
	        && transformCoordWithViewport(out, elTarget, _calcOut[0], _calcOut[1]);
	}
	exports.transformLocalCoord = transformLocalCoord;
	function transformCoordWithViewport(out, el, inX, inY, inverse) {
	    if (el.getBoundingClientRect && env_1["default"].domSupported && !isCanvasEl(el)) {
	        var saved = el[EVENT_SAVED_PROP] || (el[EVENT_SAVED_PROP] = {});
	        var markers = prepareCoordMarkers(el, saved);
	        var transformer = preparePointerTransformer(markers, saved, inverse);
	        if (transformer) {
	            transformer(out, inX, inY);
	            return true;
	        }
	    }
	    return false;
	}
	exports.transformCoordWithViewport = transformCoordWithViewport;
	function prepareCoordMarkers(el, saved) {
	    var markers = saved.markers;
	    if (markers) {
	        return markers;
	    }
	    markers = saved.markers = [];
	    var propLR = ['left', 'right'];
	    var propTB = ['top', 'bottom'];
	    for (var i = 0; i < 4; i++) {
	        var marker = document.createElement('div');
	        var stl = marker.style;
	        var idxLR = i % 2;
	        var idxTB = (i >> 1) % 2;
	        stl.cssText = [
	            'position: absolute',
	            'visibility: hidden',
	            'padding: 0',
	            'margin: 0',
	            'border-width: 0',
	            'user-select: none',
	            'width:0',
	            'height:0',
	            propLR[idxLR] + ':0',
	            propTB[idxTB] + ':0',
	            propLR[1 - idxLR] + ':auto',
	            propTB[1 - idxTB] + ':auto',
	            ''
	        ].join('!important;');
	        el.appendChild(marker);
	        markers.push(marker);
	    }
	    return markers;
	}
	function preparePointerTransformer(markers, saved, inverse) {
	    var transformerName = inverse ? 'invTrans' : 'trans';
	    var transformer = saved[transformerName];
	    var oldSrcCoords = saved.srcCoords;
	    var srcCoords = [];
	    var destCoords = [];
	    var oldCoordTheSame = true;
	    for (var i = 0; i < 4; i++) {
	        var rect = markers[i].getBoundingClientRect();
	        var ii = 2 * i;
	        var x = rect.left;
	        var y = rect.top;
	        srcCoords.push(x, y);
	        oldCoordTheSame = oldCoordTheSame && oldSrcCoords && x === oldSrcCoords[ii] && y === oldSrcCoords[ii + 1];
	        destCoords.push(markers[i].offsetLeft, markers[i].offsetTop);
	    }
	    return (oldCoordTheSame && transformer)
	        ? transformer
	        : (saved.srcCoords = srcCoords,
	            saved[transformerName] = inverse
	                ? fourPointsTransform_1.buildTransformer(destCoords, srcCoords)
	                : fourPointsTransform_1.buildTransformer(srcCoords, destCoords));
	}
	function isCanvasEl(el) {
	    return el.nodeName.toUpperCase() === 'CANVAS';
	}
	exports.isCanvasEl = isCanvasEl;


/***/ },
/* 182 */
/***/ function(module, exports) {

	"use strict";
	exports.__esModule = true;
	var DEFAULT_MIN_MERGE = 32;
	var DEFAULT_MIN_GALLOPING = 7;
	var DEFAULT_TMP_STORAGE_LENGTH = 256;
	function minRunLength(n) {
	    var r = 0;
	    while (n >= DEFAULT_MIN_MERGE) {
	        r |= n & 1;
	        n >>= 1;
	    }
	    return n + r;
	}
	function makeAscendingRun(array, lo, hi, compare) {
	    var runHi = lo + 1;
	    if (runHi === hi) {
	        return 1;
	    }
	    if (compare(array[runHi++], array[lo]) < 0) {
	        while (runHi < hi && compare(array[runHi], array[runHi - 1]) < 0) {
	            runHi++;
	        }
	        reverseRun(array, lo, runHi);
	    }
	    else {
	        while (runHi < hi && compare(array[runHi], array[runHi - 1]) >= 0) {
	            runHi++;
	        }
	    }
	    return runHi - lo;
	}
	function reverseRun(array, lo, hi) {
	    hi--;
	    while (lo < hi) {
	        var t = array[lo];
	        array[lo++] = array[hi];
	        array[hi--] = t;
	    }
	}
	function binaryInsertionSort(array, lo, hi, start, compare) {
	    if (start === lo) {
	        start++;
	    }
	    for (; start < hi; start++) {
	        var pivot = array[start];
	        var left = lo;
	        var right = start;
	        var mid;
	        while (left < right) {
	            mid = left + right >>> 1;
	            if (compare(pivot, array[mid]) < 0) {
	                right = mid;
	            }
	            else {
	                left = mid + 1;
	            }
	        }
	        var n = start - left;
	        switch (n) {
	            case 3:
	                array[left + 3] = array[left + 2];
	            case 2:
	                array[left + 2] = array[left + 1];
	            case 1:
	                array[left + 1] = array[left];
	                break;
	            default:
	                while (n > 0) {
	                    array[left + n] = array[left + n - 1];
	                    n--;
	                }
	        }
	        array[left] = pivot;
	    }
	}
	function gallopLeft(value, array, start, length, hint, compare) {
	    var lastOffset = 0;
	    var maxOffset = 0;
	    var offset = 1;
	    if (compare(value, array[start + hint]) > 0) {
	        maxOffset = length - hint;
	        while (offset < maxOffset && compare(value, array[start + hint + offset]) > 0) {
	            lastOffset = offset;
	            offset = (offset << 1) + 1;
	            if (offset <= 0) {
	                offset = maxOffset;
	            }
	        }
	        if (offset > maxOffset) {
	            offset = maxOffset;
	        }
	        lastOffset += hint;
	        offset += hint;
	    }
	    else {
	        maxOffset = hint + 1;
	        while (offset < maxOffset && compare(value, array[start + hint - offset]) <= 0) {
	            lastOffset = offset;
	            offset = (offset << 1) + 1;
	            if (offset <= 0) {
	                offset = maxOffset;
	            }
	        }
	        if (offset > maxOffset) {
	            offset = maxOffset;
	        }
	        var tmp = lastOffset;
	        lastOffset = hint - offset;
	        offset = hint - tmp;
	    }
	    lastOffset++;
	    while (lastOffset < offset) {
	        var m = lastOffset + (offset - lastOffset >>> 1);
	        if (compare(value, array[start + m]) > 0) {
	            lastOffset = m + 1;
	        }
	        else {
	            offset = m;
	        }
	    }
	    return offset;
	}
	function gallopRight(value, array, start, length, hint, compare) {
	    var lastOffset = 0;
	    var maxOffset = 0;
	    var offset = 1;
	    if (compare(value, array[start + hint]) < 0) {
	        maxOffset = hint + 1;
	        while (offset < maxOffset && compare(value, array[start + hint - offset]) < 0) {
	            lastOffset = offset;
	            offset = (offset << 1) + 1;
	            if (offset <= 0) {
	                offset = maxOffset;
	            }
	        }
	        if (offset > maxOffset) {
	            offset = maxOffset;
	        }
	        var tmp = lastOffset;
	        lastOffset = hint - offset;
	        offset = hint - tmp;
	    }
	    else {
	        maxOffset = length - hint;
	        while (offset < maxOffset && compare(value, array[start + hint + offset]) >= 0) {
	            lastOffset = offset;
	            offset = (offset << 1) + 1;
	            if (offset <= 0) {
	                offset = maxOffset;
	            }
	        }
	        if (offset > maxOffset) {
	            offset = maxOffset;
	        }
	        lastOffset += hint;
	        offset += hint;
	    }
	    lastOffset++;
	    while (lastOffset < offset) {
	        var m = lastOffset + (offset - lastOffset >>> 1);
	        if (compare(value, array[start + m]) < 0) {
	            offset = m;
	        }
	        else {
	            lastOffset = m + 1;
	        }
	    }
	    return offset;
	}
	function TimSort(array, compare) {
	    var minGallop = DEFAULT_MIN_GALLOPING;
	    var length = 0;
	    var tmpStorageLength = DEFAULT_TMP_STORAGE_LENGTH;
	    var stackLength = 0;
	    var runStart;
	    var runLength;
	    var stackSize = 0;
	    length = array.length;
	    if (length < 2 * DEFAULT_TMP_STORAGE_LENGTH) {
	        tmpStorageLength = length >>> 1;
	    }
	    var tmp = [];
	    stackLength = length < 120 ? 5 : length < 1542 ? 10 : length < 119151 ? 19 : 40;
	    runStart = [];
	    runLength = [];
	    function pushRun(_runStart, _runLength) {
	        runStart[stackSize] = _runStart;
	        runLength[stackSize] = _runLength;
	        stackSize += 1;
	    }
	    function mergeRuns() {
	        while (stackSize > 1) {
	            var n = stackSize - 2;
	            if ((n >= 1 && runLength[n - 1] <= runLength[n] + runLength[n + 1])
	                || (n >= 2 && runLength[n - 2] <= runLength[n] + runLength[n - 1])) {
	                if (runLength[n - 1] < runLength[n + 1]) {
	                    n--;
	                }
	            }
	            else if (runLength[n] > runLength[n + 1]) {
	                break;
	            }
	            mergeAt(n);
	        }
	    }
	    function forceMergeRuns() {
	        while (stackSize > 1) {
	            var n = stackSize - 2;
	            if (n > 0 && runLength[n - 1] < runLength[n + 1]) {
	                n--;
	            }
	            mergeAt(n);
	        }
	    }
	    function mergeAt(i) {
	        var start1 = runStart[i];
	        var length1 = runLength[i];
	        var start2 = runStart[i + 1];
	        var length2 = runLength[i + 1];
	        runLength[i] = length1 + length2;
	        if (i === stackSize - 3) {
	            runStart[i + 1] = runStart[i + 2];
	            runLength[i + 1] = runLength[i + 2];
	        }
	        stackSize--;
	        var k = gallopRight(array[start2], array, start1, length1, 0, compare);
	        start1 += k;
	        length1 -= k;
	        if (length1 === 0) {
	            return;
	        }
	        length2 = gallopLeft(array[start1 + length1 - 1], array, start2, length2, length2 - 1, compare);
	        if (length2 === 0) {
	            return;
	        }
	        if (length1 <= length2) {
	            mergeLow(start1, length1, start2, length2);
	        }
	        else {
	            mergeHigh(start1, length1, start2, length2);
	        }
	    }
	    function mergeLow(start1, length1, start2, length2) {
	        var i = 0;
	        for (i = 0; i < length1; i++) {
	            tmp[i] = array[start1 + i];
	        }
	        var cursor1 = 0;
	        var cursor2 = start2;
	        var dest = start1;
	        array[dest++] = array[cursor2++];
	        if (--length2 === 0) {
	            for (i = 0; i < length1; i++) {
	                array[dest + i] = tmp[cursor1 + i];
	            }
	            return;
	        }
	        if (length1 === 1) {
	            for (i = 0; i < length2; i++) {
	                array[dest + i] = array[cursor2 + i];
	            }
	            array[dest + length2] = tmp[cursor1];
	            return;
	        }
	        var _minGallop = minGallop;
	        var count1;
	        var count2;
	        var exit;
	        while (1) {
	            count1 = 0;
	            count2 = 0;
	            exit = false;
	            do {
	                if (compare(array[cursor2], tmp[cursor1]) < 0) {
	                    array[dest++] = array[cursor2++];
	                    count2++;
	                    count1 = 0;
	                    if (--length2 === 0) {
	                        exit = true;
	                        break;
	                    }
	                }
	                else {
	                    array[dest++] = tmp[cursor1++];
	                    count1++;
	                    count2 = 0;
	                    if (--length1 === 1) {
	                        exit = true;
	                        break;
	                    }
	                }
	            } while ((count1 | count2) < _minGallop);
	            if (exit) {
	                break;
	            }
	            do {
	                count1 = gallopRight(array[cursor2], tmp, cursor1, length1, 0, compare);
	                if (count1 !== 0) {
	                    for (i = 0; i < count1; i++) {
	                        array[dest + i] = tmp[cursor1 + i];
	                    }
	                    dest += count1;
	                    cursor1 += count1;
	                    length1 -= count1;
	                    if (length1 <= 1) {
	                        exit = true;
	                        break;
	                    }
	                }
	                array[dest++] = array[cursor2++];
	                if (--length2 === 0) {
	                    exit = true;
	                    break;
	                }
	                count2 = gallopLeft(tmp[cursor1], array, cursor2, length2, 0, compare);
	                if (count2 !== 0) {
	                    for (i = 0; i < count2; i++) {
	                        array[dest + i] = array[cursor2 + i];
	                    }
	                    dest += count2;
	                    cursor2 += count2;
	                    length2 -= count2;
	                    if (length2 === 0) {
	                        exit = true;
	                        break;
	                    }
	                }
	                array[dest++] = tmp[cursor1++];
	                if (--length1 === 1) {
	                    exit = true;
	                    break;
	                }
	                _minGallop--;
	            } while (count1 >= DEFAULT_MIN_GALLOPING || count2 >= DEFAULT_MIN_GALLOPING);
	            if (exit) {
	                break;
	            }
	            if (_minGallop < 0) {
	                _minGallop = 0;
	            }
	            _minGallop += 2;
	        }
	        minGallop = _minGallop;
	        minGallop < 1 && (minGallop = 1);
	        if (length1 === 1) {
	            for (i = 0; i < length2; i++) {
	                array[dest + i] = array[cursor2 + i];
	            }
	            array[dest + length2] = tmp[cursor1];
	        }
	        else if (length1 === 0) {
	            throw new Error();
	        }
	        else {
	            for (i = 0; i < length1; i++) {
	                array[dest + i] = tmp[cursor1 + i];
	            }
	        }
	    }
	    function mergeHigh(start1, length1, start2, length2) {
	        var i = 0;
	        for (i = 0; i < length2; i++) {
	            tmp[i] = array[start2 + i];
	        }
	        var cursor1 = start1 + length1 - 1;
	        var cursor2 = length2 - 1;
	        var dest = start2 + length2 - 1;
	        var customCursor = 0;
	        var customDest = 0;
	        array[dest--] = array[cursor1--];
	        if (--length1 === 0) {
	            customCursor = dest - (length2 - 1);
	            for (i = 0; i < length2; i++) {
	                array[customCursor + i] = tmp[i];
	            }
	            return;
	        }
	        if (length2 === 1) {
	            dest -= length1;
	            cursor1 -= length1;
	            customDest = dest + 1;
	            customCursor = cursor1 + 1;
	            for (i = length1 - 1; i >= 0; i--) {
	                array[customDest + i] = array[customCursor + i];
	            }
	            array[dest] = tmp[cursor2];
	            return;
	        }
	        var _minGallop = minGallop;
	        while (true) {
	            var count1 = 0;
	            var count2 = 0;
	            var exit = false;
	            do {
	                if (compare(tmp[cursor2], array[cursor1]) < 0) {
	                    array[dest--] = array[cursor1--];
	                    count1++;
	                    count2 = 0;
	                    if (--length1 === 0) {
	                        exit = true;
	                        break;
	                    }
	                }
	                else {
	                    array[dest--] = tmp[cursor2--];
	                    count2++;
	                    count1 = 0;
	                    if (--length2 === 1) {
	                        exit = true;
	                        break;
	                    }
	                }
	            } while ((count1 | count2) < _minGallop);
	            if (exit) {
	                break;
	            }
	            do {
	                count1 = length1 - gallopRight(tmp[cursor2], array, start1, length1, length1 - 1, compare);
	                if (count1 !== 0) {
	                    dest -= count1;
	                    cursor1 -= count1;
	                    length1 -= count1;
	                    customDest = dest + 1;
	                    customCursor = cursor1 + 1;
	                    for (i = count1 - 1; i >= 0; i--) {
	                        array[customDest + i] = array[customCursor + i];
	                    }
	                    if (length1 === 0) {
	                        exit = true;
	                        break;
	                    }
	                }
	                array[dest--] = tmp[cursor2--];
	                if (--length2 === 1) {
	                    exit = true;
	                    break;
	                }
	                count2 = length2 - gallopLeft(array[cursor1], tmp, 0, length2, length2 - 1, compare);
	                if (count2 !== 0) {
	                    dest -= count2;
	                    cursor2 -= count2;
	                    length2 -= count2;
	                    customDest = dest + 1;
	                    customCursor = cursor2 + 1;
	                    for (i = 0; i < count2; i++) {
	                        array[customDest + i] = tmp[customCursor + i];
	                    }
	                    if (length2 <= 1) {
	                        exit = true;
	                        break;
	                    }
	                }
	                array[dest--] = array[cursor1--];
	                if (--length1 === 0) {
	                    exit = true;
	                    break;
	                }
	                _minGallop--;
	            } while (count1 >= DEFAULT_MIN_GALLOPING || count2 >= DEFAULT_MIN_GALLOPING);
	            if (exit) {
	                break;
	            }
	            if (_minGallop < 0) {
	                _minGallop = 0;
	            }
	            _minGallop += 2;
	        }
	        minGallop = _minGallop;
	        if (minGallop < 1) {
	            minGallop = 1;
	        }
	        if (length2 === 1) {
	            dest -= length1;
	            cursor1 -= length1;
	            customDest = dest + 1;
	            customCursor = cursor1 + 1;
	            for (i = length1 - 1; i >= 0; i--) {
	                array[customDest + i] = array[customCursor + i];
	            }
	            array[dest] = tmp[cursor2];
	        }
	        else if (length2 === 0) {
	            throw new Error();
	        }
	        else {
	            customCursor = dest - (length2 - 1);
	            for (i = 0; i < length2; i++) {
	                array[customCursor + i] = tmp[i];
	            }
	        }
	    }
	    return {
	        mergeRuns: mergeRuns,
	        forceMergeRuns: forceMergeRuns,
	        pushRun: pushRun
	    };
	}
	function sort(array, compare, lo, hi) {
	    if (!lo) {
	        lo = 0;
	    }
	    if (!hi) {
	        hi = array.length;
	    }
	    var remaining = hi - lo;
	    if (remaining < 2) {
	        return;
	    }
	    var runLength = 0;
	    if (remaining < DEFAULT_MIN_MERGE) {
	        runLength = makeAscendingRun(array, lo, hi, compare);
	        binaryInsertionSort(array, lo, hi, lo + runLength, compare);
	        return;
	    }
	    var ts = TimSort(array, compare);
	    var minRun = minRunLength(remaining);
	    do {
	        runLength = makeAscendingRun(array, lo, hi, compare);
	        if (runLength < minRun) {
	            var force = remaining;
	            if (force > minRun) {
	                force = minRun;
	            }
	            binaryInsertionSort(array, lo, lo + force, lo + runLength, compare);
	            runLength = force;
	        }
	        ts.pushRun(lo, runLength);
	        ts.mergeRuns();
	        remaining -= runLength;
	        lo += runLength;
	    } while (remaining !== 0);
	    ts.forceMergeRuns();
	}
	exports["default"] = sort;


/***/ },
/* 183 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	exports.__esModule = true;
	var zrUtil = __webpack_require__(1);
	exports.util = zrUtil;
	var matrix = __webpack_require__(27);
	exports.matrix = matrix;
	var vector = __webpack_require__(11);
	exports.vector = vector;
	var colorTool = __webpack_require__(34);
	exports.color = colorTool;
	var pathTool = __webpack_require__(117);
	exports.path = pathTool;
	var parseSVG_1 = __webpack_require__(194);
	exports.parseSVG = parseSVG_1.parseSVG;
	var morphPath_1 = __webpack_require__(475);
	exports.morphPath = morphPath_1.morphPath;
	var Point_1 = __webpack_require__(79);
	exports.Point = Point_1["default"];
	var Element_1 = __webpack_require__(36);
	exports.Element = Element_1["default"];
	var Group_1 = __webpack_require__(51);
	exports.Group = Group_1["default"];
	var Path_1 = __webpack_require__(8);
	exports.Path = Path_1["default"];
	var Image_1 = __webpack_require__(43);
	exports.Image = Image_1["default"];
	var CompoundPath_1 = __webpack_require__(184);
	exports.CompoundPath = CompoundPath_1["default"];
	var TSpan_1 = __webpack_require__(80);
	exports.TSpan = TSpan_1["default"];
	var IncrementalDisplayable_1 = __webpack_require__(186);
	exports.IncrementalDisplayable = IncrementalDisplayable_1["default"];
	var Text_1 = __webpack_require__(60);
	exports.Text = Text_1["default"];
	var Arc_1 = __webpack_require__(191);
	exports.Arc = Arc_1["default"];
	var BezierCurve_1 = __webpack_require__(192);
	exports.BezierCurve = BezierCurve_1["default"];
	var Circle_1 = __webpack_require__(111);
	exports.Circle = Circle_1["default"];
	var Droplet_1 = __webpack_require__(468);
	exports.Droplet = Droplet_1["default"];
	var Ellipse_1 = __webpack_require__(112);
	exports.Ellipse = Ellipse_1["default"];
	var Heart_1 = __webpack_require__(469);
	exports.Heart = Heart_1["default"];
	var Isogon_1 = __webpack_require__(470);
	exports.Isogon = Isogon_1["default"];
	var Line_1 = __webpack_require__(113);
	exports.Line = Line_1["default"];
	var Polygon_1 = __webpack_require__(114);
	exports.Polygon = Polygon_1["default"];
	var Polyline_1 = __webpack_require__(115);
	exports.Polyline = Polyline_1["default"];
	var Rect_1 = __webpack_require__(61);
	exports.Rect = Rect_1["default"];
	var Ring_1 = __webpack_require__(193);
	exports.Ring = Ring_1["default"];
	var Rose_1 = __webpack_require__(471);
	exports.Rose = Rose_1["default"];
	var Sector_1 = __webpack_require__(116);
	exports.Sector = Sector_1["default"];
	var Star_1 = __webpack_require__(472);
	exports.Star = Star_1["default"];
	var Trochoid_1 = __webpack_require__(473);
	exports.Trochoid = Trochoid_1["default"];
	var LinearGradient_1 = __webpack_require__(109);
	exports.LinearGradient = LinearGradient_1["default"];
	var RadialGradient_1 = __webpack_require__(187);
	exports.RadialGradient = RadialGradient_1["default"];
	var Pattern_1 = __webpack_require__(462);
	exports.Pattern = Pattern_1["default"];
	var BoundingRect_1 = __webpack_require__(17);
	exports.BoundingRect = BoundingRect_1["default"];
	var OrientedBoundingRect_1 = __webpack_require__(180);
	exports.OrientedBoundingRect = OrientedBoundingRect_1["default"];
	var showDebugDirtyRect_1 = __webpack_require__(460);
	exports.showDebugDirtyRect = showDebugDirtyRect_1["default"];


/***/ },
/* 184 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	exports.__esModule = true;
	var tslib_1 = __webpack_require__(5);
	var Path_1 = __webpack_require__(8);
	var CompoundPath = (function (_super) {
	    tslib_1.__extends(CompoundPath, _super);
	    function CompoundPath() {
	        var _this = _super !== null && _super.apply(this, arguments) || this;
	        _this.type = 'compound';
	        return _this;
	    }
	    CompoundPath.prototype._updatePathDirty = function () {
	        var paths = this.shape.paths;
	        var dirtyPath = this.shapeChanged();
	        for (var i = 0; i < paths.length; i++) {
	            dirtyPath = dirtyPath || paths[i].shapeChanged();
	        }
	        if (dirtyPath) {
	            this.dirtyShape();
	        }
	    };
	    CompoundPath.prototype.beforeBrush = function () {
	        this._updatePathDirty();
	        var paths = this.shape.paths || [];
	        var scale = this.getGlobalScale();
	        for (var i = 0; i < paths.length; i++) {
	            if (!paths[i].path) {
	                paths[i].createPathProxy();
	            }
	            paths[i].path.setScale(scale[0], scale[1], paths[i].segmentIgnoreThreshold);
	        }
	    };
	    CompoundPath.prototype.buildPath = function (ctx, shape) {
	        var paths = shape.paths || [];
	        for (var i = 0; i < paths.length; i++) {
	            paths[i].buildPath(ctx, paths[i].shape, true);
	        }
	    };
	    CompoundPath.prototype.afterBrush = function () {
	        var paths = this.shape.paths || [];
	        for (var i = 0; i < paths.length; i++) {
	            paths[i].pathUpdated();
	        }
	    };
	    CompoundPath.prototype.getBoundingRect = function () {
	        this._updatePathDirty.call(this);
	        return Path_1["default"].prototype.getBoundingRect.call(this);
	    };
	    return CompoundPath;
	}(Path_1["default"]));
	exports["default"] = CompoundPath;


/***/ },
/* 185 */
/***/ function(module, exports) {

	"use strict";
	exports.__esModule = true;
	var Gradient = (function () {
	    function Gradient(colorStops) {
	        this.colorStops = colorStops || [];
	    }
	    Gradient.prototype.addColorStop = function (offset, color) {
	        this.colorStops.push({
	            offset: offset,
	            color: color
	        });
	    };
	    return Gradient;
	}());
	exports["default"] = Gradient;


/***/ },
/* 186 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	exports.__esModule = true;
	var tslib_1 = __webpack_require__(5);
	var Displayable_1 = __webpack_require__(50);
	var BoundingRect_1 = __webpack_require__(17);
	var m = [];
	var IncrementalDisplayble = (function (_super) {
	    tslib_1.__extends(IncrementalDisplayble, _super);
	    function IncrementalDisplayble() {
	        var _this = _super !== null && _super.apply(this, arguments) || this;
	        _this.notClear = true;
	        _this.incremental = true;
	        _this._displayables = [];
	        _this._temporaryDisplayables = [];
	        _this._cursor = 0;
	        return _this;
	    }
	    IncrementalDisplayble.prototype.traverse = function (cb, context) {
	        cb.call(context, this);
	    };
	    IncrementalDisplayble.prototype.useStyle = function () {
	        this.style = {};
	    };
	    IncrementalDisplayble.prototype.getCursor = function () {
	        return this._cursor;
	    };
	    IncrementalDisplayble.prototype.innerAfterBrush = function () {
	        this._cursor = this._displayables.length;
	    };
	    IncrementalDisplayble.prototype.clearDisplaybles = function () {
	        this._displayables = [];
	        this._temporaryDisplayables = [];
	        this._cursor = 0;
	        this.markRedraw();
	        this.notClear = false;
	    };
	    IncrementalDisplayble.prototype.clearTemporalDisplayables = function () {
	        this._temporaryDisplayables = [];
	    };
	    IncrementalDisplayble.prototype.addDisplayable = function (displayable, notPersistent) {
	        if (notPersistent) {
	            this._temporaryDisplayables.push(displayable);
	        }
	        else {
	            this._displayables.push(displayable);
	        }
	        this.markRedraw();
	    };
	    IncrementalDisplayble.prototype.addDisplayables = function (displayables, notPersistent) {
	        notPersistent = notPersistent || false;
	        for (var i = 0; i < displayables.length; i++) {
	            this.addDisplayable(displayables[i], notPersistent);
	        }
	    };
	    IncrementalDisplayble.prototype.getDisplayables = function () {
	        return this._displayables;
	    };
	    IncrementalDisplayble.prototype.getTemporalDisplayables = function () {
	        return this._temporaryDisplayables;
	    };
	    IncrementalDisplayble.prototype.eachPendingDisplayable = function (cb) {
	        for (var i = this._cursor; i < this._displayables.length; i++) {
	            cb && cb(this._displayables[i]);
	        }
	        for (var i = 0; i < this._temporaryDisplayables.length; i++) {
	            cb && cb(this._temporaryDisplayables[i]);
	        }
	    };
	    IncrementalDisplayble.prototype.update = function () {
	        this.updateTransform();
	        for (var i = this._cursor; i < this._displayables.length; i++) {
	            var displayable = this._displayables[i];
	            displayable.parent = this;
	            displayable.update();
	            displayable.parent = null;
	        }
	        for (var i = 0; i < this._temporaryDisplayables.length; i++) {
	            var displayable = this._temporaryDisplayables[i];
	            displayable.parent = this;
	            displayable.update();
	            displayable.parent = null;
	        }
	    };
	    IncrementalDisplayble.prototype.getBoundingRect = function () {
	        if (!this._rect) {
	            var rect = new BoundingRect_1["default"](Infinity, Infinity, -Infinity, -Infinity);
	            for (var i = 0; i < this._displayables.length; i++) {
	                var displayable = this._displayables[i];
	                var childRect = displayable.getBoundingRect().clone();
	                if (displayable.needLocalTransform()) {
	                    childRect.applyTransform(displayable.getLocalTransform(m));
	                }
	                rect.union(childRect);
	            }
	            this._rect = rect;
	        }
	        return this._rect;
	    };
	    IncrementalDisplayble.prototype.contain = function (x, y) {
	        var localPos = this.transformCoordToLocal(x, y);
	        var rect = this.getBoundingRect();
	        if (rect.contain(localPos[0], localPos[1])) {
	            for (var i = 0; i < this._displayables.length; i++) {
	                var displayable = this._displayables[i];
	                if (displayable.contain(x, y)) {
	                    return true;
	                }
	            }
	        }
	        return false;
	    };
	    return IncrementalDisplayble;
	}(Displayable_1["default"]));
	exports["default"] = IncrementalDisplayble;


/***/ },
/* 187 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	exports.__esModule = true;
	var tslib_1 = __webpack_require__(5);
	var Gradient_1 = __webpack_require__(185);
	var RadialGradient = (function (_super) {
	    tslib_1.__extends(RadialGradient, _super);
	    function RadialGradient(x, y, r, colorStops, globalCoord) {
	        var _this = _super.call(this, colorStops) || this;
	        _this.x = x == null ? 0.5 : x;
	        _this.y = y == null ? 0.5 : y;
	        _this.r = r == null ? 0.5 : r;
	        _this.type = 'radial';
	        _this.global = globalCoord || false;
	        return _this;
	    }
	    return RadialGradient;
	}(Gradient_1["default"]));
	exports["default"] = RadialGradient;


/***/ },
/* 188 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	exports.__esModule = true;
	var LRU_1 = __webpack_require__(59);
	var globalImageCache = new LRU_1["default"](50);
	function findExistImage(newImageOrSrc) {
	    if (typeof newImageOrSrc === 'string') {
	        var cachedImgObj = globalImageCache.get(newImageOrSrc);
	        return cachedImgObj && cachedImgObj.image;
	    }
	    else {
	        return newImageOrSrc;
	    }
	}
	exports.findExistImage = findExistImage;
	function createOrUpdateImage(newImageOrSrc, image, hostEl, onload, cbPayload) {
	    if (!newImageOrSrc) {
	        return image;
	    }
	    else if (typeof newImageOrSrc === 'string') {
	        if ((image && image.__zrImageSrc === newImageOrSrc) || !hostEl) {
	            return image;
	        }
	        var cachedImgObj = globalImageCache.get(newImageOrSrc);
	        var pendingWrap = { hostEl: hostEl, cb: onload, cbPayload: cbPayload };
	        if (cachedImgObj) {
	            image = cachedImgObj.image;
	            !isImageReady(image) && cachedImgObj.pending.push(pendingWrap);
	        }
	        else {
	            image = new Image();
	            image.onload = image.onerror = imageOnLoad;
	            globalImageCache.put(newImageOrSrc, image.__cachedImgObj = {
	                image: image,
	                pending: [pendingWrap]
	            });
	            image.src = image.__zrImageSrc = newImageOrSrc;
	        }
	        return image;
	    }
	    else {
	        return newImageOrSrc;
	    }
	}
	exports.createOrUpdateImage = createOrUpdateImage;
	function imageOnLoad() {
	    var cachedImgObj = this.__cachedImgObj;
	    this.onload = this.onerror = this.__cachedImgObj = null;
	    for (var i = 0; i < cachedImgObj.pending.length; i++) {
	        var pendingWrap = cachedImgObj.pending[i];
	        var cb = pendingWrap.cb;
	        cb && cb(this, pendingWrap.cbPayload);
	        pendingWrap.hostEl.dirty();
	    }
	    cachedImgObj.pending.length = 0;
	}
	function isImageReady(image) {
	    return image && image.width && image.height;
	}
	exports.isImageReady = isImageReady;


/***/ },
/* 189 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	exports.__esModule = true;
	var imageHelper = __webpack_require__(188);
	var util_1 = __webpack_require__(1);
	var text_1 = __webpack_require__(26);
	var STYLE_REG = /\{([a-zA-Z0-9_]+)\|([^}]*)\}/g;
	function truncateText(text, containerWidth, font, ellipsis, options) {
	    if (!containerWidth) {
	        return '';
	    }
	    var textLines = (text + '').split('\n');
	    options = prepareTruncateOptions(containerWidth, font, ellipsis, options);
	    for (var i = 0, len = textLines.length; i < len; i++) {
	        textLines[i] = truncateSingleLine(textLines[i], options);
	    }
	    return textLines.join('\n');
	}
	exports.truncateText = truncateText;
	function prepareTruncateOptions(containerWidth, font, ellipsis, options) {
	    options = options || {};
	    var preparedOpts = util_1.extend({}, options);
	    preparedOpts.font = font;
	    ellipsis = util_1.retrieve2(ellipsis, '...');
	    preparedOpts.maxIterations = util_1.retrieve2(options.maxIterations, 2);
	    var minChar = preparedOpts.minChar = util_1.retrieve2(options.minChar, 0);
	    preparedOpts.cnCharWidth = text_1.getWidth('国', font);
	    var ascCharWidth = preparedOpts.ascCharWidth = text_1.getWidth('a', font);
	    preparedOpts.placeholder = util_1.retrieve2(options.placeholder, '');
	    var contentWidth = containerWidth = Math.max(0, containerWidth - 1);
	    for (var i = 0; i < minChar && contentWidth >= ascCharWidth; i++) {
	        contentWidth -= ascCharWidth;
	    }
	    var ellipsisWidth = text_1.getWidth(ellipsis, font);
	    if (ellipsisWidth > contentWidth) {
	        ellipsis = '';
	        ellipsisWidth = 0;
	    }
	    contentWidth = containerWidth - ellipsisWidth;
	    preparedOpts.ellipsis = ellipsis;
	    preparedOpts.ellipsisWidth = ellipsisWidth;
	    preparedOpts.contentWidth = contentWidth;
	    preparedOpts.containerWidth = containerWidth;
	    return preparedOpts;
	}
	function truncateSingleLine(textLine, options) {
	    var containerWidth = options.containerWidth;
	    var font = options.font;
	    var contentWidth = options.contentWidth;
	    if (!containerWidth) {
	        return '';
	    }
	    var lineWidth = text_1.getWidth(textLine, font);
	    if (lineWidth <= containerWidth) {
	        return textLine;
	    }
	    for (var j = 0;; j++) {
	        if (lineWidth <= contentWidth || j >= options.maxIterations) {
	            textLine += options.ellipsis;
	            break;
	        }
	        var subLength = j === 0
	            ? estimateLength(textLine, contentWidth, options.ascCharWidth, options.cnCharWidth)
	            : lineWidth > 0
	                ? Math.floor(textLine.length * contentWidth / lineWidth)
	                : 0;
	        textLine = textLine.substr(0, subLength);
	        lineWidth = text_1.getWidth(textLine, font);
	    }
	    if (textLine === '') {
	        textLine = options.placeholder;
	    }
	    return textLine;
	}
	function estimateLength(text, contentWidth, ascCharWidth, cnCharWidth) {
	    var width = 0;
	    var i = 0;
	    for (var len = text.length; i < len && width < contentWidth; i++) {
	        var charCode = text.charCodeAt(i);
	        width += (0 <= charCode && charCode <= 127) ? ascCharWidth : cnCharWidth;
	    }
	    return i;
	}
	function parsePlainText(text, style) {
	    text != null && (text += '');
	    var overflow = style.overflow;
	    var padding = style.padding;
	    var font = style.font;
	    var truncate = overflow === 'truncate';
	    var calculatedLineHeight = text_1.getLineHeight(font);
	    var lineHeight = util_1.retrieve2(style.lineHeight, calculatedLineHeight);
	    var truncateLineOverflow = style.lineOverflow === 'truncate';
	    var width = style.width;
	    var lines;
	    if (width != null && overflow === 'break' || overflow === 'breakAll') {
	        lines = text ? wrapText(text, style.font, width, overflow === 'breakAll', 0).lines : [];
	    }
	    else {
	        lines = text ? text.split('\n') : [];
	    }
	    var contentHeight = lines.length * lineHeight;
	    var height = util_1.retrieve2(style.height, contentHeight);
	    if (contentHeight > height && truncateLineOverflow) {
	        var lineCount = Math.floor(height / lineHeight);
	        lines = lines.slice(0, lineCount);
	    }
	    var outerHeight = height;
	    var outerWidth = width;
	    if (padding) {
	        outerHeight += padding[0] + padding[2];
	        if (outerWidth != null) {
	            outerWidth += padding[1] + padding[3];
	        }
	    }
	    if (text && truncate && outerWidth != null) {
	        var options = prepareTruncateOptions(width, font, style.ellipsis, {
	            minChar: style.truncateMinChar,
	            placeholder: style.placeholder
	        });
	        for (var i = 0; i < lines.length; i++) {
	            lines[i] = truncateSingleLine(lines[i], options);
	        }
	    }
	    if (width == null) {
	        var maxWidth = 0;
	        for (var i = 0; i < lines.length; i++) {
	            maxWidth = Math.max(text_1.getWidth(lines[i], font), maxWidth);
	        }
	        width = maxWidth;
	    }
	    return {
	        lines: lines,
	        height: height,
	        outerHeight: outerHeight,
	        lineHeight: lineHeight,
	        calculatedLineHeight: calculatedLineHeight,
	        contentHeight: contentHeight,
	        width: width
	    };
	}
	exports.parsePlainText = parsePlainText;
	var RichTextToken = (function () {
	    function RichTextToken() {
	    }
	    return RichTextToken;
	}());
	var RichTextLine = (function () {
	    function RichTextLine(tokens) {
	        this.tokens = [];
	        if (tokens) {
	            this.tokens = tokens;
	        }
	    }
	    return RichTextLine;
	}());
	var RichTextContentBlock = (function () {
	    function RichTextContentBlock() {
	        this.width = 0;
	        this.height = 0;
	        this.contentWidth = 0;
	        this.contentHeight = 0;
	        this.outerWidth = 0;
	        this.outerHeight = 0;
	        this.lines = [];
	    }
	    return RichTextContentBlock;
	}());
	exports.RichTextContentBlock = RichTextContentBlock;
	function parseRichText(text, style) {
	    var contentBlock = new RichTextContentBlock();
	    text != null && (text += '');
	    if (!text) {
	        return contentBlock;
	    }
	    var topWidth = style.width;
	    var topHeight = style.height;
	    var overflow = style.overflow;
	    var wrapInfo = (overflow === 'break' || overflow === 'breakAll') && topWidth != null
	        ? { width: topWidth, accumWidth: 0, breakAll: overflow === 'breakAll' }
	        : null;
	    var lastIndex = STYLE_REG.lastIndex = 0;
	    var result;
	    while ((result = STYLE_REG.exec(text)) != null) {
	        var matchedIndex = result.index;
	        if (matchedIndex > lastIndex) {
	            pushTokens(contentBlock, text.substring(lastIndex, matchedIndex), style, wrapInfo);
	        }
	        pushTokens(contentBlock, result[2], style, wrapInfo, result[1]);
	        lastIndex = STYLE_REG.lastIndex;
	    }
	    if (lastIndex < text.length) {
	        pushTokens(contentBlock, text.substring(lastIndex, text.length), style, wrapInfo);
	    }
	    var pendingList = [];
	    var calculatedHeight = 0;
	    var calculatedWidth = 0;
	    var stlPadding = style.padding;
	    var truncate = overflow === 'truncate';
	    var truncateLine = style.lineOverflow === 'truncate';
	    var prevToken;
	    function finishLine(line, lineWidth, lineHeight) {
	        line.width = lineWidth;
	        line.lineHeight = lineHeight;
	        calculatedHeight += lineHeight;
	        calculatedWidth = Math.max(calculatedWidth, lineWidth);
	    }
	    outer: for (var i = 0; i < contentBlock.lines.length; i++) {
	        var line = contentBlock.lines[i];
	        var lineHeight = 0;
	        var lineWidth = 0;
	        for (var j = 0; j < line.tokens.length; j++) {
	            var token = line.tokens[j];
	            var tokenStyle = token.styleName && style.rich[token.styleName] || {};
	            var textPadding = token.textPadding = tokenStyle.padding;
	            var paddingH = textPadding ? textPadding[1] + textPadding[3] : 0;
	            var font = token.font = tokenStyle.font || style.font;
	            token.contentHeight = text_1.getLineHeight(font);
	            var tokenHeight = util_1.retrieve2(tokenStyle.height, token.contentHeight);
	            token.innerHeight = tokenHeight;
	            textPadding && (tokenHeight += textPadding[0] + textPadding[2]);
	            token.height = tokenHeight;
	            token.lineHeight = util_1.retrieve3(tokenStyle.lineHeight, style.lineHeight, tokenHeight);
	            token.align = tokenStyle && tokenStyle.align || style.align;
	            token.verticalAlign = tokenStyle && tokenStyle.verticalAlign || 'middle';
	            if (truncateLine && topHeight != null && calculatedHeight + token.lineHeight > topHeight) {
	                if (j > 0) {
	                    line.tokens = line.tokens.slice(0, j);
	                    finishLine(line, lineWidth, lineHeight);
	                    contentBlock.lines = contentBlock.lines.slice(0, i + 1);
	                }
	                else {
	                    contentBlock.lines = contentBlock.lines.slice(0, i);
	                }
	                break outer;
	            }
	            var styleTokenWidth = tokenStyle.width;
	            var tokenWidthNotSpecified = styleTokenWidth == null || styleTokenWidth === 'auto';
	            if (typeof styleTokenWidth === 'string' && styleTokenWidth.charAt(styleTokenWidth.length - 1) === '%') {
	                token.percentWidth = styleTokenWidth;
	                pendingList.push(token);
	                token.contentWidth = text_1.getWidth(token.text, font);
	            }
	            else {
	                if (tokenWidthNotSpecified) {
	                    var textBackgroundColor = tokenStyle.backgroundColor;
	                    var bgImg = textBackgroundColor && textBackgroundColor.image;
	                    if (bgImg) {
	                        bgImg = imageHelper.findExistImage(bgImg);
	                        if (imageHelper.isImageReady(bgImg)) {
	                            token.width = Math.max(token.width, bgImg.width * tokenHeight / bgImg.height);
	                        }
	                    }
	                }
	                var remainTruncWidth = truncate && topWidth != null
	                    ? topWidth - lineWidth : null;
	                if (remainTruncWidth != null && remainTruncWidth < token.width) {
	                    if (!tokenWidthNotSpecified || remainTruncWidth < paddingH) {
	                        token.text = '';
	                        token.width = token.contentWidth = 0;
	                    }
	                    else {
	                        token.text = truncateText(token.text, remainTruncWidth - paddingH, font, style.ellipsis, { minChar: style.truncateMinChar });
	                        token.width = token.contentWidth = text_1.getWidth(token.text, font);
	                    }
	                }
	                else {
	                    token.contentWidth = text_1.getWidth(token.text, font);
	                }
	            }
	            token.width += paddingH;
	            lineWidth += token.width;
	            tokenStyle && (lineHeight = Math.max(lineHeight, token.lineHeight));
	            prevToken = token;
	        }
	        finishLine(line, lineWidth, lineHeight);
	    }
	    contentBlock.outerWidth = contentBlock.width = util_1.retrieve2(topWidth, calculatedWidth);
	    contentBlock.outerHeight = contentBlock.height = util_1.retrieve2(topHeight, calculatedHeight);
	    contentBlock.contentHeight = calculatedHeight;
	    contentBlock.contentWidth = calculatedWidth;
	    if (stlPadding) {
	        contentBlock.outerWidth += stlPadding[1] + stlPadding[3];
	        contentBlock.outerHeight += stlPadding[0] + stlPadding[2];
	    }
	    for (var i = 0; i < pendingList.length; i++) {
	        var token = pendingList[i];
	        var percentWidth = token.percentWidth;
	        token.width = parseInt(percentWidth, 10) / 100 * contentBlock.width;
	    }
	    return contentBlock;
	}
	exports.parseRichText = parseRichText;
	function pushTokens(block, str, style, wrapInfo, styleName) {
	    var isEmptyStr = str === '';
	    var tokenStyle = styleName && style.rich[styleName] || {};
	    var lines = block.lines;
	    var font = tokenStyle.font || style.font;
	    var newLine = false;
	    var strLines;
	    var linesWidths;
	    if (wrapInfo) {
	        var tokenPadding = tokenStyle.padding;
	        var tokenPaddingH = tokenPadding ? tokenPadding[1] + tokenPadding[3] : 0;
	        if (tokenStyle.width != null && tokenStyle.width !== 'auto') {
	            var outerWidth_1 = parsePercent(tokenStyle.width, wrapInfo.width) + tokenPaddingH;
	            if (lines.length > 0) {
	                if (outerWidth_1 + wrapInfo.accumWidth > wrapInfo.width) {
	                    strLines = str.split('\n');
	                    newLine = true;
	                }
	            }
	            wrapInfo.accumWidth = outerWidth_1;
	        }
	        else {
	            var res = wrapText(str, font, wrapInfo.width, wrapInfo.breakAll, wrapInfo.accumWidth);
	            wrapInfo.accumWidth = res.accumWidth + tokenPaddingH;
	            linesWidths = res.linesWidths;
	            strLines = res.lines;
	        }
	    }
	    else {
	        strLines = str.split('\n');
	    }
	    for (var i = 0; i < strLines.length; i++) {
	        var text = strLines[i];
	        var token = new RichTextToken();
	        token.styleName = styleName;
	        token.text = text;
	        token.isLineHolder = !text && !isEmptyStr;
	        if (typeof tokenStyle.width === 'number') {
	            token.width = tokenStyle.width;
	        }
	        else {
	            token.width = linesWidths
	                ? linesWidths[i]
	                : text_1.getWidth(text, font);
	        }
	        if (!i && !newLine) {
	            var tokens = (lines[lines.length - 1] || (lines[0] = new RichTextLine())).tokens;
	            var tokensLen = tokens.length;
	            (tokensLen === 1 && tokens[0].isLineHolder)
	                ? (tokens[0] = token)
	                : ((text || !tokensLen || isEmptyStr) && tokens.push(token));
	        }
	        else {
	            lines.push(new RichTextLine([token]));
	        }
	    }
	}
	function isLatin(ch) {
	    var code = ch.charCodeAt(0);
	    return code >= 0x21 && code <= 0xFF;
	}
	var breakCharMap = util_1.reduce(',&?/;] '.split(''), function (obj, ch) {
	    obj[ch] = true;
	    return obj;
	}, {});
	function isWordBreakChar(ch) {
	    if (isLatin(ch)) {
	        if (breakCharMap[ch]) {
	            return true;
	        }
	        return false;
	    }
	    return true;
	}
	function wrapText(text, font, lineWidth, isBreakAll, lastAccumWidth) {
	    var lines = [];
	    var linesWidths = [];
	    var line = '';
	    var currentWord = '';
	    var currentWordWidth = 0;
	    var accumWidth = 0;
	    for (var i = 0; i < text.length; i++) {
	        var ch = text.charAt(i);
	        if (ch === '\n') {
	            if (currentWord) {
	                line += currentWord;
	                accumWidth += currentWordWidth;
	            }
	            lines.push(line);
	            linesWidths.push(accumWidth);
	            line = '';
	            currentWord = '';
	            currentWordWidth = 0;
	            accumWidth = 0;
	            continue;
	        }
	        var chWidth = text_1.getWidth(ch, font);
	        var inWord = isBreakAll ? false : !isWordBreakChar(ch);
	        if (!lines.length
	            ? lastAccumWidth + accumWidth + chWidth > lineWidth
	            : accumWidth + chWidth > lineWidth) {
	            if (!accumWidth) {
	                if (inWord) {
	                    lines.push(currentWord);
	                    linesWidths.push(currentWordWidth);
	                    currentWord = ch;
	                    currentWordWidth = chWidth;
	                }
	                else {
	                    lines.push(ch);
	                    linesWidths.push(chWidth);
	                }
	            }
	            else if (line || currentWord) {
	                if (inWord) {
	                    if (!line) {
	                        line = currentWord;
	                        currentWord = '';
	                        currentWordWidth = 0;
	                        accumWidth = currentWordWidth;
	                    }
	                    lines.push(line);
	                    linesWidths.push(accumWidth - currentWordWidth);
	                    currentWord += ch;
	                    currentWordWidth += chWidth;
	                    line = '';
	                    accumWidth = currentWordWidth;
	                }
	                else {
	                    if (currentWord) {
	                        line += currentWord;
	                        accumWidth += currentWordWidth;
	                        currentWord = '';
	                        currentWordWidth = 0;
	                    }
	                    lines.push(line);
	                    linesWidths.push(accumWidth);
	                    line = ch;
	                    accumWidth = chWidth;
	                }
	            }
	            continue;
	        }
	        accumWidth += chWidth;
	        if (inWord) {
	            currentWord += ch;
	            currentWordWidth += chWidth;
	        }
	        else {
	            if (currentWord) {
	                line += currentWord;
	                currentWord = '';
	                currentWordWidth = 0;
	            }
	            line += ch;
	        }
	    }
	    if (!lines.length && !line) {
	        line = text;
	        currentWord = '';
	        currentWordWidth = 0;
	    }
	    if (currentWord) {
	        line += currentWord;
	    }
	    if (line) {
	        lines.push(line);
	        linesWidths.push(accumWidth);
	    }
	    if (lines.length === 1) {
	        accumWidth += lastAccumWidth;
	    }
	    return {
	        accumWidth: accumWidth,
	        lines: lines,
	        linesWidths: linesWidths
	    };
	}
	function parsePercent(value, maxValue) {
	    if (typeof value === 'string') {
	        if (value.lastIndexOf('%') >= 0) {
	            return parseFloat(value) / 100 * maxValue;
	        }
	        return parseFloat(value);
	    }
	    return value;
	}


/***/ },
/* 190 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	exports.__esModule = true;
	var smoothSpline_1 = __webpack_require__(467);
	var smoothBezier_1 = __webpack_require__(466);
	function buildPath(ctx, shape, closePath) {
	    var smooth = shape.smooth;
	    var points = shape.points;
	    if (points && points.length >= 2) {
	        if (smooth && smooth !== 'spline') {
	            var controlPoints = smoothBezier_1["default"](points, smooth, closePath, shape.smoothConstraint);
	            ctx.moveTo(points[0][0], points[0][1]);
	            var len = points.length;
	            for (var i = 0; i < (closePath ? len : len - 1); i++) {
	                var cp1 = controlPoints[i * 2];
	                var cp2 = controlPoints[i * 2 + 1];
	                var p = points[(i + 1) % len];
	                ctx.bezierCurveTo(cp1[0], cp1[1], cp2[0], cp2[1], p[0], p[1]);
	            }
	        }
	        else {
	            if (smooth === 'spline') {
	                points = smoothSpline_1["default"](points, closePath);
	            }
	            ctx.moveTo(points[0][0], points[0][1]);
	            for (var i = 1, l = points.length; i < l; i++) {
	                ctx.lineTo(points[i][0], points[i][1]);
	            }
	        }
	        closePath && ctx.closePath();
	    }
	}
	exports.buildPath = buildPath;


/***/ },
/* 191 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	exports.__esModule = true;
	var tslib_1 = __webpack_require__(5);
	var Path_1 = __webpack_require__(8);
	var ArcShape = (function () {
	    function ArcShape() {
	        this.cx = 0;
	        this.cy = 0;
	        this.r = 0;
	        this.startAngle = 0;
	        this.endAngle = Math.PI * 2;
	        this.clockwise = true;
	    }
	    return ArcShape;
	}());
	var Arc = (function (_super) {
	    tslib_1.__extends(Arc, _super);
	    function Arc(opts) {
	        return _super.call(this, opts) || this;
	    }
	    Arc.prototype.getDefaultStyle = function () {
	        return {
	            stroke: '#000',
	            fill: null
	        };
	    };
	    Arc.prototype.getDefaultShape = function () {
	        return new ArcShape();
	    };
	    Arc.prototype.buildPath = function (ctx, shape) {
	        var x = shape.cx;
	        var y = shape.cy;
	        var r = Math.max(shape.r, 0);
	        var startAngle = shape.startAngle;
	        var endAngle = shape.endAngle;
	        var clockwise = shape.clockwise;
	        var unitX = Math.cos(startAngle);
	        var unitY = Math.sin(startAngle);
	        ctx.moveTo(unitX * r + x, unitY * r + y);
	        ctx.arc(x, y, r, startAngle, endAngle, !clockwise);
	    };
	    return Arc;
	}(Path_1["default"]));
	Arc.prototype.type = 'arc';
	exports["default"] = Arc;


/***/ },
/* 192 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	exports.__esModule = true;
	var tslib_1 = __webpack_require__(5);
	var Path_1 = __webpack_require__(8);
	var vec2 = __webpack_require__(11);
	var curve_1 = __webpack_require__(33);
	var out = [];
	var BezierCurveShape = (function () {
	    function BezierCurveShape() {
	        this.x1 = 0;
	        this.y1 = 0;
	        this.x2 = 0;
	        this.y2 = 0;
	        this.cpx1 = 0;
	        this.cpy1 = 0;
	        this.percent = 1;
	    }
	    return BezierCurveShape;
	}());
	function someVectorAt(shape, t, isTangent) {
	    var cpx2 = shape.cpx2;
	    var cpy2 = shape.cpy2;
	    if (cpx2 === null || cpy2 === null) {
	        return [
	            (isTangent ? curve_1.cubicDerivativeAt : curve_1.cubicAt)(shape.x1, shape.cpx1, shape.cpx2, shape.x2, t),
	            (isTangent ? curve_1.cubicDerivativeAt : curve_1.cubicAt)(shape.y1, shape.cpy1, shape.cpy2, shape.y2, t)
	        ];
	    }
	    else {
	        return [
	            (isTangent ? curve_1.quadraticDerivativeAt : curve_1.quadraticAt)(shape.x1, shape.cpx1, shape.x2, t),
	            (isTangent ? curve_1.quadraticDerivativeAt : curve_1.quadraticAt)(shape.y1, shape.cpy1, shape.y2, t)
	        ];
	    }
	}
	var BezierCurve = (function (_super) {
	    tslib_1.__extends(BezierCurve, _super);
	    function BezierCurve(opts) {
	        return _super.call(this, opts) || this;
	    }
	    BezierCurve.prototype.getDefaultStyle = function () {
	        return {
	            stroke: '#000',
	            fill: null
	        };
	    };
	    BezierCurve.prototype.getDefaultShape = function () {
	        return new BezierCurveShape();
	    };
	    BezierCurve.prototype.buildPath = function (ctx, shape) {
	        var x1 = shape.x1;
	        var y1 = shape.y1;
	        var x2 = shape.x2;
	        var y2 = shape.y2;
	        var cpx1 = shape.cpx1;
	        var cpy1 = shape.cpy1;
	        var cpx2 = shape.cpx2;
	        var cpy2 = shape.cpy2;
	        var percent = shape.percent;
	        if (percent === 0) {
	            return;
	        }
	        ctx.moveTo(x1, y1);
	        if (cpx2 == null || cpy2 == null) {
	            if (percent < 1) {
	                curve_1.quadraticSubdivide(x1, cpx1, x2, percent, out);
	                cpx1 = out[1];
	                x2 = out[2];
	                curve_1.quadraticSubdivide(y1, cpy1, y2, percent, out);
	                cpy1 = out[1];
	                y2 = out[2];
	            }
	            ctx.quadraticCurveTo(cpx1, cpy1, x2, y2);
	        }
	        else {
	            if (percent < 1) {
	                curve_1.cubicSubdivide(x1, cpx1, cpx2, x2, percent, out);
	                cpx1 = out[1];
	                cpx2 = out[2];
	                x2 = out[3];
	                curve_1.cubicSubdivide(y1, cpy1, cpy2, y2, percent, out);
	                cpy1 = out[1];
	                cpy2 = out[2];
	                y2 = out[3];
	            }
	            ctx.bezierCurveTo(cpx1, cpy1, cpx2, cpy2, x2, y2);
	        }
	    };
	    BezierCurve.prototype.pointAt = function (t) {
	        return someVectorAt(this.shape, t, false);
	    };
	    BezierCurve.prototype.tangentAt = function (t) {
	        var p = someVectorAt(this.shape, t, true);
	        return vec2.normalize(p, p);
	    };
	    return BezierCurve;
	}(Path_1["default"]));
	;
	BezierCurve.prototype.type = 'bezier-curve';
	exports["default"] = BezierCurve;


/***/ },
/* 193 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	exports.__esModule = true;
	var tslib_1 = __webpack_require__(5);
	var Path_1 = __webpack_require__(8);
	var RingShape = (function () {
	    function RingShape() {
	        this.cx = 0;
	        this.cy = 0;
	        this.r = 0;
	        this.r0 = 0;
	    }
	    return RingShape;
	}());
	var Ring = (function (_super) {
	    tslib_1.__extends(Ring, _super);
	    function Ring(opts) {
	        return _super.call(this, opts) || this;
	    }
	    Ring.prototype.getDefaultShape = function () {
	        return new RingShape();
	    };
	    Ring.prototype.buildPath = function (ctx, shape) {
	        var x = shape.cx;
	        var y = shape.cy;
	        var PI2 = Math.PI * 2;
	        ctx.moveTo(x + shape.r, y);
	        ctx.arc(x, y, shape.r, 0, PI2, false);
	        ctx.moveTo(x + shape.r0, y);
	        ctx.arc(x, y, shape.r0, 0, PI2, true);
	    };
	    return Ring;
	}(Path_1["default"]));
	Ring.prototype.type = 'ring';
	exports["default"] = Ring;


/***/ },
/* 194 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	exports.__esModule = true;
	var Group_1 = __webpack_require__(51);
	var Image_1 = __webpack_require__(43);
	var Circle_1 = __webpack_require__(111);
	var Rect_1 = __webpack_require__(61);
	var Ellipse_1 = __webpack_require__(112);
	var Line_1 = __webpack_require__(113);
	var Path_1 = __webpack_require__(8);
	var Polygon_1 = __webpack_require__(114);
	var Polyline_1 = __webpack_require__(115);
	var matrix = __webpack_require__(27);
	var path_1 = __webpack_require__(117);
	var util_1 = __webpack_require__(1);
	var LinearGradient_1 = __webpack_require__(109);
	var TSpan_1 = __webpack_require__(80);
	var DILIMITER_REG = /[\s,]+/;
	function parseXML(svg) {
	    if (util_1.isString(svg)) {
	        var parser = new DOMParser();
	        svg = parser.parseFromString(svg, 'text/xml');
	    }
	    var svgNode = svg;
	    if (svgNode.nodeType === 9) {
	        svgNode = svgNode.firstChild;
	    }
	    while (svgNode.nodeName.toLowerCase() !== 'svg' || svgNode.nodeType !== 1) {
	        svgNode = svgNode.nextSibling;
	    }
	    return svgNode;
	}
	exports.parseXML = parseXML;
	var nodeParsers;
	var SVGParser = (function () {
	    function SVGParser() {
	        this._defs = {};
	        this._root = null;
	        this._isDefine = false;
	        this._isText = false;
	    }
	    SVGParser.prototype.parse = function (xml, opt) {
	        opt = opt || {};
	        var svg = parseXML(xml);
	        if (!svg) {
	            throw new Error('Illegal svg');
	        }
	        var root = new Group_1["default"]();
	        this._root = root;
	        var viewBox = svg.getAttribute('viewBox') || '';
	        var width = parseFloat((svg.getAttribute('width') || opt.width));
	        var height = parseFloat((svg.getAttribute('height') || opt.height));
	        isNaN(width) && (width = null);
	        isNaN(height) && (height = null);
	        parseAttributes(svg, root, null, true);
	        var child = svg.firstChild;
	        while (child) {
	            this._parseNode(child, root);
	            child = child.nextSibling;
	        }
	        var viewBoxRect;
	        var viewBoxTransform;
	        if (viewBox) {
	            var viewBoxArr = util_1.trim(viewBox).split(DILIMITER_REG);
	            if (viewBoxArr.length >= 4) {
	                viewBoxRect = {
	                    x: parseFloat((viewBoxArr[0] || 0)),
	                    y: parseFloat((viewBoxArr[1] || 0)),
	                    width: parseFloat(viewBoxArr[2]),
	                    height: parseFloat(viewBoxArr[3])
	                };
	            }
	        }
	        if (viewBoxRect && width != null && height != null) {
	            viewBoxTransform = makeViewBoxTransform(viewBoxRect, width, height);
	            if (!opt.ignoreViewBox) {
	                var elRoot = root;
	                root = new Group_1["default"]();
	                root.add(elRoot);
	                elRoot.scaleX = elRoot.scaleY = viewBoxTransform.scale;
	                elRoot.x = viewBoxTransform.x;
	                elRoot.y = viewBoxTransform.y;
	            }
	        }
	        if (!opt.ignoreRootClip && width != null && height != null) {
	            root.setClipPath(new Rect_1["default"]({
	                shape: { x: 0, y: 0, width: width, height: height }
	            }));
	        }
	        return {
	            root: root,
	            width: width,
	            height: height,
	            viewBoxRect: viewBoxRect,
	            viewBoxTransform: viewBoxTransform
	        };
	    };
	    SVGParser.prototype._parseNode = function (xmlNode, parentGroup) {
	        var nodeName = xmlNode.nodeName.toLowerCase();
	        if (nodeName === 'defs') {
	            this._isDefine = true;
	        }
	        else if (nodeName === 'text') {
	            this._isText = true;
	        }
	        var el;
	        if (this._isDefine) {
	            var parser = defineParsers[nodeName];
	            if (parser) {
	                var def = parser.call(this, xmlNode);
	                var id = xmlNode.getAttribute('id');
	                if (id) {
	                    this._defs[id] = def;
	                }
	            }
	        }
	        else {
	            var parser = nodeParsers[nodeName];
	            if (parser) {
	                el = parser.call(this, xmlNode, parentGroup);
	                parentGroup.add(el);
	            }
	        }
	        if (el) {
	            var child = xmlNode.firstChild;
	            while (child) {
	                if (child.nodeType === 1) {
	                    this._parseNode(child, el);
	                }
	                if (child.nodeType === 3 && this._isText) {
	                    this._parseText(child, el);
	                }
	                child = child.nextSibling;
	            }
	        }
	        if (nodeName === 'defs') {
	            this._isDefine = false;
	        }
	        else if (nodeName === 'text') {
	            this._isText = false;
	        }
	    };
	    SVGParser.prototype._parseText = function (xmlNode, parentGroup) {
	        if (xmlNode.nodeType === 1) {
	            var dx = xmlNode.getAttribute('dx') || 0;
	            var dy = xmlNode.getAttribute('dy') || 0;
	            this._textX += parseFloat(dx);
	            this._textY += parseFloat(dy);
	        }
	        var text = new TSpan_1["default"]({
	            style: {
	                text: xmlNode.textContent
	            },
	            x: this._textX || 0,
	            y: this._textY || 0
	        });
	        inheritStyle(parentGroup, text);
	        parseAttributes(xmlNode, text, this._defs);
	        var textStyle = text.style;
	        var fontSize = textStyle.fontSize;
	        if (fontSize && fontSize < 9) {
	            textStyle.fontSize = 9;
	            text.scaleX *= fontSize / 9;
	            text.scaleY *= fontSize / 9;
	        }
	        var font = (textStyle.fontSize || textStyle.fontFamily) && [
	            textStyle.fontStyle,
	            textStyle.fontWeight,
	            (textStyle.fontSize || 12) + 'px',
	            textStyle.fontFamily || 'sans-serif'
	        ].join(' ');
	        textStyle.font = font;
	        var rect = text.getBoundingRect();
	        this._textX += rect.width;
	        parentGroup.add(text);
	        return text;
	    };
	    SVGParser.internalField = (function () {
	        nodeParsers = {
	            'g': function (xmlNode, parentGroup) {
	                var g = new Group_1["default"]();
	                inheritStyle(parentGroup, g);
	                parseAttributes(xmlNode, g, this._defs);
	                return g;
	            },
	            'rect': function (xmlNode, parentGroup) {
	                var rect = new Rect_1["default"]();
	                inheritStyle(parentGroup, rect);
	                parseAttributes(xmlNode, rect, this._defs);
	                rect.setShape({
	                    x: parseFloat(xmlNode.getAttribute('x') || '0'),
	                    y: parseFloat(xmlNode.getAttribute('y') || '0'),
	                    width: parseFloat(xmlNode.getAttribute('width') || '0'),
	                    height: parseFloat(xmlNode.getAttribute('height') || '0')
	                });
	                return rect;
	            },
	            'circle': function (xmlNode, parentGroup) {
	                var circle = new Circle_1["default"]();
	                inheritStyle(parentGroup, circle);
	                parseAttributes(xmlNode, circle, this._defs);
	                circle.setShape({
	                    cx: parseFloat(xmlNode.getAttribute('cx') || '0'),
	                    cy: parseFloat(xmlNode.getAttribute('cy') || '0'),
	                    r: parseFloat(xmlNode.getAttribute('r') || '0')
	                });
	                return circle;
	            },
	            'line': function (xmlNode, parentGroup) {
	                var line = new Line_1["default"]();
	                inheritStyle(parentGroup, line);
	                parseAttributes(xmlNode, line, this._defs);
	                line.setShape({
	                    x1: parseFloat(xmlNode.getAttribute('x1') || '0'),
	                    y1: parseFloat(xmlNode.getAttribute('y1') || '0'),
	                    x2: parseFloat(xmlNode.getAttribute('x2') || '0'),
	                    y2: parseFloat(xmlNode.getAttribute('y2') || '0')
	                });
	                return line;
	            },
	            'ellipse': function (xmlNode, parentGroup) {
	                var ellipse = new Ellipse_1["default"]();
	                inheritStyle(parentGroup, ellipse);
	                parseAttributes(xmlNode, ellipse, this._defs);
	                ellipse.setShape({
	                    cx: parseFloat(xmlNode.getAttribute('cx') || '0'),
	                    cy: parseFloat(xmlNode.getAttribute('cy') || '0'),
	                    rx: parseFloat(xmlNode.getAttribute('rx') || '0'),
	                    ry: parseFloat(xmlNode.getAttribute('ry') || '0')
	                });
	                return ellipse;
	            },
	            'polygon': function (xmlNode, parentGroup) {
	                var pointsStr = xmlNode.getAttribute('points');
	                var pointsArr;
	                if (pointsStr) {
	                    pointsArr = parsePoints(pointsStr);
	                }
	                var polygon = new Polygon_1["default"]({
	                    shape: {
	                        points: pointsArr || []
	                    }
	                });
	                inheritStyle(parentGroup, polygon);
	                parseAttributes(xmlNode, polygon, this._defs);
	                return polygon;
	            },
	            'polyline': function (xmlNode, parentGroup) {
	                var path = new Path_1["default"]();
	                inheritStyle(parentGroup, path);
	                parseAttributes(xmlNode, path, this._defs);
	                var pointsStr = xmlNode.getAttribute('points');
	                var pointsArr;
	                if (pointsStr) {
	                    pointsArr = parsePoints(pointsStr);
	                }
	                var polyline = new Polyline_1["default"]({
	                    shape: {
	                        points: pointsArr || []
	                    }
	                });
	                return polyline;
	            },
	            'image': function (xmlNode, parentGroup) {
	                var img = new Image_1["default"]();
	                inheritStyle(parentGroup, img);
	                parseAttributes(xmlNode, img, this._defs);
	                img.setStyle({
	                    image: xmlNode.getAttribute('xlink:href'),
	                    x: +xmlNode.getAttribute('x'),
	                    y: +xmlNode.getAttribute('y'),
	                    width: +xmlNode.getAttribute('width'),
	                    height: +xmlNode.getAttribute('height')
	                });
	                return img;
	            },
	            'text': function (xmlNode, parentGroup) {
	                var x = xmlNode.getAttribute('x') || '0';
	                var y = xmlNode.getAttribute('y') || '0';
	                var dx = xmlNode.getAttribute('dx') || '0';
	                var dy = xmlNode.getAttribute('dy') || '0';
	                this._textX = parseFloat(x) + parseFloat(dx);
	                this._textY = parseFloat(y) + parseFloat(dy);
	                var g = new Group_1["default"]();
	                inheritStyle(parentGroup, g);
	                parseAttributes(xmlNode, g, this._defs);
	                return g;
	            },
	            'tspan': function (xmlNode, parentGroup) {
	                var x = xmlNode.getAttribute('x');
	                var y = xmlNode.getAttribute('y');
	                if (x != null) {
	                    this._textX = parseFloat(x);
	                }
	                if (y != null) {
	                    this._textY = parseFloat(y);
	                }
	                var dx = xmlNode.getAttribute('dx') || 0;
	                var dy = xmlNode.getAttribute('dy') || 0;
	                var g = new Group_1["default"]();
	                inheritStyle(parentGroup, g);
	                parseAttributes(xmlNode, g, this._defs);
	                this._textX += dx;
	                this._textY += dy;
	                return g;
	            },
	            'path': function (xmlNode, parentGroup) {
	                var d = xmlNode.getAttribute('d') || '';
	                var path = path_1.createFromString(d);
	                inheritStyle(parentGroup, path);
	                parseAttributes(xmlNode, path, this._defs);
	                return path;
	            }
	        };
	    })();
	    return SVGParser;
	}());
	var defineParsers = {
	    'lineargradient': function (xmlNode) {
	        var x1 = parseInt(xmlNode.getAttribute('x1') || '0', 10);
	        var y1 = parseInt(xmlNode.getAttribute('y1') || '0', 10);
	        var x2 = parseInt(xmlNode.getAttribute('x2') || '10', 10);
	        var y2 = parseInt(xmlNode.getAttribute('y2') || '0', 10);
	        var gradient = new LinearGradient_1["default"](x1, y1, x2, y2);
	        _parseGradientColorStops(xmlNode, gradient);
	        return gradient;
	    }
	};
	function _parseGradientColorStops(xmlNode, gradient) {
	    var stop = xmlNode.firstChild;
	    while (stop) {
	        if (stop.nodeType === 1) {
	            var offsetStr = stop.getAttribute('offset');
	            var offset = void 0;
	            if (offsetStr.indexOf('%') > 0) {
	                offset = parseInt(offsetStr, 10) / 100;
	            }
	            else if (offsetStr) {
	                offset = parseFloat(offsetStr);
	            }
	            else {
	                offset = 0;
	            }
	            var stopColor = stop.getAttribute('stop-color') || '#000000';
	            gradient.colorStops.push({
	                offset: offset,
	                color: stopColor
	            });
	        }
	        stop = stop.nextSibling;
	    }
	}
	function inheritStyle(parent, child) {
	    if (parent && parent.__inheritedStyle) {
	        if (!child.__inheritedStyle) {
	            child.__inheritedStyle = {};
	        }
	        util_1.defaults(child.__inheritedStyle, parent.__inheritedStyle);
	    }
	}
	function parsePoints(pointsString) {
	    var list = util_1.trim(pointsString).split(DILIMITER_REG);
	    var points = [];
	    for (var i = 0; i < list.length; i += 2) {
	        var x = parseFloat(list[i]);
	        var y = parseFloat(list[i + 1]);
	        points.push([x, y]);
	    }
	    return points;
	}
	var attributesMap = {
	    'fill': 'fill',
	    'stroke': 'stroke',
	    'stroke-width': 'lineWidth',
	    'opacity': 'opacity',
	    'fill-opacity': 'fillOpacity',
	    'stroke-opacity': 'strokeOpacity',
	    'stroke-dasharray': 'lineDash',
	    'stroke-dashoffset': 'lineDashOffset',
	    'stroke-linecap': 'lineCap',
	    'stroke-linejoin': 'lineJoin',
	    'stroke-miterlimit': 'miterLimit',
	    'font-family': 'fontFamily',
	    'font-size': 'fontSize',
	    'font-style': 'fontStyle',
	    'font-weight': 'fontWeight',
	    'text-align': 'textAlign',
	    'alignment-baseline': 'textBaseline'
	};
	function parseAttributes(xmlNode, el, defs, onlyInlineStyle) {
	    var disp = el;
	    var zrStyle = disp.__inheritedStyle || {};
	    if (xmlNode.nodeType === 1) {
	        parseTransformAttribute(xmlNode, el);
	        util_1.extend(zrStyle, parseStyleAttribute(xmlNode));
	        if (!onlyInlineStyle) {
	            for (var svgAttrName in attributesMap) {
	                if (attributesMap.hasOwnProperty(svgAttrName)) {
	                    var attrValue = xmlNode.getAttribute(svgAttrName);
	                    if (attrValue != null) {
	                        zrStyle[attributesMap[svgAttrName]] = attrValue;
	                    }
	                }
	            }
	        }
	    }
	    disp.style = disp.style || {};
	    zrStyle.fill != null && (disp.style.fill = getPaint(zrStyle.fill, defs));
	    zrStyle.stroke != null && (disp.style.stroke = getPaint(zrStyle.stroke, defs));
	    util_1.each([
	        'lineWidth', 'opacity', 'fillOpacity', 'strokeOpacity', 'miterLimit', 'fontSize'
	    ], function (propName) {
	        zrStyle[propName] != null && (disp.style[propName] = parseFloat(zrStyle[propName]));
	    });
	    if (!zrStyle.textBaseline || zrStyle.textBaseline === 'auto') {
	        zrStyle.textBaseline = 'alphabetic';
	    }
	    if (zrStyle.textBaseline === 'alphabetic') {
	        zrStyle.textBaseline = 'bottom';
	    }
	    if (zrStyle.textAlign === 'start') {
	        zrStyle.textAlign = 'left';
	    }
	    if (zrStyle.textAlign === 'end') {
	        zrStyle.textAlign = 'right';
	    }
	    util_1.each(['lineDashOffset', 'lineCap', 'lineJoin',
	        'fontWeight', 'fontFamily', 'fontStyle', 'textAlign', 'textBaseline'
	    ], function (propName) {
	        zrStyle[propName] != null && (disp.style[propName] = zrStyle[propName]);
	    });
	    if (zrStyle.lineDash) {
	        disp.style.lineDash = util_1.map(util_1.trim(zrStyle.lineDash).split(DILIMITER_REG), function (str) {
	            return parseFloat(str);
	        });
	    }
	    disp.__inheritedStyle = zrStyle;
	}
	var urlRegex = /url\(\s*#(.*?)\)/;
	function getPaint(str, defs) {
	    var urlMatch = defs && str && str.match(urlRegex);
	    if (urlMatch) {
	        var url = util_1.trim(urlMatch[1]);
	        var def = defs[url];
	        return def;
	    }
	    return str;
	}
	var transformRegex = /(translate|scale|rotate|skewX|skewY|matrix)\(([\-\s0-9\.e,]*)\)/g;
	function parseTransformAttribute(xmlNode, node) {
	    var transform = xmlNode.getAttribute('transform');
	    if (transform) {
	        transform = transform.replace(/,/g, ' ');
	        var transformOps_1 = [];
	        var m = null;
	        transform.replace(transformRegex, function (str, type, value) {
	            transformOps_1.push(type, value);
	            return '';
	        });
	        for (var i = transformOps_1.length - 1; i > 0; i -= 2) {
	            var value = transformOps_1[i];
	            var type = transformOps_1[i - 1];
	            var valueArr = void 0;
	            m = m || matrix.create();
	            switch (type) {
	                case 'translate':
	                    valueArr = util_1.trim(value).split(DILIMITER_REG);
	                    matrix.translate(m, m, [parseFloat(valueArr[0]), parseFloat(valueArr[1] || '0')]);
	                    break;
	                case 'scale':
	                    valueArr = util_1.trim(value).split(DILIMITER_REG);
	                    matrix.scale(m, m, [parseFloat(valueArr[0]), parseFloat(valueArr[1] || valueArr[0])]);
	                    break;
	                case 'rotate':
	                    valueArr = util_1.trim(value).split(DILIMITER_REG);
	                    matrix.rotate(m, m, parseFloat(valueArr[0]));
	                    break;
	                case 'skew':
	                    valueArr = util_1.trim(value).split(DILIMITER_REG);
	                    console.warn('Skew transform is not supported yet');
	                    break;
	                case 'matrix':
	                    valueArr = util_1.trim(value).split(DILIMITER_REG);
	                    m[0] = parseFloat(valueArr[0]);
	                    m[1] = parseFloat(valueArr[1]);
	                    m[2] = parseFloat(valueArr[2]);
	                    m[3] = parseFloat(valueArr[3]);
	                    m[4] = parseFloat(valueArr[4]);
	                    m[5] = parseFloat(valueArr[5]);
	                    break;
	            }
	        }
	        node.setLocalTransform(m);
	    }
	}
	var styleRegex = /([^\s:;]+)\s*:\s*([^:;]+)/g;
	function parseStyleAttribute(xmlNode) {
	    var style = xmlNode.getAttribute('style');
	    var result = {};
	    if (!style) {
	        return result;
	    }
	    var styleList = {};
	    styleRegex.lastIndex = 0;
	    var styleRegResult;
	    while ((styleRegResult = styleRegex.exec(style)) != null) {
	        styleList[styleRegResult[1]] = styleRegResult[2];
	    }
	    for (var svgAttrName in attributesMap) {
	        if (attributesMap.hasOwnProperty(svgAttrName) && styleList[svgAttrName] != null) {
	            result[attributesMap[svgAttrName]] = styleList[svgAttrName];
	        }
	    }
	    return result;
	}
	function makeViewBoxTransform(viewBoxRect, width, height) {
	    var scaleX = width / viewBoxRect.width;
	    var scaleY = height / viewBoxRect.height;
	    var scale = Math.min(scaleX, scaleY);
	    return {
	        scale: scale,
	        x: -(viewBoxRect.x + viewBoxRect.width / 2) * scale + width / 2,
	        y: -(viewBoxRect.y + viewBoxRect.height / 2) * scale + height / 2
	    };
	}
	exports.makeViewBoxTransform = makeViewBoxTransform;
	function parseSVG(xml, opt) {
	    var parser = new SVGParser();
	    return parser.parse(xml, opt);
	}
	exports.parseSVG = parseSVG;


/***/ },
/* 195 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	/*!
	* ZRender, a high performance 2d drawing library.
	*
	* Copyright (c) 2013, Baidu Inc.
	* All rights reserved.
	*
	* LICENSE
	* https://github.com/ecomfe/zrender/blob/master/LICENSE.txt
	*/
	exports.__esModule = true;
	var env_1 = __webpack_require__(13);
	var zrUtil = __webpack_require__(1);
	var Handler_1 = __webpack_require__(442);
	var Storage_1 = __webpack_require__(443);
	var Animation_1 = __webpack_require__(444);
	var HandlerProxy_1 = __webpack_require__(461);
	var export_1 = __webpack_require__(183);
	var color_1 = __webpack_require__(34);
	var config_1 = __webpack_require__(49);
	var useVML = !env_1["default"].canvasSupported;
	var painterCtors = {};
	var instances = {};
	function delInstance(id) {
	    delete instances[id];
	}
	function isDarkMode(backgroundColor) {
	    if (!backgroundColor) {
	        return false;
	    }
	    if (typeof backgroundColor === 'string') {
	        return color_1.lum(backgroundColor, 1) < config_1.DARK_MODE_THRESHOLD;
	    }
	    else if (backgroundColor.colorStops) {
	        var colorStops = backgroundColor.colorStops;
	        var totalLum = 0;
	        var len = colorStops.length;
	        for (var i = 0; i < len; i++) {
	            totalLum += color_1.lum(colorStops[i].color, 1);
	        }
	        totalLum /= len;
	        return totalLum < config_1.DARK_MODE_THRESHOLD;
	    }
	    return false;
	}
	var ZRender = (function () {
	    function ZRender(id, dom, opts) {
	        var _this = this;
	        this._sleepAfterStill = 10;
	        this._stillFrameAccum = 0;
	        this._needsRefresh = true;
	        this._needsRefreshHover = true;
	        this._darkMode = false;
	        opts = opts || {};
	        this.dom = dom;
	        this.id = id;
	        var self = this;
	        var storage = new Storage_1["default"]();
	        var rendererType = opts.renderer;
	        if (useVML) {
	            if (!painterCtors.vml) {
	                throw new Error('You need to require \'zrender/vml/vml\' to support IE8');
	            }
	            rendererType = 'vml';
	        }
	        else if (!rendererType) {
	            rendererType = 'canvas';
	        }
	        if (!painterCtors[rendererType]) {
	            throw new Error("Renderer '" + rendererType + "' is not imported. Please import it first.");
	        }
	        opts.useDirtyRect = opts.useDirtyRect == null
	            ? false
	            : opts.useDirtyRect;
	        var painter = new painterCtors[rendererType](dom, storage, opts, id);
	        this.storage = storage;
	        this.painter = painter;
	        var handerProxy = (!env_1["default"].node && !env_1["default"].worker)
	            ? new HandlerProxy_1["default"](painter.getViewportRoot(), painter.root)
	            : null;
	        this.handler = new Handler_1["default"](storage, painter, handerProxy, painter.root);
	        this.animation = new Animation_1["default"]({
	            stage: {
	                update: function () { return _this._flush(true); }
	            }
	        });
	        this.animation.start();
	    }
	    ZRender.prototype.add = function (el) {
	        if (!el) {
	            return;
	        }
	        this.storage.addRoot(el);
	        el.addSelfToZr(this);
	        this.refresh();
	    };
	    ZRender.prototype.remove = function (el) {
	        if (!el) {
	            return;
	        }
	        this.storage.delRoot(el);
	        el.removeSelfFromZr(this);
	        this.refresh();
	    };
	    ZRender.prototype.configLayer = function (zLevel, config) {
	        if (this.painter.configLayer) {
	            this.painter.configLayer(zLevel, config);
	        }
	        this.refresh();
	    };
	    ZRender.prototype.setBackgroundColor = function (backgroundColor) {
	        if (this.painter.setBackgroundColor) {
	            this.painter.setBackgroundColor(backgroundColor);
	        }
	        this.refresh();
	        this._backgroundColor = backgroundColor;
	        this._darkMode = isDarkMode(backgroundColor);
	    };
	    ZRender.prototype.getBackgroundColor = function () {
	        return this._backgroundColor;
	    };
	    ZRender.prototype.setDarkMode = function (darkMode) {
	        this._darkMode = darkMode;
	    };
	    ZRender.prototype.isDarkMode = function () {
	        return this._darkMode;
	    };
	    ZRender.prototype.refreshImmediately = function (fromInside) {
	        if (!fromInside) {
	            this.animation.update(true);
	        }
	        this._needsRefresh = false;
	        this.painter.refresh();
	        this._needsRefresh = false;
	    };
	    ZRender.prototype.refresh = function () {
	        this._needsRefresh = true;
	        this.animation.start();
	    };
	    ZRender.prototype.flush = function () {
	        this._flush(false);
	    };
	    ZRender.prototype._flush = function (fromInside) {
	        var triggerRendered;
	        var start = new Date().getTime();
	        if (this._needsRefresh) {
	            triggerRendered = true;
	            this.refreshImmediately(fromInside);
	        }
	        if (this._needsRefreshHover) {
	            triggerRendered = true;
	            this.refreshHoverImmediately();
	        }
	        var end = new Date().getTime();
	        if (triggerRendered) {
	            this._stillFrameAccum = 0;
	            this.trigger('rendered', {
	                elapsedTime: end - start
	            });
	        }
	        else if (this._sleepAfterStill > 0) {
	            this._stillFrameAccum++;
	            if (this._stillFrameAccum > this._sleepAfterStill) {
	                this.animation.stop();
	            }
	        }
	    };
	    ZRender.prototype.setSleepAfterStill = function (stillFramesCount) {
	        this._sleepAfterStill = stillFramesCount;
	    };
	    ZRender.prototype.wakeUp = function () {
	        this.animation.start();
	        this._stillFrameAccum = 0;
	    };
	    ZRender.prototype.addHover = function (el) {
	    };
	    ZRender.prototype.removeHover = function (el) {
	    };
	    ZRender.prototype.clearHover = function () {
	    };
	    ZRender.prototype.refreshHover = function () {
	        this._needsRefreshHover = true;
	    };
	    ZRender.prototype.refreshHoverImmediately = function () {
	        this._needsRefreshHover = false;
	        if (this.painter.refreshHover && this.painter.getType() === 'canvas') {
	            this.painter.refreshHover();
	        }
	    };
	    ZRender.prototype.resize = function (opts) {
	        opts = opts || {};
	        this.painter.resize(opts.width, opts.height);
	        this.handler.resize();
	    };
	    ZRender.prototype.clearAnimation = function () {
	        this.animation.clear();
	    };
	    ZRender.prototype.getWidth = function () {
	        return this.painter.getWidth();
	    };
	    ZRender.prototype.getHeight = function () {
	        return this.painter.getHeight();
	    };
	    ZRender.prototype.pathToImage = function (e, dpr) {
	        if (this.painter.pathToImage) {
	            return this.painter.pathToImage(e, dpr);
	        }
	    };
	    ZRender.prototype.setCursorStyle = function (cursorStyle) {
	        this.handler.setCursorStyle(cursorStyle);
	    };
	    ZRender.prototype.findHover = function (x, y) {
	        return this.handler.findHover(x, y);
	    };
	    ZRender.prototype.on = function (eventName, eventHandler, context) {
	        this.handler.on(eventName, eventHandler, context);
	        return this;
	    };
	    ZRender.prototype.off = function (eventName, eventHandler) {
	        this.handler.off(eventName, eventHandler);
	    };
	    ZRender.prototype.trigger = function (eventName, event) {
	        this.handler.trigger(eventName, event);
	    };
	    ZRender.prototype.clear = function () {
	        var roots = this.storage.getRoots();
	        for (var i = 0; i < roots.length; i++) {
	            if (roots[i] instanceof export_1.Group) {
	                roots[i].removeSelfFromZr(this);
	            }
	        }
	        this.storage.delAllRoots();
	        this.painter.clear();
	    };
	    ZRender.prototype.dispose = function () {
	        this.animation.stop();
	        this.clear();
	        this.storage.dispose();
	        this.painter.dispose();
	        this.handler.dispose();
	        this.animation =
	            this.storage =
	                this.painter =
	                    this.handler = null;
	        delInstance(this.id);
	    };
	    return ZRender;
	}());
	function init(dom, opts) {
	    var zr = new ZRender(zrUtil.guid(), dom, opts);
	    instances[zr.id] = zr;
	    return zr;
	}
	exports.init = init;
	function dispose(zr) {
	    zr.dispose();
	}
	exports.dispose = dispose;
	function disposeAll() {
	    for (var key in instances) {
	        if (instances.hasOwnProperty(key)) {
	            instances[key].dispose();
	        }
	    }
	    instances = {};
	}
	exports.disposeAll = disposeAll;
	function getInstance(id) {
	    return instances[id];
	}
	exports.getInstance = getInstance;
	function registerPainter(name, Ctor) {
	    painterCtors[name] = Ctor;
	}
	exports.registerPainter = registerPainter;
	exports.version = '5.0.1';
	;


/***/ },
/* 196 */
/***/ function(module, exports) {

	function _inheritsLoose(subClass, superClass) {
	  subClass.prototype = Object.create(superClass.prototype);
	  subClass.prototype.constructor = subClass;
	  subClass.__proto__ = superClass;
	}
	
	module.exports = _inheritsLoose;

/***/ },
/* 197 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	/**
	 * Copyright (c) 2017-present, Ephox, Inc.
	 *
	 * This source code is licensed under the Apache 2 license found in the
	 * LICENSE file in the root directory of this source tree.
	 *
	 */
	Object.defineProperty(exports, "__esModule", { value: true });
	exports.ScriptLoader = void 0;
	var Utils_1 = __webpack_require__(118);
	var createState = function () {
	    return {
	        listeners: [],
	        scriptId: Utils_1.uuid('tiny-script'),
	        scriptLoading: false,
	        scriptLoaded: false
	    };
	};
	var CreateScriptLoader = function () {
	    var state = createState();
	    var injectScriptTag = function (scriptId, doc, url, async, defer, callback) {
	        var scriptTag = doc.createElement('script');
	        scriptTag.referrerPolicy = 'origin';
	        scriptTag.type = 'application/javascript';
	        scriptTag.id = scriptId;
	        scriptTag.src = url;
	        scriptTag.async = async;
	        scriptTag.defer = defer;
	        var handler = function () {
	            scriptTag.removeEventListener('load', handler);
	            callback();
	        };
	        scriptTag.addEventListener('load', handler);
	        if (doc.head) {
	            doc.head.appendChild(scriptTag);
	        }
	    };
	    var load = function (doc, url, async, defer, delay, callback) {
	        var scriptTagInjection = function () { return injectScriptTag(state.scriptId, doc, url, async, defer, function () {
	            state.listeners.forEach(function (fn) { return fn(); });
	            state.scriptLoaded = true;
	        }); };
	        if (state.scriptLoaded) {
	            callback();
	        }
	        else {
	            state.listeners.push(callback);
	            if (!state.scriptLoading) {
	                state.scriptLoading = true;
	                if (delay > 0) {
	                    setTimeout(scriptTagInjection, delay);
	                }
	                else {
	                    scriptTagInjection();
	                }
	            }
	        }
	    };
	    // Only to be used by tests.
	    var reinitialize = function () {
	        state = createState();
	    };
	    return {
	        load: load,
	        reinitialize: reinitialize
	    };
	};
	var ScriptLoader = CreateScriptLoader();
	exports.ScriptLoader = ScriptLoader;


/***/ },
/* 198 */
/***/ function(module, exports) {

	/* WEBPACK VAR INJECTION */(function(global) {"use strict";
	/**
	 * Copyright (c) 2017-present, Ephox, Inc.
	 *
	 * This source code is licensed under the Apache 2 license found in the
	 * LICENSE file in the root directory of this source tree.
	 *
	 */
	Object.defineProperty(exports, "__esModule", { value: true });
	exports.getTinymce = void 0;
	var getGlobal = function () { return (typeof window !== 'undefined' ? window : global); };
	var getTinymce = function () {
	    var global = getGlobal();
	    return global && global.tinymce ? global.tinymce : null;
	};
	exports.getTinymce = getTinymce;
	
	/* WEBPACK VAR INJECTION */}.call(exports, (function() { return this; }())))

/***/ },
/* 199 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	/**
	 * Copyright (c) 2017-present, Ephox, Inc.
	 *
	 * This source code is licensed under the Apache 2 license found in the
	 * LICENSE file in the root directory of this source tree.
	 *
	 */
	var __extends = (this && this.__extends) || (function () {
	    var extendStatics = function (d, b) {
	        extendStatics = Object.setPrototypeOf ||
	            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
	            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
	        return extendStatics(d, b);
	    };
	    return function (d, b) {
	        extendStatics(d, b);
	        function __() { this.constructor = d; }
	        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	    };
	})();
	var __assign = (this && this.__assign) || function () {
	    __assign = Object.assign || function(t) {
	        for (var s, i = 1, n = arguments.length; i < n; i++) {
	            s = arguments[i];
	            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
	                t[p] = s[p];
	        }
	        return t;
	    };
	    return __assign.apply(this, arguments);
	};
	Object.defineProperty(exports, "__esModule", { value: true });
	exports.Editor = void 0;
	var React = __webpack_require__(2);
	var ScriptLoader_1 = __webpack_require__(197);
	var TinyMCE_1 = __webpack_require__(198);
	var Utils_1 = __webpack_require__(118);
	var EditorPropTypes_1 = __webpack_require__(119);
	var Editor = /** @class */ (function (_super) {
	    __extends(Editor, _super);
	    function Editor(props) {
	        var _a, _b, _c;
	        var _this = _super.call(this, props) || this;
	        _this.handleEditorChange = function (evt) {
	            var _a;
	            var editor = _this.editor;
	            if (editor) {
	                var newContent = editor.getContent({ format: _this.props.outputFormat });
	                if (newContent !== _this.currentContent) {
	                    _this.currentContent = newContent;
	                    if (Utils_1.isFunction(_this.props.onEditorChange)) {
	                        _this.props.onEditorChange((_a = _this.currentContent) !== null && _a !== void 0 ? _a : '', editor);
	                    }
	                }
	            }
	        };
	        _this.handleInit = function (initEvent) {
	            var editor = _this.editor;
	            if (editor) {
	                editor.setContent(_this.getInitialValue());
	                editor.undoManager.clear();
	                editor.undoManager.add();
	                editor.setDirty(false);
	                if (Utils_1.isFunction(_this.props.onEditorChange)) {
	                    editor.on('change keyup setcontent', _this.handleEditorChange);
	                }
	                if (Utils_1.isFunction(_this.props.onInit)) {
	                    _this.props.onInit(initEvent, editor);
	                }
	                Utils_1.bindHandlers(editor, _this.props, _this.boundHandlers);
	            }
	        };
	        _this.initialise = function () {
	            var target = _this.elementRef.current;
	            if (!target) {
	                return; // Editor has been unmounted
	            }
	            var tinymce = TinyMCE_1.getTinymce();
	            if (!tinymce) {
	                throw new Error('tinymce should have been loaded into global scope');
	            }
	            var finalInit = __assign(__assign({}, _this.props.init), { selector: undefined, target: target, readonly: _this.props.disabled, inline: _this.inline, plugins: Utils_1.mergePlugins(_this.props.init && _this.props.init.plugins, _this.props.plugins), toolbar: _this.props.toolbar || (_this.props.init && _this.props.init.toolbar), setup: function (editor) {
	                    _this.editor = editor;
	                    editor.on('init', _this.handleInit);
	                    if (_this.props.init && Utils_1.isFunction(_this.props.init.setup)) {
	                        _this.props.init.setup(editor);
	                    }
	                } });
	            if (Utils_1.isTextarea(_this.elementRef.current)) {
	                _this.elementRef.current.style.visibility = '';
	            }
	            tinymce.init(finalInit);
	        };
	        _this.id = _this.props.id || Utils_1.uuid('tiny-react');
	        _this.elementRef = React.createRef();
	        _this.inline = (_c = (_a = _this.props.inline) !== null && _a !== void 0 ? _a : (_b = _this.props.init) === null || _b === void 0 ? void 0 : _b.inline) !== null && _c !== void 0 ? _c : false;
	        _this.boundHandlers = {};
	        return _this;
	    }
	    Editor.prototype.componentDidUpdate = function (prevProps) {
	        var _this = this;
	        var _a;
	        if (this.editor && this.editor.initialized) {
	            Utils_1.bindHandlers(this.editor, this.props, this.boundHandlers);
	            this.currentContent = (_a = this.currentContent) !== null && _a !== void 0 ? _a : this.editor.getContent({ format: this.props.outputFormat });
	            if (typeof this.props.value === 'string' && this.props.value !== prevProps.value && this.props.value !== this.currentContent) {
	                var localEditor_1 = this.editor;
	                localEditor_1.undoManager.transact(function () { return localEditor_1.setContent(_this.props.value); });
	            }
	            if (typeof this.props.disabled === 'boolean' && this.props.disabled !== prevProps.disabled) {
	                this.editor.setMode(this.props.disabled ? 'readonly' : 'design');
	            }
	        }
	    };
	    Editor.prototype.componentDidMount = function () {
	        var _a, _b, _c, _d, _e, _f;
	        if (TinyMCE_1.getTinymce() !== null) {
	            this.initialise();
	        }
	        else if (this.elementRef.current && this.elementRef.current.ownerDocument) {
	            ScriptLoader_1.ScriptLoader.load(this.elementRef.current.ownerDocument, this.getScriptSrc(), (_b = (_a = this.props.scriptLoading) === null || _a === void 0 ? void 0 : _a.async) !== null && _b !== void 0 ? _b : false, (_d = (_c = this.props.scriptLoading) === null || _c === void 0 ? void 0 : _c.defer) !== null && _d !== void 0 ? _d : false, (_f = (_e = this.props.scriptLoading) === null || _e === void 0 ? void 0 : _e.delay) !== null && _f !== void 0 ? _f : 0, this.initialise);
	        }
	    };
	    Editor.prototype.componentWillUnmount = function () {
	        var _this = this;
	        var editor = this.editor;
	        if (editor) {
	            editor.off('init', this.handleInit);
	            if (editor.initialized) {
	                editor.off('change keyup setcontent', this.handleEditorChange);
	                Object.keys(this.boundHandlers).forEach(function (eventName) {
	                    editor.off(eventName, _this.boundHandlers[eventName]);
	                });
	                this.boundHandlers = {};
	            }
	            editor.remove();
	        }
	    };
	    Editor.prototype.render = function () {
	        return this.inline ? this.renderInline() : this.renderIframe();
	    };
	    Editor.prototype.renderInline = function () {
	        var _a = this.props.tagName, tagName = _a === void 0 ? 'div' : _a;
	        return React.createElement(tagName, {
	            ref: this.elementRef,
	            id: this.id
	        });
	    };
	    Editor.prototype.renderIframe = function () {
	        return React.createElement('textarea', {
	            ref: this.elementRef,
	            style: { visibility: 'hidden' },
	            name: this.props.textareaName,
	            id: this.id
	        });
	    };
	    Editor.prototype.getScriptSrc = function () {
	        if (typeof this.props.tinymceScriptSrc === 'string') {
	            return this.props.tinymceScriptSrc;
	        }
	        else {
	            var channel = this.props.cloudChannel;
	            var apiKey = this.props.apiKey ? this.props.apiKey : 'no-api-key';
	            return "https://cdn.tiny.cloud/1/" + apiKey + "/tinymce/" + channel + "/tinymce.min.js";
	        }
	    };
	    Editor.prototype.getInitialValue = function () {
	        if (typeof this.props.value === 'string') {
	            return this.props.value;
	        }
	        else if (typeof this.props.initialValue === 'string') {
	            return this.props.initialValue;
	        }
	        else {
	            return '';
	        }
	    };
	    Editor.propTypes = EditorPropTypes_1.EditorPropTypes;
	    Editor.defaultProps = {
	        cloudChannel: '5'
	    };
	    return Editor;
	}(React.Component));
	exports.Editor = Editor;


/***/ },
/* 200 */
/***/ function(module, exports) {

	/* WEBPACK VAR INJECTION */(function(global) {"use strict";
	
	// Use the fastest means possible to execute a task in its own turn, with
	// priority over other events including IO, animation, reflow, and redraw
	// events in browsers.
	//
	// An exception thrown by a task will permanently interrupt the processing of
	// subsequent tasks. The higher level `asap` function ensures that if an
	// exception is thrown by a task, that the task queue will continue flushing as
	// soon as possible, but if you use `rawAsap` directly, you are responsible to
	// either ensure that no exceptions are thrown from your task, or to manually
	// call `rawAsap.requestFlush` if an exception is thrown.
	module.exports = rawAsap;
	function rawAsap(task) {
	    if (!queue.length) {
	        requestFlush();
	        flushing = true;
	    }
	    // Equivalent to push, but avoids a function call.
	    queue[queue.length] = task;
	}
	
	var queue = [];
	// Once a flush has been requested, no further calls to `requestFlush` are
	// necessary until the next `flush` completes.
	var flushing = false;
	// `requestFlush` is an implementation-specific method that attempts to kick
	// off a `flush` event as quickly as possible. `flush` will attempt to exhaust
	// the event queue before yielding to the browser's own event loop.
	var requestFlush;
	// The position of the next task to execute in the task queue. This is
	// preserved between calls to `flush` so that it can be resumed if
	// a task throws an exception.
	var index = 0;
	// If a task schedules additional tasks recursively, the task queue can grow
	// unbounded. To prevent memory exhaustion, the task queue will periodically
	// truncate already-completed tasks.
	var capacity = 1024;
	
	// The flush function processes all tasks that have been scheduled with
	// `rawAsap` unless and until one of those tasks throws an exception.
	// If a task throws an exception, `flush` ensures that its state will remain
	// consistent and will resume where it left off when called again.
	// However, `flush` does not make any arrangements to be called again if an
	// exception is thrown.
	function flush() {
	    while (index < queue.length) {
	        var currentIndex = index;
	        // Advance the index before calling the task. This ensures that we will
	        // begin flushing on the next task the task throws an error.
	        index = index + 1;
	        queue[currentIndex].call();
	        // Prevent leaking memory for long chains of recursive calls to `asap`.
	        // If we call `asap` within tasks scheduled by `asap`, the queue will
	        // grow, but to avoid an O(n) walk for every task we execute, we don't
	        // shift tasks off the queue after they have been executed.
	        // Instead, we periodically shift 1024 tasks off the queue.
	        if (index > capacity) {
	            // Manually shift all values starting at the index back to the
	            // beginning of the queue.
	            for (var scan = 0, newLength = queue.length - index; scan < newLength; scan++) {
	                queue[scan] = queue[scan + index];
	            }
	            queue.length -= index;
	            index = 0;
	        }
	    }
	    queue.length = 0;
	    index = 0;
	    flushing = false;
	}
	
	// `requestFlush` is implemented using a strategy based on data collected from
	// every available SauceLabs Selenium web driver worker at time of writing.
	// https://docs.google.com/spreadsheets/d/1mG-5UYGup5qxGdEMWkhP6BWCz053NUb2E1QoUTU16uA/edit#gid=783724593
	
	// Safari 6 and 6.1 for desktop, iPad, and iPhone are the only browsers that
	// have WebKitMutationObserver but not un-prefixed MutationObserver.
	// Must use `global` or `self` instead of `window` to work in both frames and web
	// workers. `global` is a provision of Browserify, Mr, Mrs, or Mop.
	
	/* globals self */
	var scope = typeof global !== "undefined" ? global : self;
	var BrowserMutationObserver = scope.MutationObserver || scope.WebKitMutationObserver;
	
	// MutationObservers are desirable because they have high priority and work
	// reliably everywhere they are implemented.
	// They are implemented in all modern browsers.
	//
	// - Android 4-4.3
	// - Chrome 26-34
	// - Firefox 14-29
	// - Internet Explorer 11
	// - iPad Safari 6-7.1
	// - iPhone Safari 7-7.1
	// - Safari 6-7
	if (typeof BrowserMutationObserver === "function") {
	    requestFlush = makeRequestCallFromMutationObserver(flush);
	
	// MessageChannels are desirable because they give direct access to the HTML
	// task queue, are implemented in Internet Explorer 10, Safari 5.0-1, and Opera
	// 11-12, and in web workers in many engines.
	// Although message channels yield to any queued rendering and IO tasks, they
	// would be better than imposing the 4ms delay of timers.
	// However, they do not work reliably in Internet Explorer or Safari.
	
	// Internet Explorer 10 is the only browser that has setImmediate but does
	// not have MutationObservers.
	// Although setImmediate yields to the browser's renderer, it would be
	// preferrable to falling back to setTimeout since it does not have
	// the minimum 4ms penalty.
	// Unfortunately there appears to be a bug in Internet Explorer 10 Mobile (and
	// Desktop to a lesser extent) that renders both setImmediate and
	// MessageChannel useless for the purposes of ASAP.
	// https://github.com/kriskowal/q/issues/396
	
	// Timers are implemented universally.
	// We fall back to timers in workers in most engines, and in foreground
	// contexts in the following browsers.
	// However, note that even this simple case requires nuances to operate in a
	// broad spectrum of browsers.
	//
	// - Firefox 3-13
	// - Internet Explorer 6-9
	// - iPad Safari 4.3
	// - Lynx 2.8.7
	} else {
	    requestFlush = makeRequestCallFromTimer(flush);
	}
	
	// `requestFlush` requests that the high priority event queue be flushed as
	// soon as possible.
	// This is useful to prevent an error thrown in a task from stalling the event
	// queue if the exception handled by Node.js’s
	// `process.on("uncaughtException")` or by a domain.
	rawAsap.requestFlush = requestFlush;
	
	// To request a high priority event, we induce a mutation observer by toggling
	// the text of a text node between "1" and "-1".
	function makeRequestCallFromMutationObserver(callback) {
	    var toggle = 1;
	    var observer = new BrowserMutationObserver(callback);
	    var node = document.createTextNode("");
	    observer.observe(node, {characterData: true});
	    return function requestCall() {
	        toggle = -toggle;
	        node.data = toggle;
	    };
	}
	
	// The message channel technique was discovered by Malte Ubl and was the
	// original foundation for this library.
	// http://www.nonblocking.io/2011/06/windownexttick.html
	
	// Safari 6.0.5 (at least) intermittently fails to create message ports on a
	// page's first load. Thankfully, this version of Safari supports
	// MutationObservers, so we don't need to fall back in that case.
	
	// function makeRequestCallFromMessageChannel(callback) {
	//     var channel = new MessageChannel();
	//     channel.port1.onmessage = callback;
	//     return function requestCall() {
	//         channel.port2.postMessage(0);
	//     };
	// }
	
	// For reasons explained above, we are also unable to use `setImmediate`
	// under any circumstances.
	// Even if we were, there is another bug in Internet Explorer 10.
	// It is not sufficient to assign `setImmediate` to `requestFlush` because
	// `setImmediate` must be called *by name* and therefore must be wrapped in a
	// closure.
	// Never forget.
	
	// function makeRequestCallFromSetImmediate(callback) {
	//     return function requestCall() {
	//         setImmediate(callback);
	//     };
	// }
	
	// Safari 6.0 has a problem where timers will get lost while the user is
	// scrolling. This problem does not impact ASAP because Safari 6.0 supports
	// mutation observers, so that implementation is used instead.
	// However, if we ever elect to use timers in Safari, the prevalent work-around
	// is to add a scroll event listener that calls for a flush.
	
	// `setTimeout` does not call the passed callback if the delay is less than
	// approximately 7 in web workers in Firefox 8 through 18, and sometimes not
	// even then.
	
	function makeRequestCallFromTimer(callback) {
	    return function requestCall() {
	        // We dispatch a timeout with a specified delay of 0 for engines that
	        // can reliably accommodate that request. This will usually be snapped
	        // to a 4 milisecond delay, but once we're flushing, there's no delay
	        // between events.
	        var timeoutHandle = setTimeout(handleTimer, 0);
	        // However, since this timer gets frequently dropped in Firefox
	        // workers, we enlist an interval handle that will try to fire
	        // an event 20 times per second until it succeeds.
	        var intervalHandle = setInterval(handleTimer, 50);
	
	        function handleTimer() {
	            // Whichever timer succeeds will cancel both timers and
	            // execute the callback.
	            clearTimeout(timeoutHandle);
	            clearInterval(intervalHandle);
	            callback();
	        }
	    };
	}
	
	// This is for `asap.js` only.
	// Its name will be periodically randomized to break any code that depends on
	// its existence.
	rawAsap.makeRequestCallFromTimer = makeRequestCallFromTimer;
	
	// ASAP was originally a nextTick shim included in Q. This was factored out
	// into this ASAP package. It was later adapted to RSVP which made further
	// amendments. These decisions, particularly to marginalize MessageChannel and
	// to capture the MutationObserver implementation in a closure, were integrated
	// back into ASAP proper.
	// https://github.com/tildeio/rsvp.js/blob/cddf7232546a9cf858524b75cde6f9edf72620a7/lib/rsvp/asap.js
	
	/* WEBPACK VAR INJECTION */}.call(exports, (function() { return this; }())))

/***/ },
/* 201 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	
	var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();
	
	var _react = __webpack_require__(2);
	
	var _react2 = _interopRequireDefault(_react);
	
	var _reactRouterDom = __webpack_require__(409);
	
	var _Dashboard = __webpack_require__(280);
	
	var _Dashboard2 = _interopRequireDefault(_Dashboard);
	
	__webpack_require__(389);
	
	__webpack_require__(393);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
	
	function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }
	
	function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }
	
	var App = function (_Component) {
	  _inherits(App, _Component);
	
	  function App() {
	    _classCallCheck(this, App);
	
	    return _possibleConstructorReturn(this, (App.__proto__ || Object.getPrototypeOf(App)).apply(this, arguments));
	  }
	
	  _createClass(App, [{
	    key: 'render',
	    value: function render() {
	      return _react2.default.createElement(
	        _reactRouterDom.BrowserRouter,
	        null,
	        _react2.default.createElement(
	          _reactRouterDom.Switch,
	          null,
	          _react2.default.createElement(_reactRouterDom.Route, { exact: true, path: '/', component: _Dashboard2.default })
	        )
	      );
	    }
	  }]);
	
	  return App;
	}(_react.Component);
	
	exports.default = App;

/***/ },
/* 202 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	
	var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();
	
	var _react = __webpack_require__(2);
	
	var _react2 = _interopRequireDefault(_react);
	
	__webpack_require__(390);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
	
	function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }
	
	function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }
	
	var AdminSidebar = function (_React$Component) {
	  _inherits(AdminSidebar, _React$Component);
	
	  function AdminSidebar(props) {
	    _classCallCheck(this, AdminSidebar);
	
	    var _this = _possibleConstructorReturn(this, (AdminSidebar.__proto__ || Object.getPrototypeOf(AdminSidebar)).call(this, props));
	
	    _this.isOpened = _this.isOpened.bind(_this);
	    return _this;
	  }
	
	  _createClass(AdminSidebar, [{
	    key: 'isOpened',
	    value: function isOpened(tab) {
	      if (this.props.openedTab === tab) return "menu_tab";
	    }
	  }, {
	    key: 'render',
	    value: function render() {
	      var _this2 = this;
	
	      return _react2.default.createElement(
	        'div',
	        { className: 'sidebar-admin' },
	        _react2.default.createElement(
	          'div',
	          { className: 'sidebar-wrapper-admin' },
	          _react2.default.createElement(
	            'div',
	            { className: 'logo' },
	            _react2.default.createElement(
	              'a',
	              null,
	              'Hallo Doctor'
	            )
	          ),
	          _react2.default.createElement(
	            'ul',
	            { className: 'menu' },
	            _react2.default.createElement(
	              'li',
	              null,
	              'Patient Data'
	            ),
	            _react2.default.createElement(
	              'li',
	              { id: 'Allgemein', className: this.isOpened("Allgemein"), onClick: function onClick(e) {
	                  return _this2.props.tabClicked(e);
	                } },
	              'Dashboard'
	            ),
	            _react2.default.createElement(
	              'li',
	              { id: 'PatientList', className: this.isOpened("PatientList"), onClick: function onClick(e) {
	                  return _this2.props.tabClicked(e);
	                } },
	              'All Patients'
	            )
	          ),
	          _react2.default.createElement(
	            'ul',
	            { className: 'menu' },
	            _react2.default.createElement(
	              'li',
	              null,
	              'Chat'
	            ),
	            _react2.default.createElement(
	              'li',
	              { id: 'Chat', className: this.isOpened("Chat"), onClick: function onClick(e) {
	                  return _this2.props.tabClicked(e);
	                } },
	              'Inbox'
	            )
	          ),
	          _react2.default.createElement(
	            'ul',
	            { className: 'menu' },
	            _react2.default.createElement(
	              'li',
	              null,
	              'Settings'
	            ),
	            _react2.default.createElement(
	              'li',
	              { id: 'Settings', className: this.isOpened("Settings"), onClick: function onClick(e) {
	                  return _this2.props.tabClicked(e);
	                } },
	              'Profil'
	            ),
	            _react2.default.createElement(
	              'li',
	              { className: 'log_me_out', onClick: function onClick(e) {
	                  return _this2.props.logout(e);
	                } },
	              'log out'
	            )
	          )
	        )
	      );
	    }
	  }]);
	
	  return AdminSidebar;
	}(_react2.default.Component);
	
	exports.default = AdminSidebar;

/***/ },
/* 203 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	
	var _AdminSidebar = __webpack_require__(202);
	
	Object.defineProperty(exports, 'default', {
	  enumerable: true,
	  get: function get() {
	    return _interopRequireDefault(_AdminSidebar).default;
	  }
	});

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/***/ },
/* 204 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	
	var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();
	
	var _react = __webpack_require__(2);
	
	var _react2 = _interopRequireDefault(_react);
	
	var _reactTabs = __webpack_require__(74);
	
	var _SelectedPatient = __webpack_require__(208);
	
	var _SelectedPatient2 = _interopRequireDefault(_SelectedPatient);
	
	var _PatientProfile = __webpack_require__(121);
	
	var _PatientProfile2 = _interopRequireDefault(_PatientProfile);
	
	var _blood_pressure = __webpack_require__(104);
	
	var _blood_pressure2 = _interopRequireDefault(_blood_pressure);
	
	var _tasks_temperature = __webpack_require__(106);
	
	var _tasks_temperature2 = _interopRequireDefault(_tasks_temperature);
	
	var _heart_rate = __webpack_require__(105);
	
	var _heart_rate2 = _interopRequireDefault(_heart_rate);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
	
	function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }
	
	function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }
	
	var Allgemein = function (_React$Component) {
	  _inherits(Allgemein, _React$Component);
	
	  function Allgemein(props) {
	    _classCallCheck(this, Allgemein);
	
	    var _this = _possibleConstructorReturn(this, (Allgemein.__proto__ || Object.getPrototypeOf(Allgemein)).call(this, props));
	
	    _this.selectPatient = function (patient) {
	      _this.setState({ selectedPatient: patient, patientSelectedBool: true });
	    };
	
	    _this.checkIfSelectedCss = function (patient) {
	      if (_this.state.selectedPatient === patient) return { backgroundColor: 'rgb(172 195 227 / 35%)', marginTop: '20px', borderRadius: '5px' };else return { backgroundColor: 'white', marginTop: '20px', borderRadius: '5px' };
	    };
	
	    _this.get_patient_bad_stats = function (health) {
	      var stats = { bad_temperate_days: 0, bad_pulse_days: 0, missed_medication_takes: 0, sever_weight_loss: 0, bad_blood_pressure_days: 0 };
	
	      var puls_history = health.pulses.history.filter(function (pulse) {
	        return Number(pulse.timestamp) >= Number(new Date(Date.now() - 28 * 24 * 60 * 60 * 1000).valueOf()) && pulse.measured;
	      });
	      puls_history.forEach(function (pulse) {
	        if (pulse.pulse >= 50 && pulse.pulse <= 60) stats.bad_pulse_days += stats.bad_pulse_days + 1;
	        if (pulse.pulse < 50 || pulse.pulse > 100) stats.bad_pulse_days += stats.bad_pulse_days + 1;
	      });
	
	      //weight of last 90 days
	      var weight_history = health.weights.history.filter(function (pulse) {
	        return Number(pulse.timestamp) >= Number(new Date(Date.now() - 90 * 24 * 60 * 60 * 1000).valueOf()) && pulse.measured;
	      });
	      var old_weight = weight_history[0];
	      var old_weight_10_percent = old_weight * 0.1;
	      var new_weight = weight_history[weight_history.length - 1];
	
	      if (new_weight >= old_weight + old_weight_10_percent || new_weight <= old_weight - old_weight_10_percent) stats.sever_weight_loss = Math.abs(old_weight - new_weight);
	
	      return stats;
	    };
	
	    _this.state = {
	      dataLoaded: false,
	      rist_patients: [],
	      patientSelectedBool: false,
	      selectedPatient: {},
	      patient_profile_bool: false
	    };
	    return _this;
	  }
	
	  _createClass(Allgemein, [{
	    key: 'componentDidMount',
	    value: function componentDidMount() {
	      var _this2 = this;
	
	      fetch('/api/doctor/getPatients/health/risk').then(function (blob) {
	        return blob.json();
	      }).then(function (blob) {
	        blob.forEach(function (patient) {
	          var bad_stats = _this2.get_patient_bad_stats(patient.health);
	          patient.bad_stats = bad_stats;
	        });
	        console.log(blob);
	        var patients = _this2.setState({ dataLoaded: true, rist_patients: blob.sort(function (a, b) {
	            return a.health.points > b.health.points ? 1 : b.health.points > a.health.points ? -1 : 0;
	          }).reverse() });
	        // this.setState({ patients: blob.sort(function(a, b){ if(a.firstname < b.firstname) { return -1; } if(a.firstname > b.firstname) { return 1; } return 0; }), isLoaded: true });
	        // this.baseState.patient = blob.sort(function(a, b){ if(a.firstname < b.firstname) { return -1; } if(a.firstname > b.firstname) { return 1; } return 0; })
	        // this.baseState.isLoaded = true
	        // if (blob.length > 0){
	        //     this.setState({ noPatients: false });
	        //     this.baseState.noPatients = true
	        // }
	      }).catch(function (error) {
	        return _this2.setState({ errorPatientLoad: true });
	      });
	    }
	  }, {
	    key: 'render',
	    value: function render() {
	      var _this3 = this;
	
	      document.title = "Dashboard";
	      if (!this.state.dataLoaded) {
	        return _react2.default.createElement(
	          'div',
	          { className: 'container-fluid' },
	          _react2.default.createElement(
	            'div',
	            { className: 'row' },
	            _react2.default.createElement(
	              'div',
	              { className: 'myBox height75', style: { marginLeft: '30px' } },
	              _react2.default.createElement(
	                'div',
	                { className: 'loading' },
	                _react2.default.createElement(
	                  'div',
	                  null,
	                  _react2.default.createElement('div', { className: 'c1' }),
	                  _react2.default.createElement('div', { className: 'c2' }),
	                  _react2.default.createElement('div', { className: 'c3' }),
	                  _react2.default.createElement('div', { className: 'c4' })
	                ),
	                _react2.default.createElement(
	                  'span',
	                  null,
	                  'Loading patient\'s data..'
	                )
	              )
	            )
	          )
	        );
	      } else if (!this.state.patient_profile_bool) {
	        return _react2.default.createElement(
	          'div',
	          { className: 'container-fluid' },
	          _react2.default.createElement(
	            'div',
	            { className: 'row' },
	            _react2.default.createElement(
	              'div',
	              { className: 'col-6' },
	              _react2.default.createElement(
	                'h3',
	                { style: { marginLeft: '15px' } },
	                'Patients at risk'
	              ),
	              _react2.default.createElement(
	                'div',
	                { className: 'row' },
	                _react2.default.createElement(
	                  'div',
	                  { className: 'col-6 ' },
	                  _react2.default.createElement(
	                    'div',
	                    { className: 'row patient_at_risk_red' },
	                    _react2.default.createElement(
	                      'div',
	                      { className: 'col-6 ' },
	                      _react2.default.createElement(
	                        'p',
	                        { className: 'vertical_center', style: { color: 'white' } },
	                        ' High Risk: '
	                      )
	                    ),
	                    _react2.default.createElement(
	                      'div',
	                      { className: 'col-6 ' },
	                      _react2.default.createElement(
	                        'p',
	                        { className: 'vertical_horizontnal_center', style: { fontSize: '50px', color: 'white', textAlign: 'center' } },
	                        ' ',
	                        this.state.rist_patients.filter(function (patient) {
	                          return patient.health.points > 5;
	                        }).length,
	                        ' '
	                      )
	                    )
	                  )
	                ),
	                _react2.default.createElement(
	                  'div',
	                  { className: 'col-6' },
	                  _react2.default.createElement(
	                    'div',
	                    { className: 'row patient_at_risk_orange' },
	                    _react2.default.createElement(
	                      'div',
	                      { className: 'col-6 ' },
	                      _react2.default.createElement(
	                        'p',
	                        { className: 'vertical_center', style: { color: 'white' } },
	                        ' Average Risk: '
	                      )
	                    ),
	                    _react2.default.createElement(
	                      'div',
	                      { className: 'col-6 ' },
	                      _react2.default.createElement(
	                        'p',
	                        { className: 'vertical_horizontnal_center', style: { fontSize: '50px', color: 'white', textAlign: 'center' } },
	                        ' ',
	                        this.state.rist_patients.filter(function (patient) {
	                          return patient.health.points <= 5;
	                        }).length,
	                        ' '
	                      )
	                    )
	                  )
	                ),
	                _react2.default.createElement(
	                  'div',
	                  { className: 'col-12 full_height_patient_health' },
	                  this.state.rist_patients.map(function (patient, i) {
	                    return _react2.default.createElement(
	                      'div',
	                      { key: i * 100, className: 'row' },
	                      _react2.default.createElement(
	                        'div',
	                        { className: 'col-12 hover_hightlight_patient_dashboard', style: _this3.checkIfSelectedCss(patient), onClick: function onClick(e) {
	                            return _this3.selectPatient(patient);
	                          } },
	                        _react2.default.createElement(
	                          'p',
	                          { style: { marginTop: '10px', fontSize: '17px', fontWeight: 'bold' } },
	                          ' ',
	                          patient.firstname + ' ' + patient.lastname
	                        ),
	                        _react2.default.createElement(
	                          'p',
	                          { style: { marginTop: '-17px' } },
	                          ' Points: ',
	                          patient.health.points
	                        ),
	                        _react2.default.createElement(
	                          'p',
	                          null,
	                          ' Patient status: ',
	                          patient.health.points > 5 ? _react2.default.createElement(
	                            'span',
	                            { style: { color: 'red' } },
	                            'red'
	                          ) : _react2.default.createElement(
	                            'span',
	                            { style: { color: '#ffc459' } },
	                            'orange'
	                          )
	                        ),
	                        _react2.default.createElement(
	                          'p',
	                          { style: { marginTop: '10px', fontSize: '14px', fontWeight: 'bold' } },
	                          ' Patient\'s last entry overview: '
	                        ),
	                        _react2.default.createElement(
	                          'div',
	                          { className: 'row' },
	                          _react2.default.createElement(
	                            'div',
	                            { className: 'col-4' },
	                            _react2.default.createElement(
	                              'div',
	                              { className: 'patient_task_buble_container_doctor' },
	                              _react2.default.createElement(
	                                'div',
	                                { className: ' patient_task_buble_doctor' },
	                                _react2.default.createElement('img', { src: _tasks_temperature2.default, alt: 'logout', className: 'tasks_pill_doctor' }),
	                                _react2.default.createElement(
	                                  'p',
	                                  { className: 'patient_tasks_title_doctor' },
	                                  ' Temperature'
	                                ),
	                                patient.health.temperatures.history[patient.health.temperatures.history.length - 1].temperature !== "" ? _react2.default.createElement(
	                                  'p',
	                                  { style: { textAlign: 'center', fontSize: '14px' } },
	                                  ' ',
	                                  patient.health.temperatures.history[patient.health.temperatures.history.length - 1].temperature,
	                                  ' '
	                                ) : _react2.default.createElement(
	                                  'p',
	                                  { style: { textAlign: 'center', fontSize: '14px' } },
	                                  'No Entry'
	                                )
	                              )
	                            )
	                          ),
	                          _react2.default.createElement(
	                            'div',
	                            { className: 'col-4' },
	                            _react2.default.createElement(
	                              'div',
	                              { className: 'patient_task_buble_container_doctor' },
	                              _react2.default.createElement(
	                                'div',
	                                { className: ' patient_task_buble_doctor' },
	                                _react2.default.createElement('img', { src: _blood_pressure2.default, alt: 'logout', className: 'tasks_pill_doctor' }),
	                                _react2.default.createElement(
	                                  'p',
	                                  { className: 'patient_tasks_title_doctor', style: { marginTop: '-12px' } },
	                                  ' Blood Pressure'
	                                ),
	                                patient.health.blood_pressures.history[patient.health.blood_pressures.history.length - 1].bloodpres_dia !== "" ? _react2.default.createElement(
	                                  'p',
	                                  { style: { textAlign: 'center', fontSize: '14px' } },
	                                  ' ',
	                                  patient.health.blood_pressures.history[patient.health.blood_pressures.history.length - 1].bloodpres_dia,
	                                  '/',
	                                  patient.health.blood_pressures.history[0].bloodpres_sys,
	                                  ' '
	                                ) : _react2.default.createElement(
	                                  'p',
	                                  { style: { textAlign: 'center', fontSize: '14px' } },
	                                  'No Entry'
	                                )
	                              )
	                            )
	                          ),
	                          _react2.default.createElement(
	                            'div',
	                            { className: 'col-4' },
	                            _react2.default.createElement(
	                              'div',
	                              { className: 'patient_task_buble_container_doctor' },
	                              _react2.default.createElement(
	                                'div',
	                                { className: ' patient_task_buble_doctor' },
	                                _react2.default.createElement('img', { src: _heart_rate2.default, alt: 'logout', className: 'tasks_pill_doctor' }),
	                                _react2.default.createElement(
	                                  'p',
	                                  { className: 'patient_tasks_title_doctor' },
	                                  ' Pulse'
	                                ),
	                                patient.health.pulses.history[patient.health.pulses.history.length - 1].pulse !== "" ? _react2.default.createElement(
	                                  'p',
	                                  { style: { textAlign: 'center', fontSize: '14px' } },
	                                  ' ',
	                                  patient.health.pulses.history[patient.health.pulses.history.length - 1].pulse,
	                                  ' '
	                                ) : _react2.default.createElement(
	                                  'p',
	                                  { style: { textAlign: 'center', fontSize: '14px' } },
	                                  'No Entry'
	                                )
	                              )
	                            )
	                          )
	                        )
	                      )
	                    );
	                  })
	                )
	              )
	            ),
	            _react2.default.createElement(
	              'div',
	              { className: 'col-6' },
	              _react2.default.createElement(
	                'h3',
	                null,
	                'Patient\'s health data'
	              ),
	              _react2.default.createElement(_SelectedPatient2.default, { patientSelectedBool: this.state.patientSelectedBool, selectedPatient: this.state.selectedPatient, openProfile: function openProfile(e) {
	                  return _this3.setState({ patient_profile_bool: true });
	                } })
	            )
	          )
	        );
	      } else if (this.state.patient_profile_bool) {
	        return _react2.default.createElement(_PatientProfile2.default, { patientSelectedBool: this.state.patientSelectedBool, selectedPatient: this.state.selectedPatient, goBack: function goBack(e) {
	            return _this3.setState({ patient_profile_bool: false });
	          } });
	      }
	    }
	  }]);
	
	  return Allgemein;
	}(_react2.default.Component);
	
	exports.default = Allgemein;

/***/ },
/* 205 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	
	var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();
	
	var _react = __webpack_require__(2);
	
	var _react2 = _interopRequireDefault(_react);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
	
	function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }
	
	function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }
	
	var PointsOverview = function (_React$PureComponent) {
	  _inherits(PointsOverview, _React$PureComponent);
	
	  function PointsOverview(props) {
	    _classCallCheck(this, PointsOverview);
	
	    var _this = _possibleConstructorReturn(this, (PointsOverview.__proto__ || Object.getPrototypeOf(PointsOverview)).call(this, props));
	
	    _this.has_missed_medication = function (medication) {
	      var bool = false;
	      Object.values(medication).forEach(function (med) {
	        if (med.missed.length > 0) bool = true;
	      });
	
	      Object.values(medication).forEach(function (med) {
	        if (med.history.filter(function (entry) {
	          return !entry.measured;
	        }).length > 0) bool = true;
	      });
	
	      return bool;
	    };
	
	    _this.was_this_med_missed = function (med) {
	      if (med.missed.length > 0) return true;
	      if (med.history.filter(function (entry) {
	        return !entry.measured;
	      }).length > 0) return true;
	
	      return false;
	    };
	
	    _this.get_total_med_missed = function (med) {
	      return med.missed.length + med.history.filter(function (entry) {
	        return !entry.measured;
	      }).length;
	    };
	
	    return _this;
	  }
	
	  _createClass(PointsOverview, [{
	    key: 'render',
	    value: function render() {
	      var _this2 = this;
	
	      return _react2.default.createElement(
	        'span',
	        null,
	        _react2.default.createElement(
	          'p',
	          { style: { marginTop: '10px', fontSize: '15px', fontWeight: 'bold' } },
	          'Points for bad entered health data:'
	        ),
	        _react2.default.createElement(
	          'div',
	          { className: 'container', style: { backgroundColor: '#f7f7f7', paddingTop: '10px', borderRadius: '7px' } },
	          _react2.default.createElement(
	            'div',
	            { className: 'row' },
	            _react2.default.createElement(
	              'div',
	              { className: 'col-12' },
	              this.props.health.first_step_points === 0 ? _react2.default.createElement(
	                'p',
	                { style: { color: 'black', fontStyle: 'italic' } },
	                'no bad health data.'
	              ) : null,
	              this.props.health.detailed_first_step_points.temperature_low > 0 || this.props.health.detailed_first_step_points.temperature_hight > 0 ? _react2.default.createElement(
	                'span',
	                null,
	                _react2.default.createElement(
	                  'p',
	                  { style: { color: 'black' } },
	                  'Temperature'
	                ),
	                this.props.health.detailed_first_step_points.temperature_low > 0 ? _react2.default.createElement(
	                  'p',
	                  { style: { fontSize: '15px', fontStyle: 'italic', marginTop: '-15px', paddingLeft: '20px' } },
	                  ' - ',
	                  this.props.health.detailed_first_step_points.temperature_low,
	                  ' days of low risk temerature ',
	                  _react2.default.createElement(
	                    'span',
	                    { style: { fontSize: '12px' } },
	                    ' (',
	                    this.props.health.detailed_first_step_points.temperature_low,
	                    ' points)'
	                  ),
	                  '. '
	                ) : null,
	                this.props.health.detailed_first_step_points.temperature_high > 0 ? _react2.default.createElement(
	                  'p',
	                  { style: { fontSize: '15px', fontStyle: 'italic', marginTop: '-15px', paddingLeft: '20px' } },
	                  ' - ',
	                  this.props.health.detailed_first_step_points.temperature_high,
	                  ' days of high risk temperature ',
	                  _react2.default.createElement(
	                    'span',
	                    { style: { fontSize: '12px' } },
	                    ' (2x',
	                    this.props.health.detailed_first_step_points.temperature_high,
	                    ' points)'
	                  ),
	                  '. '
	                ) : null
	              ) : null,
	              this.props.health.detailed_first_step_points.pulse_low > 0 || this.props.health.detailed_first_step_points.pulse_high > 0 ? _react2.default.createElement(
	                'span',
	                null,
	                _react2.default.createElement(
	                  'p',
	                  { style: { color: 'black' } },
	                  'Pulse'
	                ),
	                this.props.health.detailed_first_step_points.pulse_low > 0 ? _react2.default.createElement(
	                  'p',
	                  { style: { fontSize: '15px', fontStyle: 'italic', marginTop: '-15px', paddingLeft: '20px' } },
	                  ' - ',
	                  this.props.health.detailed_first_step_points.pulse_low,
	                  ' days of low risk pulse ',
	                  _react2.default.createElement(
	                    'span',
	                    { style: { fontSize: '12px' } },
	                    ' (',
	                    this.props.health.detailed_first_step_points.pulse_low,
	                    ' points)'
	                  ),
	                  '. '
	                ) : null,
	                this.props.health.detailed_first_step_points.pulse_high > 0 ? _react2.default.createElement(
	                  'p',
	                  { style: { fontSize: '15px', fontStyle: 'italic', marginTop: '-15px', paddingLeft: '20px' } },
	                  ' - ',
	                  this.props.health.detailed_first_step_points.pulse_high,
	                  ' days of high risk pulse ',
	                  _react2.default.createElement(
	                    'span',
	                    { style: { fontSize: '12px' } },
	                    ' (2x',
	                    this.props.health.detailed_first_step_points.pulse_high,
	                    ' points)'
	                  ),
	                  '. '
	                ) : null
	              ) : null,
	              this.props.health.detailed_first_step_points.blood_pressure_low > 0 || this.props.health.detailed_first_step_points.blood_pressure_high > 0 ? _react2.default.createElement(
	                'span',
	                null,
	                _react2.default.createElement(
	                  'p',
	                  { style: { color: 'black' } },
	                  'Blood pressure'
	                ),
	                this.props.health.detailed_first_step_points.blood_pressure_low > 0 ? _react2.default.createElement(
	                  'p',
	                  { style: { fontSize: '15px', fontStyle: 'italic', marginTop: '-15px', paddingLeft: '20px' } },
	                  ' - ',
	                  this.props.health.detailed_first_step_points.blood_pressure_low,
	                  ' days of low risk blood pressure ',
	                  _react2.default.createElement(
	                    'span',
	                    { style: { fontSize: '12px' } },
	                    ' (',
	                    this.props.health.detailed_first_step_points.blood_pressure_low,
	                    ' points)'
	                  ),
	                  '. '
	                ) : null,
	                this.props.health.detailed_first_step_points.blood_pressure_high > 0 ? _react2.default.createElement(
	                  'p',
	                  { style: { fontSize: '15px', fontStyle: 'italic', marginTop: '-15px', paddingLeft: '20px' } },
	                  ' - ',
	                  this.props.health.detailed_first_step_points.blood_pressure_high,
	                  ' days of high risk blood pressure ',
	                  _react2.default.createElement(
	                    'span',
	                    { style: { fontSize: '12px' } },
	                    ' (2x',
	                    this.props.health.detailed_first_step_points.blood_pressure_high,
	                    ' points)'
	                  ),
	                  '. '
	                ) : null
	              ) : null,
	              this.props.health.detailed_first_step_points.weight > 0 ? _react2.default.createElement(
	                'span',
	                null,
	                _react2.default.createElement(
	                  'p',
	                  { style: { color: 'black' } },
	                  'Weight'
	                ),
	                this.props.health.detailed_first_step_points.weight > 0 ? _react2.default.createElement(
	                  'p',
	                  { style: { fontSize: '15px', fontStyle: 'italic', marginTop: '-15px', paddingLeft: '20px' } },
	                  ' - Weight change of more than 10% of total weight in the last 90 days ',
	                  _react2.default.createElement(
	                    'span',
	                    { style: { fontSize: '12px' } },
	                    ' (3 points)'
	                  ),
	                  '. '
	                ) : null
	              ) : null
	            )
	          )
	        ),
	        _react2.default.createElement(
	          'p',
	          { style: { color: 'black', fontStyle: 'italic', fontSize: '16px', marginTop: '20px' } },
	          'Intermediate Points: ',
	          this.props.health.first_step_points,
	          ' '
	        ),
	        this.props.health.first_step_points <= 1 ? _react2.default.createElement(
	          'p',
	          { style: { color: 'black', fontStyle: 'italic', fontSize: '16px', marginTop: '-18px' } },
	          'Intermediate Status: ',
	          _react2.default.createElement(
	            'span',
	            { style: { color: 'green' } },
	            'green'
	          ),
	          ' '
	        ) : null,
	        this.props.health.first_step_points === 2 || this.props.health.first_step_points === 3 ? _react2.default.createElement(
	          'p',
	          { style: { color: 'black', fontStyle: 'italic', fontSize: '16px', marginTop: '-18px' } },
	          'Intermediate Status: ',
	          _react2.default.createElement(
	            'span',
	            { style: { color: '#ffc459' } },
	            'orange'
	          ),
	          ' '
	        ) : null,
	        this.props.health.first_step_points > 3 ? _react2.default.createElement(
	          'p',
	          { style: { color: 'black', fontStyle: 'italic', fontSize: '16px', marginTop: '-18px' } },
	          'Intermediate Status: ',
	          _react2.default.createElement(
	            'span',
	            { style: { color: 'red' } },
	            'red'
	          ),
	          ' '
	        ) : null,
	        _react2.default.createElement(
	          'p',
	          { style: { marginTop: '10px', fontSize: '15px', fontWeight: 'bold' } },
	          ' Penalties for not entering Data'
	        ),
	        this.has_missed_medication(this.props.health.medication) ? _react2.default.createElement(
	          'div',
	          { className: 'container', style: { backgroundColor: '#f7f7f7', paddingTop: '10px', borderRadius: '7px' } },
	          _react2.default.createElement(
	            'p',
	            { style: { marginTop: '10px' } },
	            'Missed medication:'
	          ),
	          Object.values(this.props.health.medication).map(function (med) {
	            if (_this2.was_this_med_missed(med)) return _react2.default.createElement(
	              'div',
	              { className: 'row' },
	              _react2.default.createElement(
	                'div',
	                { className: 'col-12' },
	                _react2.default.createElement(
	                  'p',
	                  { style: { fontSize: '15px', color: 'black' } },
	                  ' - ',
	                  med.title,
	                  ' ',
	                  _this2.get_total_med_missed(med),
	                  ' times',
	                  _this2.props.health.first_step_points > 5 ? _react2.default.createElement(
	                    'span',
	                    { style: { color: 'red', fontSize: '12px' } },
	                    ' (3 x ',
	                    _this2.get_total_med_missed(med),
	                    ' points)'
	                  ) : null,
	                  _this2.props.health.first_step_points >= 2 && _this2.props.health.first_step_points <= 5 ? _react2.default.createElement(
	                    'span',
	                    { style: { color: '#ffc459', fontSize: '12px' } },
	                    ' (2 x ',
	                    _this2.get_total_med_missed(med),
	                    ' points)'
	                  ) : null,
	                  _this2.props.health.first_step_points < 2 ? _react2.default.createElement(
	                    'span',
	                    { style: { color: 'green', fontSize: '12px' } },
	                    ' (1 x ',
	                    _this2.get_total_med_missed(med),
	                    ' points)'
	                  ) : null
	                )
	              )
	            );
	          })
	        ) : null,
	        this.props.health.detailed_final_step_points.temperature > 0 || this.props.health.detailed_final_step_points.pulse > 0 || this.props.health.detailed_final_step_points.blood_pressure > 0 || this.props.health.detailed_final_step_points.weight > 0 ? _react2.default.createElement(
	          'div',
	          { className: 'container', style: { backgroundColor: '#f7f7f7', paddingTop: '10px', borderRadius: '7px', marginTop: '15px' } },
	          _react2.default.createElement(
	            'div',
	            { className: 'row' },
	            _react2.default.createElement(
	              'div',
	              { className: 'col-12' },
	              this.props.health.detailed_final_step_points.temperature > 0 ? _react2.default.createElement(
	                'span',
	                null,
	                _react2.default.createElement(
	                  'p',
	                  { style: { color: 'black' } },
	                  'Temperature'
	                ),
	                _react2.default.createElement(
	                  'p',
	                  { style: { fontSize: '15px', fontStyle: 'italic', marginTop: '-15px', paddingLeft: '20px' } },
	                  ' - No entry on ',
	                  this.props.health.detailed_final_step_points.temperature,
	                  ' days',
	                  this.props.health.first_step_points <= 1 ? _react2.default.createElement(
	                    'span',
	                    { style: { color: 'green', fontSize: '12px' } },
	                    ' (1 x ',
	                    this.props.health.detailed_final_step_points.temperature,
	                    ' points)'
	                  ) : null,
	                  this.props.health.first_step_points === 2 || this.props.health.first_step_points === 3 ? _react2.default.createElement(
	                    'span',
	                    { style: { color: '#ffc459', fontSize: '12px' } },
	                    ' (2 x ',
	                    this.props.health.detailed_final_step_points.temperature,
	                    ' points)'
	                  ) : null,
	                  this.props.health.first_step_points > 3 ? _react2.default.createElement(
	                    'span',
	                    { style: { color: 'red', fontSize: '12px' } },
	                    ' (3 x ',
	                    this.props.health.detailed_final_step_points.temperature,
	                    ' points)'
	                  ) : null,
	                  '.'
	                )
	              ) : null,
	              this.props.health.detailed_final_step_points.pulse > 0 ? _react2.default.createElement(
	                'span',
	                null,
	                _react2.default.createElement(
	                  'p',
	                  { style: { color: 'black' } },
	                  'Pulse'
	                ),
	                _react2.default.createElement(
	                  'p',
	                  { style: { fontSize: '15px', fontStyle: 'italic', marginTop: '-15px', paddingLeft: '20px' } },
	                  ' - No entry on ',
	                  this.props.health.detailed_final_step_points.pulse,
	                  ' days',
	                  this.props.health.first_step_points <= 1 ? _react2.default.createElement(
	                    'span',
	                    { style: { color: 'green', fontSize: '12px' } },
	                    ' (1 x ',
	                    this.props.health.detailed_final_step_points.pulse,
	                    ' points)'
	                  ) : null,
	                  this.props.health.first_step_points === 2 || this.props.health.first_step_points === 3 ? _react2.default.createElement(
	                    'span',
	                    { style: { color: '#ffc459', fontSize: '12px' } },
	                    ' (2 x ',
	                    this.props.health.detailed_final_step_points.pulse,
	                    ' points)'
	                  ) : null,
	                  this.props.health.first_step_points > 3 ? _react2.default.createElement(
	                    'span',
	                    { style: { color: 'red', fontSize: '12px' } },
	                    ' (3 x ',
	                    this.props.health.detailed_final_step_points.pulse,
	                    ' points)'
	                  ) : null,
	                  '.'
	                )
	              ) : null,
	              this.props.health.detailed_final_step_points.blood_pressure > 0 ? _react2.default.createElement(
	                'span',
	                null,
	                _react2.default.createElement(
	                  'p',
	                  { style: { color: 'black' } },
	                  'Blood Pressure'
	                ),
	                _react2.default.createElement(
	                  'p',
	                  { style: { fontSize: '15px', fontStyle: 'italic', marginTop: '-15px', paddingLeft: '20px' } },
	                  ' - No entry on ',
	                  this.props.health.detailed_final_step_points.blood_pressure,
	                  ' days',
	                  this.props.health.first_step_points <= 1 ? _react2.default.createElement(
	                    'span',
	                    { style: { color: 'green', fontSize: '12px' } },
	                    ' (1 x ',
	                    this.props.health.detailed_final_step_points.blood_pressure,
	                    ' points)'
	                  ) : null,
	                  this.props.health.first_step_points === 2 || this.props.health.first_step_points === 3 ? _react2.default.createElement(
	                    'span',
	                    { style: { color: '#ffc459', fontSize: '12px' } },
	                    ' (2 x ',
	                    this.props.health.detailed_final_step_points.blood_pressure,
	                    ' points)'
	                  ) : null,
	                  this.props.health.first_step_points > 3 ? _react2.default.createElement(
	                    'span',
	                    { style: { color: 'red', fontSize: '12px' } },
	                    ' (3 x ',
	                    this.props.health.detailed_final_step_points.blood_pressure,
	                    ' points)'
	                  ) : null,
	                  '.'
	                )
	              ) : null,
	              this.props.health.detailed_final_step_points.weight > 0 ? _react2.default.createElement(
	                'span',
	                null,
	                _react2.default.createElement(
	                  'p',
	                  { style: { color: 'black' } },
	                  'Weight'
	                ),
	                _react2.default.createElement(
	                  'p',
	                  { style: { fontSize: '15px', fontStyle: 'italic', marginTop: '-15px', paddingLeft: '20px' } },
	                  ' - No entry on ',
	                  this.props.health.detailed_final_step_points.weight,
	                  ' days',
	                  this.props.health.first_step_points <= 1 ? _react2.default.createElement(
	                    'span',
	                    { style: { color: 'green', fontSize: '12px' } },
	                    ' (1 x ',
	                    this.props.health.detailed_final_step_points.weight,
	                    ' points)'
	                  ) : null,
	                  this.props.health.first_step_points === 2 || this.props.health.first_step_points === 3 ? _react2.default.createElement(
	                    'span',
	                    { style: { color: '#ffc459', fontSize: '12px' } },
	                    ' (2 x ',
	                    this.props.health.detailed_final_step_points.weight,
	                    ' points)'
	                  ) : null,
	                  this.props.health.first_step_points > 3 ? _react2.default.createElement(
	                    'span',
	                    { style: { color: 'red', fontSize: '12px' } },
	                    ' (3 x ',
	                    this.props.health.detailed_final_step_points.weight,
	                    ' points)'
	                  ) : null,
	                  '.'
	                )
	              ) : null
	            )
	          )
	        ) : null,
	        this.props.health.first_step_points === this.props.health.points ? _react2.default.createElement(
	          'div',
	          { className: 'container', style: { backgroundColor: '#f7f7f7', paddingTop: '10px', borderRadius: '7px', marginTop: '15px' } },
	          _react2.default.createElement(
	            'div',
	            { className: 'row' },
	            _react2.default.createElement(
	              'div',
	              { className: 'col-12' },
	              _react2.default.createElement(
	                'p',
	                { style: { color: 'black', fontStyle: 'italic' } },
	                'no penalties.'
	              )
	            )
	          )
	        ) : null,
	        _react2.default.createElement(
	          'p',
	          { style: { color: 'black', fontStyle: 'italic', fontSize: '16px', marginTop: '20px' } },
	          'Final Points: ',
	          this.props.health.points,
	          ' '
	        ),
	        this.props.health.points <= 2 ? _react2.default.createElement(
	          'p',
	          { style: { color: 'black', fontStyle: 'italic', fontSize: '16px', marginTop: '-18px' } },
	          'Final Status: ',
	          _react2.default.createElement(
	            'span',
	            { style: { color: 'green' } },
	            'green'
	          ),
	          ' '
	        ) : null,
	        this.props.health.points === 3 || this.props.health.points === 4 || this.props.health.points === 5 ? _react2.default.createElement(
	          'p',
	          { style: { color: 'black', fontStyle: 'italic', fontSize: '16px', marginTop: '-18px' } },
	          'Final Status: ',
	          _react2.default.createElement(
	            'span',
	            { style: { color: '#ffc459' } },
	            'orange'
	          ),
	          ' '
	        ) : null,
	        this.props.health.points > 5 ? _react2.default.createElement(
	          'p',
	          { style: { color: 'black', fontStyle: 'italic', fontSize: '16px', marginTop: '-18px' } },
	          'Final Status: ',
	          _react2.default.createElement(
	            'span',
	            { style: { color: 'red' } },
	            'red'
	          ),
	          ' '
	        ) : null
	      );
	    }
	  }]);
	
	  return PointsOverview;
	}(_react2.default.PureComponent);
	
	exports.default = PointsOverview;

/***/ },
/* 206 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	
	var _PointsOverview = __webpack_require__(205);
	
	Object.defineProperty(exports, 'default', {
	  enumerable: true,
	  get: function get() {
	    return _interopRequireDefault(_PointsOverview).default;
	  }
	});

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/***/ },
/* 207 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	
	var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();
	
	var _react = __webpack_require__(2);
	
	var _react2 = _interopRequireDefault(_react);
	
	var _PointsOverview = __webpack_require__(206);
	
	var _PointsOverview2 = _interopRequireDefault(_PointsOverview);
	
	var _Temperature = __webpack_require__(124);
	
	var _Temperature2 = _interopRequireDefault(_Temperature);
	
	var _BloodPressure = __webpack_require__(122);
	
	var _BloodPressure2 = _interopRequireDefault(_BloodPressure);
	
	var _Weight = __webpack_require__(125);
	
	var _Weight2 = _interopRequireDefault(_Weight);
	
	var _Pulse = __webpack_require__(123);
	
	var _Pulse2 = _interopRequireDefault(_Pulse);
	
	var _User_icon_BLACK = __webpack_require__(173);
	
	var _User_icon_BLACK2 = _interopRequireDefault(_User_icon_BLACK);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
	
	function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }
	
	function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }
	
	var SelectedPatient = function (_React$PureComponent) {
	  _inherits(SelectedPatient, _React$PureComponent);
	
	  function SelectedPatient(props) {
	    _classCallCheck(this, SelectedPatient);
	
	    var _this = _possibleConstructorReturn(this, (SelectedPatient.__proto__ || Object.getPrototypeOf(SelectedPatient)).call(this, props));
	
	    _this.has_missed_medication = function (medication) {
	      var bool = false;
	      Object.values(medication).forEach(function (med) {
	        if (med.missed.length.length > 0) bool = true;
	      });
	
	      Object.values(medication).forEach(function (med) {
	        if (med.history.filter(function (entry) {
	          return !entry.measured;
	        }).length > 0) bool = true;
	      });
	
	      return bool;
	    };
	
	    _this.was_this_med_missed = function (med) {
	      if (med.missed.length.length > 0) return true;
	      if (med.history.filter(function (entry) {
	        return !entry.measured;
	      }).length > 0) return true;
	
	      return false;
	    };
	
	    _this.state = {
	      error: false,
	      isLoaded: false
	    };
	    return _this;
	  }
	
	  _createClass(SelectedPatient, [{
	    key: 'componentDidUpdate',
	    value: function componentDidUpdate(prevProps, prevState) {
	      window.scrollTo({ top: 0 });
	    }
	  }, {
	    key: 'render',
	    value: function render() {
	      var _this2 = this;
	
	      document.title = "Homecare App";
	
	      if (!this.props.patientSelectedBool) {
	        return _react2.default.createElement(
	          'div',
	          { className: 'col-12 full_height_patient_health_show' },
	          _react2.default.createElement(
	            'p',
	            { className: 'vertical_horizontnal_center', style: { fontSize: '20px', textAlign: 'center', color: 'gray' } },
	            ' Select patient to see Data '
	          )
	        );
	      } else {
	        return _react2.default.createElement(
	          'div',
	          { className: 'col-12 full_height_patient_health_show' },
	          _react2.default.createElement('img', { src: _User_icon_BLACK2.default, alt: 'logout', className: 'user_cion_next_to_name' }),
	          _react2.default.createElement(
	            'p',
	            { style: { paddingTop: '10px', fontSize: '19px', fontWeight: 'bold', display: 'inline-block', marginTop: '5px' } },
	            this.props.selectedPatient.firstname + ' ' + this.props.selectedPatient.lastname,
	            ' ',
	            _react2.default.createElement(
	              'span',
	              { style: { cursor: 'pointer', color: 'gray', fontSize: '14px', fontWeight: '100' }, onClick: function onClick() {
	                  return _this2.props.openProfile();
	                } },
	              '(view all data \u27F6)'
	            )
	          ),
	          _react2.default.createElement(
	            'p',
	            { style: { marginTop: '50px', fontSize: '20px', textAlign: 'center', color: 'rgb(74 122 173)', fontWeight: 'bold' } },
	            ' Points overview '
	          ),
	          _react2.default.createElement(_PointsOverview2.default, { health: this.props.selectedPatient.health }),
	          _react2.default.createElement(
	            'p',
	            { style: { marginTop: '30px', fontSize: '20px', textAlign: 'center', color: 'rgb(74 122 173)', fontWeight: 'bold' } },
	            ' Health Data overview '
	          ),
	          _react2.default.createElement(_Temperature2.default, { temperatures: this.props.selectedPatient.health.temperatures }),
	          _react2.default.createElement(_BloodPressure2.default, { blood_pressures: this.props.selectedPatient.health.blood_pressures }),
	          _react2.default.createElement(_Pulse2.default, { pulses: this.props.selectedPatient.health.pulses }),
	          _react2.default.createElement(_Weight2.default, { weights: this.props.selectedPatient.health.weights })
	        );
	      }
	    }
	  }]);
	
	  return SelectedPatient;
	}(_react2.default.PureComponent);
	
	exports.default = SelectedPatient;

/***/ },
/* 208 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	
	var _SelectedPatient = __webpack_require__(207);
	
	Object.defineProperty(exports, 'default', {
	  enumerable: true,
	  get: function get() {
	    return _interopRequireDefault(_SelectedPatient).default;
	  }
	});

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/***/ },
/* 209 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	
	var _Allgemein = __webpack_require__(204);
	
	Object.defineProperty(exports, 'default', {
	  enumerable: true,
	  get: function get() {
	    return _interopRequireDefault(_Allgemein).default;
	  }
	});

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/***/ },
/* 210 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	
	var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();
	
	var _react = __webpack_require__(2);
	
	var _react2 = _interopRequireDefault(_react);
	
	var _reactTabs = __webpack_require__(74);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
	
	function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }
	
	function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }
	
	var Chat = function (_React$Component) {
	  _inherits(Chat, _React$Component);
	
	  function Chat(props) {
	    _classCallCheck(this, Chat);
	
	    var _this = _possibleConstructorReturn(this, (Chat.__proto__ || Object.getPrototypeOf(Chat)).call(this, props));
	
	    _this.state = {};
	    return _this;
	  }
	
	  _createClass(Chat, [{
	    key: 'componentDidMount',
	    value: function componentDidMount() {}
	  }, {
	    key: 'render',
	    value: function render() {
	      document.title = "Chat";
	      return _react2.default.createElement(
	        'div',
	        { className: 'container-fluid' },
	        _react2.default.createElement(
	          'div',
	          { className: 'row' },
	          _react2.default.createElement(
	            'div',
	            { className: 'col-6' },
	            _react2.default.createElement(
	              'h3',
	              { style: { marginLeft: '15px' } },
	              'Chat'
	            )
	          )
	        )
	      );
	    }
	  }]);
	
	  return Chat;
	}(_react2.default.Component);
	
	exports.default = Chat;

/***/ },
/* 211 */
[477, 210],
/* 212 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	
	var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();
	
	var _react = __webpack_require__(2);
	
	var _react2 = _interopRequireDefault(_react);
	
	var _tinymceReact = __webpack_require__(120);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
	
	function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }
	
	function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }
	
	var Edit = function (_React$Component) {
	  _inherits(Edit, _React$Component);
	
	  function Edit(props) {
	    _classCallCheck(this, Edit);
	
	    var _this = _possibleConstructorReturn(this, (Edit.__proto__ || Object.getPrototypeOf(Edit)).call(this, props));
	
	    _this.state = {
	      step: 1,
	
	      firstname: _this.props.patientClicked.firstname,
	      lastname: _this.props.patientClicked.lastname,
	      email: _this.props.patientClicked.email,
	      birthday: _this.props.patientClicked.birthdate,
	      username: _this.props.patientClicked.username,
	      password: '',
	
	      transplants: [],
	      medicaments: _this.props.patientClicked.medication.medication,
	
	      selectedTransplant: '',
	      selectedTransplantID: '',
	      selectedTransplantUID: ''
	
	    };
	
	    _this.handleFirstNameChange = _this.handleFirstNameChange.bind(_this);
	    _this.handleLastNameChange = _this.handleLastNameChange.bind(_this);
	    _this.handleEmailChange = _this.handleEmailChange.bind(_this);
	    _this.handleBirthdayChange = _this.handleBirthdayChange.bind(_this);
	    _this.handleUsernameChange = _this.handleUsernameChange.bind(_this);
	    _this.handlePasswordChange = _this.handlePasswordChange.bind(_this);
	    _this.handleDisplayChange = _this.handleDisplayChange.bind(_this);
	    _this.handleCheckbox = _this.handleCheckbox.bind(_this);
	    _this.registerPatient = _this.registerPatient.bind(_this);
	    _this.checkboxClassname = _this.checkboxClassname.bind(_this);
	    _this.weiter = _this.weiter.bind(_this);
	    _this.zuruck = _this.zuruck.bind(_this);
	    _this.handleAdviceChange = _this.handleAdviceChange.bind(_this);
	    _this.handleMedicineAmmount = _this.handleMedicineAmmount.bind(_this);
	    _this.handleMedicineDuration = _this.handleMedicineDuration.bind(_this);
	
	    return _this;
	  }
	
	  _createClass(Edit, [{
	    key: 'componentDidMount',
	    value: function componentDidMount() {
	      var _this2 = this;
	
	      window.scrollTo(0, 0);
	      fetch('/extern/api/alltransplants/').then(function (blob) {
	        return blob.json();
	      }).then(function (blob) {
	        _this2.setState({
	          guidelineLoaded: true,
	          transplants: blob.data
	        });
	      },
	      // Note: it's important to handle errors here
	      // instead of a catch() block so that we don't swallow
	      // exceptions from actual bugs in components.
	      function (error) {
	        _this2.setState({
	          guidelineLoaded: false,
	          error: error
	        });
	      });
	    }
	  }, {
	    key: 'handleFirstNameChange',
	    value: function handleFirstNameChange(e) {
	      this.setState({ firstname: e.target.value });
	    }
	  }, {
	    key: 'handleUsernameChange',
	    value: function handleUsernameChange(e) {
	      this.setState({ username: e.target.value });
	    }
	  }, {
	    key: 'handlePasswordChange',
	    value: function handlePasswordChange(e) {
	      this.setState({ password: e.target.value });
	    }
	  }, {
	    key: 'handleBirthdayChange',
	    value: function handleBirthdayChange(e) {
	      this.setState({ birthday: e.target.value });
	    }
	  }, {
	    key: 'handleLastNameChange',
	    value: function handleLastNameChange(e) {
	      this.setState({ lastname: e.target.value });
	    }
	  }, {
	    key: 'handleEmailChange',
	    value: function handleEmailChange(e) {
	      this.setState({ email: e.target.value });
	    }
	  }, {
	    key: 'handleAdviceChange',
	    value: function handleAdviceChange(e, c) {
	      this.setState({ advice: e });
	    }
	  }, {
	    key: 'handleDisplayChange',
	    value: function handleDisplayChange(e) {
	      this.setState({ display: e.target.value });
	    }
	  }, {
	    key: 'handleInvitationTextChange',
	    value: function handleInvitationTextChange(content, editor) {
	      this.setState({ invitationText: content });
	    }
	  }, {
	    key: 'handleClosedTextChange',
	    value: function handleClosedTextChange(content, editor) {
	      this.setState({ closedText: content });
	    }
	  }, {
	    key: 'handleCheckbox',
	    value: function handleCheckbox(item) {
	      console.log(item);
	      var bool = this.state.medicaments.some(function (chapter) {
	        return chapter.title === item.title;
	      });
	      if (bool) {
	        var medicaments = this.state.medicaments;
	        var index = medicaments.findIndex(function (x) {
	          return x.title === item.title;
	        });
	        if (index !== -1 && index !== undefined) medicaments.splice(index, 1);
	        this.setState({ medicaments: medicaments });
	        // this.props.handleSelectedChapters(selectedChapters)
	      } else {
	        var _medicaments = this.state.medicaments;
	        item.ammount = 0;
	        item.duration = 0;
	        item.history = [];
	        _medicaments.push(item);
	        this.setState({ medicaments: _medicaments });
	        // this.props.handleSelectedChapters(selectedChapters)
	      }
	    }
	  }, {
	    key: 'handleOptionChange',
	    value: function handleOptionChange(title, id) {
	      this.setState({
	        selectedTransplant: title,
	        selectedTransplantID: id
	      });
	    }
	  }, {
	    key: 'weiter',
	    value: function weiter() {
	      if (this.state.selectedTransplant === '') {
	        return;
	      }
	
	      var newStep = this.state.step + 1;
	      this.setState({ step: newStep });
	    }
	  }, {
	    key: 'zuruck',
	    value: function zuruck() {
	      var newStep = this.state.step - 1;
	      this.setState({ step: newStep });
	    }
	  }, {
	    key: 'registerPatient',
	    value: function registerPatient() {
	      var _this3 = this;
	
	      fetch('/api/doctor/addPatient', {
	        method: 'post',
	        headers: { 'Content-Type': 'application/json' },
	        body: JSON.stringify({ firstname: this.state.firstname, lastname: this.state.lastname, birthdate: this.state.birthday, email: this.state.email, username: this.state.username, password: this.state.password, medication: this.state.medicaments
	        })
	      }).then(function (res) {
	        return console.log('response ', res.json());
	      }).then(function (res) {
	        return _this3.props.closesignup();
	      });
	    }
	  }, {
	    key: 'checkboxClassname',
	    value: function checkboxClassname(item) {
	      if (this.state.medicaments.some(function (medicament) {
	        return medicament.title === item.title;
	      })) return "radioholder activeradioholder";else return "radioholder";
	    }
	  }, {
	    key: 'handleMedicineAmmount',
	    value: function handleMedicineAmmount(e, item) {
	      if (isNaN(e.target.value)) return;
	      var medicaments = this.state.medicaments;
	      medicaments.forEach(function (medicament) {
	        if (medicament.title === item.title) {
	          medicament.ammount = Number(e.target.value);
	        }
	      });
	      this.setState({ medicaments: medicaments });
	    }
	  }, {
	    key: 'handleMedicineDuration',
	    value: function handleMedicineDuration(e, item) {
	      if (isNaN(e.target.value)) return;
	      var medicaments = this.state.medicaments;
	      medicaments.forEach(function (medicament) {
	        if (medicament.title === item.title) {
	          medicament.duration = Number(e.target.value);
	        }
	      });
	      this.setState({ medicaments: medicaments });
	    }
	  }, {
	    key: 'render',
	    value: function render() {
	      var _this4 = this;
	
	      var allmedicaments = [{ title: 'Azathioprine' }, { title: 'Ciclosporin' }, { title: 'Mycophenolate mofetil' }, { title: 'Cyclophosphamide' }, { title: 'Azathioprine tablets' }, { title: 'Prednisone tablets' }, { title: 'Mycophenolate capsule' }, { title: 'Methotrexate' }, { title: 'Methotrexate injection' }, { title: 'Tacrolimus' }, { title: 'Cyclosporine' }, { title: 'Mycophenolate Mofetil' }, { title: 'Imuran' }, { title: 'Rapamune' }, { title: 'Cyclosporine' }, { title: 'Tacrolimus' }, { title: 'Prednisolone' }, { title: 'Budesonide' }, { title: 'Everolimus' }, { title: 'Sirolimus' }, { title: 'Adalimumab' }, { title: 'Anakinra' }, { title: 'Certolizumab' }, { title: 'Etanercept' }, { title: 'Golimumab' }, { title: 'Ixekizumab' }, { title: 'Natalizumab' }, { title: 'Rituximab' }, { title: 'Secukinumab' }, { title: 'Tocilizumab' }, { title: 'Ustekinumab' }, { title: 'Vedolizumab' }, { title: 'Basiliximab' }];
	
	      return _react2.default.createElement(
	        'div',
	        { className: 'row', style: { marginLeft: '0' } },
	        _react2.default.createElement(
	          'div',
	          { className: 'col-12' },
	          _react2.default.createElement(
	            'h3',
	            null,
	            'Personal information'
	          )
	        ),
	        _react2.default.createElement(
	          'div',
	          { className: 'col-12' },
	          _react2.default.createElement(
	            'div',
	            { className: 'row', style: { backgroundColor: '#ffffffd1', borderRadius: '15px' } },
	            _react2.default.createElement(
	              'div',
	              { className: 'col-6' },
	              _react2.default.createElement(
	                'h4',
	                { style: { paddingTop: '30px', fontSize: '20px', fontWeight: '400' } },
	                'Firstname:'
	              ),
	              _react2.default.createElement('input', { className: 'userinput', type: 'text', placeholder: 'Firstname', name: 'firstname', value: this.state.firstname, onChange: this.handleFirstNameChange, style: { width: '100%' } })
	            ),
	            _react2.default.createElement(
	              'div',
	              { className: 'col-6' },
	              _react2.default.createElement(
	                'h4',
	                { style: { paddingTop: '30px', fontSize: '20px', fontWeight: '400' } },
	                'Lastname:'
	              ),
	              _react2.default.createElement('input', { className: 'userinput', type: 'text', placeholder: 'Lastname', name: 'lastname', value: this.state.lastname, onChange: this.handleLastNameChange, style: { width: '100%' } })
	            ),
	            _react2.default.createElement(
	              'div',
	              { className: 'col-6', style: { paddingTop: '30px', paddingBottom: '30px' } },
	              _react2.default.createElement(
	                'h4',
	                { style: { fontSize: '20px', fontWeight: '400' } },
	                'Bithday:'
	              ),
	              _react2.default.createElement('input', { className: 'userinput', type: 'text', placeholder: 'Birthdate', name: 'birthday', value: this.state.birthday, onChange: this.handleBirthdayChange, style: { width: '100%' } })
	            ),
	            _react2.default.createElement(
	              'div',
	              { className: 'col-6', style: { paddingTop: '30px', paddingBottom: '30px' } },
	              _react2.default.createElement(
	                'h4',
	                { style: { fontSize: '20px', fontWeight: '400' } },
	                'Email:'
	              ),
	              _react2.default.createElement('input', { className: 'userinput', type: 'text', placeholder: 'Email', name: 'firstname', value: this.state.email, onChange: this.handleEmailChange, style: { width: '100%' } })
	            )
	          )
	        ),
	        _react2.default.createElement(
	          'div',
	          { className: 'col-12', style: { paddingTop: '20px' } },
	          _react2.default.createElement(
	            'h3',
	            null,
	            'Account information'
	          )
	        ),
	        _react2.default.createElement(
	          'div',
	          { className: 'col-12' },
	          _react2.default.createElement(
	            'div',
	            { className: 'row', style: { backgroundColor: '#ffffffd1', borderRadius: '15px' } },
	            _react2.default.createElement(
	              'div',
	              { className: 'col-6', style: { paddingTop: '30px', paddingBottom: '30px' } },
	              _react2.default.createElement(
	                'h4',
	                { style: { fontSize: '20px', fontWeight: '400' } },
	                'Username:'
	              ),
	              _react2.default.createElement('input', { className: 'userinput', type: 'text', placeholder: 'Username', name: 'username', value: this.state.username, onChange: this.handleUsernameChange, style: { width: '100%' } })
	            )
	          )
	        ),
	        _react2.default.createElement(
	          'div',
	          { className: 'col-12', style: { paddingTop: '20px', paddingBottom: '20px' } },
	          _react2.default.createElement(
	            'h3',
	            null,
	            'Medication'
	          )
	        ),
	        _react2.default.createElement(
	          'div',
	          { className: 'col-12' },
	          _react2.default.createElement(
	            'div',
	            { className: 'row' },
	            _react2.default.createElement(
	              'div',
	              { className: 'row' },
	              _react2.default.createElement(
	                'div',
	                { className: 'col-12' },
	                _react2.default.createElement(
	                  'div',
	                  { id: 'checks', className: 'myBox', style: { height: '55vh', overflow: 'scroll' } },
	                  allmedicaments.map(function (item, i) {
	                    return _react2.default.createElement(
	                      'span',
	                      { key: i, style: { display: 'block', paddingBottom: '20px' } },
	                      _react2.default.createElement(
	                        'div',
	                        { className: _this4.checkboxClassname(item), onClick: function onClick(e) {
	                            return _this4.handleCheckbox(item);
	                          } },
	                        _react2.default.createElement('span', { className: 'tick' }),
	                        _react2.default.createElement('input', { type: 'radio', uid: item.uid, title: item.title, value: item.title,
	                          checked: _this4.state.medicaments.some(function (medicament) {
	                            return medicament.title === item.title;
	                          }), style: { display: 'none' } }),
	                        ' ' + item.title
	                      ),
	                      _this4.state.medicaments.some(function (medicament) {
	                        return medicament.title === item.title;
	                      }) ? _react2.default.createElement(
	                        'span',
	                        { style: { fontSize: '18px', paddingLeft: '60px' } },
	                        _react2.default.createElement(
	                          'p',
	                          { style: { display: 'inline' } },
	                          'Take '
	                        ),
	                        _react2.default.createElement('input', { className: 'medicationinput', type: 'text', value: _this4.state.medicaments.filter(function (medicament) {
	                            return medicament.title === item.title;
	                          })[0].ammount, onChange: function onChange(e) {
	                            return _this4.handleMedicineAmmount(e, item);
	                          } }),
	                        _react2.default.createElement(
	                          'p',
	                          { style: { display: 'inline' } },
	                          ' every '
	                        ),
	                        _react2.default.createElement('input', { className: 'medicationinput', type: 'text', value: _this4.state.medicaments.filter(function (medicament) {
	                            return medicament.title === item.title;
	                          })[0].duration, onChange: function onChange(e) {
	                            return _this4.handleMedicineDuration(e, item);
	                          } }),
	                        '  ',
	                        _react2.default.createElement(
	                          'p',
	                          { style: { display: 'inline' } },
	                          ' days '
	                        )
	                      ) : null
	                    );
	                  }),
	                  _react2.default.createElement('br', null)
	                )
	              )
	            ),
	            _react2.default.createElement(
	              'div',
	              { className: 'row', style: { marginTop: '20px' } },
	              _react2.default.createElement(
	                'div',
	                { className: 'col-12 margin_top', style: { textAlign: 'center' } },
	                _react2.default.createElement(
	                  'button',
	                  { className: 'importbutton_dkg', style: { border: '2px solid', marginRight: '10px', padding: '3px 12px', borderRadius: '15px', marginTop: '5px', float: 'left', cursor: 'pointer' }, onClick: function onClick(e) {
	                      return _this4.props.zuruck();
	                    } },
	                  'back'
	                ),
	                _react2.default.createElement(
	                  'button',
	                  { type: 'submit', className: 'signupbtn margin_right button_dkg', style: { fontSize: '20px' },
	                    onClick: function onClick(e) {
	                      return _this4.registerPatient();
	                    } },
	                  'Save Patient Data'
	                )
	              )
	            )
	          )
	        )
	      );
	    }
	  }]);
	
	  return Edit;
	}(_react2.default.Component);
	
	exports.default = Edit;

/***/ },
/* 213 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	
	var _Edit = __webpack_require__(212);
	
	Object.defineProperty(exports, 'default', {
	  enumerable: true,
	  get: function get() {
	    return _interopRequireDefault(_Edit).default;
	  }
	});

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/***/ },
/* 214 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	    value: true
	});
	
	var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();
	
	var _reactDom = __webpack_require__(58);
	
	var _reactDom2 = _interopRequireDefault(_reactDom);
	
	var _react = __webpack_require__(2);
	
	var _react2 = _interopRequireDefault(_react);
	
	var _echarts = __webpack_require__(6);
	
	var _echarts2 = _interopRequireDefault(_echarts);
	
	__webpack_require__(35);
	
	__webpack_require__(19);
	
	__webpack_require__(15);
	
	__webpack_require__(14);
	
	__webpack_require__(23);
	
	var _jquery = __webpack_require__(16);
	
	var _jquery2 = _interopRequireDefault(_jquery);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
	
	function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }
	
	function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }
	
	// import ECharts
	
	//Aufruf von $ Zeichen 
	
	
	var BoodPressure = function (_Component) {
	    _inherits(BoodPressure, _Component);
	
	    function BoodPressure() {
	        var _ref;
	
	        var _temp, _this, _ret;
	
	        _classCallCheck(this, BoodPressure);
	
	        for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
	            args[_key] = arguments[_key];
	        }
	
	        return _ret = (_temp = (_this = _possibleConstructorReturn(this, (_ref = BoodPressure.__proto__ || Object.getPrototypeOf(BoodPressure)).call.apply(_ref, [this].concat(args))), _this), _this.create_graph = function () {
	            var history = _this.props.blood_pressures;
	            var jsonData = { blood_pressure: history
	                //  currentDate
	            };var currentDate = new Date();
	            // old7Datetimestample
	            var days7before = currentDate.setDate(currentDate.getDate() - 7); //  最终获得的 old7Date 是时间戳 
	            //console.log(days7before)    
	
	            var truejsonData = jsonData.blood_pressure.filter(function (obj) {
	                return obj.timestamp > days7before;
	            });
	            console.log(truejsonData);
	
	            function timeformater(ts) {
	                var date = new Date(ts);
	                var Y = date.getFullYear() + '-';
	                var M = (date.getMonth() + 1 < 10 ? '0' + (date.getMonth() + 1) : date.getMonth() + 1) + '-';
	                var D = date.getDate() + ' ';
	                var result = Y + M + D;
	                return result;
	            }
	
	            var timelist = [null, null, null, null, null, null, null];
	            timelist.forEach(function (item, index, timelist) {
	                var currentDate = new Date();
	                var data = currentDate.setDate(currentDate.getDate() - index);
	                timelist[index] = timeformater(data);
	            });
	            timelist = timelist.reverse();
	
	            var templist1 = [null, null, null, null, null, null, null];
	            var templist2 = [null, null, null, null, null, null, null];
	
	            truejsonData.forEach(function (item, index, arr) {
	                //db中近7天的array 可能只有3天
	                var i = timelist.indexOf(timeformater(item.timestamp)); //richtige x axis daten value index
	                if (i > -1) {
	                    //wenn an dem Tag etwas in DB erschienen 
	                    if (item.measured !== false) {
	                        templist1[i] = item.bloodpres_dia;
	                        templist2[i] = item.bloodpres_sys;
	                    } // wenn measured nicht false dann ersetzt die richtige weight dadrauf
	                }
	            });
	
	            var option = {
	                tooltip: {
	                    trigger: 'axis'
	                    // position: function (pt) {
	                    //     return [pt[0], '10%'];
	                    // },
	                },
	                xAxis: [{
	                    data: timelist,
	                    gridIndex: 0,
	                    axisTick: { show: false },
	                    axisLabel: { show: false }
	                }, {
	                    data: timelist,
	                    gridIndex: 1,
	                    axisLine: { show: false },
	                    axisLabel: { show: false },
	                    splitLine: { show: false },
	                    axisTick: { show: false }
	                }],
	                yAxis: [{
	                    axisLine: { show: false },
	                    axisLabel: { show: false },
	                    splitLine: { show: false },
	                    axisTick: { show: false },
	                    type: 'value',
	                    gridIndex: 0,
	                    min: function min(extent) {
	                        return extent.min < 100 ? extent.min : 100;
	                    }
	                }, {
	                    axisLine: { show: false },
	                    axisLabel: { show: false },
	                    splitLine: { show: false },
	                    axisTick: { show: false },
	                    type: 'value',
	                    gridIndex: 1,
	                    min: function min(extent) {
	                        return extent.min < 70 ? extent.min : 70;
	                    }
	                }],
	                grid: [{
	                    bottom: '60%'
	                }, {
	                    top: '60%'
	                }],
	                series: [{
	                    connectNulls: true,
	                    type: 'line',
	                    name: "sys",
	                    data: templist1,
	                    xAxisIndex: 0,
	                    yAxisIndex: 0
	                }, {
	                    connectNulls: true,
	                    type: 'line',
	                    name: "dia",
	                    data: templist2,
	                    xAxisIndex: 1,
	                    yAxisIndex: 1
	                }]
	            };
	
	            var myChart = _echarts2.default.init(document.getElementById("blood_pressure" + _this.props.id));
	            myChart.setOption(option);
	            //fuer bootstrap layout
	            (0, _jquery2.default)(window).on('resize', function () {
	                if (myChart !== null && myChart !== undefined) {
	                    myChart.resize();
	                }
	            });
	        }, _temp), _possibleConstructorReturn(_this, _ret);
	    }
	
	    _createClass(BoodPressure, [{
	        key: 'componentDidMount',
	        value: function componentDidMount() {
	            this.create_graph();
	        }
	    }, {
	        key: 'render',
	        value: function render() {
	            return _react2.default.createElement('div', { id: "blood_pressure" + this.props.id, style: { width: '100%', minHeight: '200px' } });
	        }
	    }]);
	
	    return BoodPressure;
	}(_react.Component);
	
	exports.default = BoodPressure;

/***/ },
/* 215 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	
	var _BoodPressure = __webpack_require__(214);
	
	Object.defineProperty(exports, 'default', {
	  enumerable: true,
	  get: function get() {
	    return _interopRequireDefault(_BoodPressure).default;
	  }
	});

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/***/ },
/* 216 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	    value: true
	});
	
	var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();
	
	var _reactDom = __webpack_require__(58);
	
	var _reactDom2 = _interopRequireDefault(_reactDom);
	
	var _react = __webpack_require__(2);
	
	var _react2 = _interopRequireDefault(_react);
	
	var _echarts = __webpack_require__(6);
	
	var _echarts2 = _interopRequireDefault(_echarts);
	
	__webpack_require__(35);
	
	__webpack_require__(19);
	
	__webpack_require__(15);
	
	__webpack_require__(14);
	
	__webpack_require__(23);
	
	var _jquery = __webpack_require__(16);
	
	var _jquery2 = _interopRequireDefault(_jquery);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
	
	function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }
	
	function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }
	
	// import ECharts
	
	//Aufruf von $ Zeichen 
	
	
	var Pulse = function (_Component) {
	    _inherits(Pulse, _Component);
	
	    function Pulse() {
	        var _ref;
	
	        var _temp, _this, _ret;
	
	        _classCallCheck(this, Pulse);
	
	        for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
	            args[_key] = arguments[_key];
	        }
	
	        return _ret = (_temp = (_this = _possibleConstructorReturn(this, (_ref = Pulse.__proto__ || Object.getPrototypeOf(Pulse)).call.apply(_ref, [this].concat(args))), _this), _this.create_graph = function () {
	            var history = _this.props.pulses;
	            var jsonData = { pulse: history
	                //  currentDate
	            };var currentDate = new Date();
	            // old7Datetimestample
	            var days7before = currentDate.setDate(currentDate.getDate() - 7); //  最终获得的 old7Date 是时间戳 
	            console.log(days7before);
	            var truejsonData = jsonData.pulse.filter(function (obj) {
	                return obj.timestamp > days7before;
	            });
	            console.log(truejsonData);
	
	            function timeformater(ts) {
	                var date = new Date(ts);
	                var Y = date.getFullYear() + '-';
	                var M = (date.getMonth() + 1 < 10 ? '0' + (date.getMonth() + 1) : date.getMonth() + 1) + '-';
	                var D = date.getDate() + ' ';
	                var result = Y + M + D;
	                return result;
	            }
	
	            var timelist = [null, null, null, null, null, null, null];
	            timelist.forEach(function (item, index, timelist) {
	                var currentDate = new Date();
	                var data = currentDate.setDate(currentDate.getDate() - index);
	                timelist[index] = timeformater(data);
	            });
	            timelist = timelist.reverse();
	
	            var templist = [null, null, null, null, null, null, null];
	            truejsonData.reverse().forEach(function (item, index, arr) {
	                //db中近7天的array 可能只有3天
	                var i = timelist.indexOf(timeformater(item.timestamp)); //richtige x axis daten value index
	                if (i > -1) {
	                    //wenn an dem Tag etwas in DB erschienen 
	                    templist[i] = item.pulse;
	                    // wenn measured nicht false dann ersetzt die richtige weight dadrauf
	                }
	            });
	
	            //graph infos
	            var option = {
	                color: '#800000',
	                tooltip: {
	                    trigger: 'axis',
	                    position: function position(pt) {
	                        return [pt[0], '10%'];
	                    }
	                },
	                xAxis: {
	                    data: timelist,
	                    axisTick: { show: false },
	                    axisLabel: { show: false }
	                },
	                yAxis: {
	                    axisLine: { show: false },
	                    axisLabel: { show: false },
	                    splitLine: { show: false },
	                    axisTick: { show: false },
	                    type: 'value',
	                    min: function min(extent) {
	                        return extent.min <= 60 ? extent.min - 5 : 50;
	                    },
	                    max: function max(extent) {
	                        return extent.max > 90 ? extent.max + 1 : 92;
	                    }
	                },
	                series: [{
	                    connectNulls: true,
	                    name: 'pulse',
	                    type: 'line',
	                    data: templist,
	                    markLine: {
	                        symbol: "none",
	                        data: [{
	
	                            lineStyle: { //警戒线的样式  ，虚实  颜色
	                                type: "solid",
	                                color: "#FA3934"
	                            },
	                            label: {
	                                textStyle: {
	                                    fonttemperature: "bolder",
	                                    color: 'black',
	                                    fontSize: "4"
	                                },
	                                position: 'start',
	                                formatter: "90"
	                            },
	                            yAxis: 90
	
	                        }, {
	
	                            lineStyle: { //警戒线的样式  ，虚实  颜色
	                                type: "solid",
	                                color: "green"
	                            },
	                            label: {
	                                textStyle: {
	                                    fonttemperature: "bolder",
	                                    color: 'black',
	                                    fontSize: "4"
	                                },
	                                position: 'start',
	                                formatter: "60 "
	                            },
	                            yAxis: 60
	
	                        }]
	                    }
	                }]
	            };
	
	            var myChart = _echarts2.default.init(document.getElementById('pulse' + _this.props.id));
	            myChart.setOption(option);
	            //fuer bootstrap layout
	            (0, _jquery2.default)(window).on('resize', function () {
	                if (myChart !== null && myChart !== undefined) {
	                    myChart.resize();
	                }
	            });
	        }, _temp), _possibleConstructorReturn(_this, _ret);
	    }
	
	    _createClass(Pulse, [{
	        key: 'componentDidMount',
	        value: function componentDidMount() {
	            this.create_graph();
	        }
	    }, {
	        key: 'render',
	        value: function render() {
	            return _react2.default.createElement('div', { id: "pulse" + this.props.id, style: { width: '100%', minHeight: '200px' } });
	        }
	    }]);
	
	    return Pulse;
	}(_react.Component);
	
	exports.default = Pulse;

/***/ },
/* 217 */
[478, 216],
/* 218 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	    value: true
	});
	
	var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();
	
	var _reactDom = __webpack_require__(58);
	
	var _reactDom2 = _interopRequireDefault(_reactDom);
	
	var _react = __webpack_require__(2);
	
	var _react2 = _interopRequireDefault(_react);
	
	var _echarts = __webpack_require__(6);
	
	var _echarts2 = _interopRequireDefault(_echarts);
	
	__webpack_require__(35);
	
	__webpack_require__(19);
	
	__webpack_require__(15);
	
	__webpack_require__(14);
	
	__webpack_require__(23);
	
	var _jquery = __webpack_require__(16);
	
	var _jquery2 = _interopRequireDefault(_jquery);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
	
	function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }
	
	function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }
	
	// import ECharts
	
	//Aufruf von $ Zeichen 
	
	
	var Temperature = function (_Component) {
	    _inherits(Temperature, _Component);
	
	    function Temperature() {
	        var _ref;
	
	        var _temp, _this, _ret;
	
	        _classCallCheck(this, Temperature);
	
	        for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
	            args[_key] = arguments[_key];
	        }
	
	        return _ret = (_temp = (_this = _possibleConstructorReturn(this, (_ref = Temperature.__proto__ || Object.getPrototypeOf(Temperature)).call.apply(_ref, [this].concat(args))), _this), _this.create_graph = function () {
	            var history = _this.props.temperatures;
	            var jsonData = { temperature: history
	                //  currentDate
	                //  currentDate
	            };var currentDate = new Date();
	            // old7Datetimestample
	            var days7before = currentDate.setDate(currentDate.getDate() - 7); //  最终获得的 old7Date 是时间戳 
	            //console.log(days7before)    
	            var truejsonData = jsonData.temperature.filter(function (obj) {
	                return obj.timestamp > days7before;
	            });
	            console.log(truejsonData);
	
	            function timeformater(ts) {
	                var date = new Date(ts);
	                var Y = date.getFullYear() + '-';
	                var M = (date.getMonth() + 1 < 10 ? '0' + (date.getMonth() + 1) : date.getMonth() + 1) + '-';
	                var D = date.getDate() + ' ';
	                var result = Y + M + D;
	                return result;
	            }
	
	            var timelist = [null, null, null, null, null, null, null];
	            timelist.forEach(function (item, index, timelist) {
	                var currentDate = new Date();
	                var data = currentDate.setDate(currentDate.getDate() - index);
	                timelist[index] = timeformater(data);
	            });
	            timelist = timelist.reverse();
	
	            var templist = [null, null, null, null, null, null, null];
	            truejsonData.reverse().forEach(function (item, index, arr) {
	                //db中近7天的array 可能只有3天
	                var i = timelist.indexOf(timeformater(item.timestamp)); //richtige x axis daten value index
	                if (i > -1 && item.measured !== false) {
	                    //wenn an dem Tag etwas in DB erschienen 
	                    templist[i] = item.temperature;
	                    // wenn measured nicht false dann ersetzt die richtige weight dadrauf
	                }
	            });
	
	            //graph infos
	            var option = {
	                color: 'black',
	                xAxis: {
	                    data: timelist,
	                    axisTick: { show: false },
	                    axisLabel: { show: false }
	                },
	                yAxis: {
	                    axisLine: { show: false },
	                    axisLabel: { show: false },
	                    splitLine: { show: false },
	                    axisTick: { show: false },
	                    type: 'value',
	                    min: function min(extent) {
	                        return extent.min <= 34 ? extent.min - 1 : 33;
	                    },
	                    max: function max(extent) {
	                        return extent.max > 37.5 ? extent.max : 37.5;
	                    }
	                },
	                tooltip: {
	                    trigger: 'axis',
	                    position: function position(pt) {
	                        return [pt[0], '10%'];
	                    }
	                },
	                series: [{
	
	                    barCategoryGap: "2%",
	                    name: 'temperature',
	                    type: 'bar',
	                    data: templist,
	                    itemStyle: {
	                        normal: {
	                            color: function color(params) {
	                                if (params.value > 37.5) {
	                                    return "#DC143C";
	                                } else if (params.value >= 36.5 && params.value <= 37.5) {
	                                    return "#32CD32";
	                                } else if (params.value < 36.5) {
	                                    return "#FFA500";
	                                } else return 'black';
	                            }
	                        }
	                    },
	                    // label: {
	                    //     textStyle: {
	                    //         fonttemperature: "bolder",
	                    //         fontSize: "8",
	                    //         color: "#fff"
	                    //     },
	                    //     show: true,
	                    //     position: 'inside',
	                    //     formatter: '{c}°C'//echarts selbst build in variable fuer valu
	
	                    // },
	                    markLine: {
	                        symbol: "none",
	                        data: [{
	                            lineStyle: { //警戒线的样式  ，虚实  颜色
	                                type: "solid",
	                                color: "#FA3934"
	                            },
	                            label: {
	                                textStyle: {
	                                    fonttemperature: "bolder",
	                                    color: 'black',
	                                    fontSize: "4"
	                                },
	                                position: 'left',
	                                formatter: "37.5"
	                            },
	                            yAxis: 37.5
	
	                        }, {
	
	                            lineStyle: { //警戒线的样式  ，虚实  颜色
	                                type: "solid",
	                                color: "green"
	                            },
	                            label: {
	                                textStyle: {
	                                    fonttemperature: "bolder",
	                                    color: 'black',
	                                    fontSize: "4"
	                                },
	                                position: 'left',
	                                formatter: "36.5 "
	                            },
	                            yAxis: 36.5
	
	                        }]
	                    }
	                }]
	            };
	
	            var myChart = _echarts2.default.init(document.getElementById("temperature" + _this.props.id));
	            myChart.setOption(option);
	            //fuer bootstrap layout
	            (0, _jquery2.default)(window).on('resize', function () {
	                if (myChart !== null && myChart !== undefined) {
	                    myChart.resize();
	                }
	            });
	        }, _temp), _possibleConstructorReturn(_this, _ret);
	    }
	
	    _createClass(Temperature, [{
	        key: 'componentDidMount',
	        value: function componentDidMount() {
	            this.create_graph();
	        }
	    }, {
	        key: 'render',
	        value: function render() {
	            return _react2.default.createElement('div', { id: "temperature" + this.props.id, style: { width: '100%', minHeight: '200px' } });
	        }
	    }]);
	
	    return Temperature;
	}(_react.Component);
	
	exports.default = Temperature;

/***/ },
/* 219 */
[479, 218],
/* 220 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	    value: true
	});
	
	var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();
	
	var _reactDom = __webpack_require__(58);
	
	var _reactDom2 = _interopRequireDefault(_reactDom);
	
	var _react = __webpack_require__(2);
	
	var _react2 = _interopRequireDefault(_react);
	
	var _echarts = __webpack_require__(6);
	
	var _echarts2 = _interopRequireDefault(_echarts);
	
	__webpack_require__(35);
	
	__webpack_require__(19);
	
	__webpack_require__(15);
	
	__webpack_require__(14);
	
	__webpack_require__(23);
	
	var _jquery = __webpack_require__(16);
	
	var _jquery2 = _interopRequireDefault(_jquery);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
	
	function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }
	
	function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }
	
	// import ECharts
	
	//Aufruf von $ Zeichen 
	
	
	var Weight = function (_Component) {
	    _inherits(Weight, _Component);
	
	    function Weight() {
	        var _ref;
	
	        var _temp, _this, _ret;
	
	        _classCallCheck(this, Weight);
	
	        for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
	            args[_key] = arguments[_key];
	        }
	
	        return _ret = (_temp = (_this = _possibleConstructorReturn(this, (_ref = Weight.__proto__ || Object.getPrototypeOf(Weight)).call.apply(_ref, [this].concat(args))), _this), _this.create_graph = function () {
	            var history = _this.props.weights;
	            var jsonData = { weight: history
	                //  currentDate
	            };var currentDate = new Date();
	            // old7Datetimestample
	            var days7before = currentDate.setDate(currentDate.getDate() - 7); //  最终获得的 old7Date 是时间戳 
	            //console.log(days7before)    
	            var truejsonData = jsonData.weight.filter(function (obj) {
	                return obj.timestamp > days7before;
	            });
	            console.log(truejsonData);
	
	            function timeformater(ts) {
	                var date = new Date(ts);
	                var Y = date.getFullYear() + '-';
	                var M = (date.getMonth() + 1 < 10 ? '0' + (date.getMonth() + 1) : date.getMonth() + 1) + '-';
	                var D = date.getDate() + ' ';
	                var result = Y + M + D;
	                return result;
	            }
	            var timelist = [null, null, null, null, null, null, null];
	            timelist.forEach(function (item, index, timelist) {
	                var currentDate = new Date();
	                var data = currentDate.setDate(currentDate.getDate() - index);
	                timelist[index] = timeformater(data);
	            });
	            timelist = timelist.reverse();
	            var templist1 = [null, null, null, null, null, null, null];
	            var templist2 = [null, null, null, null, null, null, null];
	            var hilfsweight = null;
	            truejsonData.forEach(function (item, index, arr) {
	                //db中近7天的array 可能只有3天
	                var i = timelist.indexOf(timeformater(item.timestamp)); //richtige x axis daten value index
	                if (i > -1) {
	                    //wenn an dem Tag etwas in DB erschienen 
	                    if (item.measured !== false) {
	                        templist1[i] = (item.weight * 0.1).toFixed(2);
	                    } // wenn measured nicht false dann ersetzt die richtige weight dadrauf
	                    if (i === 0 && item.measured !== false) {
	                        hilfsweight = item.weight;
	                    } //first keine Aenderung erst ab zweite, wenn erste value hat dann hilfswert weist hinzu
	                    else if (item.measured !== false) {
	                            if (hilfsweight === null) {
	                                hilfsweight = item.weight;
	                            } else {
	                                templist2[i] = (item.weight - hilfsweight).toFixed(2);
	                                hilfsweight = item.weight;
	                            }
	                        }
	                }
	            });
	
	            var option = {
	                tooltip: {
	                    trigger: 'axis',
	                    position: function position(pt) {
	                        return [pt[0], '10%'];
	                    }
	                },
	                xAxis: {
	                    axisLabel: { show: false },
	
	                    axisTick: { show: false },
	                    splitLine: { show: false },
	                    data: timelist
	
	                },
	                yAxis: {
	                    axisLine: { show: false },
	                    axisLabel: { show: false },
	                    splitLine: { show: false },
	                    axisTick: { show: false },
	                    type: 'value'
	                },
	                series: [{
	                    barCategoryGap: "0%",
	                    name: 'change',
	                    type: 'bar',
	                    data: templist2
	                }]
	            };
	
	            var myChart = _echarts2.default.init(document.getElementById("weight" + _this.props.id));
	            myChart.setOption(option);
	            //fuer bootstrap layout
	            (0, _jquery2.default)(window).on('resize', function () {
	                if (myChart !== null && myChart !== undefined) {
	                    myChart.resize();
	                }
	            });
	        }, _temp), _possibleConstructorReturn(_this, _ret);
	    }
	
	    _createClass(Weight, [{
	        key: 'componentDidMount',
	        value: function componentDidMount() {
	            this.create_graph();
	        }
	    }, {
	        key: 'render',
	        value: function render() {
	            return _react2.default.createElement('div', { id: "weight" + this.props.id, style: { width: '100%', minHeight: '200px' } });
	        }
	    }]);
	
	    return Weight;
	}(_react.Component);
	
	exports.default = Weight;

/***/ },
/* 221 */
[480, 220],
/* 222 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	
	var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();
	
	var _react = __webpack_require__(2);
	
	var _react2 = _interopRequireDefault(_react);
	
	var _reactTabs = __webpack_require__(74);
	
	var _Signup = __webpack_require__(224);
	
	var _Signup2 = _interopRequireDefault(_Signup);
	
	var _PatientProfile = __webpack_require__(121);
	
	var _PatientProfile2 = _interopRequireDefault(_PatientProfile);
	
	var _Pulse = __webpack_require__(217);
	
	var _Pulse2 = _interopRequireDefault(_Pulse);
	
	var _Temperature = __webpack_require__(219);
	
	var _Temperature2 = _interopRequireDefault(_Temperature);
	
	var _Weight = __webpack_require__(221);
	
	var _Weight2 = _interopRequireDefault(_Weight);
	
	var _BoodPressure = __webpack_require__(215);
	
	var _BoodPressure2 = _interopRequireDefault(_BoodPressure);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
	
	function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }
	
	function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }
	
	// import seachIcon from './images/search.png';
	// import emptyStar from './images/emptystar.png';
	// import yellowStar from './images/yellowstar.png';
	// import expandArrow from './images/expandArrow.png';
	
	var PatientList = function (_React$Component) {
	  _inherits(PatientList, _React$Component);
	
	  function PatientList(props) {
	    _classCallCheck(this, PatientList);
	
	    var _this = _possibleConstructorReturn(this, (PatientList.__proto__ || Object.getPrototypeOf(PatientList)).call(this, props));
	
	    _this.state = {
	      error: false,
	      errorPatientLoad: false,
	      isLoaded: false,
	      LoadingSection: false,
	
	      view: 'patients',
	
	      patients: [],
	      patientsPerPage: 60,
	      noPatients: true,
	
	      patientForm: false,
	      firstName: '',
	      lastName: '',
	      email: '',
	
	      admin_display: false,
	      sort_new: true,
	      sort_old: false,
	      sort_alphabetically: false,
	
	      simpleMode: true,
	
	      patientClicked: {},
	      patientClickedBool: false,
	
	      active: null,
	      actives: [],
	
	      import: false,
	
	      expandSize: '20px',
	      profile: false,
	      edit: false,
	
	      currentPage: 1,
	      sort: "alphabetisch",
	
	      showSearch: false,
	      search: '',
	
	      refresh: _this.props.refresh
	    };
	
	    _this.baseState = _this.state; // preserve the initial state
	    _this.closesignup = _this.closesignup.bind(_this);
	    _this.patientClicked = _this.patientClicked.bind(_this);
	    _this.timeSince = _this.timeSince.bind(_this);
	    _this.myColor = _this.myColor.bind(_this);
	    _this.handlePageChange = _this.handlePageChange.bind(_this);
	    _this.sort = _this.sort.bind(_this);
	    _this.admin_display = _this.admin_display.bind(_this);
	    _this.handleSearchChange = _this.handleSearchChange.bind(_this);
	    _this.clearSearch = _this.clearSearch.bind(_this);
	    _this.timeConverter = _this.timeConverter.bind(_this);
	
	    return _this;
	  }
	
	  _createClass(PatientList, [{
	    key: 'componentDidMount',
	    value: function componentDidMount() {
	      var _this2 = this;
	
	      // fetch patient list
	      fetch('/api/doctor/getPatients').then(function (blob) {
	        return blob.json();
	      }).then(function (blob) {
	        _this2.setState({ patients: blob.sort(function (a, b) {
	            if (a.firstname < b.firstname) {
	              return -1;
	            }if (a.firstname > b.firstname) {
	              return 1;
	            }return 0;
	          }), isLoaded: true });
	        _this2.baseState.patient = blob.sort(function (a, b) {
	          if (a.firstname < b.firstname) {
	            return -1;
	          }if (a.firstname > b.firstname) {
	            return 1;
	          }return 0;
	        });
	        _this2.baseState.isLoaded = true;
	        if (blob.length > 0) {
	          _this2.setState({ noPatients: false });
	          _this2.baseState.noPatients = true;
	        }
	      }).catch(function (error) {
	        return _this2.setState({ errorPatientLoad: true });
	      });
	    }
	
	    // componentDidUpdate(prevProps) {
	    //   if (this.props.refresh && (this.state.edit || this.state.patientForm)) {
	    //   }
	    // }
	
	  }, {
	    key: 'handleSearchChange',
	    value: function handleSearchChange(e) {
	      this.setState({ search: e.target.value });
	    }
	  }, {
	    key: 'clearSearch',
	    value: function clearSearch() {
	      this.setState({ search: '' });
	    }
	  }, {
	    key: 'patientClicked',
	    value: function patientClicked(e, patient) {
	      //select different patient
	      this.setState({ patientClicked: patient, patientClickedBool: true });
	    }
	  }, {
	    key: 'timeSince',
	    value: function timeSince(UNIX_timestamp) {
	      var date = new Date(Number(UNIX_timestamp));
	      return (date.getDate() + "/" + (date.getMonth() + 1) + "/" + date.getFullYear()).toString();
	    }
	  }, {
	    key: 'myColor',
	    value: function myColor(position) {
	      if (this.state.loadMultipleClicked) {
	        if (this.state.actives.includes(position)) return "#efdecb59";
	      }
	      if (this.state.active === position) {
	        return "#efdecb59";
	      }
	      return "";
	    }
	  }, {
	    key: 'handlePageChange',
	    value: function handlePageChange(e) {
	      this.setState({
	        currentPage: Number(event.target.id)
	      });
	      window.scrollTo(0, 0);
	    }
	  }, {
	    key: 'sort',
	    value: function sort() {
	      var patients = this.state.patients;
	
	      if (event.target.value === "recent") {
	        patients.sort(function (a, b) {
	          return parseInt(b.created_on) - parseInt(a.created_on);
	        });
	        this.setState({ sort: event.target.value, patients: patients });
	        return;
	      }
	
	      if (event.target.value === "lastActive") {
	        patients.sort(function (a, b) {
	          return parseInt(b.last_login) - parseInt(a.last_login);
	        });
	        this.setState({ sort: event.target.value, patients: patients });
	        return;
	      }
	
	      if (event.target.value === "alphabetisch") {
	        patients.sort(function (a, b) {
	          if (a.firstname < b.firstname) {
	            return -1;
	          }if (a.firstname > b.firstname) {
	            return 1;
	          }return 0;
	        });
	        this.setState({ sort: event.target.value, patients: patients });
	        return;
	      }
	
	      if (event.target.value === "nichtAlphabetisch") {
	        patients.sort(function (a, b) {
	          if (a.firstname > b.firstname) {
	            return -1;
	          } else {
	            return 1;
	          }return 0;
	        });
	        this.setState({ sort: event.target.value, patients: patients });
	        return;
	      }
	    }
	  }, {
	    key: 'admin_display',
	    value: function admin_display() {
	      if (!this.state.admin_display) return "col-4 half_transparent";else return "col-4";
	    }
	  }, {
	    key: 'timeConverter',
	    value: function timeConverter(UNIX_timestamp) {
	      var a = new Date(Number(UNIX_timestamp));
	      var months = ['Januar', 'Februar', 'März', 'April', 'May', 'Juni', 'Juli', 'August', 'September', 'Oktober', 'November', 'Dezember'];
	      var year = a.getFullYear();
	      var month = months[a.getMonth()];
	      var date = a.getDate();
	      var hour = a.getHours();
	      var min = a.getMinutes();
	      var sec = a.getSeconds();
	      var time = date + ' ' + month + ' ' + year + ' ' + hour + ':' + min + ':' + sec;
	      return time;
	    }
	  }, {
	    key: 'closesignup',
	    value: function closesignup() {
	      this.setState({ patientForm: false });
	      window.scrollTo(0, 0);
	    }
	  }, {
	    key: 'render',
	    value: function render() {
	      var _this3 = this;
	
	      if (this.state.patientForm) {
	        return _react2.default.createElement(_Signup2.default, { closesignup: this.closesignup, zuruck: this.closesignup });
	      }
	
	      if (this.state.patientClickedBool) {
	        return _react2.default.createElement(_PatientProfile2.default, { selectedPatient: this.state.patientClicked, goBack: function goBack(e) {
	            return _this3.setState({ patientClickedBool: false });
	          } });
	      }
	
	      if (this.state.errorPatientLoad) {
	        return _react2.default.createElement(
	          'p',
	          null,
	          'Error: Patients data cannot be loaded'
	        );
	      }
	
	      var isLoading = !this.state.isLoaded;
	      var noPatients = this.state.noPatients;
	      var Patients = this.state.patients;
	      var patientForm = this.state.patientForm;
	      var simpleMode = this.state.simpleMode;
	      var loadMultipleClicked = this.state.loadMultipleClicked;
	
	      if (this.state.admin_display) {
	        Patients = Patients.filter(function (patient) {
	          return patient.role !== 'patient';
	        });
	      }
	
	      if (this.state.search !== '') {
	        Patients = Patients.filter(function (patient) {
	          return patient.firstname.toLowerCase().includes(_this3.state.search.toLowerCase()) || patient.lastname.toLowerCase().includes(_this3.state.search.toLowerCase());
	        });
	      }
	
	      // Logic for displaying patients
	      var indexOfLastPatients = this.state.currentPage * this.state.patientsPerPage;
	      var indexOfFirstPatient = indexOfLastPatients - this.state.patientsPerPage;
	      var currentPatients = Patients.slice(indexOfFirstPatient, indexOfLastPatients);
	
	      var renderPatients = currentPatients.map(function (patient, index) {
	        return _react2.default.createElement(
	          'li',
	          { key: index },
	          patient
	        );
	      });
	
	      // Logic for displaying page numbers
	      var pageNumbers = [];
	      for (var i = 1; i <= Math.ceil(Patients.length / this.state.patientsPerPage); i++) {
	        pageNumbers.push(i);
	      }
	
	      var renderPageNumbers = ' ';
	      if (pageNumbers.length > 1) {
	        renderPageNumbers = pageNumbers.map(function (number, i) {
	          if (i === _this3.state.currentPage - 1) {
	            return _react2.default.createElement(
	              'li',
	              {
	                key: number,
	                id: number,
	                style: { display: 'inline', marginRight: '10px', fontSize: '20px', cursor: 'pointer' },
	                onClick: _this3.handlePageChange
	              },
	              number
	            );
	          }
	
	          return _react2.default.createElement(
	            'li',
	            {
	              key: number,
	              id: number,
	              style: { display: 'inline', marginRight: '10px', cursor: 'pointer' },
	              onClick: _this3.handlePageChange
	            },
	            number
	          );
	        });
	      }
	
	      if (!this.state.profile && !this.state.edit) {
	        document.title = "Patient List";
	        return _react2.default.createElement(
	          'div',
	          { className: 'container-fluid' },
	          _react2.default.createElement(
	            'div',
	            { className: 'row', style: { marginLeft: '0' } },
	            _react2.default.createElement(
	              'div',
	              { className: 'col-8', style: { marginBottom: '20px', marginLeft: '-10px' } },
	              _react2.default.createElement(
	                'h3',
	                null,
	                'Patients'
	              )
	            ),
	            isLoading ? _react2.default.createElement(
	              'div',
	              null,
	              _react2.default.createElement(
	                'p',
	                null,
	                'Loading user...'
	              )
	            ) : null,
	            !isLoading && noPatients ? _react2.default.createElement(
	              'div',
	              null,
	              _react2.default.createElement(
	                'button',
	                { className: 'button_dkg', onClick: function onClick(e) {
	                    return _this3.setState({ patientForm: true });
	                  } },
	                'Add Patient'
	              )
	            ) : null,
	            !isLoading && !noPatients && simpleMode && !this.state.patientClickedExpand ? _react2.default.createElement(
	              'div',
	              { className: 'col-12', style: { padding: '10px 0px' } },
	              _react2.default.createElement(
	                'button',
	                { className: 'add_new_patient', onClick: function onClick(e) {
	                    return _this3.setState({ patientForm: true });
	                  } },
	                '+ add new patient'
	              ),
	              _react2.default.createElement('input', { id: 'search-btn', type: 'checkbox' }),
	              _react2.default.createElement('label', { htmlFor: 'search-btn', onClick: function onClick(e) {
	                  return _this3.clearSearch(e);
	                } }),
	              _react2.default.createElement('input', { id: 'search-bar', type: 'text', placeholder: '...', value: this.state.search, onChange: this.handleSearchChange }),
	              _react2.default.createElement('div', { style: { display: 'inline-block', marginLeft: '10px' } })
	            ) : null,
	            !isLoading && !noPatients ? _react2.default.createElement(
	              'div',
	              { className: "col-12" },
	              _react2.default.createElement(
	                'div',
	                { className: 'row', style: { boxShadow: '0 0 28px -16px #888888', marginBottom: '20px', padding: '20px 0', borderRadius: '30px' } },
	                _react2.default.createElement(
	                  'div',
	                  { className: "col-2" },
	                  _react2.default.createElement(
	                    'p',
	                    null,
	                    'Name'
	                  )
	                ),
	                _react2.default.createElement(
	                  'div',
	                  { className: "col-2" },
	                  _react2.default.createElement(
	                    'p',
	                    null,
	                    'Temperature'
	                  )
	                ),
	                _react2.default.createElement(
	                  'div',
	                  { className: "col-2" },
	                  _react2.default.createElement(
	                    'p',
	                    null,
	                    'Pulse'
	                  )
	                ),
	                _react2.default.createElement(
	                  'div',
	                  { className: "col-2" },
	                  _react2.default.createElement(
	                    'p',
	                    null,
	                    'Weight'
	                  )
	                ),
	                _react2.default.createElement(
	                  'div',
	                  { className: "col-2" },
	                  _react2.default.createElement(
	                    'p',
	                    null,
	                    'Blood Pressure'
	                  )
	                ),
	                _react2.default.createElement(
	                  'div',
	                  { className: "col-2" },
	                  _react2.default.createElement(
	                    'p',
	                    null,
	                    'Status'
	                  )
	                ),
	                currentPatients.map(function (patient, i) {
	                  return _react2.default.createElement(
	                    'div',
	                    { className: 'col-12 hover_gray', style: { borderTop: '1px solid #80808038', paddingTop: '10px', background: _this3.myColor(i) }, onClick: function onClick(e) {
	                        _this3.patientClicked(e, patient);
	                      } },
	                    _react2.default.createElement(
	                      'div',
	                      { className: 'row', style: { cursor: 'pointer' } },
	                      _react2.default.createElement(
	                        'div',
	                        { className: "col-2" },
	                        _react2.default.createElement(
	                          'p',
	                          { style: { marginTop: '60px' } },
	                          patient.firstname + ' ' + patient.lastname
	                        )
	                      ),
	                      _react2.default.createElement(
	                        'div',
	                        { className: "col-2" },
	                        _react2.default.createElement(_Temperature2.default, { temperatures: patient.temperature.temperature, id: patient.addressid })
	                      ),
	                      _react2.default.createElement(
	                        'div',
	                        { className: "col-2" },
	                        _react2.default.createElement(_Pulse2.default, { pulses: patient.pulse.pulse, id: patient.addressid })
	                      ),
	                      _react2.default.createElement(
	                        'div',
	                        { className: "col-2" },
	                        _react2.default.createElement(_Weight2.default, { weights: patient.weight.weight, id: patient.addressid })
	                      ),
	                      _react2.default.createElement(
	                        'div',
	                        { className: "col-2" },
	                        _react2.default.createElement(_BoodPressure2.default, { blood_pressures: patient.blood_pressure.blood_pressure, id: patient.addressid })
	                      ),
	                      _react2.default.createElement(
	                        'div',
	                        { className: "col-2" },
	                        patient.health.points <= 2 ? _react2.default.createElement(
	                          'p',
	                          { style: { color: 'black', fontStyle: 'italic', fontSize: '16px', marginTop: '62px' } },
	                          _react2.default.createElement(
	                            'span',
	                            { style: { color: 'green' } },
	                            'green'
	                          ),
	                          ' '
	                        ) : null,
	                        patient.health.points === 3 || patient.health.points === 4 || patient.health.points === 5 ? _react2.default.createElement(
	                          'p',
	                          { style: { color: 'black', fontStyle: 'italic', fontSize: '16px', marginTop: '62px' } },
	                          _react2.default.createElement(
	                            'span',
	                            { style: { color: '#ffc459' } },
	                            'orange'
	                          ),
	                          ' '
	                        ) : null,
	                        patient.health.points > 5 ? _react2.default.createElement(
	                          'p',
	                          { style: { color: 'black', fontStyle: 'italic', fontSize: '16px', marginTop: '62px' } },
	                          _react2.default.createElement(
	                            'span',
	                            { style: { color: 'red' } },
	                            'red'
	                          ),
	                          ' '
	                        ) : null
	                      )
	                    )
	                  );
	                }),
	                currentPatients.length === 0 ? _react2.default.createElement(
	                  'p',
	                  null,
	                  'no user...'
	                ) : null
	              ),
	              renderPageNumbers
	            ) : null
	          )
	        );
	      }
	    }
	  }]);
	
	  return PatientList;
	}(_react2.default.Component);
	
	exports.default = PatientList;

/***/ },
/* 223 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	
	var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();
	
	var _react = __webpack_require__(2);
	
	var _react2 = _interopRequireDefault(_react);
	
	var _tinymceReact = __webpack_require__(120);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
	
	function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }
	
	function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }
	
	var Signup = function (_React$Component) {
	  _inherits(Signup, _React$Component);
	
	  function Signup(props) {
	    _classCallCheck(this, Signup);
	
	    var _this = _possibleConstructorReturn(this, (Signup.__proto__ || Object.getPrototypeOf(Signup)).call(this, props));
	
	    _this.state = {
	      step: 1,
	
	      firstname: '',
	      lastname: '',
	      email: '',
	      birthday: '',
	      advice: '',
	      username: '',
	      password: '',
	
	      transplants: [],
	      medicaments: [],
	
	      search: '',
	
	      selectedTransplant: '',
	      selectedTransplantID: '',
	      selectedTransplantUID: ''
	    };
	
	    _this.handleFirstNameChange = _this.handleFirstNameChange.bind(_this);
	    _this.handleLastNameChange = _this.handleLastNameChange.bind(_this);
	    _this.handleEmailChange = _this.handleEmailChange.bind(_this);
	    _this.handleBirthdayChange = _this.handleBirthdayChange.bind(_this);
	    _this.handleUsernameChange = _this.handleUsernameChange.bind(_this);
	    _this.handlePasswordChange = _this.handlePasswordChange.bind(_this);
	    _this.handleDisplayChange = _this.handleDisplayChange.bind(_this);
	    _this.handleCheckbox = _this.handleCheckbox.bind(_this);
	    _this.registerPatient = _this.registerPatient.bind(_this);
	    _this.checkboxClassname = _this.checkboxClassname.bind(_this);
	    _this.weiter = _this.weiter.bind(_this);
	    _this.zuruck = _this.zuruck.bind(_this);
	    _this.handleAdviceChange = _this.handleAdviceChange.bind(_this);
	    _this.handleMedicineAmmount = _this.handleMedicineAmmount.bind(_this);
	    _this.handleMedicineDuration = _this.handleMedicineDuration.bind(_this);
	
	    return _this;
	  }
	
	  _createClass(Signup, [{
	    key: 'componentDidMount',
	    value: function componentDidMount() {
	      var _this2 = this;
	
	      window.scrollTo(0, 0);
	      fetch('/extern/api/alltransplants/').then(function (blob) {
	        return blob.json();
	      }).then(function (blob) {
	        _this2.setState({
	          guidelineLoaded: true,
	          transplants: blob.data
	        });
	      },
	      // Note: it's important to handle errors here
	      // instead of a catch() block so that we don't swallow
	      // exceptions from actual bugs in components.
	      function (error) {
	        _this2.setState({
	          guidelineLoaded: false,
	          error: error
	        });
	      });
	    }
	  }, {
	    key: 'handleFirstNameChange',
	    value: function handleFirstNameChange(e) {
	      this.setState({ firstname: e.target.value });
	    }
	  }, {
	    key: 'handleUsernameChange',
	    value: function handleUsernameChange(e) {
	      this.setState({ username: e.target.value });
	    }
	  }, {
	    key: 'handlePasswordChange',
	    value: function handlePasswordChange(e) {
	      this.setState({ password: e.target.value });
	    }
	  }, {
	    key: 'handleBirthdayChange',
	    value: function handleBirthdayChange(e) {
	      this.setState({ birthday: e.target.value });
	    }
	  }, {
	    key: 'handleLastNameChange',
	    value: function handleLastNameChange(e) {
	      this.setState({ lastname: e.target.value });
	    }
	  }, {
	    key: 'handleEmailChange',
	    value: function handleEmailChange(e) {
	      this.setState({ email: e.target.value });
	    }
	  }, {
	    key: 'handleAdviceChange',
	    value: function handleAdviceChange(e, c) {
	      this.setState({ advice: e });
	    }
	  }, {
	    key: 'handleDisplayChange',
	    value: function handleDisplayChange(e) {
	      this.setState({ display: e.target.value });
	    }
	  }, {
	    key: 'handleInvitationTextChange',
	    value: function handleInvitationTextChange(content, editor) {
	      this.setState({ invitationText: content });
	    }
	  }, {
	    key: 'handleClosedTextChange',
	    value: function handleClosedTextChange(content, editor) {
	      this.setState({ closedText: content });
	    }
	  }, {
	    key: 'handleCheckbox',
	    value: function handleCheckbox(item) {
	      console.log(item);
	      var bool = this.state.medicaments.some(function (chapter) {
	        return chapter.title === item.title;
	      });
	      if (bool) {
	        var medicaments = this.state.medicaments;
	        var index = medicaments.findIndex(function (x) {
	          return x.title === item.title;
	        });
	        if (index !== -1 && index !== undefined) medicaments.splice(index, 1);
	        this.setState({ medicaments: medicaments });
	      } else {
	        var _medicaments = this.state.medicaments;
	        item.ammount = 0;
	        item.duration = 0;
	        item.history = [];
	        _medicaments.push(item);
	        this.setState({ medicaments: _medicaments });
	      }
	    }
	  }, {
	    key: 'handleOptionChange',
	    value: function handleOptionChange(title, id) {
	      this.setState({
	        selectedTransplant: title,
	        selectedTransplantID: id
	      });
	    }
	  }, {
	    key: 'weiter',
	    value: function weiter() {
	      if (this.state.selectedTransplant === '') {
	        return;
	      }
	
	      var newStep = this.state.step + 1;
	      this.setState({ step: newStep });
	    }
	  }, {
	    key: 'zuruck',
	    value: function zuruck() {
	      var newStep = this.state.step - 1;
	      this.setState({ step: newStep });
	    }
	  }, {
	    key: 'registerPatient',
	    value: function registerPatient() {
	      var _this3 = this;
	
	      fetch('/api/doctor/addPatient', {
	        method: 'post',
	        headers: { 'Content-Type': 'application/json' },
	        body: JSON.stringify({ firstname: this.state.firstname, lastname: this.state.lastname, birthdate: this.state.birthday, email: this.state.email, username: this.state.username, password: this.state.password, medication: this.state.medicaments
	        })
	      }).then(function (res) {
	        return console.log('response ', res.json());
	      }).then(function (res) {
	        return _this3.props.closesignup();
	      });
	    }
	  }, {
	    key: 'checkboxClassname',
	    value: function checkboxClassname(item) {
	      if (this.state.medicaments.some(function (medicament) {
	        return medicament.title === item.title;
	      })) return "radioholder activeradioholder";else return "radioholder";
	    }
	  }, {
	    key: 'handleMedicineAmmount',
	    value: function handleMedicineAmmount(e, item) {
	      if (isNaN(e.target.value)) return;
	      var medicaments = this.state.medicaments;
	      medicaments.forEach(function (medicament) {
	        if (medicament.title === item.title) {
	          medicament.ammount = Number(e.target.value);
	        }
	      });
	      this.setState({ medicaments: medicaments });
	    }
	  }, {
	    key: 'handleMedicineDuration',
	    value: function handleMedicineDuration(e, item) {
	      if (isNaN(e.target.value)) return;
	      var medicaments = this.state.medicaments;
	      medicaments.forEach(function (medicament) {
	        if (medicament.title === item.title) {
	          medicament.duration = Number(e.target.value);
	        }
	      });
	      this.setState({ medicaments: medicaments });
	    }
	  }, {
	    key: 'render',
	    value: function render() {
	      var _this4 = this;
	
	      var allmedicaments = [{ title: 'Azathioprine' }, { title: 'Ciclosporin' }, { title: 'Mycophenolate mofetil' }, { title: 'Cyclophosphamide' }, { title: 'Azathioprine tablets' }, { title: 'Prednisone tablets' }, { title: 'Mycophenolate capsule' }, { title: 'Methotrexate' }, { title: 'Methotrexate injection' }, { title: 'Tacrolimus' }, { title: 'Cyclosporine' }, { title: 'Mycophenolate Mofetil' }, { title: 'Imuran' }, { title: 'Rapamune' }, { title: 'Cyclosporine' }, { title: 'Tacrolimus' }, { title: 'Prednisolone' }, { title: 'Budesonide' }, { title: 'Everolimus' }, { title: 'Sirolimus' }, { title: 'Adalimumab' }, { title: 'Anakinra' }, { title: 'Certolizumab' }, { title: 'Etanercept' }, { title: 'Golimumab' }, { title: 'Ixekizumab' }, { title: 'Natalizumab' }, { title: 'Rituximab' }, { title: 'Secukinumab' }, { title: 'Tocilizumab' }, { title: 'Ustekinumab' }, { title: 'Vedolizumab' }, { title: 'Basiliximab' }];
	
	      return _react2.default.createElement(
	        'div',
	        { className: 'row', style: { marginLeft: '0' } },
	        _react2.default.createElement(
	          'div',
	          { className: 'col-12' },
	          _react2.default.createElement(
	            'h3',
	            null,
	            'Personal information'
	          )
	        ),
	        _react2.default.createElement(
	          'div',
	          { className: 'col-12' },
	          _react2.default.createElement(
	            'div',
	            { className: 'row', style: { backgroundColor: '#ffffffd1', borderRadius: '15px' } },
	            _react2.default.createElement(
	              'div',
	              { className: 'col-6' },
	              _react2.default.createElement(
	                'h4',
	                { style: { paddingTop: '30px', fontSize: '20px', fontWeight: '400' } },
	                'Firstname:'
	              ),
	              _react2.default.createElement('input', { className: 'userinput', type: 'text', placeholder: 'Firstname', name: 'firstname', value: this.state.firstname, onChange: this.handleFirstNameChange, style: { width: '100%' } })
	            ),
	            _react2.default.createElement(
	              'div',
	              { className: 'col-6' },
	              _react2.default.createElement(
	                'h4',
	                { style: { paddingTop: '30px', fontSize: '20px', fontWeight: '400' } },
	                'Lastname:'
	              ),
	              _react2.default.createElement('input', { className: 'userinput', type: 'text', placeholder: 'Lastname', name: 'lastname', value: this.state.lastname, onChange: this.handleLastNameChange, style: { width: '100%' } })
	            ),
	            _react2.default.createElement(
	              'div',
	              { className: 'col-6', style: { paddingTop: '30px', paddingBottom: '30px' } },
	              _react2.default.createElement(
	                'h4',
	                { style: { fontSize: '20px', fontWeight: '400' } },
	                'Bithday:'
	              ),
	              _react2.default.createElement('input', { className: 'userinput', type: 'text', placeholder: 'Birthdate', name: 'birthday', value: this.state.birthday, onChange: this.handleBirthdayChange, style: { width: '100%' } })
	            ),
	            _react2.default.createElement(
	              'div',
	              { className: 'col-6', style: { paddingTop: '30px', paddingBottom: '30px' } },
	              _react2.default.createElement(
	                'h4',
	                { style: { fontSize: '20px', fontWeight: '400' } },
	                'Email:'
	              ),
	              _react2.default.createElement('input', { className: 'userinput', type: 'text', placeholder: 'Email', name: 'firstname', value: this.state.email, onChange: this.handleEmailChange, style: { width: '100%' } })
	            )
	          )
	        ),
	        _react2.default.createElement(
	          'div',
	          { className: 'col-12', style: { paddingTop: '20px' } },
	          _react2.default.createElement(
	            'h3',
	            null,
	            'Account information'
	          )
	        ),
	        _react2.default.createElement(
	          'div',
	          { className: 'col-12' },
	          _react2.default.createElement(
	            'div',
	            { className: 'row', style: { backgroundColor: '#ffffffd1', borderRadius: '15px' } },
	            _react2.default.createElement(
	              'div',
	              { className: 'col-6', style: { paddingTop: '30px', paddingBottom: '30px' } },
	              _react2.default.createElement(
	                'h4',
	                { style: { fontSize: '20px', fontWeight: '400' } },
	                'Username:'
	              ),
	              _react2.default.createElement('input', { className: 'userinput', type: 'text', placeholder: 'Username', name: 'username', value: this.state.username, onChange: this.handleUsernameChange, style: { width: '100%' } })
	            ),
	            _react2.default.createElement(
	              'div',
	              { className: 'col-6', style: { paddingTop: '30px', paddingBottom: '30px' } },
	              _react2.default.createElement(
	                'h4',
	                { style: { fontSize: '20px', fontWeight: '400' } },
	                'Password:'
	              ),
	              _react2.default.createElement('input', { className: 'userinput', type: 'password', placeholder: 'Password', name: 'password', value: this.state.password, onChange: this.handlePasswordChange, style: { width: '100%' } })
	            )
	          )
	        ),
	        _react2.default.createElement(
	          'div',
	          { className: 'col-12', style: { paddingTop: '20px', paddingBottom: '20px' } },
	          _react2.default.createElement(
	            'h3',
	            null,
	            'Medication'
	          )
	        ),
	        _react2.default.createElement(
	          'div',
	          { className: 'col-12' },
	          _react2.default.createElement(
	            'div',
	            { className: 'row' },
	            _react2.default.createElement(
	              'div',
	              { className: 'row' },
	              _react2.default.createElement(
	                'div',
	                { className: 'col-12' },
	                _react2.default.createElement(
	                  'div',
	                  { id: 'checks', className: 'myBox', style: { height: '55vh', overflow: 'scroll' } },
	                  allmedicaments.map(function (item, i) {
	                    return _react2.default.createElement(
	                      'span',
	                      { key: i, style: { display: 'block', paddingBottom: '20px' } },
	                      _react2.default.createElement(
	                        'div',
	                        { className: _this4.checkboxClassname(item), onClick: function onClick(e) {
	                            return _this4.handleCheckbox(item);
	                          } },
	                        _react2.default.createElement('span', { className: 'tick' }),
	                        _react2.default.createElement('input', { type: 'radio', uid: item.uid, title: item.title, value: item.title,
	                          checked: _this4.state.medicaments.some(function (medicament) {
	                            return medicament.title === item.title;
	                          }), style: { display: 'none' } }),
	                        ' ' + item.title
	                      ),
	                      _this4.state.medicaments.some(function (medicament) {
	                        return medicament.title === item.title;
	                      }) ? _react2.default.createElement(
	                        'span',
	                        { style: { fontSize: '18px', paddingLeft: '60px' } },
	                        _react2.default.createElement(
	                          'p',
	                          { style: { display: 'inline' } },
	                          'Take '
	                        ),
	                        _react2.default.createElement('input', { className: 'medicationinput', type: 'text', value: _this4.state.medicaments.filter(function (medicament) {
	                            return medicament.title === item.title;
	                          })[0].ammount, onChange: function onChange(e) {
	                            return _this4.handleMedicineAmmount(e, item);
	                          } }),
	                        _react2.default.createElement(
	                          'p',
	                          { style: { display: 'inline' } },
	                          ' every '
	                        ),
	                        _react2.default.createElement('input', { className: 'medicationinput', type: 'text', value: _this4.state.medicaments.filter(function (medicament) {
	                            return medicament.title === item.title;
	                          })[0].duration, onChange: function onChange(e) {
	                            return _this4.handleMedicineDuration(e, item);
	                          } }),
	                        '  ',
	                        _react2.default.createElement(
	                          'p',
	                          { style: { display: 'inline' } },
	                          ' days '
	                        )
	                      ) : null
	                    );
	                  }),
	                  _react2.default.createElement('br', null)
	                )
	              )
	            ),
	            _react2.default.createElement(
	              'div',
	              { className: 'row', style: { marginTop: '20px' } },
	              _react2.default.createElement(
	                'div',
	                { className: 'col-12 margin_top', style: { textAlign: 'center' } },
	                _react2.default.createElement(
	                  'button',
	                  { className: 'importbutton_dkg', style: { border: '2px solid', marginRight: '10px', padding: '3px 12px', borderRadius: '15px', marginTop: '5px', float: 'left', cursor: 'pointer' }, onClick: function onClick(e) {
	                      return _this4.props.zuruck();
	                    } },
	                  'back'
	                ),
	                _react2.default.createElement(
	                  'button',
	                  { type: 'submit', className: 'signupbtn margin_right button_dkg', style: { fontSize: '20px' },
	                    onClick: function onClick(e) {
	                      return _this4.registerPatient();
	                    } },
	                  'Add Patient'
	                )
	              )
	            )
	          )
	        )
	      );
	    }
	  }]);
	
	  return Signup;
	}(_react2.default.Component);
	
	exports.default = Signup;

/***/ },
/* 224 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	
	var _Signup = __webpack_require__(223);
	
	Object.defineProperty(exports, 'default', {
	  enumerable: true,
	  get: function get() {
	    return _interopRequireDefault(_Signup).default;
	  }
	});

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/***/ },
/* 225 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	
	var _PatientList = __webpack_require__(222);
	
	Object.defineProperty(exports, 'default', {
	  enumerable: true,
	  get: function get() {
	    return _interopRequireDefault(_PatientList).default;
	  }
	});

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/***/ },
/* 226 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	
	var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();
	
	var _react = __webpack_require__(2);
	
	var _react2 = _interopRequireDefault(_react);
	
	var _Temperature = __webpack_require__(124);
	
	var _Temperature2 = _interopRequireDefault(_Temperature);
	
	var _BloodPressure = __webpack_require__(122);
	
	var _BloodPressure2 = _interopRequireDefault(_BloodPressure);
	
	var _Pulse = __webpack_require__(123);
	
	var _Pulse2 = _interopRequireDefault(_Pulse);
	
	var _Weight = __webpack_require__(125);
	
	var _Weight2 = _interopRequireDefault(_Weight);
	
	var _Edit = __webpack_require__(213);
	
	var _Edit2 = _interopRequireDefault(_Edit);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
	
	function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }
	
	function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }
	
	// import Medication from '../../components/Patient/Medication';
	// import Temperature from '../../components/Patient/Temperature';
	// import Weight from '../../components/Patient/Weight';
	// import Pulse from '../../components/Patient/Pulse';
	// import BloodPressure from '../../components/Patient/BloodPressure';
	
	
	// import { Tab, Tabs, TabList, TabPanel } from 'react-tabs';
	
	// import Logout from'../../images/logout.png';
	
	// import Home_botton from'../../images/Home_botton.png';
	// import Chat_menu from'../../images/Chat_menu.png';
	// import Settings_wheel from'../../images/settings_wheel.png';
	
	
	var PatientProfile = function (_React$PureComponent) {
	  _inherits(PatientProfile, _React$PureComponent);
	
	  function PatientProfile(props) {
	    _classCallCheck(this, PatientProfile);
	
	    var _this = _possibleConstructorReturn(this, (PatientProfile.__proto__ || Object.getPrototypeOf(PatientProfile)).call(this, props));
	
	    _this.beautify_timestamp = function (unix_timestamp) {
	      var a = new Date(Number(unix_timestamp));
	      var months = ['Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun', 'Jul', 'Aug', 'Sep', 'Oct', 'Nov', 'Dec'];
	      var year = a.getFullYear();
	      var month = months[a.getMonth()];
	      var date = a.getDate();
	      var time = date + ' ' + month + ' ' + year;
	
	      return time;
	    };
	
	    _this.getMissed = function (med) {
	      var missed_array = [];
	
	      med.missed.forEach(function (miss) {
	        missed_array.push(miss);
	      });
	      med.history.forEach(function (obj) {
	        if (!obj.measured) {
	          obj.from = obj.timestamp;
	          obj.to = obj.timestamp + 24 * 60 * 60 * 1000 * med.duration;
	          missed_array.push(obj);
	        }
	      });
	
	      return missed_array.sort(function (x, y) {
	        return x.timestamp - y.timestamp;
	      });
	    };
	
	    _this.state = {
	      error: false,
	      isLoaded: false,
	      edit: false
	    };
	    return _this;
	  }
	
	  _createClass(PatientProfile, [{
	    key: 'componentDidUpdate',
	    value: function componentDidUpdate(prevProps, prevState) {
	      window.scrollTo({ top: 0 });
	    }
	  }, {
	    key: 'render',
	    value: function render() {
	      var _this2 = this;
	
	      document.title = "Profile - " + this.props.selectedPatient.firstname + ' ' + this.props.selectedPatient.lastname;
	
	      if (this.state.edit) {
	        return _react2.default.createElement(_Edit2.default, { patientClicked: this.props.selectedPatient, zuruck: function zuruck(e) {
	            return _this2.setState({ edit: false });
	          } });
	      }
	      return _react2.default.createElement(
	        'div',
	        { className: 'row' },
	        _react2.default.createElement(
	          'div',
	          { className: 'col-12' },
	          _react2.default.createElement(
	            'p',
	            { className: 'goback', onClick: function onClick() {
	                return _this2.props.goBack();
	              } },
	            ' \u27F6'
	          ),
	          _react2.default.createElement(
	            'button',
	            { className: 'importbutton_dkg', style: { border: '2px solid', marginRight: '10px', padding: '3px 12px', borderRadius: '15px', marginTop: '5px', cursor: 'pointer', float: 'right' }, onClick: function onClick(e) {
	                return _this2.setState({ edit: true });
	              } },
	            'Edit'
	          ),
	          _react2.default.createElement(
	            'p',
	            { style: { marginTop: '10px', fontSize: '19px', fontWeight: 'bold' } },
	            this.props.selectedPatient.firstname + ' ' + this.props.selectedPatient.lastname
	          ),
	          _react2.default.createElement(
	            'p',
	            { style: { marginTop: '10px', fontSize: '19px' } },
	            'Medication:'
	          ),
	          _react2.default.createElement(
	            'div',
	            { className: 'container-fluid', style: { backgroundColor: '#f7f7f7', borderRadius: '7px' } },
	            Object.values(this.props.selectedPatient.medication.medication).map(function (med) {
	              return _react2.default.createElement(
	                'div',
	                { className: 'row', style: { marginTop: '20px' } },
	                _react2.default.createElement(
	                  'div',
	                  { className: 'col-12' },
	                  _react2.default.createElement(
	                    'p',
	                    { style: { color: 'black' } },
	                    ' ',
	                    _react2.default.createElement(
	                      'b',
	                      null,
	                      med.title
	                    ),
	                    ' - ',
	                    med.amount,
	                    ' every ',
	                    med.duration,
	                    ' day.'
	                  )
	                ),
	                _react2.default.createElement(
	                  'div',
	                  { className: 'col-6' },
	                  _react2.default.createElement(
	                    'p',
	                    { style: { color: 'black' } },
	                    'History of confirmed intake:'
	                  ),
	                  _react2.default.createElement(
	                    'div',
	                    { className: 'row gray_background_radius_scroll' },
	                    med.history.map(function (obj) {
	                      return _react2.default.createElement(
	                        'p',
	                        null,
	                        ' - Taken on ',
	                        _this2.beautify_timestamp(obj.timestamp),
	                        '.'
	                      );
	                    })
	                  )
	                ),
	                _react2.default.createElement(
	                  'div',
	                  { className: 'col-6' },
	                  _react2.default.createElement(
	                    'p',
	                    { style: { color: 'black' } },
	                    'Missed dates:'
	                  ),
	                  _react2.default.createElement(
	                    'div',
	                    { className: 'row gray_background_radius_scroll' },
	                    _this2.getMissed(med).map(function (obj) {
	                      return _react2.default.createElement(
	                        'p',
	                        null,
	                        ' - Missed on ',
	                        _this2.beautify_timestamp(obj.from),
	                        '. '
	                      );
	                    })
	                  )
	                )
	              );
	            })
	          ),
	          _react2.default.createElement(
	            'p',
	            { style: { marginTop: '10px', fontSize: '19px' } },
	            'Physical State:'
	          ),
	          _react2.default.createElement(_Temperature2.default, { temperatures: this.props.selectedPatient.health.temperatures }),
	          _react2.default.createElement(_BloodPressure2.default, { blood_pressures: this.props.selectedPatient.health.blood_pressures }),
	          _react2.default.createElement(_Pulse2.default, { pulses: this.props.selectedPatient.health.pulses }),
	          _react2.default.createElement(_Weight2.default, { weights: this.props.selectedPatient.health.weights })
	        )
	      );
	    }
	  }]);
	
	  return PatientProfile;
	}(_react2.default.PureComponent);
	
	exports.default = PatientProfile;

/***/ },
/* 227 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	    value: true
	});
	
	var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();
	
	var _react = __webpack_require__(2);
	
	var _react2 = _interopRequireDefault(_react);
	
	var _echarts = __webpack_require__(6);
	
	var _echarts2 = _interopRequireDefault(_echarts);
	
	__webpack_require__(35);
	
	__webpack_require__(15);
	
	__webpack_require__(14);
	
	__webpack_require__(23);
	
	__webpack_require__(64);
	
	__webpack_require__(19);
	
	var _jquery = __webpack_require__(16);
	
	var _jquery2 = _interopRequireDefault(_jquery);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
	
	function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }
	
	function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }
	
	// import ECharts
	
	
	//Aufruf von $ Zeichen 
	
	
	var BloodPressure = function (_React$PureComponent) {
	    _inherits(BloodPressure, _React$PureComponent);
	
	    function BloodPressure(props) {
	        _classCallCheck(this, BloodPressure);
	
	        var _this = _possibleConstructorReturn(this, (BloodPressure.__proto__ || Object.getPrototypeOf(BloodPressure)).call(this, props));
	
	        _this.create_graph = function () {
	            //  currentDate
	
	            var currentDate = new Date();
	            // old7Datetimestample
	            var days7before = currentDate.setDate(currentDate.getDate() - 28); //  最终获得的 old7Date 是时间戳 
	            var history = _this.props.blood_pressures.history;
	            var jsonData = { bloodpres: history };
	
	            var truejsonData = jsonData.bloodpres.filter(function (obj) {
	                return obj.timestamp > days7before;
	            });
	
	            function timeformater(ts) {
	                var date = new Date(ts);
	                var Y = date.getFullYear() + '.';
	                var M = (date.getMonth() + 1 < 10 ? '0' + (date.getMonth() + 1) : date.getMonth() + 1) + '.';
	                var D = date.getDate();
	                var result = Y + M + D;
	                return result;
	            }
	
	            var timelist = new Array(28);
	            for (var i = 0; i < 28; i++) {
	                var _currentDate = new Date();
	                var data = _currentDate.setDate(_currentDate.getDate() - i);
	                timelist[i] = timeformater(data);
	            }
	            timelist = timelist.reverse();
	
	            var templist1 = Array(28);
	            var templist2 = Array(28);
	
	            truejsonData.forEach(function (item, index, arr) {
	                //db中近7天的array 可能只有3天
	                var i = timelist.indexOf(timeformater(item.timestamp)); //richtige x axis daten value index
	                if (i > -1) {
	                    //wenn an dem Tag etwas in DB erschienen 
	                    if (item.measured !== false) {
	                        templist1[i] = item.bloodpres_dia;
	                        templist2[i] = item.bloodpres_sys;
	                    } // wenn measured nicht false dann ersetzt die richtige weight dadrauf
	                }
	            });
	
	            var option = {
	                title: [{
	                    left: 'center',
	                    text: '(sys.) blood pressure last 28 days'
	                }, {
	                    top: '45%',
	                    left: 'center',
	                    text: '(dia. ) blood pressure last 28 days'
	                }],
	                dataZoom: [{
	                    show: true,
	                    realtime: true,
	                    start: 0,
	                    end: 100,
	                    xAxisIndex: [0, 1]
	                }, {
	                    type: 'slider',
	                    start: 0,
	                    end: 100,
	                    xAxisIndex: [0, 1]
	                }],
	                tooltip: {
	                    trigger: 'axis',
	                    position: function position(pt) {
	                        return [pt[0], '10%'];
	                    }
	                },
	                xAxis: [{
	                    data: timelist,
	                    gridIndex: 0,
	                    axisTick: { show: false }
	                }, {
	                    data: timelist,
	                    gridIndex: 1,
	                    axisTick: { show: false }
	                }],
	                yAxis: [{
	                    axisLine: { show: false },
	                    axisLabel: { show: false },
	                    splitLine: { show: false },
	                    axisTick: { show: false },
	                    type: 'value',
	                    gridIndex: 0,
	                    min: function min(extent) {
	                        return extent.min < 100 ? extent.min : 100;
	                    }
	                }, {
	                    axisLine: { show: false },
	                    axisLabel: { show: false },
	                    splitLine: { show: false },
	                    axisTick: { show: false },
	                    type: 'value',
	                    gridIndex: 1,
	                    min: function min(extent) {
	                        return extent.min < 70 ? extent.min : 70;
	                    }
	                }],
	                grid: [{
	                    bottom: '60%'
	                }, {
	                    top: '60%'
	                }],
	                series: [{
	                    name: "sys",
	                    connectNulls: true,
	                    type: 'line',
	                    data: templist1,
	                    xAxisIndex: 0,
	                    yAxisIndex: 0
	                }, {
	                    name: "dia",
	                    connectNulls: true,
	                    type: 'line',
	                    data: templist2,
	                    xAxisIndex: 1,
	                    yAxisIndex: 1
	                }]
	            };
	
	            var myChart = _echarts2.default.init(document.getElementById('blood_pressure_graph'));
	            myChart.setOption(option);
	            //fuer bootstrap layout
	            (0, _jquery2.default)(window).on('resize', function () {
	                if (myChart !== null && myChart !== undefined) {
	                    myChart.resize();
	                }
	            });
	        };
	
	        _this.beautify_timestamp = function (unix_timestamp) {
	            var a = new Date(Number(unix_timestamp));
	            var months = ['Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun', 'Jul', 'Aug', 'Sep', 'Oct', 'Nov', 'Dec'];
	            var year = a.getFullYear();
	            var month = months[a.getMonth()];
	            var date = a.getDate();
	            var time = date + ' ' + month + ' ' + year;
	
	            return time;
	        };
	
	        return _this;
	    }
	
	    _createClass(BloodPressure, [{
	        key: 'componentDidMount',
	        value: function componentDidMount() {
	            this.create_graph();
	        }
	    }, {
	        key: 'componentDidUpdate',
	        value: function componentDidUpdate(prevProps, prevState) {
	            this.create_graph();
	        }
	    }, {
	        key: 'render',
	        value: function render() {
	            return _react2.default.createElement(
	                'div',
	                { className: 'container-fluid', style: { backgroundColor: '#f7f7f7', marginTop: '-20px', borderRadius: '7px' } },
	                _react2.default.createElement(
	                    'div',
	                    { className: 'patient_health_status_doctor', style: { marginTop: '50px', paddingRight: '0', paddingLeft: '0' } },
	                    _react2.default.createElement(
	                        'div',
	                        { className: 'row' },
	                        _react2.default.createElement(
	                            'div',
	                            { className: 'col-md-12 col-xs-12 col-sm-12', style: { padding: '0' } },
	                            _react2.default.createElement('div', { id: 'blood_pressure_graph', style: { width: '100%', minHeight: '400px' } })
	                        )
	                    )
	                )
	            );
	        }
	    }]);
	
	    return BloodPressure;
	}(_react2.default.PureComponent);
	
	exports.default = BloodPressure;

/***/ },
/* 228 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	    value: true
	});
	
	var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();
	
	var _react = __webpack_require__(2);
	
	var _react2 = _interopRequireDefault(_react);
	
	var _echarts = __webpack_require__(6);
	
	var _echarts2 = _interopRequireDefault(_echarts);
	
	__webpack_require__(35);
	
	__webpack_require__(15);
	
	__webpack_require__(14);
	
	__webpack_require__(23);
	
	__webpack_require__(64);
	
	__webpack_require__(19);
	
	var _jquery = __webpack_require__(16);
	
	var _jquery2 = _interopRequireDefault(_jquery);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
	
	function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }
	
	function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }
	
	// import ECharts
	
	
	//Aufruf von $ Zeichen 
	
	
	var Pulse = function (_React$PureComponent) {
	    _inherits(Pulse, _React$PureComponent);
	
	    function Pulse(props) {
	        _classCallCheck(this, Pulse);
	
	        var _this = _possibleConstructorReturn(this, (Pulse.__proto__ || Object.getPrototypeOf(Pulse)).call(this, props));
	
	        _this.create_graph = function () {
	            var currentDate = new Date();
	            // old7Datetimestample
	            var history = _this.props.pulses.history;
	            var jsonData = { pulse: history };
	            var days7before = currentDate.setDate(currentDate.getDate() - 28); //  最终获得的 old7Date 是时间戳 
	            //console.log(days7before)    
	            var truejsonData = jsonData.pulse.filter(function (obj) {
	                return obj.timestamp > days7before;
	            });
	            console.log(truejsonData);
	
	            function timeformater(ts) {
	                var date = new Date(ts);
	                var Y = date.getFullYear() + '.';
	                var M = (date.getMonth() + 1 < 10 ? '0' + (date.getMonth() + 1) : date.getMonth() + 1) + '.';
	                var D = date.getDate();
	                var result = Y + M + D;
	                return result;
	            }
	
	            var timelist = new Array(28);
	            for (var i = 0; i < 28; i++) {
	                var _currentDate = new Date();
	                var data = _currentDate.setDate(_currentDate.getDate() - i);
	                timelist[i] = timeformater(data);
	            }
	            timelist = timelist.reverse();
	
	            var templist = new Array(28);
	            truejsonData.reverse().forEach(function (item, index, arr) {
	                //db中近7天的array 可能只有3天
	                var i = timelist.indexOf(timeformater(item.timestamp)); //richtige x axis daten value index
	                if (i > -1) {
	                    //wenn an dem Tag etwas in DB erschienen 
	                    templist[i] = item.pulse;
	                    // wenn measured nicht false dann ersetzt die richtige weight dadrauf
	                }
	            });
	
	            //graph infos
	            var option = {
	                color: '#800000',
	                title: {
	                    left: 'center',
	                    text: 'pulse last 28 days' },
	                xAxis: {
	                    data: timelist,
	                    axisTick: { show: false }
	
	                },
	                yAxis: {
	                    axisLine: { show: false },
	                    axisLabel: { show: false },
	                    splitLine: { show: false },
	                    axisTick: { show: false },
	                    type: 'value',
	                    min: function min(extent) {
	                        return extent.min <= 30 ? extent.min - 5 : 30;
	                    }
	                    // max: extent => extent.max >130 ? extent.max+1 : 130
	                },
	                dataZoom: [{
	                    type: 'slider',
	                    start: 0,
	                    end: 100
	                }],
	                tooltip: {
	                    trigger: 'axis',
	                    position: function position(pt) {
	                        return [pt[0], '10%'];
	                    }
	                },
	                series: [{
	                    connectNulls: true,
	                    name: 'pulse',
	                    type: 'line',
	                    data: templist
	
	                }]
	            };
	
	            var myChart = _echarts2.default.init(document.getElementById('pulse_graph'));
	            myChart.setOption(option);
	            //fuer bootstrap layout
	            (0, _jquery2.default)(window).on('resize', function () {
	                if (myChart !== null && myChart !== undefined) {
	                    myChart.resize();
	                }
	            });
	        };
	
	        _this.beautify_timestamp = function (unix_timestamp) {
	            var a = new Date(Number(unix_timestamp));
	            var months = ['Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun', 'Jul', 'Aug', 'Sep', 'Oct', 'Nov', 'Dec'];
	            var year = a.getFullYear();
	            var month = months[a.getMonth()];
	            var date = a.getDate();
	            var time = date + ' ' + month + ' ' + year;
	
	            return time;
	        };
	
	        return _this;
	    }
	
	    _createClass(Pulse, [{
	        key: 'componentDidMount',
	        value: function componentDidMount() {
	            window.scrollTo({ top: 0 });
	            this.create_graph();
	        }
	    }, {
	        key: 'componentDidUpdate',
	        value: function componentDidUpdate(prevProps, prevState) {
	            this.create_graph();
	        }
	    }, {
	        key: 'render',
	        value: function render() {
	
	            return _react2.default.createElement(
	                'div',
	                { className: 'container-fluid', style: { backgroundColor: '#f7f7f7', marginTop: '-20px', borderRadius: '7px' } },
	                _react2.default.createElement(
	                    'div',
	                    { className: 'patient_health_status_doctor', style: { marginTop: '50px' } },
	                    _react2.default.createElement(
	                        'div',
	                        { className: 'row' },
	                        _react2.default.createElement(
	                            'div',
	                            { className: 'col-md-12 col-xs-12 col-sm-12' },
	                            _react2.default.createElement('div', { id: 'pulse_graph', style: { width: '100%', minHeight: '400px' } })
	                        )
	                    )
	                )
	            );
	        }
	    }]);
	
	    return Pulse;
	}(_react2.default.PureComponent);
	
	exports.default = Pulse;

/***/ },
/* 229 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	    value: true
	});
	
	var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();
	
	var _react = __webpack_require__(2);
	
	var _react2 = _interopRequireDefault(_react);
	
	var _echarts = __webpack_require__(6);
	
	var _echarts2 = _interopRequireDefault(_echarts);
	
	__webpack_require__(38);
	
	__webpack_require__(19);
	
	__webpack_require__(15);
	
	__webpack_require__(14);
	
	__webpack_require__(46);
	
	__webpack_require__(64);
	
	var _jquery = __webpack_require__(16);
	
	var _jquery2 = _interopRequireDefault(_jquery);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
	
	function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }
	
	function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }
	
	// import ECharts
	
	
	//Aufruf von $ Zeichen 
	
	
	var Temperature = function (_React$PureComponent) {
	    _inherits(Temperature, _React$PureComponent);
	
	    function Temperature(props) {
	        _classCallCheck(this, Temperature);
	
	        var _this = _possibleConstructorReturn(this, (Temperature.__proto__ || Object.getPrototypeOf(Temperature)).call(this, props));
	
	        _this.create_graph = function () {
	            //  currentDate
	            var currentDate = new Date();
	            var history = _this.props.temperatures.history;
	            var jsonData = { temperature: history
	                // old7Datetimestample
	            };var days7before = currentDate.setDate(currentDate.getDate() - 28); //  最终获得的 old7Date 是时间戳 
	            //console.log(days7before)    
	            var truejsonData = jsonData.temperature.filter(function (obj) {
	                return obj.timestamp > days7before;
	            });
	            // console.log(truejsonData)
	
	
	            function timeformater(ts) {
	                var date = new Date(ts);
	                var Y = date.getFullYear() + '.';
	                var M = (date.getMonth() + 1 < 10 ? '0' + (date.getMonth() + 1) : date.getMonth() + 1) + '.';
	                var D = date.getDate();
	                var result = Y + M + D;
	                return result;
	            }
	
	            var timelist = new Array(28);
	            for (var i = 0; i < 28; i++) {
	                var _currentDate = new Date();
	                var data = _currentDate.setDate(_currentDate.getDate() - i);
	                timelist[i] = timeformater(data);
	            }
	            timelist = timelist.reverse();
	
	            var templist = new Array(28);
	            truejsonData.reverse().forEach(function (item, index, arr) {
	                //db中近7天的array 可能只有3天
	                var i = timelist.indexOf(timeformater(item.timestamp)); //richtige x axis daten value index
	                if (i > -1 && item.measured !== false) {
	                    //wenn an dem Tag etwas in DB erschienen 
	                    templist[i] = item.temperature;
	                    // wenn measured nicht false dann ersetzt die richtige weight dadrauf
	                }
	            });
	
	            //graph infos
	            var option = {
	                color: 'black',
	                title: {
	                    left: 'center',
	                    text: 'Temperature last 28 days' },
	                xAxis: {
	                    data: timelist,
	                    axisTick: { show: false }
	                },
	                yAxis: {
	                    axisLine: { show: false },
	                    axisLabel: { show: false },
	                    splitLine: { show: false },
	                    axisTick: { show: false },
	                    type: 'value',
	                    min: function min(extent) {
	                        return extent.min <= 34 ? extent.min - 1 : 33;
	                    },
	                    max: function max(extent) {
	                        return extent.max > 37.5 ? extent.max : 37.5;
	                    }
	                },
	                dataZoom: [{
	                    type: 'slider',
	                    start: 0,
	                    end: 100
	                }],
	                tooltip: {
	                    trigger: 'axis',
	                    position: function position(pt) {
	                        return [pt[0], '10%'];
	                    }
	                },
	                series: [{
	                    name: 'temperature',
	                    type: 'bar',
	                    data: templist,
	                    itemStyle: {
	                        normal: {
	                            color: function color(params) {
	                                if (params.value > 37.5) {
	                                    return "#DC143C";
	                                } else if (params.value >= 36.5 && params.value <= 37.5) {
	                                    return "#32CD32";
	                                } else if (params.value < 36.5) {
	                                    return "#FFA500";
	                                } else return 'black';
	                            }
	                        }
	                    },
	                    markLine: {
	                        symbol: "none",
	                        data: [{
	
	                            lineStyle: { //警戒线的样式  ，虚实  颜色
	                                type: "solid",
	                                color: "#FA3934"
	                            },
	                            label: {
	                                textStyle: {
	                                    fontWeight: "bolder",
	                                    color: 'black',
	                                    fontSize: "7"
	                                },
	                                position: 'start',
	                                formatter: "37.5°C"
	                            },
	                            yAxis: 37.5
	
	                        }, {
	
	                            lineStyle: { //警戒线的样式  ，虚实  颜色
	                                type: "solid",
	                                color: "green"
	                            },
	                            label: {
	                                textStyle: {
	                                    fontWeight: "bolder",
	                                    color: 'black',
	                                    fontSize: "7"
	                                },
	                                position: 'start',
	                                formatter: "36.5 °C"
	                            },
	                            yAxis: 36.5
	
	                        }]
	                    }
	                }]
	            };
	
	            var myChart = _echarts2.default.init(document.getElementById('temperature_graph'));
	            myChart.setOption(option);
	            //fuer bootstrap layout
	            (0, _jquery2.default)(window).on('resize', function () {
	                if (myChart !== null && myChart !== undefined) {
	                    myChart.resize();
	                }
	            });
	        };
	
	        _this.beautify_timestamp = function (unix_timestamp) {
	            var a = new Date(Number(unix_timestamp));
	            var months = ['Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun', 'Jul', 'Aug', 'Sep', 'Oct', 'Nov', 'Dec'];
	            var year = a.getFullYear();
	            var month = months[a.getMonth()];
	            var date = a.getDate();
	            var time = date + ' ' + month + ' ' + year;
	
	            return time;
	        };
	
	        _this.state = {};
	        return _this;
	    }
	
	    _createClass(Temperature, [{
	        key: 'componentDidMount',
	        value: function componentDidMount() {
	            this.create_graph();
	        }
	    }, {
	        key: 'componentDidUpdate',
	        value: function componentDidUpdate(prevProps, prevState) {
	            if (!this.state.confirmPopupPending && !this.state.confirmPopupMissed) {
	                this.create_graph();
	            }
	        }
	    }, {
	        key: 'render',
	        value: function render() {
	
	            return _react2.default.createElement(
	                'div',
	                { className: 'container-fluid', style: { backgroundColor: '#f7f7f7', marginTop: '-20px', borderRadius: '7px' } },
	                _react2.default.createElement(
	                    'div',
	                    { className: 'patient_health_status_doctor', style: { marginTop: '50px' } },
	                    _react2.default.createElement(
	                        'div',
	                        { className: 'row' },
	                        _react2.default.createElement(
	                            'div',
	                            { className: 'col-md-12 col-xs-12 col-sm-12' },
	                            _react2.default.createElement('div', { id: 'temperature_graph', style: { width: '100%', minHeight: '400px' } })
	                        )
	                    )
	                )
	            );
	        }
	    }]);
	
	    return Temperature;
	}(_react2.default.PureComponent);
	
	exports.default = Temperature;

/***/ },
/* 230 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	    value: true
	});
	
	var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();
	
	var _react = __webpack_require__(2);
	
	var _react2 = _interopRequireDefault(_react);
	
	var _echarts = __webpack_require__(6);
	
	var _echarts2 = _interopRequireDefault(_echarts);
	
	__webpack_require__(38);
	
	__webpack_require__(19);
	
	__webpack_require__(15);
	
	__webpack_require__(14);
	
	__webpack_require__(46);
	
	var _jquery = __webpack_require__(16);
	
	var _jquery2 = _interopRequireDefault(_jquery);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
	
	function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }
	
	function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }
	
	// import ECharts
	
	
	//Aufruf von $ Zeichen 
	
	
	var BloodPressure = function (_React$PureComponent) {
	    _inherits(BloodPressure, _React$PureComponent);
	
	    function BloodPressure(props) {
	        _classCallCheck(this, BloodPressure);
	
	        var _this = _possibleConstructorReturn(this, (BloodPressure.__proto__ || Object.getPrototypeOf(BloodPressure)).call(this, props));
	
	        _this.create_graph = function () {
	            //  currentDate
	            var currentDate = new Date();
	            // old7Datetimestample
	            var days7before = currentDate.setDate(currentDate.getDate() - 7); //  最终获得的 old7Date 是时间戳 
	            var history = _this.props.blood_pressures.history;
	            var jsonData = { bloodpres: history
	
	                // console.log(jsonData)
	
	            };var truejsonData = jsonData.bloodpres.filter(function (obj) {
	                return obj.timestamp > days7before;
	            });
	
	            function timeformater(ts) {
	                var date = new Date(ts);
	                var Y = date.getFullYear() + '-';
	                var M = (date.getMonth() + 1 < 10 ? '0' + (date.getMonth() + 1) : date.getMonth() + 1) + '-';
	                var D = date.getDate() + ' ';
	                var result = Y + M + D;
	                return result;
	            }
	
	            var timelist = [null, null, null, null, null, null, null];
	            timelist.forEach(function (item, index, timelist) {
	                var currentDate = new Date();
	                var data = currentDate.setDate(currentDate.getDate() - index);
	                timelist[index] = timeformater(data);
	            });
	            timelist = timelist.reverse();
	
	            var templist1 = [null, null, null, null, null, null, null];
	            var templist2 = [null, null, null, null, null, null, null];
	
	            truejsonData.forEach(function (item, index, arr) {
	                //db中近7天的array 可能只有3天
	                var i = timelist.indexOf(timeformater(item.timestamp)); //richtige x axis daten value index
	                if (i > -1) {
	                    //wenn an dem Tag etwas in DB erschienen 
	                    if (item.measured !== false) {
	                        templist1[i] = item.bloodpres_dia;
	                        templist2[i] = item.bloodpres_sys;
	                    } // wenn measured nicht false dann ersetzt die richtige weight dadrauf
	                }
	            });
	
	            var option = {
	                title: [{
	                    left: 'center',
	                    text: '(sys.) blood pressure'
	                }, {
	                    top: '55%',
	                    left: 'center',
	                    text: '(dia. ) blood pressure'
	                }],
	                xAxis: [{
	                    axisTick: { show: false },
	                    data: timelist,
	                    gridIndex: 0
	                }, {
	                    axisTick: { show: false },
	                    data: timelist,
	                    gridIndex: 1
	                }],
	                yAxis: [{
	                    axisLine: { show: false },
	                    axisLabel: { show: false },
	                    splitLine: { show: false },
	                    axisTick: { show: false },
	                    type: 'value',
	                    gridIndex: 0,
	                    min: function min(extent) {
	                        return extent.min < 100 ? extent.min : 100;
	                    }
	                }, {
	                    axisLine: { show: false },
	                    axisLabel: { show: false },
	                    splitLine: { show: false },
	                    axisTick: { show: false },
	                    type: 'value',
	                    gridIndex: 1,
	                    min: function min(extent) {
	                        return extent.min < 70 ? extent.min : 70;
	                    }
	                }],
	                grid: [{
	                    bottom: '60%'
	                }, {
	                    top: '60%'
	                }],
	                series: [{
	                    type: 'line',
	                    connectNulls: true,
	                    data: templist1,
	                    xAxisIndex: 0,
	                    yAxisIndex: 0,
	                    label: {
	                        normal: {
	                            show: true,
	                            position: 'top'
	                        }
	                    }
	                }, {
	                    type: 'line',
	                    connectNulls: true,
	                    data: templist2,
	                    xAxisIndex: 1,
	                    yAxisIndex: 1,
	                    label: {
	                        normal: {
	                            show: true,
	                            position: 'top'
	                        }
	                    }
	                }]
	            };
	
	            var myChart = _echarts2.default.init(document.getElementById('blood_pressure_graph'));
	            myChart.setOption(option);
	            //fuer bootstrap layout
	            (0, _jquery2.default)(window).on('resize', function () {
	                if (myChart !== null && myChart !== undefined) {
	                    myChart.resize();
	                }
	            });
	        };
	
	        _this.beautify_timestamp = function (unix_timestamp) {
	            var a = new Date(Number(unix_timestamp));
	            var months = ['Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun', 'Jul', 'Aug', 'Sep', 'Oct', 'Nov', 'Dec'];
	            var year = a.getFullYear();
	            var month = months[a.getMonth()];
	            var date = a.getDate();
	            var time = date + ' ' + month + ' ' + year;
	
	            return time;
	        };
	
	        return _this;
	    }
	
	    _createClass(BloodPressure, [{
	        key: 'componentDidMount',
	        value: function componentDidMount() {
	            this.create_graph();
	        }
	    }, {
	        key: 'componentDidUpdate',
	        value: function componentDidUpdate(prevProps, prevState) {
	            this.create_graph();
	        }
	    }, {
	        key: 'render',
	        value: function render() {
	            return _react2.default.createElement(
	                'div',
	                { className: 'patient_health_status', style: { marginTop: '50px', paddingRight: '0', paddingLeft: '0' } },
	                _react2.default.createElement(
	                    'div',
	                    { className: 'row' },
	                    _react2.default.createElement(
	                        'div',
	                        { className: 'col-md-12 col-xs-12 col-sm-12', style: { padding: '0' } },
	                        _react2.default.createElement('div', { id: 'blood_pressure_graph', style: { width: '100%', minHeight: '400px' } })
	                    )
	                )
	            );
	        }
	    }]);
	
	    return BloodPressure;
	}(_react2.default.PureComponent);
	
	exports.default = BloodPressure;

/***/ },
/* 231 */
[481, 230],
/* 232 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	    value: true
	});
	
	var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();
	
	var _react = __webpack_require__(2);
	
	var _react2 = _interopRequireDefault(_react);
	
	var _echarts = __webpack_require__(6);
	
	var _echarts2 = _interopRequireDefault(_echarts);
	
	__webpack_require__(38);
	
	__webpack_require__(19);
	
	__webpack_require__(15);
	
	__webpack_require__(14);
	
	var _jquery = __webpack_require__(16);
	
	var _jquery2 = _interopRequireDefault(_jquery);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
	
	function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }
	
	function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }
	
	// import ECharts
	
	
	//Aufruf von $ Zeichen 
	
	
	var Pulse = function (_React$PureComponent) {
	    _inherits(Pulse, _React$PureComponent);
	
	    function Pulse(props) {
	        _classCallCheck(this, Pulse);
	
	        var _this = _possibleConstructorReturn(this, (Pulse.__proto__ || Object.getPrototypeOf(Pulse)).call(this, props));
	
	        _this.create_graph = function () {
	            //  currentDate
	
	            var currentDate = new Date();
	            // old7Datetimestample
	            var days7before = currentDate.setDate(currentDate.getDate() - 7); //  最终获得的 old7Date 是时间戳 
	            //console.log(days7before)    
	            var history = _this.props.pulses;
	            var jsonData = { pulse: history };
	
	            var truejsonData = jsonData.pulse.filter(function (obj) {
	                return obj.timestamp > days7before;
	            });
	            console.log(truejsonData);
	
	            function timeformater(ts) {
	                var date = new Date(ts);
	                var Y = date.getFullYear() + '-';
	                var M = (date.getMonth() + 1 < 10 ? '0' + (date.getMonth() + 1) : date.getMonth() + 1) + '-';
	                var D = date.getDate() + ' ';
	                var result = Y + M + D;
	                return result;
	            }
	
	            var timelist = [null, null, null, null, null, null, null];
	            timelist.forEach(function (item, index, timelist) {
	                var currentDate = new Date();
	                var data = currentDate.setDate(currentDate.getDate() - index);
	                timelist[index] = timeformater(data);
	            });
	            timelist = timelist.reverse();
	
	            var templist = [null, null, null, null, null, null, null];
	            truejsonData.reverse().forEach(function (item, index, arr) {
	                //db中近7天的array 可能只有3天
	                var i = timelist.indexOf(timeformater(item.timestamp)); //richtige x axis daten value index
	                if (i > -1) {
	                    //wenn an dem Tag etwas in DB erschienen 
	                    templist[i] = item.pulse;
	                    // wenn measured nicht false dann ersetzt die richtige weight dadrauf
	                }
	            });
	            //graph infos
	            var option = {
	                color: '#800000',
	                title: {
	                    left: 'center',
	                    text: 'pulse last 7 Days per minute' },
	                xAxis: {
	                    data: timelist,
	                    axisTick: { show: false }
	
	                },
	                yAxis: {
	                    axisLabel: { show: false },
	                    splitLine: { show: false },
	                    axisTick: { show: false },
	                    type: 'value'
	                    // min: extent => extent.min <=70 ? extent.min-5 : 70,
	                    // max: extent => extent.max >130 ? extent.max+1 : 130
	                },
	                series: [{
	                    connectNulls: true, //laesst sich null wert nicht leer sein 
	                    name: 'pulse',
	                    type: 'line',
	                    data: templist,
	                    label: {
	                        show: true,
	                        position: 'top',
	                        formatter: '{c}' //echarts selbst build in variable fuer valu
	
	                    }
	                }]
	            };
	
	            var myChart = _echarts2.default.init(document.getElementById('pulse_graph'));
	            myChart.setOption(option);
	            //fuer bootstrap layout
	            (0, _jquery2.default)(window).on('resize', function () {
	                if (myChart !== null && myChart !== undefined) {
	                    myChart.resize();
	                }
	            });
	        };
	
	        _this.beautify_timestamp = function (unix_timestamp) {
	            var a = new Date(Number(unix_timestamp));
	            var months = ['Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun', 'Jul', 'Aug', 'Sep', 'Oct', 'Nov', 'Dec'];
	            var year = a.getFullYear();
	            var month = months[a.getMonth()];
	            var date = a.getDate();
	            var time = date + ' ' + month + ' ' + year;
	
	            return time;
	        };
	
	        _this.state = {
	            pendingMedication: _this.props.pendingMedication,
	            confirmPopupPending: false,
	            confirmPopupMissed: false,
	            popupMissedTimestampFrom: '',
	            popupMissedTimestampTo: '',
	            history_bool: false
	        };
	        return _this;
	    }
	
	    _createClass(Pulse, [{
	        key: 'componentDidMount',
	        value: function componentDidMount() {
	            window.scrollTo({ top: 0 });
	            this.create_graph();
	        }
	    }, {
	        key: 'render',
	        value: function render() {
	
	            return _react2.default.createElement(
	                'div',
	                { className: 'patient_health_status', style: { marginTop: '50px' } },
	                _react2.default.createElement(
	                    'div',
	                    { className: 'row' },
	                    _react2.default.createElement(
	                        'div',
	                        { className: 'col-md-12 col-xs-12 col-sm-12' },
	                        _react2.default.createElement('div', { id: 'pulse_graph', style: { width: '100%', minHeight: '400px' } })
	                    )
	                )
	            );
	        }
	    }]);
	
	    return Pulse;
	}(_react2.default.PureComponent);
	
	exports.default = Pulse;

/***/ },
/* 233 */
[478, 232],
/* 234 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	    value: true
	});
	
	var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();
	
	var _react = __webpack_require__(2);
	
	var _react2 = _interopRequireDefault(_react);
	
	var _echarts = __webpack_require__(6);
	
	var _echarts2 = _interopRequireDefault(_echarts);
	
	__webpack_require__(38);
	
	__webpack_require__(19);
	
	__webpack_require__(15);
	
	__webpack_require__(14);
	
	__webpack_require__(46);
	
	__webpack_require__(23);
	
	var _jquery = __webpack_require__(16);
	
	var _jquery2 = _interopRequireDefault(_jquery);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
	
	function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }
	
	function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }
	
	// import ECharts
	
	
	//Aufruf von $ Zeichen 
	
	
	var Weight = function (_React$PureComponent) {
	    _inherits(Weight, _React$PureComponent);
	
	    function Weight(props) {
	        _classCallCheck(this, Weight);
	
	        var _this = _possibleConstructorReturn(this, (Weight.__proto__ || Object.getPrototypeOf(Weight)).call(this, props));
	
	        _this.create_graph = function () {
	            var history = _this.props.weights.history;
	            var jsonData = { weight: history
	                //  currentDate
	            };var currentDate = new Date();
	            // old7Datetimestample
	            var days7before = currentDate.setDate(currentDate.getDate() - 7); //  最终获得的 old7Date 是时间戳    
	
	            var truejsonData = jsonData.weight.filter(function (obj) {
	                return obj.timestamp > days7before;
	            });
	
	            function timeformater(ts) {
	                var date = new Date(ts);
	                var Y = date.getFullYear() + '-';
	                var M = (date.getMonth() + 1 < 10 ? '0' + (date.getMonth() + 1) : date.getMonth() + 1) + '-';
	                var D = date.getDate() + ' ';
	                var result = Y + M + D;
	                return result;
	            }
	
	            var timelist = [null, null, null, null, null, null, null];
	            timelist.forEach(function (item, index, timelist) {
	                var currentDate = new Date();
	                var data = currentDate.setDate(currentDate.getDate() - index);
	                timelist[index] = timeformater(data);
	            });
	            timelist = timelist.reverse();
	
	            var templist1 = [null, null, null, null, null, null, null];
	            var templist2 = [null, null, null, null, null, null, null];
	            var hilfsweight = null;
	            truejsonData.forEach(function (item, index, arr) {
	                //db中近7天的array 可能只有3天
	                var i = timelist.indexOf(timeformater(item.timestamp)); //richtige x axis daten value index
	                if (i > -1) {
	                    //wenn an dem Tag etwas in DB erschienen 
	                    if (item.measured !== false) {
	                        templist1[i] = (item.weight * 0.1).toFixed(2);
	                    } // wenn measured nicht false dann ersetzt die richtige weight dadrauf
	                    if (i === 0 && item.measured !== false) {
	                        hilfsweight = item.weight.toFixed(2);
	                    } //first keine Aenderung erst ab zweite, wenn erste value hat dann hilfswert weist hinzu
	                    else if (item.measured !== false) {
	                            if (hilfsweight === null) {
	                                hilfsweight = item.weight.toFixed(2);
	                            } else {
	                                templist2[i] = ((item.weight - hilfsweight) * 10).toFixed(2);
	                                hilfsweight = item.weight.toFixed(2);
	                            }
	                        }
	                }
	            });
	
	            var option = {
	
	                title: {
	                    left: 'center',
	                    text: 'Weight last 7 Days in Kg'
	                },
	                legend: {
	                    top: "6%",
	                    left: 'right',
	                    data: ['weight', 'change']
	                },
	                xAxis: {
	
	                    type: 'category',
	
	                    axisTick: { show: false },
	                    data: timelist
	
	                },
	                yAxis: {
	
	                    axisLabel: { show: false },
	                    splitLine: { show: false },
	                    axisTick: { show: false },
	                    type: 'value'
	
	                },
	                series: [{
	                    name: 'weight',
	                    type: 'bar',
	                    data: templist1,
	                    stack: 'weightgain',
	
	                    label: {
	                        textStyle: {
	                            fontWeight: "bolder",
	                            fontSize: "8"
	                        },
	                        show: true,
	                        position: 'inside',
	                        formatter: function formatter(params) {
	                            return (params.value * 10).toFixed(2);
	                        }
	                    }
	                }, {
	                    name: 'change',
	                    type: 'bar',
	                    data: templist2,
	                    stack: 'weightgain',
	
	                    label: {
	                        textStyle: {
	                            fontWeight: "bolder",
	                            fontSize: "8"
	                        },
	                        show: true,
	                        position: 'inside',
	                        formatter: function formatter(params) {
	                            return (params.value / 10).toFixed(2);
	                        }
	
	                    }
	                }]
	            };
	
	            var myChart = _echarts2.default.init(document.getElementById('weight_graph'));
	            myChart.setOption(option);
	            //fuer bootstrap layout
	            (0, _jquery2.default)(window).on('resize', function () {
	                if (myChart !== null && myChart !== undefined) {
	                    myChart.resize();
	                }
	            });
	        };
	
	        _this.beautify_timestamp = function (unix_timestamp) {
	            var a = new Date(Number(unix_timestamp));
	            var months = ['Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun', 'Jul', 'Aug', 'Sep', 'Oct', 'Nov', 'Dec'];
	            var year = a.getFullYear();
	            var month = months[a.getMonth()];
	            var date = a.getDate();
	            var time = date + ' ' + month + ' ' + year;
	
	            return time;
	        };
	
	        return _this;
	    }
	
	    _createClass(Weight, [{
	        key: 'componentDidMount',
	        value: function componentDidMount() {
	            this.create_graph();
	        }
	    }, {
	        key: 'componentDidUpdate',
	        value: function componentDidUpdate(prevProps, prevState) {
	            this.create_graph();
	        }
	    }, {
	        key: 'render',
	        value: function render() {
	
	            return _react2.default.createElement(
	                'div',
	                { className: 'patient_health_status', style: { marginTop: '50px', paddingRight: '0', paddingLeft: '0' } },
	                _react2.default.createElement(
	                    'div',
	                    { className: 'row' },
	                    _react2.default.createElement(
	                        'div',
	                        { className: 'col-md-12 col-xs-12 col-sm-12', style: { padding: '0' } },
	                        _react2.default.createElement('div', { id: 'weight_graph', style: { width: '100%', minHeight: '400px' } })
	                    )
	                )
	            );
	        }
	    }]);
	
	    return Weight;
	}(_react2.default.PureComponent);
	
	exports.default = Weight;

/***/ },
/* 235 */
[480, 234],
/* 236 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	    value: true
	});
	
	var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();
	
	var _react = __webpack_require__(2);
	
	var _react2 = _interopRequireDefault(_react);
	
	var _echarts = __webpack_require__(6);
	
	var _echarts2 = _interopRequireDefault(_echarts);
	
	__webpack_require__(38);
	
	__webpack_require__(19);
	
	__webpack_require__(15);
	
	__webpack_require__(14);
	
	__webpack_require__(46);
	
	__webpack_require__(64);
	
	var _jquery = __webpack_require__(16);
	
	var _jquery2 = _interopRequireDefault(_jquery);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
	
	function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }
	
	function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }
	
	// import ECharts
	
	
	//Aufruf von $ Zeichen 
	
	
	var Weight = function (_React$PureComponent) {
	    _inherits(Weight, _React$PureComponent);
	
	    function Weight(props) {
	        _classCallCheck(this, Weight);
	
	        var _this = _possibleConstructorReturn(this, (Weight.__proto__ || Object.getPrototypeOf(Weight)).call(this, props));
	
	        _this.create_graph = function () {
	            var history = _this.props.weights.history;
	            var jsonData = { weight: history
	                //  currentDate
	            };var currentDate = new Date();
	            // old7Datetimestample
	            var days7before = currentDate.setDate(currentDate.getDate() - 90); //  最终获得的 old7Date 是时间戳 
	            //console.log(days7before)    
	
	            var truejsonData = jsonData.weight.filter(function (obj) {
	                return obj.timestamp > days7before;
	            });
	            //console.log(truejsonData)
	
	            function timeformater(ts) {
	                var date = new Date(ts);
	                var Y = date.getFullYear() + '.';
	                var M = (date.getMonth() + 1 < 10 ? '0' + (date.getMonth() + 1) : date.getMonth() + 1) + '.';
	                var D = date.getDate();
	                var result = Y + M + D;
	                return result;
	            }
	
	            var timelist = new Array(90);
	            for (var i = 0; i < 90; i++) {
	                var _currentDate = new Date();
	                var data = _currentDate.setDate(_currentDate.getDate() - i);
	                timelist[i] = timeformater(data);
	            }
	            timelist = timelist.reverse();
	
	            var templist1 = new Array(90);
	            var templist2 = new Array(90);
	            var hilfsweight = null;
	            truejsonData.forEach(function (item, index, arr) {
	                //db中近90天的array 可能只有3天
	                var i = timelist.indexOf(timeformater(item.timestamp)); //richtige x axis daten value index
	                if (i > -1) {
	                    //wenn an dem Tag etwas in DB erschienen 
	                    if (item.measured !== false) {
	                        templist1[i] = (item.weight * 0.1).toFixed(2);
	                    } // wenn measured nicht false dann ersetzt die richtige weight dadrauf
	                    if (i === 0 && item.measured !== false) {
	                        hilfsweight = item.weight;
	                    } else if (item.measured !== false) {
	                        if (hilfsweight === null || hilfsweight === undefined) {
	                            hilfsweight = item.weight.toFixed(2);
	                        } else {
	                            templist2[i] = (item.weight - hilfsweight).toFixed(2);
	                            //hilfsweight=((item.weight)).toFixed(2)//falls den Unterschied je zwei Tage sein solltet
	                        }
	                    }
	                }
	            });
	            var pos = (hilfsweight * 0.1).toFixed(2);
	            var neg = -(hilfsweight * 0.1).toFixed(2);
	            console.log(pos);
	            var option = {
	                title: {
	                    left: 'center',
	                    text: 'Weightgain last 90 days'
	                },
	                xAxis: {
	
	                    axisTick: { show: false },
	                    data: timelist
	
	                },
	                yAxis: {
	                    axisLine: { show: false },
	                    axisLabel: { show: false },
	                    splitLine: { show: false },
	                    axisTick: { show: false },
	                    type: 'value',
	                    min: function min(extent) {
	                        return extent.min <= neg ? extent.min : neg;
	                    },
	                    max: function max(extent) {
	                        return extent.max >= pos ? extent.max : pos;
	                    }
	                },
	                dataZoom: [{
	                    type: 'slider',
	                    start: 0,
	                    end: 100
	                }],
	                tooltip: {
	                    trigger: 'axis',
	                    position: function position(pt) {
	                        return [pt[0], '10%'];
	                    }
	                },
	                series: [{
	                    name: 'change',
	                    type: 'bar',
	                    data: templist2,
	                    markLine: {
	                        symbol: "none",
	                        data: [{
	                            lineStyle: {
	                                type: "solid",
	                                color: "FA3934"
	                            },
	                            label: {
	                                textstyle: {
	                                    fontWeight: "bolder",
	                                    fontSize: "7",
	                                    color: "#fff"
	                                },
	                                position: "start",
	                                formatter: "+10%"
	                            },
	                            yAxis: pos
	                        }, {
	                            lineStyle: {
	                                type: "solid",
	                                color: "FA3934"
	                            },
	                            label: {
	                                textstyle: {
	                                    fontWeight: "bolder",
	                                    fontSize: "7",
	                                    color: "#fff"
	                                },
	                                position: "start",
	                                formatter: "-10%"
	                            },
	                            yAxis: neg
	                        }]
	                    }
	                }]
	
	            };
	
	            var myChart = _echarts2.default.init(document.getElementById('weight_graph'));
	            myChart.setOption(option);
	            //fuer bootstrap layout
	            (0, _jquery2.default)(window).on('resize', function () {
	                if (myChart !== null && myChart !== undefined) {
	                    myChart.resize();
	                }
	            });
	        };
	
	        _this.beautify_timestamp = function (unix_timestamp) {
	            var a = new Date(Number(unix_timestamp));
	            var months = ['Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun', 'Jul', 'Aug', 'Sep', 'Oct', 'Nov', 'Dec'];
	            var year = a.getFullYear();
	            var month = months[a.getMonth()];
	            var date = a.getDate();
	            var time = date + ' ' + month + ' ' + year;
	
	            return time;
	        };
	
	        return _this;
	    }
	
	    _createClass(Weight, [{
	        key: 'componentDidMount',
	        value: function componentDidMount() {
	            this.create_graph();
	        }
	    }, {
	        key: 'componentDidUpdate',
	        value: function componentDidUpdate(prevProps, prevState) {
	            this.create_graph();
	        }
	    }, {
	        key: 'render',
	        value: function render() {
	
	            return _react2.default.createElement(
	                'div',
	                { className: 'container-fluid', style: { backgroundColor: '#f7f7f7', marginTop: '-20px', borderRadius: '7px' } },
	                _react2.default.createElement(
	                    'div',
	                    { className: 'patient_health_status_doctor', style: { marginTop: '50px', paddingRight: '0', paddingLeft: '0' } },
	                    _react2.default.createElement(
	                        'div',
	                        { className: 'row' },
	                        _react2.default.createElement(
	                            'div',
	                            { className: 'col-md-12 col-xs-12 col-sm-12', style: { padding: '0' } },
	                            _react2.default.createElement('div', { id: 'weight_graph', style: { width: '100%', minHeight: '400px' } })
	                        )
	                    )
	                )
	            );
	        }
	    }]);
	
	    return Weight;
	}(_react2.default.PureComponent);
	
	exports.default = Weight;

/***/ },
/* 237 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	
	var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();
	
	var _react = __webpack_require__(2);
	
	var _react2 = _interopRequireDefault(_react);
	
	__webpack_require__(391);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
	
	function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }
	
	function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }
	
	// colors: #466d95a1 (blue), #ffca8fc9 (orange)
	
	var Login = function (_React$Component) {
	  _inherits(Login, _React$Component);
	
	  // eslint-disable-line react/prefer-stateless-function
	
	  function Login(props) {
	    _classCallCheck(this, Login);
	
	    var _this = _possibleConstructorReturn(this, (Login.__proto__ || Object.getPrototypeOf(Login)).call(this, props));
	
	    _this.state = {
	      username: '',
	      password: '',
	      wrong: false
	    };
	
	    _this.logme = _this.logme.bind(_this);
	    _this.handleUsernameChange = _this.handleUsernameChange.bind(_this);
	    _this.handlePasswordChange = _this.handlePasswordChange.bind(_this);
	    return _this;
	  }
	
	  _createClass(Login, [{
	    key: 'handleUsernameChange',
	    value: function handleUsernameChange(e) {
	      this.setState({ username: e.target.value });
	    }
	  }, {
	    key: 'handlePasswordChange',
	    value: function handlePasswordChange(e) {
	      this.setState({ password: e.target.value });
	    }
	  }, {
	    key: 'logme',
	    value: function logme() {
	      var _this2 = this;
	
	      var new_user = { username: this.state.username, password: this.state.password };
	      fetch('/api/login', {
	        method: 'post',
	        headers: {
	          'Content-Type': 'application/json'
	        },
	        body: JSON.stringify(new_user)
	      }).then(function (res) {
	        return res.json();
	      }).then(function (res) {
	        console.log(res);
	        if (res.authenticated) {
	          _this2.props.loggedIn(res.user);
	        } else {
	          _this2.setState({ wrong: true });
	          return;
	        }
	      });
	    }
	  }, {
	    key: 'render',
	    value: function render() {
	      var _this3 = this;
	
	      document.title = "Login - HomeCareApp";
	      return _react2.default.createElement(
	        'div',
	        { className: 'pagebody' },
	        _react2.default.createElement(
	          'div',
	          { className: 'blob_gray' },
	          _react2.default.createElement(
	            'svg',
	            { viewBox: '0 0 500 500', xmlns: 'http://www.w3.org/2000/svg', width: '100%', id: 'blobSvg' },
	            _react2.default.createElement('path', { id: 'blob', d: 'M422.5,290.5Q403,331,352.5,328Q302,325,284,354Q266,383,219,419Q172,455,138,417.5Q104,380,61,343.5Q18,307,67,262Q116,217,138.5,194Q161,171,162.5,97.5Q164,24,216,62.5Q268,101,316,92.5Q364,84,409.5,113.5Q455,143,448.5,196.5Q442,250,422.5,290.5Z', fill: '#e9dfd3c4' })
	          )
	        ),
	        _react2.default.createElement(
	          'div',
	          { className: 'blob_orange' },
	          _react2.default.createElement(
	            'svg',
	            { viewBox: '0 0 500 500', xmlns: 'http://www.w3.org/2000/svg', width: '100%', id: 'blobSvg' },
	            _react2.default.createElement('path', { id: 'blob', d: 'M384.5,266Q312,282,307,304Q302,326,281,330.5Q260,335,240.5,331.5Q221,328,156,359.5Q91,391,127,331.5Q163,272,118,239Q73,206,68.5,145.5Q64,85,124,80.5Q184,76,224.5,99.5Q265,123,328,84.5Q391,46,414.5,99Q438,152,447.5,201Q457,250,384.5,266Z', fill: '#466d9582' })
	          )
	        ),
	        _react2.default.createElement(
	          'div',
	          { className: 'row', style: { marginLeft: '0' } },
	          _react2.default.createElement(
	            'div',
	            { className: 'col-12', style: { height: '100vh', backgroundColor: 'rgb(250 244 220 / 47%)' } },
	            _react2.default.createElement(
	              'div',
	              { className: 'centerVertical_fdsafsdfsdf', style: { textAlign: 'center', zIndex: '100' } },
	              _react2.default.createElement(
	                'h6',
	                { className: 'center_text marginTop', style: { color: 'black', fontSize: '28px', textAlign: 'center', marginBottom: '40px' } },
	                'Homecare App'
	              ),
	              _react2.default.createElement(
	                'p',
	                { style: { fontSize: '20px' } },
	                'Please enter your login details:'
	              ),
	              this.state.wrong ? _react2.default.createElement(
	                'p',
	                { style: { fontSize: '16px', color: 'red', padding: '10px 0' } },
	                'Wrong login details!'
	              ) : null,
	              _react2.default.createElement(
	                'div',
	                { className: 'formular', style: { marginTop: '0px' } },
	                _react2.default.createElement(
	                  'form',
	                  { style: { display: 'inline-block', width: '66vw' } },
	                  _react2.default.createElement(
	                    'div',
	                    { className: 'form-group col-12', style: { display: 'inline-block', padding: '0 10px' } },
	                    _react2.default.createElement('input', { type: 'text', placeholder: ' username', className: 'input_username', value: this.state.username, onChange: this.handleUsernameChange })
	                  ),
	                  _react2.default.createElement(
	                    'div',
	                    { className: 'form-group col-xs-6', style: { display: 'inline-block', padding: '0 10px' } },
	                    _react2.default.createElement('input', { type: 'password', placeholder: ' password', className: 'input_username', style: { marginBottom: '30px' }, autoComplete: 'on', value: this.state.password, onChange: this.handlePasswordChange }),
	                    ' ',
	                    _react2.default.createElement('br', null)
	                  )
	                )
	              )
	            ),
	            _react2.default.createElement(
	              'a',
	              { className: 'teilnehmen-btn', style: { cursor: 'pointer', marginTop: '40px', zIndex: '99999999', backgroundColor: '#000000' }, onClick: function onClick(e) {
	                  _this3.logme(e);
	                } },
	              'Login'
	            )
	          )
	        )
	      );
	    }
	  }]);
	
	  return Login;
	}(_react2.default.Component);
	
	exports.default = Login;

/***/ },
/* 238 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	
	var _Login = __webpack_require__(237);
	
	Object.defineProperty(exports, 'default', {
	  enumerable: true,
	  get: function get() {
	    return _interopRequireDefault(_Login).default;
	  }
	});

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/***/ },
/* 239 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	
	var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();
	
	var _react = __webpack_require__(2);
	
	var _react2 = _interopRequireDefault(_react);
	
	var _Confirmation = __webpack_require__(241);
	
	var _Confirmation2 = _interopRequireDefault(_Confirmation);
	
	var _MissedConfirmation = __webpack_require__(245);
	
	var _MissedConfirmation2 = _interopRequireDefault(_MissedConfirmation);
	
	var _History = __webpack_require__(243);
	
	var _History2 = _interopRequireDefault(_History);
	
	var _BloodPressure = __webpack_require__(231);
	
	var _BloodPressure2 = _interopRequireDefault(_BloodPressure);
	
	var _blood_pressure = __webpack_require__(104);
	
	var _blood_pressure2 = _interopRequireDefault(_blood_pressure);
	
	var _my_history = __webpack_require__(77);
	
	var _my_history2 = _interopRequireDefault(_my_history);
	
	var _echarts = __webpack_require__(6);
	
	var _echarts2 = _interopRequireDefault(_echarts);
	
	__webpack_require__(35);
	
	__webpack_require__(15);
	
	__webpack_require__(14);
	
	__webpack_require__(23);
	
	var _jquery = __webpack_require__(16);
	
	var _jquery2 = _interopRequireDefault(_jquery);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
	
	function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }
	
	function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }
	
	// import ECharts
	
	
	//Aufruf von $ Zeichen 
	
	
	var BloodPressure = function (_React$PureComponent) {
	  _inherits(BloodPressure, _React$PureComponent);
	
	  function BloodPressure(props) {
	    _classCallCheck(this, BloodPressure);
	
	    var _this = _possibleConstructorReturn(this, (BloodPressure.__proto__ || Object.getPrototypeOf(BloodPressure)).call(this, props));
	
	    _this.addBloodPressurePending = function (sys, dia) {
	
	      fetch('/api/patient/blood_pressure/pending/' + _this.props.username + '/', {
	        method: 'post',
	        headers: { 'Content-Type': 'application/json' },
	        body: JSON.stringify({ bloodpres_dia: dia, bloodpres_sys: sys, measured: true })
	      }).then(function (blob) {
	        return blob.json();
	      }).then(function (blob) {
	        console.log(blob);
	        // this.props.removeMedFromPending(this.state.popupMedication)
	        _this.setState({ confirmPopupPending: false, popupMedication: '' });
	        _this.props.get_health();
	      });
	      // .then(res => this.props.closesignup())
	    };
	
	    _this.addBloodPressureMissed = function (sys, dia, measured) {
	      fetch('/api/patient/blood_pressure/missed/' + _this.props.username + '/' + _this.state.popupMissedTimestamp, {
	        method: 'post',
	        headers: { 'Content-Type': 'application/json' },
	        body: JSON.stringify({ bloodpres_dia: dia, bloodpres_sys: sys, measured: measured })
	      }).then(function (blob) {
	        return blob.json();
	      }).then(function (blob) {
	        console.log(blob);
	        // this.props.removeMedFromPending(this.state.popupMedication)
	        _this.setState({ confirmPopupMissed: false });
	        _this.props.get_health();
	      });
	      // .then(res => this.props.closesignup())
	    };
	
	    _this.beautify_timestamp = function (unix_timestamp) {
	      var a = new Date(Number(unix_timestamp));
	      var months = ['Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun', 'Jul', 'Aug', 'Sep', 'Oct', 'Nov', 'Dec'];
	      var year = a.getFullYear();
	      var month = months[a.getMonth()];
	      var date = a.getDate();
	      var time = date + ' ' + month + ' ' + year;
	
	      return time;
	    };
	
	    _this.state = {
	      pendingMedication: _this.props.pendingMedication,
	      confirmPopupPending: false,
	      confirmPopupMissed: false,
	      popupMissedTimestampFrom: '',
	      popupMissedTimestampTo: '',
	      history_bool: false
	    };
	    return _this;
	  }
	
	  _createClass(BloodPressure, [{
	    key: 'componentDidMount',
	    value: function componentDidMount() {
	      window.scrollTo({ top: 0 });
	    }
	  }, {
	    key: 'componentDidUpdate',
	    value: function componentDidUpdate(prevProps, prevState) {
	      if (!this.state.confirmPopupPending && !this.state.confirmPopupMissed) {}
	    }
	  }, {
	    key: 'render',
	    value: function render() {
	      var _this2 = this;
	
	      var pendingMedication = this.props.pendingMedication;
	
	      if (this.state.confirmPopupPending) {
	        return _react2.default.createElement(_Confirmation2.default, { addBloodPressurePending: this.addBloodPressurePending, goBack: function goBack(e) {
	            return _this2.setState({ confirmPopupPending: false });
	          } });
	      }
	
	      if (this.state.confirmPopupMissed) {
	        return _react2.default.createElement(_MissedConfirmation2.default, { addBloodPressureMissed: this.addBloodPressureMissed, goBack: function goBack(e) {
	            return _this2.setState({ confirmPopupMissed: false });
	          }, popupMissedTimestampFrom: this.state.popupMissedTimestampFrom, popupMissedTimestampTo: this.state.popupMissedTimestampTo });
	      }
	
	      if (this.state.history_bool) {
	        return _react2.default.createElement(_History2.default, { blood_pressure: this.props.blood_pressure, goBack: function goBack(e) {
	            return _this2.setState({ history_bool: false });
	          } });
	      }
	
	      return _react2.default.createElement(
	        'div',
	        { className: 'container-fluid', style: { backgroundColor: '#f7f7f7', marginTop: '-20px', paddingTop: '30px', minHeight: '100vh' } },
	        _react2.default.createElement(
	          'div',
	          { className: 'col-12' },
	          _react2.default.createElement(
	            'p',
	            { className: 'patient_back', onClick: function onClick() {
	                return _this2.props.backToDashboard();
	              } },
	            '\u27F6'
	          ),
	          _react2.default.createElement(
	            'div',
	            { className: 'patient_health_status', style: { marginTop: '40px' } },
	            _react2.default.createElement(
	              'div',
	              { className: 'row' },
	              _react2.default.createElement(
	                'div',
	                { className: 'col-9' },
	                _react2.default.createElement(
	                  'h3',
	                  { className: 'patient_status' },
	                  'My BloodPressure'
	                ),
	                this.props.blood_pressures.pending.length > 0 || this.props.blood_pressures.missed.length > 0 ? _react2.default.createElement(
	                  'p',
	                  { className: 'patient_status_task', style: { color: "red" } },
	                  'You have some opened Tasks..'
	                ) : _react2.default.createElement(
	                  'p',
	                  { className: 'patient_status_task' },
	                  'You have completed all your tasks for today'
	                )
	              ),
	              _react2.default.createElement(
	                'div',
	                { className: 'col-3' },
	                _react2.default.createElement('img', { style: { marginTop: '30px' }, src: _blood_pressure2.default, alt: 'medication pill', className: 'tasks_pill' })
	              )
	            )
	          )
	        ),
	        this.props.blood_pressures.pending.length > 0 ? _react2.default.createElement(
	          'p',
	          { className: 'patient_tasks', style: { marginLeft: '25px' } },
	          'Pending Task'
	        ) : null,
	        this.props.blood_pressures.pending.length > 0 ? _react2.default.createElement(
	          'div',
	          { className: 'row', style: { padding: '0 20px' } },
	          _react2.default.createElement(
	            'div',
	            { className: 'col-12', style: { padding: '0' } },
	            _react2.default.createElement(
	              'div',
	              { className: 'row', style: { borderRadius: '20px', padding: '10px 0' } },
	              _react2.default.createElement(
	                'div',
	                { className: 'col-3' },
	                _react2.default.createElement('img', { style: { marginTop: '21px' }, src: _blood_pressure2.default, alt: 'medication pill', className: 'tasks_pill' })
	              ),
	              _react2.default.createElement(
	                'div',
	                { className: 'col-5' },
	                _react2.default.createElement(
	                  'p',
	                  { className: 'add_temprature' },
	                  'Add today\'s Blood Pressure'
	                )
	              ),
	              _react2.default.createElement(
	                'div',
	                { className: 'col-4', onClick: function onClick(e) {
	                    return _this2.setState({ confirmPopupPending: true });
	                  } },
	                _react2.default.createElement(
	                  'span',
	                  { className: 'go' },
	                  '\u27F6'
	                )
	              )
	            )
	          )
	        ) : null,
	        this.props.blood_pressures.missed.map(function (missed_temp, i) {
	          return _react2.default.createElement(
	            'div',
	            { className: 'col-12' },
	            _react2.default.createElement(
	              'div',
	              { className: 'patient_health_status', style: { marginTop: '40px', backgroundColor: '#ff00000a' } },
	              _react2.default.createElement(
	                'div',
	                { className: 'row' },
	                _react2.default.createElement(
	                  'div',
	                  { className: 'col-9' },
	                  _react2.default.createElement(
	                    'p',
	                    { className: '', style: { fontSize: '18px' } },
	                    'Blood Pressure from ',
	                    _this2.beautify_timestamp(missed_temp.from),
	                    ' to ',
	                    _this2.beautify_timestamp(missed_temp.to),
	                    ' not taken'
	                  )
	                ),
	                _react2.default.createElement(
	                  'div',
	                  { className: 'col-3', onClick: function onClick(e) {
	                      return _this2.setState({ confirmPopupMissed: true, popupMissedTimestampFrom: _this2.beautify_timestamp(missed_temp.from), popupMissedTimestampTo: _this2.beautify_timestamp(missed_temp.to), popupMissedTimestamp: (Number(missed_temp.to) + Number(missed_temp.from)) / 2 });
	                    } },
	                  _react2.default.createElement(
	                    'span',
	                    { className: 'go' },
	                    '\u27F6'
	                  )
	                )
	              )
	            )
	          );
	        }),
	        _react2.default.createElement(
	          'p',
	          { className: 'patient_tasks', style: { marginLeft: '25px' } },
	          'History'
	        ),
	        _react2.default.createElement(_BloodPressure2.default, { blood_pressures: this.props.blood_pressures })
	      );
	    }
	  }]);
	
	  return BloodPressure;
	}(_react2.default.PureComponent);
	
	exports.default = BloodPressure;

/***/ },
/* 240 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	
	var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();
	
	var _react = __webpack_require__(2);
	
	var _react2 = _interopRequireDefault(_react);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
	
	function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }
	
	function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }
	
	var Confirmation = function (_PureComponent) {
	  _inherits(Confirmation, _PureComponent);
	
	  function Confirmation(props) {
	    _classCallCheck(this, Confirmation);
	
	    var _this = _possibleConstructorReturn(this, (Confirmation.__proto__ || Object.getPrototypeOf(Confirmation)).call(this, props));
	
	    _this.handleBloodPressureChangeSys = function (e) {
	      _this.setState({ sys: e.target.value });
	    };
	
	    _this.handleBloodPressureChangeDia = function (e) {
	      _this.setState({ dia: e.target.value });
	    };
	
	    _this.onBlurSys = function (e) {
	      if (_this.state.sys.length === 0) return;
	      _this.setState({ sys: parseFloat(e.target.value.replace(',', '.')).toFixed(2) });
	    };
	
	    _this.onBlurDia = function (e) {
	      if (_this.state.dia.length === 0) return;
	      _this.setState({ dia: parseFloat(e.target.value.replace(',', '.')).toFixed(2) });
	    };
	
	    _this.state = {
	      sys: '',
	      dia: ''
	    };
	    return _this;
	  }
	
	  _createClass(Confirmation, [{
	    key: 'render',
	    value: function render() {
	      var _this2 = this;
	
	      return _react2.default.createElement(
	        'div',
	        { className: 'container-fluid', style: { backgroundColor: '#f7f7f7', marginTop: '-20px', paddingTop: '30px', minHeight: '100vh' } },
	        _react2.default.createElement(
	          'p',
	          { className: 'patient_back', style: { marginTop: '0px', marginLeft: '20px' }, onClick: function onClick() {
	              return _this2.props.goBack();
	            } },
	          '\u27F6'
	        ),
	        _react2.default.createElement(
	          'p',
	          { className: 'patient_tasks', style: { marginLeft: '25px' } },
	          'What was your blood pressure today:'
	        ),
	        _react2.default.createElement('input', { className: 'userinput', type: 'text', placeholder: 'sys', name: 'blood_pressure', value: this.state.sys, onChange: this.handleBloodPressureChangeSys, style: { width: '100%', marginTop: '30px' }, onBlur: this.onBlurSys }),
	        _react2.default.createElement('input', { className: 'userinput', type: 'text', placeholder: 'dia', name: 'blood_pressure', value: this.state.dia, onChange: this.handleBloodPressureChangeDia, style: { width: '100%', marginTop: '30px' }, onBlur: this.onBlurDia }),
	        _react2.default.createElement(
	          'button',
	          { className: 'no_im_not', onClick: function onClick(e) {
	              return _this2.props.goBack();
	            } },
	          'Go back'
	        ),
	        this.state.blood_pressure !== '' ? _react2.default.createElement(
	          'button',
	          { className: 'yes_im_sure', onClick: function onClick(e) {
	              return _this2.props.addBloodPressurePending(_this2.state.sys, _this2.state.dia);
	            } },
	          'Confirm'
	        ) : _react2.default.createElement(
	          'button',
	          { className: 'yes_im_sure_gray' },
	          'Yes'
	        )
	      );
	    }
	  }]);
	
	  return Confirmation;
	}(_react.PureComponent);
	
	exports.default = Confirmation;

/***/ },
/* 241 */
[482, 240],
/* 242 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	
	var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();
	
	var _react = __webpack_require__(2);
	
	var _react2 = _interopRequireDefault(_react);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
	
	function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }
	
	function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }
	
	var History = function (_PureComponent) {
	  _inherits(History, _PureComponent);
	
	  function History(props) {
	    _classCallCheck(this, History);
	
	    var _this = _possibleConstructorReturn(this, (History.__proto__ || Object.getPrototypeOf(History)).call(this, props));
	
	    _this.state = {
	      temperature: ''
	    };
	    return _this;
	  }
	
	  _createClass(History, [{
	    key: 'render',
	    value: function render() {
	      return _react2.default.createElement(
	        'div',
	        { className: 'container-fluid', style: { backgroundColor: '#f7f7f7', marginTop: '-20px', paddingTop: '30px', minHeight: '100vh' } },
	        _react2.default.createElement(
	          'p',
	          { className: 'patient_tasks', style: { marginLeft: '25px' } },
	          'My Temprature History'
	        ),
	        this.props.temperature.reverse().map(function (temperature, i) {
	          return _react2.default.createElement(
	            'div',
	            { key: i, className: 'row', style: { padding: '0 20px' } },
	            _react2.default.createElement(
	              'div',
	              { className: 'col-12', style: { padding: '0' } },
	              _react2.default.createElement(
	                'div',
	                { className: 'row', style: { borderRadius: '20px', padding: '10px 0' } },
	                _react2.default.createElement(
	                  'div',
	                  { className: 'col-8' },
	                  _react2.default.createElement(
	                    'p',
	                    { className: 'patient_med' },
	                    temperature.temperature
	                  ),
	                  _react2.default.createElement(
	                    'p',
	                    { className: '' },
	                    temperature.date
	                  )
	                ),
	                _react2.default.createElement('div', { className: 'col-4' })
	              )
	            )
	          );
	        })
	      );
	    }
	  }]);
	
	  return History;
	}(_react.PureComponent);
	
	exports.default = History;

/***/ },
/* 243 */
[483, 242],
/* 244 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	
	var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();
	
	var _react = __webpack_require__(2);
	
	var _react2 = _interopRequireDefault(_react);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
	
	function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }
	
	function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }
	
	var MissedConfirmation = function (_PureComponent) {
	  _inherits(MissedConfirmation, _PureComponent);
	
	  function MissedConfirmation(props) {
	    _classCallCheck(this, MissedConfirmation);
	
	    var _this = _possibleConstructorReturn(this, (MissedConfirmation.__proto__ || Object.getPrototypeOf(MissedConfirmation)).call(this, props));
	
	    _this.handleBloodPressureChangeSys = function (e) {
	      _this.setState({ sys: e.target.value });
	    };
	
	    _this.handleBloodPressureChangeDia = function (e) {
	      _this.setState({ dia: e.target.value });
	    };
	
	    _this.onBlurSys = function (e) {
	      if (_this.state.sys.length === 0) return;
	      _this.setState({ sys: parseFloat(e.target.value.replace(',', '.')).toFixed(2) });
	    };
	
	    _this.onBlurDia = function (e) {
	      if (_this.state.dia.length === 0) return;
	      _this.setState({ dia: parseFloat(e.target.value.replace(',', '.')).toFixed(2) });
	    };
	
	    _this.state = {
	      sys: '',
	      dia: ''
	    };
	    return _this;
	  }
	
	  _createClass(MissedConfirmation, [{
	    key: 'render',
	    value: function render() {
	      var _this2 = this;
	
	      return _react2.default.createElement(
	        'div',
	        { className: 'container-fluid', style: { backgroundColor: '#f7f7f7', marginTop: '-20px', paddingTop: '30px', minHeight: '100vh' } },
	        _react2.default.createElement(
	          'p',
	          { className: 'patient_back', style: { marginTop: '0px', marginLeft: '20px' }, onClick: function onClick() {
	              return _this2.props.goBack();
	            } },
	          '\u27F6'
	        ),
	        _react2.default.createElement(
	          'p',
	          { className: 'patient_tasks', style: { marginLeft: '25px' } },
	          'Did you measured your blood pressure between ',
	          this.props.popupMissedTimestampFrom,
	          ' and ',
	          this.props.popupMissedTimestampTo,
	          ' ?'
	        ),
	        _react2.default.createElement('input', { className: 'userinput', type: 'text', placeholder: 'sys', name: 'blood_pressure', value: this.state.sys, onChange: this.handleBloodPressureChangeSys, style: { width: '100%', marginTop: '30px' }, onBlur: this.onBlurSys }),
	        _react2.default.createElement('input', { className: 'userinput', type: 'text', placeholder: 'dia', name: 'blood_pressure', value: this.state.dia, onChange: this.handleBloodPressureChangeDia, style: { width: '100%', marginTop: '30px' }, onBlur: this.onBlurDia }),
	        _react2.default.createElement(
	          'button',
	          { className: 'no_im_not', onClick: function onClick(e) {
	              return _this2.props.addBloodPressureMissed(_this2.state.blood_pressure, false);
	            } },
	          'I Forgot'
	        ),
	        this.state.blood_pressure !== '' ? _react2.default.createElement(
	          'button',
	          { className: 'yes_im_sure', onClick: function onClick(e) {
	              return _this2.props.addBloodPressureMissed(_this2.state.sys, _this2.state.dia, true);
	            } },
	          'Yes, my is blood pressure is ',
	          this.state.blood_pressure
	        ) : _react2.default.createElement(
	          'button',
	          { className: 'yes_im_sure_gray' },
	          'Yes'
	        )
	      );
	    }
	  }]);
	
	  return MissedConfirmation;
	}(_react.PureComponent);
	
	exports.default = MissedConfirmation;

/***/ },
/* 245 */
[484, 244],
/* 246 */
[481, 239],
/* 247 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	
	var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();
	
	var _react = __webpack_require__(2);
	
	var _react2 = _interopRequireDefault(_react);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
	
	function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }
	
	function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }
	
	var Chat = function (_React$PureComponent) {
	  _inherits(Chat, _React$PureComponent);
	
	  function Chat(props) {
	    _classCallCheck(this, Chat);
	
	    var _this = _possibleConstructorReturn(this, (Chat.__proto__ || Object.getPrototypeOf(Chat)).call(this, props));
	
	    _this.state = {
	      random: false
	    };
	    return _this;
	  }
	
	  _createClass(Chat, [{
	    key: 'render',
	    value: function render() {
	
	      return _react2.default.createElement(
	        'div',
	        { className: 'container-fluid', style: { backgroundColor: '#f7f7f7', marginTop: '-20px', paddingTop: '30px', minHeight: '100vh' } },
	        _react2.default.createElement(
	          'div',
	          { className: 'col-12' },
	          _react2.default.createElement(
	            'p',
	            null,
	            'Chat'
	          )
	        )
	      );
	    }
	  }]);
	
	  return Chat;
	}(_react2.default.PureComponent);
	
	exports.default = Chat;

/***/ },
/* 248 */
[477, 247],
/* 249 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	
	var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();
	
	var _react = __webpack_require__(2);
	
	var _react2 = _interopRequireDefault(_react);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
	
	function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }
	
	function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }
	
	var Confirmation = function (_PureComponent) {
	  _inherits(Confirmation, _PureComponent);
	
	  function Confirmation() {
	    _classCallCheck(this, Confirmation);
	
	    return _possibleConstructorReturn(this, (Confirmation.__proto__ || Object.getPrototypeOf(Confirmation)).apply(this, arguments));
	  }
	
	  _createClass(Confirmation, [{
	    key: 'render',
	    value: function render() {
	      var _this2 = this;
	
	      return _react2.default.createElement(
	        'div',
	        { className: 'container-fluid', style: { backgroundColor: '#f7f7f7', marginTop: '-20px', paddingTop: '30px', minHeight: '100vh' } },
	        _react2.default.createElement(
	          'p',
	          { className: 'patient_tasks', style: { marginLeft: '25px' } },
	          'Are  you sure you took the appropriate dose of ',
	          this.props.popupMedication
	        ),
	        _react2.default.createElement(
	          'button',
	          { className: 'no_im_not', onClick: function onClick(e) {
	              return _this2.props.goBack();
	            } },
	          'Not Yet'
	        ),
	        _react2.default.createElement(
	          'button',
	          { className: 'yes_im_sure', onClick: function onClick(e) {
	              return _this2.props.iTookMedicationPending();
	            } },
	          'Yes, I\'m sure!'
	        )
	      );
	    }
	  }]);
	
	  return Confirmation;
	}(_react.PureComponent);
	
	exports.default = Confirmation;

/***/ },
/* 250 */
[482, 249],
/* 251 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	
	var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();
	
	var _react = __webpack_require__(2);
	
	var _react2 = _interopRequireDefault(_react);
	
	var _Confirmation = __webpack_require__(250);
	
	var _Confirmation2 = _interopRequireDefault(_Confirmation);
	
	var _MissedConfirmation = __webpack_require__(253);
	
	var _MissedConfirmation2 = _interopRequireDefault(_MissedConfirmation);
	
	var _tasks_pill = __webpack_require__(174);
	
	var _tasks_pill2 = _interopRequireDefault(_tasks_pill);
	
	var _green_checkmark = __webpack_require__(436);
	
	var _green_checkmark2 = _interopRequireDefault(_green_checkmark);
	
	var _explamation_ark = __webpack_require__(435);
	
	var _explamation_ark2 = _interopRequireDefault(_explamation_ark);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
	
	function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }
	
	function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }
	
	var Medication = function (_React$PureComponent) {
	  _inherits(Medication, _React$PureComponent);
	
	  function Medication(props) {
	    _classCallCheck(this, Medication);
	
	    var _this = _possibleConstructorReturn(this, (Medication.__proto__ || Object.getPrototypeOf(Medication)).call(this, props));
	
	    _this.iTookMedicationPending = function () {
	
	      fetch('/api/patient/medication/pending/' + _this.props.username + '/' + _this.state.popupMedication, {
	        method: 'post',
	        headers: { 'Content-Type': 'application/json' },
	        body: JSON.stringify({})
	      }).then(function (blob) {
	        return blob.json();
	      }).then(function (blob) {
	        // console.log(blob)
	        _this.props.removeMedFromPending(_this.state.popupMedication);
	        _this.setState({ confirmPopupPending: false, popupMedication: '' });
	        _this.props.get_health();
	      });
	      // .then(res => this.props.closesignup())
	    };
	
	    _this.iTookMedicationMissed = function (taken) {
	      fetch('/api/patient/medication/missed/' + _this.props.username + '/' + _this.state.popupMedication + '/' + _this.state.popupMissedTimestamp, {
	        method: 'post',
	        headers: { 'Content-Type': 'application/json' },
	        body: JSON.stringify({ taken: taken })
	      }).then(function (blob) {
	        return blob.json();
	      }).then(function (blob) {
	        // console.log(blob)
	        // this.props.removeMedFromPending(this.state.popupMedication)
	        _this.setState({ confirmPopupMissed: false, popupMedication: '' });
	        _this.props.get_health();
	      });
	      // .then(res => this.props.closesignup())
	    };
	
	    _this.beautify_timestamp = function (unix_timestamp) {
	      var a = new Date(Number(unix_timestamp));
	      var months = ['Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun', 'Jul', 'Aug', 'Sep', 'Oct', 'Nov', 'Dec'];
	      var year = a.getFullYear();
	      var month = months[a.getMonth()];
	      var date = a.getDate();
	      var time = date + ' ' + month + ' ' + year;
	
	      return time;
	    };
	
	    _this.state = {
	      pendingMedication: _this.props.pendingMedication,
	      confirmPopupPending: false,
	      confirmPopupMissed: false,
	      popupMedication: '',
	      popupMissedTimestamp: ''
	    };
	    return _this;
	  }
	
	  _createClass(Medication, [{
	    key: 'componentDidMount',
	    value: function componentDidMount() {
	      window.scrollTo({ top: 0 });
	    }
	  }, {
	    key: 'render',
	    value: function render() {
	      var _this2 = this;
	
	      var pendingMedication = this.props.pendingMedication;
	
	      if (this.state.confirmPopupPending) {
	        return _react2.default.createElement(_Confirmation2.default, { popupMedication: this.state.popupMedication, iTookMedicationPending: this.iTookMedicationPending, goBack: function goBack(e) {
	            return _this2.setState({ confirmPopupPending: false, popupMedication: '' });
	          } });
	      }
	
	      if (this.state.confirmPopupMissed) {
	        return _react2.default.createElement(_MissedConfirmation2.default, { popupMedication: this.state.popupMedication, iTookMedicationMissed: this.iTookMedicationMissed, goBack: function goBack(e) {
	            return _this2.setState({ confirmPopupMissed: false, popupMedication: '' });
	          } });
	      }
	
	      return _react2.default.createElement(
	        'div',
	        { className: 'container-fluid', style: { backgroundColor: '#f7f7f7', marginTop: '-20px', paddingTop: '30px', minHeight: '100vh' } },
	        _react2.default.createElement(
	          'div',
	          { className: 'col-12' },
	          _react2.default.createElement(
	            'p',
	            { className: 'patient_back', onClick: function onClick() {
	                return _this2.props.backToDashboard();
	              } },
	            '\u27F6'
	          ),
	          _react2.default.createElement(
	            'div',
	            { className: '', style: { marginTop: '40px' } },
	            _react2.default.createElement(
	              'div',
	              { className: 'row' },
	              _react2.default.createElement(
	                'div',
	                { className: 'col-12' },
	                _react2.default.createElement(
	                  'h3',
	                  { className: 'patient_status' },
	                  'My Medication'
	                ),
	                this.props.is_there_missed_med().missed ? _react2.default.createElement(
	                  'p',
	                  { className: 'patient_tasks_subtitle', style: { color: 'red' } },
	                  'Missed tasks'
	                ) : null,
	                !this.props.is_there_missed_med().missed && this.props.is_there_missed_med().pending ? _react2.default.createElement(
	                  'p',
	                  { className: 'patient_tasks_subtitle', style: { color: '#f58900' } },
	                  'Pending task'
	                ) : null,
	                !this.props.is_there_missed_med().missed && !this.props.is_there_missed_med().pending ? _react2.default.createElement(
	                  'p',
	                  { className: 'patient_status_task' },
	                  'You have completed all your tasks for today'
	                ) : null
	              )
	            )
	          )
	        ),
	        this.props.medication.length === 0 ? _react2.default.createElement(
	          'p',
	          { className: 'patient_tasks', style: { marginLeft: '25px' } },
	          'No Medication'
	        ) : null,
	        this.props.medication.map(function (med, i) {
	          return _react2.default.createElement(
	            'div',
	            { key: i, className: 'row patient_health_status', style: { padding: '0 20px' } },
	            _react2.default.createElement(
	              'div',
	              { className: 'col-12', style: { padding: '0' } },
	              _react2.default.createElement(
	                'div',
	                { className: 'row', style: { borderRadius: '20px', padding: '10px 0' } },
	                _react2.default.createElement(
	                  'div',
	                  { className: 'col-3' },
	                  _react2.default.createElement('img', { style: { marginTop: '30px' }, src: _tasks_pill2.default, alt: 'medication pill', className: 'tasks_pill' })
	                ),
	                _react2.default.createElement(
	                  'div',
	                  { className: 'col-6' },
	                  _react2.default.createElement(
	                    'p',
	                    { className: 'patient_med' },
	                    med.title
	                  ),
	                  _react2.default.createElement(
	                    'p',
	                    { className: '' },
	                    med.ammount,
	                    ' every ',
	                    med.duration,
	                    ' day, starting from ',
	                    _this2.beautify_timestamp(med.assigned_on),
	                    ' '
	                  )
	                ),
	                med.missed.length === 0 && med.pending.length === 0 ? _react2.default.createElement(
	                  'div',
	                  { className: 'col-3' },
	                  _react2.default.createElement('img', { style: { marginTop: '30px', float: 'right' }, src: _green_checkmark2.default, alt: 'medication pill', className: 'tasks_pill' }),
	                  _react2.default.createElement('p', { className: '' })
	                ) : null,
	                med.missed.length === 0 && med.pending.length > 0 ? _react2.default.createElement(
	                  'div',
	                  { className: 'col-3' },
	                  _react2.default.createElement('img', { style: { marginTop: '30px', float: 'right' }, src: _explamation_ark2.default, alt: 'medication pill', className: 'tasks_pill' }),
	                  _react2.default.createElement('p', { className: '' })
	                ) : null,
	                med.missed.length > 0 ? _react2.default.createElement(
	                  'div',
	                  { className: 'col-3' },
	                  _react2.default.createElement('img', { style: { marginTop: '30px', float: 'right' }, src: _explamation_ark2.default, alt: 'medication pill', className: 'tasks_pill' }),
	                  _react2.default.createElement('p', { className: '' })
	                ) : null,
	                med.pending.length > 0 ? _react2.default.createElement(
	                  'div',
	                  { className: 'col-12' },
	                  _react2.default.createElement(
	                    'div',
	                    { className: '', style: { marginTop: '40px' } },
	                    _react2.default.createElement(
	                      'div',
	                      { className: 'row' },
	                      _react2.default.createElement(
	                        'div',
	                        { className: 'col-12' },
	                        _react2.default.createElement(
	                          'h3',
	                          { className: 'patient_status' },
	                          ' Pending Task'
	                        )
	                      ),
	                      _react2.default.createElement(
	                        'div',
	                        { className: 'col-9', style: { marginTop: '40px' } },
	                        _react2.default.createElement(
	                          'p',
	                          { className: '', style: { fontSize: '18px' } },
	                          'Medication from ',
	                          _this2.beautify_timestamp(med.pending[0].from),
	                          ' to ',
	                          _this2.beautify_timestamp(med.pending[0].to),
	                          ' not taken'
	                        )
	                      ),
	                      _react2.default.createElement(
	                        'div',
	                        { className: 'col-3', onClick: function onClick(e) {
	                            return _this2.setState({ confirmPopupPending: true, popupMedication: med.title });
	                          } },
	                        _react2.default.createElement(
	                          'span',
	                          { className: 'go' },
	                          '\u27F6'
	                        )
	                      )
	                    )
	                  )
	                ) : null,
	                med.missed.length > 0 ? _react2.default.createElement(
	                  'div',
	                  { className: 'col-12' },
	                  _react2.default.createElement(
	                    'div',
	                    { className: 'row' },
	                    _react2.default.createElement(
	                      'div',
	                      { className: 'col-12' },
	                      _react2.default.createElement(
	                        'h3',
	                        { className: 'patient_status' },
	                        ' Missed Tasks'
	                      )
	                    )
	                  )
	                ) : null,
	                med.missed.map(function (missed_med, i) {
	                  return _react2.default.createElement(
	                    'div',
	                    { className: 'col-12' },
	                    _react2.default.createElement(
	                      'div',
	                      { className: 'patient_health_status', style: { marginTop: '40px', backgroundColor: '#ff00000a' } },
	                      _react2.default.createElement(
	                        'div',
	                        { className: 'row' },
	                        _react2.default.createElement(
	                          'div',
	                          { className: 'col-9' },
	                          _react2.default.createElement(
	                            'p',
	                            { className: '', style: { fontSize: '18px' } },
	                            'Medication from ',
	                            _this2.beautify_timestamp(missed_med.from),
	                            ' to ',
	                            _this2.beautify_timestamp(missed_med.to),
	                            ' not taken'
	                          )
	                        ),
	                        _react2.default.createElement(
	                          'div',
	                          { className: 'col-3', onClick: function onClick(e) {
	                              return _this2.setState({ confirmPopupMissed: true, popupMedication: med.title, popupMissedTimestamp: (Number(missed_med.to) + Number(missed_med.from)) / 2 });
	                            } },
	                          _react2.default.createElement(
	                            'span',
	                            { className: 'go' },
	                            '\u27F6'
	                          )
	                        )
	                      )
	                    )
	                  );
	                })
	              )
	            )
	          );
	        })
	      );
	    }
	  }]);
	
	  return Medication;
	}(_react2.default.PureComponent);
	
	exports.default = Medication;

/***/ },
/* 252 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	
	var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();
	
	var _react = __webpack_require__(2);
	
	var _react2 = _interopRequireDefault(_react);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
	
	function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }
	
	function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }
	
	var MissedConfirmation = function (_PureComponent) {
	  _inherits(MissedConfirmation, _PureComponent);
	
	  function MissedConfirmation() {
	    _classCallCheck(this, MissedConfirmation);
	
	    return _possibleConstructorReturn(this, (MissedConfirmation.__proto__ || Object.getPrototypeOf(MissedConfirmation)).apply(this, arguments));
	  }
	
	  _createClass(MissedConfirmation, [{
	    key: 'render',
	    value: function render() {
	      var _this2 = this;
	
	      return _react2.default.createElement(
	        'div',
	        { className: 'container-fluid', style: { backgroundColor: '#f7f7f7', marginTop: '-20px', paddingTop: '30px', minHeight: '100vh' } },
	        _react2.default.createElement(
	          'p',
	          { className: 'patient_back', style: { marginTop: '0', width: '60px' }, onClick: function onClick() {
	              return _this2.props.goBack();
	            } },
	          '\u27F6'
	        ),
	        _react2.default.createElement(
	          'p',
	          { className: 'patient_tasks', style: { marginLeft: '25px' } },
	          'Did you miss taking your apropriate dose of ',
	          this.props.popupMedication,
	          ' ?'
	        ),
	        _react2.default.createElement(
	          'button',
	          { className: 'no_im_not', onClick: function onClick(e) {
	              return _this2.props.iTookMedicationMissed(false);
	            } },
	          'I forgot to take my medication'
	        ),
	        _react2.default.createElement(
	          'button',
	          { className: 'yes_im_sure', onClick: function onClick(e) {
	              return _this2.props.iTookMedicationMissed(true);
	            } },
	          'I have taken my Medication!'
	        )
	      );
	    }
	  }]);
	
	  return MissedConfirmation;
	}(_react.PureComponent);
	
	exports.default = MissedConfirmation;

/***/ },
/* 253 */
[484, 252],
/* 254 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	
	var _Medication = __webpack_require__(251);
	
	Object.defineProperty(exports, 'default', {
	  enumerable: true,
	  get: function get() {
	    return _interopRequireDefault(_Medication).default;
	  }
	});

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/***/ },
/* 255 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	
	var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();
	
	var _react = __webpack_require__(2);
	
	var _react2 = _interopRequireDefault(_react);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
	
	function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }
	
	function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }
	
	var Confirmation = function (_PureComponent) {
	  _inherits(Confirmation, _PureComponent);
	
	  function Confirmation(props) {
	    _classCallCheck(this, Confirmation);
	
	    var _this = _possibleConstructorReturn(this, (Confirmation.__proto__ || Object.getPrototypeOf(Confirmation)).call(this, props));
	
	    _this.handlePulseChange = function (e) {
	      _this.setState({ pulse: e.target.value });
	    };
	
	    _this.onBlur = function (e) {
	      _this.setState({ pulse: parseFloat(e.target.value.replace(',', '.')).toFixed(2) });
	    };
	
	    _this.state = {
	      pulse: ''
	    };
	    return _this;
	  }
	
	  _createClass(Confirmation, [{
	    key: 'render',
	    value: function render() {
	      var _this2 = this;
	
	      return _react2.default.createElement(
	        'div',
	        { className: 'container-fluid', style: { backgroundColor: '#f7f7f7', marginTop: '-20px', paddingTop: '30px', minHeight: '100vh' } },
	        _react2.default.createElement(
	          'p',
	          { className: 'patient_back', style: { marginTop: '0px', marginLeft: '20px' }, onClick: function onClick() {
	              return _this2.props.goBack();
	            } },
	          '\u27F6'
	        ),
	        _react2.default.createElement(
	          'p',
	          { className: 'patient_tasks', style: { marginLeft: '25px' } },
	          'What was your pulse today:'
	        ),
	        _react2.default.createElement('input', { className: 'userinput', type: 'text', placeholder: 'pulse', name: 'pulse', value: this.state.pulse, onChange: this.handlePulseChange, style: { width: '100%', marginTop: '30px' }, onBlur: this.onBlur }),
	        _react2.default.createElement(
	          'button',
	          { className: 'no_im_not', onClick: function onClick(e) {
	              return _this2.props.goBack();
	            } },
	          'Go back'
	        ),
	        this.state.pulse !== '' ? _react2.default.createElement(
	          'button',
	          { className: 'yes_im_sure', onClick: function onClick(e) {
	              return _this2.props.addPulsePending(_this2.state.pulse);
	            } },
	          'Yes, my is pulse is ',
	          this.state.pulse
	        ) : _react2.default.createElement(
	          'button',
	          { className: 'yes_im_sure_gray' },
	          'Yes'
	        )
	      );
	    }
	  }]);
	
	  return Confirmation;
	}(_react.PureComponent);
	
	exports.default = Confirmation;

/***/ },
/* 256 */
[482, 255],
/* 257 */
242,
/* 258 */
[483, 257],
/* 259 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	
	var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();
	
	var _react = __webpack_require__(2);
	
	var _react2 = _interopRequireDefault(_react);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
	
	function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }
	
	function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }
	
	var MissedConfirmation = function (_PureComponent) {
	  _inherits(MissedConfirmation, _PureComponent);
	
	  function MissedConfirmation(props) {
	    _classCallCheck(this, MissedConfirmation);
	
	    var _this = _possibleConstructorReturn(this, (MissedConfirmation.__proto__ || Object.getPrototypeOf(MissedConfirmation)).call(this, props));
	
	    _this.handlePulseChange = function (e) {
	      _this.setState({ pulse: e.target.value });
	    };
	
	    _this.onBlur = function (e) {
	      var pulse = parseFloat(e.target.value.replace(',', '.')).toFixed(2);
	      if (pulse === NaN) pulse = '';
	      _this.setState({ pulse: pulse });
	    };
	
	    _this.state = {
	      pulse: ''
	    };
	    return _this;
	  }
	
	  _createClass(MissedConfirmation, [{
	    key: 'render',
	    value: function render() {
	      var _this2 = this;
	
	      return _react2.default.createElement(
	        'div',
	        { className: 'container-fluid', style: { backgroundColor: '#f7f7f7', marginTop: '-20px', paddingTop: '30px', minHeight: '100vh' } },
	        _react2.default.createElement(
	          'p',
	          { className: 'patient_back', style: { marginTop: '0px', marginLeft: '20px' }, onClick: function onClick() {
	              return _this2.props.goBack();
	            } },
	          '\u27F6'
	        ),
	        _react2.default.createElement(
	          'p',
	          { className: 'patient_tasks', style: { marginLeft: '25px' } },
	          'Did you measured your pulse between ',
	          this.props.popupMissedTimestampFrom,
	          ' and ',
	          this.props.popupMissedTimestampTo,
	          ' ?'
	        ),
	        _react2.default.createElement('input', { className: 'userinput', type: 'text', placeholder: 'pulse', name: 'pulse', value: this.state.pulse, onChange: this.handlePulseChange, style: { width: '100%', marginTop: '30px' }, onBlur: this.onBlur }),
	        _react2.default.createElement(
	          'button',
	          { className: 'no_im_not', onClick: function onClick(e) {
	              return _this2.props.addPulseMissed(_this2.state.pulse, false);
	            } },
	          'I Forgot'
	        ),
	        this.state.pulse !== '' ? _react2.default.createElement(
	          'button',
	          { className: 'yes_im_sure', onClick: function onClick(e) {
	              return _this2.props.addPulseMissed(_this2.state.pulse, true);
	            } },
	          'Yes, my is pulse is ',
	          this.state.pulse
	        ) : _react2.default.createElement(
	          'button',
	          { className: 'yes_im_sure_gray' },
	          'Yes'
	        )
	      );
	    }
	  }]);
	
	  return MissedConfirmation;
	}(_react.PureComponent);
	
	exports.default = MissedConfirmation;

/***/ },
/* 260 */
[484, 259],
/* 261 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	
	var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();
	
	var _react = __webpack_require__(2);
	
	var _react2 = _interopRequireDefault(_react);
	
	var _Confirmation = __webpack_require__(256);
	
	var _Confirmation2 = _interopRequireDefault(_Confirmation);
	
	var _MissedConfirmation = __webpack_require__(260);
	
	var _MissedConfirmation2 = _interopRequireDefault(_MissedConfirmation);
	
	var _History = __webpack_require__(258);
	
	var _History2 = _interopRequireDefault(_History);
	
	var _Pulse = __webpack_require__(233);
	
	var _Pulse2 = _interopRequireDefault(_Pulse);
	
	var _heart_rate = __webpack_require__(105);
	
	var _heart_rate2 = _interopRequireDefault(_heart_rate);
	
	var _my_history = __webpack_require__(77);
	
	var _my_history2 = _interopRequireDefault(_my_history);
	
	var _jquery = __webpack_require__(16);
	
	var _jquery2 = _interopRequireDefault(_jquery);
	
	var _echarts = __webpack_require__(6);
	
	var _echarts2 = _interopRequireDefault(_echarts);
	
	__webpack_require__(35);
	
	__webpack_require__(15);
	
	__webpack_require__(14);
	
	__webpack_require__(23);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
	
	function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }
	
	function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }
	
	//Aufruf von $ Zeichen 
	
	
	// import ECharts
	
	
	var Pulse = function (_React$PureComponent) {
	  _inherits(Pulse, _React$PureComponent);
	
	  function Pulse(props) {
	    _classCallCheck(this, Pulse);
	
	    var _this = _possibleConstructorReturn(this, (Pulse.__proto__ || Object.getPrototypeOf(Pulse)).call(this, props));
	
	    _this.create_graph = function () {
	      //  currentDate
	
	      var currentDate = new Date();
	      // old7Datetimestample
	      var days7before = currentDate.setDate(currentDate.getDate() - 7); //  最终获得的 old7Date 是时间戳 
	      //console.log(days7before)    
	      var history = _this.props.pulses.history;
	      var jsonData = { pulse: history };
	
	      var truejsonData = jsonData.pulse.filter(function (obj) {
	        return obj.timestamp > days7before;
	      });
	      console.log(truejsonData);
	
	      function timeformater(ts) {
	        var date = new Date(ts);
	        var Y = date.getFullYear() + '-';
	        var M = (date.getMonth() + 1 < 10 ? '0' + (date.getMonth() + 1) : date.getMonth() + 1) + '-';
	        var D = date.getDate() + ' ';
	        var result = Y + M + D;
	        return result;
	      }
	
	      var timelist = [null, null, null, null, null, null, null];
	      timelist.forEach(function (item, index, timelist) {
	        var currentDate = new Date();
	        var data = currentDate.setDate(currentDate.getDate() - index);
	        timelist[index] = timeformater(data);
	      });
	      timelist = timelist.reverse();
	
	      var templist = [null, null, null, null, null, null, null];
	      truejsonData.reverse().forEach(function (item, index, arr) {
	        //db中近7天的array 可能只有3天
	        var i = timelist.indexOf(timeformater(item.timestamp)); //richtige x axis daten value index
	        if (i > -1) {
	          //wenn an dem Tag etwas in DB erschienen 
	          templist[i] = item.pulse;
	          // wenn measured nicht false dann ersetzt die richtige weight dadrauf
	        }
	      });
	      //graph infos
	      var option = {
	        color: '#800000',
	        title: {
	          left: 'center',
	          text: 'pulse last 7 days in per minute' },
	        xAxis: {
	          data: timelist
	
	        },
	        yAxis: {
	          axisLabel: { show: false },
	          splitLine: { show: false },
	          axisTick: { show: false },
	          type: 'value',
	          min: function min(extent) {
	            return extent.min <= 30 ? extent.min - 2 : 28;
	          }
	          // max: extent => extent.max >130 ? extent.max+1 : 130
	        },
	        series: [{
	          connectNulls: true, //laesst sich null wert nicht leer sein 
	          name: 'pulse',
	          type: 'line',
	          data: templist,
	          label: {
	            show: true,
	            position: 'top'
	            // formatter: '{c}/min'//echarts selbst build in variable fuer valu
	
	          }
	        }]
	      };
	
	      var myChart = _echarts2.default.init(document.getElementById('pulse_graph'));
	      myChart.setOption(option);
	      //fuer bootstrap layout
	      (0, _jquery2.default)(window).on('resize', function () {
	        if (myChart !== null && myChart !== undefined) {
	          myChart.resize();
	        }
	      });
	    };
	
	    _this.addPulsePending = function (pulse) {
	
	      fetch('/api/patient/pulse/pending/' + _this.props.username + '/', {
	        method: 'post',
	        headers: { 'Content-Type': 'application/json' },
	        body: JSON.stringify({ pulse: pulse, measured: true })
	      }).then(function (blob) {
	        return blob.json();
	      }).then(function (blob) {
	        console.log(blob);
	        // this.props.removeMedFromPending(this.state.popupMedication)
	        _this.setState({ confirmPopupPending: false, popupMedication: '' });
	        _this.props.get_health();
	      });
	      // .then(res => this.props.closesignup())
	    };
	
	    _this.addPulseMissed = function (pulse, measured) {
	      fetch('/api/patient/pulse/missed/' + _this.props.username + '/' + _this.state.popupMissedTimestamp, {
	        method: 'post',
	        headers: { 'Content-Type': 'application/json' },
	        body: JSON.stringify({ measured: measured, pulse: pulse })
	      }).then(function (blob) {
	        return blob.json();
	      }).then(function (blob) {
	        console.log(blob);
	        // this.props.removeMedFromPending(this.state.popupMedication)
	        _this.setState({ confirmPopupMissed: false });
	        _this.props.get_health();
	      });
	      // .then(res => this.props.closesignup())
	    };
	
	    _this.beautify_timestamp = function (unix_timestamp) {
	      var a = new Date(Number(unix_timestamp));
	      var months = ['Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun', 'Jul', 'Aug', 'Sep', 'Oct', 'Nov', 'Dec'];
	      var year = a.getFullYear();
	      var month = months[a.getMonth()];
	      var date = a.getDate();
	      var time = date + ' ' + month + ' ' + year;
	
	      return time;
	    };
	
	    _this.state = {
	      pendingMedication: _this.props.pendingMedication,
	      confirmPopupPending: false,
	      confirmPopupMissed: false,
	      popupMissedTimestampFrom: '',
	      popupMissedTimestampTo: '',
	      history_bool: false
	    };
	    return _this;
	  }
	
	  _createClass(Pulse, [{
	    key: 'componentDidMount',
	    value: function componentDidMount() {
	      window.scrollTo({ top: 0 });
	      this.create_graph();
	    }
	  }, {
	    key: 'componentDidUpdate',
	    value: function componentDidUpdate(prevProps, prevState) {
	      if (!this.state.confirmPopupPending && !this.state.confirmPopupMissed) {
	        // this.create_graph()
	      }
	    }
	  }, {
	    key: 'render',
	    value: function render() {
	      var _this2 = this;
	
	      var pendingMedication = this.props.pendingMedication;
	
	      if (this.state.confirmPopupPending) {
	        return _react2.default.createElement(_Confirmation2.default, { addPulsePending: this.addPulsePending, goBack: function goBack(e) {
	            return _this2.setState({ confirmPopupPending: false });
	          } });
	      }
	
	      if (this.state.confirmPopupMissed) {
	        return _react2.default.createElement(_MissedConfirmation2.default, { addPulseMissed: this.addPulseMissed, goBack: function goBack(e) {
	            return _this2.setState({ confirmPopupMissed: false });
	          }, popupMissedTimestampFrom: this.state.popupMissedTimestampFrom, popupMissedTimestampTo: this.state.popupMissedTimestampTo });
	      }
	
	      if (this.state.history_bool) {
	        return _react2.default.createElement(_History2.default, { pulse: this.props.pulse, goBack: function goBack(e) {
	            return _this2.setState({ history_bool: false });
	          } });
	      }
	
	      return _react2.default.createElement(
	        'div',
	        { className: 'container-fluid', style: { backgroundColor: '#f7f7f7', marginTop: '-20px', paddingTop: '30px', minHeight: '100vh' } },
	        _react2.default.createElement(
	          'div',
	          { className: 'col-12' },
	          _react2.default.createElement(
	            'p',
	            { className: 'patient_back', onClick: function onClick() {
	                return _this2.props.backToDashboard();
	              } },
	            '\u27F6'
	          ),
	          _react2.default.createElement(
	            'div',
	            { className: 'patient_health_status', style: { marginTop: '40px' } },
	            _react2.default.createElement(
	              'div',
	              { className: 'row' },
	              _react2.default.createElement(
	                'div',
	                { className: 'col-9' },
	                _react2.default.createElement(
	                  'h3',
	                  { className: 'patient_status' },
	                  'My Pulse'
	                ),
	                this.props.pulses.pending.length > 0 || this.props.pulses.missed.length > 0 ? _react2.default.createElement(
	                  'p',
	                  { className: 'patient_status_task' },
	                  'You have some opened Tasks..'
	                ) : _react2.default.createElement(
	                  'p',
	                  { className: 'patient_status_task' },
	                  'You have completed all your tasks for today'
	                )
	              ),
	              _react2.default.createElement(
	                'div',
	                { className: 'col-3' },
	                _react2.default.createElement('img', { style: { marginTop: '30px' }, src: _heart_rate2.default, alt: 'medication pill', className: 'tasks_pill' })
	              )
	            )
	          )
	        ),
	        this.props.pulses.pending.length > 0 ? _react2.default.createElement(
	          'p',
	          { className: 'patient_tasks', style: { marginLeft: '25px' } },
	          'Pending Task'
	        ) : null,
	        this.props.pulses.pending.length > 0 ? _react2.default.createElement(
	          'div',
	          { className: 'row', style: { padding: '0 20px' } },
	          _react2.default.createElement(
	            'div',
	            { className: 'col-12', style: { padding: '0' } },
	            _react2.default.createElement(
	              'div',
	              { className: 'row', style: { borderRadius: '20px', padding: '10px 0' } },
	              _react2.default.createElement(
	                'div',
	                { className: 'col-3' },
	                _react2.default.createElement('img', { style: { marginTop: '21px' }, src: _heart_rate2.default, alt: 'medication pill', className: 'tasks_pill' })
	              ),
	              _react2.default.createElement(
	                'div',
	                { className: 'col-5' },
	                _react2.default.createElement(
	                  'p',
	                  { className: 'add_temprature' },
	                  'Add today\'s Pulse'
	                )
	              ),
	              _react2.default.createElement(
	                'div',
	                { className: 'col-4', onClick: function onClick(e) {
	                    return _this2.setState({ confirmPopupPending: true });
	                  } },
	                _react2.default.createElement(
	                  'span',
	                  { className: 'go' },
	                  '\u27F6'
	                )
	              )
	            )
	          )
	        ) : null,
	        this.props.pulses.missed.map(function (missed_temp, i) {
	          return _react2.default.createElement(
	            'div',
	            { className: 'col-12' },
	            _react2.default.createElement(
	              'div',
	              { className: 'patient_health_status', style: { marginTop: '40px', backgroundColor: '#ff00000a' } },
	              _react2.default.createElement(
	                'div',
	                { className: 'row' },
	                _react2.default.createElement(
	                  'div',
	                  { className: 'col-9' },
	                  _react2.default.createElement(
	                    'p',
	                    { className: '', style: { fontSize: '18px' } },
	                    'Pulse from ',
	                    _this2.beautify_timestamp(missed_temp.from),
	                    ' to ',
	                    _this2.beautify_timestamp(missed_temp.to),
	                    ' not taken'
	                  )
	                ),
	                _react2.default.createElement(
	                  'div',
	                  { className: 'col-3', onClick: function onClick(e) {
	                      return _this2.setState({ confirmPopupMissed: true, popupMissedTimestampFrom: _this2.beautify_timestamp(missed_temp.from), popupMissedTimestampTo: _this2.beautify_timestamp(missed_temp.to), popupMissedTimestamp: (Number(missed_temp.to) + Number(missed_temp.from)) / 2 });
	                    } },
	                  _react2.default.createElement(
	                    'span',
	                    { className: 'go' },
	                    '\u27F6'
	                  )
	                )
	              )
	            )
	          );
	        }),
	        _react2.default.createElement(
	          'p',
	          { className: 'patient_tasks', style: { marginLeft: '25px' } },
	          'History'
	        ),
	        _react2.default.createElement(_Pulse2.default, { pulses: this.props.pulses.history })
	      );
	    }
	  }]);
	
	  return Pulse;
	}(_react2.default.PureComponent);
	
	exports.default = Pulse;

/***/ },
/* 262 */
[478, 261],
/* 263 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	
	var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();
	
	var _react = __webpack_require__(2);
	
	var _react2 = _interopRequireDefault(_react);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
	
	function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }
	
	function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }
	
	var Confirmation = function (_PureComponent) {
	  _inherits(Confirmation, _PureComponent);
	
	  function Confirmation(props) {
	    _classCallCheck(this, Confirmation);
	
	    var _this = _possibleConstructorReturn(this, (Confirmation.__proto__ || Object.getPrototypeOf(Confirmation)).call(this, props));
	
	    _this.handleTemperatureChange = function (e) {
	      _this.setState({ temperature: e.target.value });
	    };
	
	    _this.onBlur = function (e) {
	      _this.setState({ temperature: parseFloat(e.target.value.replace(',', '.')).toFixed(2) });
	    };
	
	    _this.state = {
	      temperature: '',
	      focus: false
	    };
	    return _this;
	  }
	
	  _createClass(Confirmation, [{
	    key: 'render',
	    value: function render() {
	      var _this2 = this;
	
	      return _react2.default.createElement(
	        'div',
	        { className: 'container-fluid', style: { backgroundColor: '#f7f7f7', marginTop: '-20px', paddingTop: '30px', minHeight: '100vh' } },
	        _react2.default.createElement(
	          'p',
	          { className: 'patient_back', style: { marginTop: '0px', marginLeft: '20px' }, onClick: function onClick() {
	              return _this2.props.goBack();
	            } },
	          '\u27F6'
	        ),
	        _react2.default.createElement(
	          'p',
	          { className: 'patient_tasks', style: { marginLeft: '25px' } },
	          'What was your temperature today:'
	        ),
	        _react2.default.createElement('input', { className: 'userinput', type: 'text', placeholder: 'temperature', name: 'temperature', value: this.state.temperature, onChange: this.handleTemperatureChange, style: { width: '100%', marginTop: '30px' }, onBlur: this.onBlur }),
	        _react2.default.createElement(
	          'button',
	          { className: 'no_im_not', onClick: function onClick(e) {
	              return _this2.props.goBack();
	            } },
	          'Go back'
	        ),
	        this.state.temperature !== '' ? _react2.default.createElement(
	          'button',
	          { className: 'yes_im_sure', onClick: function onClick(e) {
	              return _this2.props.addTemperaturePending(_this2.state.temperature);
	            } },
	          'Yes, my is temprature is ',
	          this.state.temperature
	        ) : _react2.default.createElement(
	          'button',
	          { className: 'yes_im_sure_gray' },
	          'Yes'
	        )
	      );
	    }
	  }]);
	
	  return Confirmation;
	}(_react.PureComponent);
	
	exports.default = Confirmation;

/***/ },
/* 264 */
[482, 263],
/* 265 */
242,
/* 266 */
[483, 265],
/* 267 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	
	var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();
	
	var _react = __webpack_require__(2);
	
	var _react2 = _interopRequireDefault(_react);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
	
	function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }
	
	function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }
	
	var MissedConfirmation = function (_PureComponent) {
	  _inherits(MissedConfirmation, _PureComponent);
	
	  function MissedConfirmation(props) {
	    _classCallCheck(this, MissedConfirmation);
	
	    var _this = _possibleConstructorReturn(this, (MissedConfirmation.__proto__ || Object.getPrototypeOf(MissedConfirmation)).call(this, props));
	
	    _this.handleTemperatureChange = function (e) {
	      _this.setState({ temperature: e.target.value });
	    };
	
	    _this.onBlur = function (e) {
	      _this.setState({ temperature: parseFloat(e.target.value.replace(',', '.')).toFixed(2) });
	    };
	
	    _this.state = {
	      temperature: ''
	    };
	    return _this;
	  }
	
	  _createClass(MissedConfirmation, [{
	    key: 'render',
	    value: function render() {
	      var _this2 = this;
	
	      return _react2.default.createElement(
	        'div',
	        { className: 'container-fluid', style: { backgroundColor: '#f7f7f7', marginTop: '-20px', paddingTop: '30px', minHeight: '100vh' } },
	        _react2.default.createElement(
	          'p',
	          { className: 'patient_back', style: { marginTop: '0px', marginLeft: '20px' }, onClick: function onClick() {
	              return _this2.props.goBack();
	            } },
	          '\u27F6'
	        ),
	        _react2.default.createElement(
	          'p',
	          { className: 'patient_tasks', style: { marginLeft: '25px' } },
	          'Did you measured your temperature between ',
	          this.props.popupMissedTimestampFrom,
	          ' and ',
	          this.props.popupMissedTimestampTo,
	          ' ?'
	        ),
	        _react2.default.createElement('input', { className: 'userinput', type: 'text', placeholder: 'temperature', name: 'temperature', value: this.state.temperature, onChange: this.handleTemperatureChange, style: { width: '100%', marginTop: '30px' }, onBlur: this.onBlur }),
	        _react2.default.createElement(
	          'button',
	          { className: 'no_im_not', onClick: function onClick(e) {
	              return _this2.props.addTemperatureMissed(_this2.state.temperature, false);
	            } },
	          'I Forgot'
	        ),
	        this.state.temperature !== '' ? _react2.default.createElement(
	          'button',
	          { className: 'yes_im_sure', onClick: function onClick(e) {
	              return _this2.props.addTemperatureMissed(_this2.state.temperature, true);
	            } },
	          'Yes, my is temprature is ',
	          this.state.temperature
	        ) : _react2.default.createElement(
	          'button',
	          { className: 'yes_im_sure_gray' },
	          'Yes'
	        )
	      );
	    }
	  }]);
	
	  return MissedConfirmation;
	}(_react.PureComponent);
	
	exports.default = MissedConfirmation;

/***/ },
/* 268 */
[484, 267],
/* 269 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	
	var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();
	
	var _react = __webpack_require__(2);
	
	var _react2 = _interopRequireDefault(_react);
	
	var _Confirmation = __webpack_require__(264);
	
	var _Confirmation2 = _interopRequireDefault(_Confirmation);
	
	var _MissedConfirmation = __webpack_require__(268);
	
	var _MissedConfirmation2 = _interopRequireDefault(_MissedConfirmation);
	
	var _History = __webpack_require__(266);
	
	var _History2 = _interopRequireDefault(_History);
	
	var _echarts = __webpack_require__(6);
	
	var _echarts2 = _interopRequireDefault(_echarts);
	
	__webpack_require__(38);
	
	__webpack_require__(19);
	
	__webpack_require__(15);
	
	__webpack_require__(14);
	
	__webpack_require__(46);
	
	var _jquery = __webpack_require__(16);
	
	var _jquery2 = _interopRequireDefault(_jquery);
	
	var _tasks_temperature = __webpack_require__(106);
	
	var _tasks_temperature2 = _interopRequireDefault(_tasks_temperature);
	
	var _my_history = __webpack_require__(77);
	
	var _my_history2 = _interopRequireDefault(_my_history);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
	
	function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }
	
	function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }
	
	// import ECharts
	
	
	//Aufruf von $ Zeichen 
	
	
	var Temperature = function (_React$PureComponent) {
	  _inherits(Temperature, _React$PureComponent);
	
	  function Temperature(props) {
	    _classCallCheck(this, Temperature);
	
	    var _this = _possibleConstructorReturn(this, (Temperature.__proto__ || Object.getPrototypeOf(Temperature)).call(this, props));
	
	    _this.create_graph = function () {
	      var history = _this.props.temperatures.history;
	      var jsonData = { temperature: history
	        //  currentDate
	      };var currentDate = new Date();
	      // old7Datetimestample
	      var days7before = currentDate.setDate(currentDate.getDate() - 7); //  最终获得的 old7Date 是时间戳 
	      //console.log(days7before)    
	      var truejsonData = jsonData.temperature.filter(function (obj) {
	        return obj.timestamp > days7before;
	      });
	      console.log(truejsonData);
	
	      function timeformater(ts) {
	        var date = new Date(ts);
	        var Y = date.getFullYear() + '-';
	        var M = (date.getMonth() + 1 < 10 ? '0' + (date.getMonth() + 1) : date.getMonth() + 1) + '-';
	        var D = date.getDate() + ' ';
	        var result = Y + M + D;
	        return result;
	      }
	
	      var timelist = [null, null, null, null, null, null, null];
	      timelist.forEach(function (item, index, timelist) {
	        var currentDate = new Date();
	        var data = currentDate.setDate(currentDate.getDate() - index);
	        timelist[index] = timeformater(data);
	      });
	      timelist = timelist.reverse();
	
	      var templist = [null, null, null, null, null, null, null];
	      truejsonData.reverse().forEach(function (item, index, arr) {
	        //db中近7天的array 可能只有3天
	        var i = timelist.indexOf(timeformater(item.timestamp)); //richtige x axis daten value index
	        if (i > -1) {
	          //wenn an dem Tag etwas in DB erschienen 
	          templist[i] = item.temperature;
	          // wenn measured nicht false dann ersetzt die richtige weight dadrauf
	        }
	      });
	
	      //graph infos
	      var option = {
	        color: 'black',
	        title: {
	          left: 'center',
	          text: 'Temperature last 7 days in °C' },
	        xAxis: {
	          data: timelist
	
	        },
	        yAxis: {
	
	          axisLabel: { show: false },
	          splitLine: { show: false },
	          axisTick: { show: false },
	          type: 'value',
	          min: function min(extent) {
	            return extent.min <= 36 ? extent.min - 1 : 35;
	          },
	          max: function max(extent) {
	            return extent.max > 37.5 ? extent.max : 37.5;
	          }
	        },
	        series: [{
	          name: 'temperature',
	          type: 'bar',
	          data: templist,
	          itemStyle: {
	            normal: {
	              color: function color(params) {
	                if (params.value < 36.5) {
	                  return "#FFA500";
	                } else if (params.value >= 36.5 && params.value <= 37.5) {
	                  return "#32CD32";
	                }
	                return "#DC143C";
	              }
	            }
	          },
	          label: {
	            textStyle: {
	              fonttemperature: "bolder",
	              fontSize: "8",
	              color: "#fff"
	            },
	            show: true,
	            position: 'inside'
	            //formatter: '{c}°C'//echarts selbst build in variable fuer valu
	
	          },
	          markLine: {
	            symbol: "none",
	            data: [{
	
	              lineStyle: { //警戒线的样式  ，虚实  颜色
	                type: "solid",
	                color: "#FA3934"
	              },
	              label: {
	                textStyle: {
	                  fonttemperature: "bolder",
	                  color: 'black',
	                  fontSize: "8"
	                },
	                position: 'start',
	                formatter: "37.5"
	              },
	              yAxis: 37.5
	
	            }, {
	
	              lineStyle: { //警戒线的样式  ，虚实  颜色
	                type: "solid",
	                color: "green"
	              },
	              label: {
	                textStyle: {
	                  fonttemperature: "bolder",
	                  color: 'black',
	                  fontSize: "8"
	                },
	                position: 'start',
	                formatter: "36.5"
	              },
	              yAxis: 36.5
	
	            }]
	          }
	        }]
	      };
	      var myChart = _echarts2.default.init(document.getElementById('history_graph'));
	      myChart.setOption(option);
	      //fuer bootstrap layout
	      (0, _jquery2.default)(window).on('resize', function () {
	        if (myChart !== null && myChart !== undefined) {
	          myChart.resize();
	        }
	      });
	    };
	
	    _this.addTemperate = function (temperature) {
	
	      fetch('/api/patient/addTemprature/' + _this.props.username + '/', {
	        method: 'post',
	        headers: { 'Content-Type': 'application/json' },
	        body: JSON.stringify({ temperature: temperature })
	      }).then(function (blob) {
	        return blob.json();
	      }).then(function (blob) {
	        console.log(blob);
	        _this.setState({ confirmPopup: false });
	      });
	      // .then(res => this.props.closesignup())
	    };
	
	    _this.addTemperaturePending = function (temperature) {
	
	      fetch('/api/patient/temperature/pending/' + _this.props.username + '/', {
	        method: 'post',
	        headers: { 'Content-Type': 'application/json' },
	        body: JSON.stringify({ temperature: temperature, measured: true })
	      }).then(function (blob) {
	        return blob.json();
	      }).then(function (blob) {
	        console.log(blob);
	        _this.props.removeMedFromPending(_this.state.popupMedication);
	        _this.setState({ confirmPopupPending: false, popupMedication: '' });
	        _this.props.get_health();
	      });
	      // .then(res => this.props.closesignup())
	    };
	
	    _this.addTemperatureMissed = function (temperature, measured) {
	      fetch('/api/patient/temperature/missed/' + _this.props.username + '/' + _this.state.popupMissedTimestamp, {
	        method: 'post',
	        headers: { 'Content-Type': 'application/json' },
	        body: JSON.stringify({ measured: measured, temperature: temperature })
	      }).then(function (blob) {
	        return blob.json();
	      }).then(function (blob) {
	        console.log(blob);
	        // this.props.removeMedFromPending(this.state.popupMedication)
	        _this.setState({ confirmPopupMissed: false });
	        _this.props.get_health();
	      });
	      // .then(res => this.props.closesignup())
	    };
	
	    _this.beautify_timestamp = function (unix_timestamp) {
	      var a = new Date(Number(unix_timestamp));
	      var months = ['Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun', 'Jul', 'Aug', 'Sep', 'Oct', 'Nov', 'Dec'];
	      var year = a.getFullYear();
	      var month = months[a.getMonth()];
	      var date = a.getDate();
	      var time = date + ' ' + month + ' ' + year;
	
	      return time;
	    };
	
	    _this.state = {
	      pendingMedication: _this.props.pendingMedication,
	      confirmPopupPending: false,
	      confirmPopupMissed: false,
	      popupMissedTimestampFrom: '',
	      popupMissedTimestampTo: '',
	      history_bool: false
	    };
	    return _this;
	  }
	
	  _createClass(Temperature, [{
	    key: 'componentDidMount',
	    value: function componentDidMount() {
	      window.scrollTo({ top: 0 });
	      this.create_graph();
	    }
	  }, {
	    key: 'componentDidUpdate',
	    value: function componentDidUpdate(prevProps, prevState) {
	      if (!this.state.confirmPopupPending && !this.state.confirmPopupMissed) {
	        this.create_graph();
	      }
	    }
	  }, {
	    key: 'render',
	    value: function render() {
	      var _this2 = this;
	
	      var pendingMedication = this.props.pendingMedication;
	
	      if (this.state.confirmPopupPending) {
	        return _react2.default.createElement(_Confirmation2.default, { addTemperaturePending: this.addTemperaturePending, goBack: function goBack(e) {
	            return _this2.setState({ confirmPopupPending: false });
	          } });
	      }
	
	      if (this.state.confirmPopupMissed) {
	        return _react2.default.createElement(_MissedConfirmation2.default, { addTemperatureMissed: this.addTemperatureMissed, goBack: function goBack(e) {
	            return _this2.setState({ confirmPopupMissed: false });
	          }, popupMissedTimestampFrom: this.state.popupMissedTimestampFrom, popupMissedTimestampTo: this.state.popupMissedTimestampTo });
	      }
	
	      if (this.state.history_bool) {
	        return _react2.default.createElement(_History2.default, { temperature: this.props.temperature, goBack: function goBack(e) {
	            return _this2.setState({ history_bool: false });
	          } });
	      }
	
	      return _react2.default.createElement(
	        'div',
	        { className: 'container-fluid', style: { backgroundColor: '#f7f7f7', marginTop: '-20px', paddingTop: '30px', minHeight: '100vh' } },
	        _react2.default.createElement(
	          'div',
	          { className: 'col-12' },
	          _react2.default.createElement(
	            'p',
	            { className: 'patient_back', onClick: function onClick() {
	                return _this2.props.backToDashboard();
	              } },
	            '\u27F6'
	          ),
	          _react2.default.createElement(
	            'div',
	            { className: 'patient_health_status', style: { marginTop: '40px' } },
	            _react2.default.createElement(
	              'div',
	              { className: 'row' },
	              _react2.default.createElement(
	                'div',
	                { className: 'col-9' },
	                _react2.default.createElement(
	                  'h3',
	                  { className: 'patient_status' },
	                  'My Temperature'
	                ),
	                pendingMedication.length > 0 ? _react2.default.createElement(
	                  'p',
	                  { className: 'patient_status_task' },
	                  'You have some opened Tasks..'
	                ) : _react2.default.createElement(
	                  'p',
	                  { className: 'patient_status_task' },
	                  'You have completed all your tasks for today'
	                )
	              ),
	              _react2.default.createElement(
	                'div',
	                { className: 'col-3' },
	                _react2.default.createElement('img', { style: { marginTop: '30px' }, src: _tasks_temperature2.default, alt: 'medication pill', className: 'tasks_pill' })
	              )
	            )
	          )
	        ),
	        this.props.temperatures.pending.length > 0 ? _react2.default.createElement(
	          'p',
	          { className: 'patient_tasks', style: { marginLeft: '25px' } },
	          'Pending Task'
	        ) : null,
	        this.props.temperatures.pending.length > 0 ? _react2.default.createElement(
	          'div',
	          { className: 'row', style: { padding: '0 20px' } },
	          _react2.default.createElement(
	            'div',
	            { className: 'col-12', style: { padding: '0' } },
	            _react2.default.createElement(
	              'div',
	              { className: 'row', style: { borderRadius: '20px', padding: '10px 0' } },
	              _react2.default.createElement(
	                'div',
	                { className: 'col-3' },
	                _react2.default.createElement('img', { style: { marginTop: '21px' }, src: _tasks_temperature2.default, alt: 'medication pill', className: 'tasks_pill' })
	              ),
	              _react2.default.createElement(
	                'div',
	                { className: 'col-5' },
	                _react2.default.createElement(
	                  'p',
	                  { className: 'add_temprature' },
	                  'Add today\'s Temprature'
	                )
	              ),
	              _react2.default.createElement(
	                'div',
	                { className: 'col-4', onClick: function onClick(e) {
	                    return _this2.setState({ confirmPopupPending: true });
	                  } },
	                _react2.default.createElement(
	                  'span',
	                  { className: 'go' },
	                  '\u27F6'
	                )
	              )
	            )
	          )
	        ) : null,
	        this.props.temperatures.missed.map(function (missed_temp, i) {
	          return _react2.default.createElement(
	            'div',
	            { className: 'col-12' },
	            _react2.default.createElement(
	              'div',
	              { className: 'patient_health_status', style: { marginTop: '40px', backgroundColor: '#ff00000a' } },
	              _react2.default.createElement(
	                'div',
	                { className: 'row' },
	                _react2.default.createElement(
	                  'div',
	                  { className: 'col-9' },
	                  _react2.default.createElement(
	                    'p',
	                    { className: '', style: { fontSize: '18px' } },
	                    'Temprature from ',
	                    _this2.beautify_timestamp(missed_temp.from),
	                    ' to ',
	                    _this2.beautify_timestamp(missed_temp.to),
	                    ' not taken'
	                  )
	                ),
	                _react2.default.createElement(
	                  'div',
	                  { className: 'col-3', onClick: function onClick(e) {
	                      return _this2.setState({ confirmPopupMissed: true, popupMissedTimestampFrom: _this2.beautify_timestamp(missed_temp.from), popupMissedTimestampTo: _this2.beautify_timestamp(missed_temp.to), popupMissedTimestamp: (Number(missed_temp.to) + Number(missed_temp.from)) / 2 });
	                    } },
	                  _react2.default.createElement(
	                    'span',
	                    { className: 'go' },
	                    '\u27F6'
	                  )
	                )
	              )
	            )
	          );
	        }),
	        _react2.default.createElement(
	          'p',
	          { className: 'patient_tasks', style: { marginLeft: '25px' } },
	          'History'
	        ),
	        _react2.default.createElement(
	          'div',
	          { className: 'patient_health_status', style: { marginTop: '50px' } },
	          _react2.default.createElement(
	            'div',
	            { className: 'row' },
	            _react2.default.createElement(
	              'div',
	              { className: 'col-md-12 col-xs-12 col-sm-12' },
	              _react2.default.createElement('div', { id: 'history_graph', style: { width: '100%', minHeight: '400px' } })
	            )
	          )
	        )
	      );
	    }
	  }]);
	
	  return Temperature;
	}(_react2.default.PureComponent);
	
	exports.default = Temperature;

/***/ },
/* 270 */
[479, 269],
/* 271 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	
	var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();
	
	var _react = __webpack_require__(2);
	
	var _react2 = _interopRequireDefault(_react);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
	
	function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }
	
	function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }
	
	var Confirmation = function (_PureComponent) {
	  _inherits(Confirmation, _PureComponent);
	
	  function Confirmation(props) {
	    _classCallCheck(this, Confirmation);
	
	    var _this = _possibleConstructorReturn(this, (Confirmation.__proto__ || Object.getPrototypeOf(Confirmation)).call(this, props));
	
	    _this.handleWeightChange = function (e) {
	      _this.setState({ weight: e.target.value });
	    };
	
	    _this.onBlur = function (e) {
	      _this.setState({ weight: parseFloat(e.target.value.replace(',', '.')).toFixed(2) });
	    };
	
	    _this.state = {
	      weight: ''
	    };
	    return _this;
	  }
	
	  _createClass(Confirmation, [{
	    key: 'render',
	    value: function render() {
	      var _this2 = this;
	
	      return _react2.default.createElement(
	        'div',
	        { className: 'container-fluid', style: { backgroundColor: '#f7f7f7', marginTop: '-20px', paddingTop: '30px', minHeight: '100vh' } },
	        _react2.default.createElement(
	          'p',
	          { className: 'patient_back', style: { marginTop: '0px', marginLeft: '20px' }, onClick: function onClick() {
	              return _this2.props.goBack();
	            } },
	          '\u27F6'
	        ),
	        _react2.default.createElement(
	          'p',
	          { className: 'patient_tasks', style: { marginLeft: '25px' } },
	          'What was your weight today:'
	        ),
	        _react2.default.createElement('input', { className: 'userinput', type: 'text', placeholder: 'weight', name: 'weight', value: this.state.weight, onChange: this.handleWeightChange, style: { width: '100%', marginTop: '30px' }, onBlur: this.onBlur }),
	        _react2.default.createElement(
	          'button',
	          { className: 'no_im_not', onClick: function onClick(e) {
	              return _this2.props.goBack();
	            } },
	          'Go back'
	        ),
	        this.state.weight !== '' ? _react2.default.createElement(
	          'button',
	          { className: 'yes_im_sure', onClick: function onClick(e) {
	              return _this2.props.addWeightPending(_this2.state.weight);
	            } },
	          'Yes, my is weight is ',
	          this.state.weight
	        ) : _react2.default.createElement(
	          'button',
	          { className: 'yes_im_sure_gray' },
	          'Yes'
	        )
	      );
	    }
	  }]);
	
	  return Confirmation;
	}(_react.PureComponent);
	
	exports.default = Confirmation;

/***/ },
/* 272 */
[482, 271],
/* 273 */
242,
/* 274 */
[483, 273],
/* 275 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	
	var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();
	
	var _react = __webpack_require__(2);
	
	var _react2 = _interopRequireDefault(_react);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
	
	function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }
	
	function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }
	
	var MissedConfirmation = function (_PureComponent) {
	  _inherits(MissedConfirmation, _PureComponent);
	
	  function MissedConfirmation(props) {
	    _classCallCheck(this, MissedConfirmation);
	
	    var _this = _possibleConstructorReturn(this, (MissedConfirmation.__proto__ || Object.getPrototypeOf(MissedConfirmation)).call(this, props));
	
	    _this.handleWeightChange = function (e) {
	      _this.setState({ weight: e.target.value });
	    };
	
	    _this.onBlur = function (e) {
	      _this.setState({ weight: parseFloat(e.target.value.replace(',', '.')).toFixed(2) });
	    };
	
	    _this.state = {
	      weight: ''
	    };
	    return _this;
	  }
	
	  _createClass(MissedConfirmation, [{
	    key: 'render',
	    value: function render() {
	      var _this2 = this;
	
	      return _react2.default.createElement(
	        'div',
	        { className: 'container-fluid', style: { backgroundColor: '#f7f7f7', marginTop: '-20px', paddingTop: '30px', minHeight: '100vh' } },
	        _react2.default.createElement(
	          'p',
	          { className: 'patient_back', style: { marginTop: '0px', marginLeft: '20px' }, onClick: function onClick() {
	              return _this2.props.goBack();
	            } },
	          '\u27F6'
	        ),
	        _react2.default.createElement(
	          'p',
	          { className: 'patient_tasks', style: { marginLeft: '25px' } },
	          'Did you measured your weight between ',
	          this.props.popupMissedTimestampFrom,
	          ' and ',
	          this.props.popupMissedTimestampTo,
	          ' ?'
	        ),
	        _react2.default.createElement('input', { className: 'userinput', type: 'text', placeholder: 'weight', name: 'weight', value: this.state.weight, onChange: this.handleWeightChange, style: { width: '100%', marginTop: '30px' }, onBlur: this.onBlur }),
	        _react2.default.createElement(
	          'button',
	          { className: 'no_im_not', onClick: function onClick(e) {
	              return _this2.props.addWeightMissed(_this2.state.weight, false);
	            } },
	          'I Forgot'
	        ),
	        this.state.weight !== '' ? _react2.default.createElement(
	          'button',
	          { className: 'yes_im_sure', onClick: function onClick(e) {
	              return _this2.props.addWeightMissed(_this2.state.weight, true);
	            } },
	          'Yes, my is weight is ',
	          this.state.weight
	        ) : _react2.default.createElement(
	          'button',
	          { className: 'yes_im_sure_gray' },
	          'Yes'
	        )
	      );
	    }
	  }]);
	
	  return MissedConfirmation;
	}(_react.PureComponent);
	
	exports.default = MissedConfirmation;

/***/ },
/* 276 */
[484, 275],
/* 277 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	
	var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();
	
	var _react = __webpack_require__(2);
	
	var _react2 = _interopRequireDefault(_react);
	
	var _Confirmation = __webpack_require__(272);
	
	var _Confirmation2 = _interopRequireDefault(_Confirmation);
	
	var _MissedConfirmation = __webpack_require__(276);
	
	var _MissedConfirmation2 = _interopRequireDefault(_MissedConfirmation);
	
	var _History = __webpack_require__(274);
	
	var _History2 = _interopRequireDefault(_History);
	
	var _Weight = __webpack_require__(235);
	
	var _Weight2 = _interopRequireDefault(_Weight);
	
	var _weightClipartBlackAndWhite = __webpack_require__(175);
	
	var _weightClipartBlackAndWhite2 = _interopRequireDefault(_weightClipartBlackAndWhite);
	
	var _my_history = __webpack_require__(77);
	
	var _my_history2 = _interopRequireDefault(_my_history);
	
	var _echarts = __webpack_require__(6);
	
	var _echarts2 = _interopRequireDefault(_echarts);
	
	__webpack_require__(38);
	
	__webpack_require__(19);
	
	__webpack_require__(15);
	
	__webpack_require__(14);
	
	__webpack_require__(46);
	
	__webpack_require__(23);
	
	var _jquery = __webpack_require__(16);
	
	var _jquery2 = _interopRequireDefault(_jquery);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
	
	function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }
	
	function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }
	
	// import ECharts
	
	
	//Aufruf von $ Zeichen 
	
	
	var Weight = function (_React$PureComponent) {
	  _inherits(Weight, _React$PureComponent);
	
	  function Weight(props) {
	    _classCallCheck(this, Weight);
	
	    var _this = _possibleConstructorReturn(this, (Weight.__proto__ || Object.getPrototypeOf(Weight)).call(this, props));
	
	    _this.create_graph = function () {
	      var history = _this.props.weights.history;
	      var jsonData = { weight: history
	        //  currentDate
	      };var currentDate = new Date();
	      // old7Datetimestample
	      var days7before = currentDate.setDate(currentDate.getDate() - 7); //  最终获得的 old7Date 是时间戳 
	      //console.log(days7before)    
	
	      var truejsonData = jsonData.weight.filter(function (obj) {
	        return obj.timestamp > days7before;
	      });
	      console.log(truejsonData);
	
	      function timeformater(ts) {
	        var date = new Date(ts);
	        var Y = date.getFullYear() + '-';
	        var M = (date.getMonth() + 1 < 10 ? '0' + (date.getMonth() + 1) : date.getMonth() + 1) + '-';
	        var D = date.getDate() + ' ';
	        var result = Y + M + D;
	        return result;
	      }
	
	      var timelist = [null, null, null, null, null, null, null];
	      timelist.forEach(function (item, index, timelist) {
	        var currentDate = new Date();
	        var data = currentDate.setDate(currentDate.getDate() - index);
	        timelist[index] = timeformater(data);
	      });
	      timelist = timelist.reverse();
	
	      var templist1 = [null, null, null, null, null, null, null];
	      var templist2 = [null, null, null, null, null, null, null];
	      var hilfsweight = null;
	      truejsonData.forEach(function (item, index, arr) {
	        //db中近7天的array 可能只有3天
	        var i = timelist.indexOf(timeformater(item.timestamp)); //richtige x axis daten value index
	        if (i > -1) {
	          //wenn an dem Tag etwas in DB erschienen 
	          if (item.measured !== false) {
	            templist1[i] = (item.weight * 0.1).toFixed(2);
	          } // wenn measured nicht false dann ersetzt die richtige weight dadrauf
	          if (i === 0 && item.measured !== false) {
	            hilfsweight = item.weight.toFixed(2);
	          } //first keine Aenderung erst ab zweite, wenn erste value hat dann hilfswert weist hinzu
	          else if (item.measured !== false) {
	              if (hilfsweight === null) {
	                hilfsweight = item.weight.toFixed(2);
	              } else {
	                templist2[i] = ((item.weight - hilfsweight) * 10).toFixed(2);
	                hilfsweight = item.weight.toFixed(2);
	              }
	            }
	        }
	      });
	
	      var option = {
	
	        title: {
	          left: 'center',
	          text: 'Weight last 7 days in kg'
	        },
	        legend: {
	          top: "6%",
	          left: 'right',
	          data: ['weight', 'change']
	        },
	        xAxis: {
	
	          type: 'category',
	
	          axisTick: { show: false },
	          data: timelist
	
	        },
	        yAxis: {
	
	          axisLabel: { show: false },
	          splitLine: { show: false },
	          axisTick: { show: false },
	          type: 'value'
	
	        },
	        series: [{
	          name: 'weight',
	          type: 'bar',
	          data: templist1,
	          stack: 'weightgain',
	
	          label: {
	            textStyle: {
	              fontWeight: "bolder",
	              fontSize: "8"
	            },
	            show: true,
	            position: 'inside',
	            formatter: function formatter(params) {
	              return (params.value * 10).toFixed(2);
	            }
	          }
	        }, {
	          name: 'change',
	          type: 'bar',
	          data: templist2,
	          stack: 'weightgain',
	
	          label: {
	            textStyle: {
	              fontWeight: "bolder",
	              fontSize: "8"
	            },
	            show: true,
	            position: 'inside',
	            formatter: function formatter(params) {
	              return (params.value / 10).toFixed(2);
	            }
	
	          }
	        }]
	      };
	
	      var myChart = _echarts2.default.init(document.getElementById('weight_graph'));
	      myChart.setOption(option);
	      //fuer bootstrap layout
	      (0, _jquery2.default)(window).on('resize', function () {
	        if (myChart !== null && myChart !== undefined) {
	          myChart.resize();
	        }
	      });
	    };
	
	    _this.addWeightPending = function (weight) {
	
	      fetch('/api/patient/weight/pending/' + _this.props.username + '/', {
	        method: 'post',
	        headers: { 'Content-Type': 'application/json' },
	        body: JSON.stringify({ weight: weight, measured: true })
	      }).then(function (blob) {
	        return blob.json();
	      }).then(function (blob) {
	        console.log(blob);
	        // this.props.removeMedFromPending(this.state.popupMedication)
	        _this.setState({ confirmPopupPending: false, popupMedication: '' });
	        _this.props.get_health();
	      });
	      // .then(res => this.props.closesignup())
	    };
	
	    _this.addWeightMissed = function (weight, measured) {
	      fetch('/api/patient/weight/missed/' + _this.props.username + '/' + _this.state.popupMissedTimestamp, {
	        method: 'post',
	        headers: { 'Content-Type': 'application/json' },
	        body: JSON.stringify({ measured: measured, weight: weight })
	      }).then(function (blob) {
	        return blob.json();
	      }).then(function (blob) {
	        console.log(blob);
	        // this.props.removeMedFromPending(this.state.popupMedication)
	        _this.setState({ confirmPopupMissed: false });
	        _this.props.get_health();
	      });
	      // .then(res => this.props.closesignup())
	    };
	
	    _this.beautify_timestamp = function (unix_timestamp) {
	      var a = new Date(Number(unix_timestamp));
	      var months = ['Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun', 'Jul', 'Aug', 'Sep', 'Oct', 'Nov', 'Dec'];
	      var year = a.getFullYear();
	      var month = months[a.getMonth()];
	      var date = a.getDate();
	      var time = date + ' ' + month + ' ' + year;
	
	      return time;
	    };
	
	    _this.state = {
	      pendingMedication: _this.props.pendingMedication,
	      confirmPopupPending: false,
	      confirmPopupMissed: false,
	      popupMissedTimestampFrom: '',
	      popupMissedTimestampTo: '',
	      history_bool: false
	    };
	    return _this;
	  }
	
	  _createClass(Weight, [{
	    key: 'componentDidMount',
	    value: function componentDidMount() {
	      window.scrollTo({ top: 0 });
	      this.create_graph();
	    }
	  }, {
	    key: 'componentDidUpdate',
	    value: function componentDidUpdate(prevProps, prevState) {
	      if (!this.state.confirmPopupPending && !this.state.confirmPopupMissed) {
	        this.create_graph();
	      }
	    }
	  }, {
	    key: 'render',
	    value: function render() {
	      var _this2 = this;
	
	      var pendingMedication = this.props.pendingMedication;
	
	      if (this.state.confirmPopupPending) {
	        return _react2.default.createElement(_Confirmation2.default, { addWeightPending: this.addWeightPending, goBack: function goBack(e) {
	            return _this2.setState({ confirmPopupPending: false });
	          } });
	      }
	
	      if (this.state.confirmPopupMissed) {
	        return _react2.default.createElement(_MissedConfirmation2.default, { addWeightMissed: this.addWeightMissed, goBack: function goBack(e) {
	            return _this2.setState({ confirmPopupMissed: false });
	          }, popupMissedTimestampFrom: this.state.popupMissedTimestampFrom, popupMissedTimestampTo: this.state.popupMissedTimestampTo });
	      }
	
	      if (this.state.history_bool) {
	        return _react2.default.createElement(_History2.default, { weight: this.props.weight, goBack: function goBack(e) {
	            return _this2.setState({ history_bool: false });
	          } });
	      }
	
	      return _react2.default.createElement(
	        'div',
	        { className: 'container-fluid', style: { backgroundColor: '#f7f7f7', marginTop: '-20px', paddingTop: '30px', minHeight: '100vh' } },
	        _react2.default.createElement(
	          'div',
	          { className: 'col-12' },
	          _react2.default.createElement(
	            'p',
	            { className: 'patient_back', onClick: function onClick() {
	                return _this2.props.backToDashboard();
	              } },
	            '\u27F6'
	          ),
	          _react2.default.createElement(
	            'div',
	            { className: 'patient_health_status', style: { marginTop: '40px' } },
	            _react2.default.createElement(
	              'div',
	              { className: 'row' },
	              _react2.default.createElement(
	                'div',
	                { className: 'col-9' },
	                _react2.default.createElement(
	                  'h3',
	                  { className: 'patient_status' },
	                  'My Weight'
	                ),
	                this.props.weights.pending.length > 0 || this.props.weights.missed.length > 0 ? _react2.default.createElement(
	                  'p',
	                  { className: 'patient_status_task' },
	                  'You have some opened Tasks..'
	                ) : _react2.default.createElement(
	                  'p',
	                  { className: 'patient_status_task' },
	                  'You have completed all your tasks for today'
	                )
	              ),
	              _react2.default.createElement(
	                'div',
	                { className: 'col-3' },
	                _react2.default.createElement('img', { style: { marginTop: '30px' }, src: _weightClipartBlackAndWhite2.default, alt: 'medication pill', className: 'tasks_pill' })
	              )
	            )
	          )
	        ),
	        this.props.weights.pending.length > 0 ? _react2.default.createElement(
	          'p',
	          { className: 'patient_tasks', style: { marginLeft: '25px' } },
	          'Pending Task'
	        ) : null,
	        this.props.weights.pending.length > 0 ? _react2.default.createElement(
	          'div',
	          { className: 'row', style: { padding: '0 20px' } },
	          _react2.default.createElement(
	            'div',
	            { className: 'col-12', style: { padding: '0' } },
	            _react2.default.createElement(
	              'div',
	              { className: 'row', style: { borderRadius: '20px', padding: '10px 0' } },
	              _react2.default.createElement(
	                'div',
	                { className: 'col-3' },
	                _react2.default.createElement('img', { style: { marginTop: '21px' }, src: _weightClipartBlackAndWhite2.default, alt: 'medication pill', className: 'tasks_pill' })
	              ),
	              _react2.default.createElement(
	                'div',
	                { className: 'col-5' },
	                _react2.default.createElement(
	                  'p',
	                  { className: 'add_temprature' },
	                  'Add today\'s Weight'
	                )
	              ),
	              _react2.default.createElement(
	                'div',
	                { className: 'col-4', onClick: function onClick(e) {
	                    return _this2.setState({ confirmPopupPending: true });
	                  } },
	                _react2.default.createElement(
	                  'span',
	                  { className: 'go' },
	                  '\u27F6'
	                )
	              )
	            )
	          )
	        ) : null,
	        this.props.weights.missed.map(function (missed_temp, i) {
	          return _react2.default.createElement(
	            'div',
	            { className: 'col-12' },
	            _react2.default.createElement(
	              'div',
	              { className: 'patient_health_status', style: { marginTop: '40px', backgroundColor: '#ff00000a' } },
	              _react2.default.createElement(
	                'div',
	                { className: 'row' },
	                _react2.default.createElement(
	                  'div',
	                  { className: 'col-9' },
	                  _react2.default.createElement(
	                    'p',
	                    { className: '', style: { fontSize: '18px' } },
	                    'Weight from ',
	                    _this2.beautify_timestamp(missed_temp.from),
	                    ' to ',
	                    _this2.beautify_timestamp(missed_temp.to),
	                    ' not taken'
	                  )
	                ),
	                _react2.default.createElement(
	                  'div',
	                  { className: 'col-3', onClick: function onClick(e) {
	                      return _this2.setState({ confirmPopupMissed: true, popupMissedTimestampFrom: _this2.beautify_timestamp(missed_temp.from), popupMissedTimestampTo: _this2.beautify_timestamp(missed_temp.to), popupMissedTimestamp: (Number(missed_temp.to) + Number(missed_temp.from)) / 2 });
	                    } },
	                  _react2.default.createElement(
	                    'span',
	                    { className: 'go' },
	                    '\u27F6'
	                  )
	                )
	              )
	            )
	          );
	        }),
	        _react2.default.createElement(
	          'p',
	          { className: 'patient_tasks', style: { marginLeft: '25px' } },
	          'History'
	        ),
	        _react2.default.createElement(_Weight2.default, { weights: this.props.weights })
	      );
	    }
	  }]);
	
	  return Weight;
	}(_react2.default.PureComponent);
	
	exports.default = Weight;

/***/ },
/* 278 */
[480, 277],
/* 279 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	
	var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();
	
	var _react = __webpack_require__(2);
	
	var _react2 = _interopRequireDefault(_react);
	
	var _jsCookie = __webpack_require__(400);
	
	var _jsCookie2 = _interopRequireDefault(_jsCookie);
	
	var _Patient = __webpack_require__(282);
	
	var _Patient2 = _interopRequireDefault(_Patient);
	
	var _Login = __webpack_require__(238);
	
	var _Login2 = _interopRequireDefault(_Login);
	
	var _Allgemein = __webpack_require__(209);
	
	var _Allgemein2 = _interopRequireDefault(_Allgemein);
	
	var _PatientList = __webpack_require__(225);
	
	var _PatientList2 = _interopRequireDefault(_PatientList);
	
	var _AdminSidebar = __webpack_require__(203);
	
	var _AdminSidebar2 = _interopRequireDefault(_AdminSidebar);
	
	var _Chat = __webpack_require__(211);
	
	var _Chat2 = _interopRequireDefault(_Chat);
	
	__webpack_require__(392);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
	
	function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }
	
	function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }
	
	var UserDashboard = function (_React$PureComponent) {
	  _inherits(UserDashboard, _React$PureComponent);
	
	  function UserDashboard(props) {
	    _classCallCheck(this, UserDashboard);
	
	    var _this = _possibleConstructorReturn(this, (UserDashboard.__proto__ || Object.getPrototypeOf(UserDashboard)).call(this, props));
	
	    _this.state = {
	      error: null,
	      isLoaded: false,
	      openedTab: 'Allgemein',
	
	      user: {},
	      authenticated: false
	    };
	
	    _this.tabClicked = _this.tabClicked.bind(_this);
	    _this.loggedIn = _this.loggedIn.bind(_this);
	    _this.logout = _this.logout.bind(_this);
	
	    _this.tabOpened = _react2.default.createElement(_Allgemein2.default, { refresh: false });
	    return _this;
	  }
	
	  _createClass(UserDashboard, [{
	    key: 'componentDidMount',
	    value: function componentDidMount() {
	      var cookies = _jsCookie2.default.get();
	      if (cookies.hasOwnProperty('authenticated') && cookies.hasOwnProperty('user')) {
	        if (cookies.authenticated) this.setState({ authenticated: true, user: JSON.parse(_jsCookie2.default.get('user')) });
	      }
	    }
	
	    /*
	    *     Call right component when Admin Dashboard sidebar tabs are clicked
	    */
	
	  }, {
	    key: 'tabClicked',
	    value: function tabClicked(e, id) {
	      var target = e.target.id;
	      this.setState({ refresh: this.state.openedTab === target });
	
	      switch (target) {
	        case "Allgemein":
	          this.setState({ openedTab: 'Allgemein' });
	          break;
	
	        case "PatientList":
	          this.setState({ openedTab: 'PatientList' });
	          break;
	        case "Chat":
	          this.setState({ openedTab: 'Chat' });
	          break;
	
	        default:
	          this.setState({ openedTab: 'Allgemein' });
	          break;
	      }
	    }
	  }, {
	    key: 'loggedIn',
	    value: function loggedIn(user) {
	      this.setState({ authenticated: true, user: user });
	      _jsCookie2.default.set('user', user);
	      _jsCookie2.default.set('authenticated', true);
	    }
	  }, {
	    key: 'logout',
	    value: function logout() {
	      this.setState({ authenticated: false, user: {} });
	      _jsCookie2.default.remove('authenticated');
	      _jsCookie2.default.remove('user');
	    }
	  }, {
	    key: 'render',
	    value: function render() {
	
	      if (this.state.authenticated && this.state.user !== {}) {
	        // console.log(this.state.user.type)
	        if (this.state.user.type === 'doctor') {
	          return _react2.default.createElement(
	            'section',
	            null,
	            _react2.default.createElement(
	              'div',
	              { className: 'wrapper' },
	              _react2.default.createElement(_AdminSidebar2.default, { firstname: this.state.user.firstname, tabClicked: this.tabClicked, openedTab: this.state.openedTab, logout: this.logout }),
	              _react2.default.createElement(
	                'div',
	                { className: 'main-panel', style: { backgroundColor: '#f5f6f8', minHeight: '100vh' } },
	                _react2.default.createElement(
	                  'div',
	                  { className: 'content' },
	                  this.state.openedTab === 'Allgemein' ? _react2.default.createElement(_Allgemein2.default, null) : null,
	                  this.state.openedTab === 'PatientList' ? _react2.default.createElement(_PatientList2.default, null) : null,
	                  this.state.openedTab === 'Chat' ? _react2.default.createElement(_Chat2.default, null) : null
	                )
	              )
	            )
	          );
	        } else if (this.state.user.type === 'patient') {
	          return _react2.default.createElement(_Patient2.default, { user: this.state.user, logout: this.logout });
	        }
	      } else {
	        return _react2.default.createElement(_Login2.default, { loggedIn: this.loggedIn });
	      }
	    }
	  }]);
	
	  return UserDashboard;
	}(_react2.default.PureComponent);
	
	exports.default = UserDashboard;

/***/ },
/* 280 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	
	var _Dashboard = __webpack_require__(279);
	
	Object.defineProperty(exports, 'default', {
	  enumerable: true,
	  get: function get() {
	    return _interopRequireDefault(_Dashboard).default;
	  }
	});

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/***/ },
/* 281 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	
	var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();
	
	var _react = __webpack_require__(2);
	
	var _react2 = _interopRequireDefault(_react);
	
	var _Medication = __webpack_require__(254);
	
	var _Medication2 = _interopRequireDefault(_Medication);
	
	var _Temperature = __webpack_require__(270);
	
	var _Temperature2 = _interopRequireDefault(_Temperature);
	
	var _Weight = __webpack_require__(278);
	
	var _Weight2 = _interopRequireDefault(_Weight);
	
	var _Pulse = __webpack_require__(262);
	
	var _Pulse2 = _interopRequireDefault(_Pulse);
	
	var _BloodPressure = __webpack_require__(246);
	
	var _BloodPressure2 = _interopRequireDefault(_BloodPressure);
	
	var _Chat = __webpack_require__(248);
	
	var _Chat2 = _interopRequireDefault(_Chat);
	
	var _reactTabs = __webpack_require__(74);
	
	var _logout = __webpack_require__(437);
	
	var _logout2 = _interopRequireDefault(_logout);
	
	var _Home_botton = __webpack_require__(434);
	
	var _Home_botton2 = _interopRequireDefault(_Home_botton);
	
	var _Chat_menu = __webpack_require__(433);
	
	var _Chat_menu2 = _interopRequireDefault(_Chat_menu);
	
	var _settings_wheel = __webpack_require__(438);
	
	var _settings_wheel2 = _interopRequireDefault(_settings_wheel);
	
	var _User_icon_BLACK = __webpack_require__(173);
	
	var _User_icon_BLACK2 = _interopRequireDefault(_User_icon_BLACK);
	
	var _tasks_pill = __webpack_require__(174);
	
	var _tasks_pill2 = _interopRequireDefault(_tasks_pill);
	
	var _tasks_temperature = __webpack_require__(106);
	
	var _tasks_temperature2 = _interopRequireDefault(_tasks_temperature);
	
	var _blood_pressure = __webpack_require__(104);
	
	var _blood_pressure2 = _interopRequireDefault(_blood_pressure);
	
	var _heart_rate = __webpack_require__(105);
	
	var _heart_rate2 = _interopRequireDefault(_heart_rate);
	
	var _weightClipartBlackAndWhite = __webpack_require__(175);
	
	var _weightClipartBlackAndWhite2 = _interopRequireDefault(_weightClipartBlackAndWhite);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
	
	function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }
	
	function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }
	
	var Patient = function (_React$PureComponent) {
	  _inherits(Patient, _React$PureComponent);
	
	  function Patient(props) {
	    _classCallCheck(this, Patient);
	
	    var _this = _possibleConstructorReturn(this, (Patient.__proto__ || Object.getPrototypeOf(Patient)).call(this, props));
	
	    _this.get_health = function () {
	      fetch('/api/patient/health/' + _this.props.user.username).then(function (blob) {
	        return blob.json();
	      }).then(function (blob) {
	
	        var missed = false;
	
	        blob.medication.forEach(function (med) {
	          if (med.missed.length !== 0) missed = true;
	        });
	
	        var finishedTasks = _this.checkFinishedTasksStatus(blob);
	
	        console.log(finishedTasks);
	
	        _this.setState({ isLoaded: true, birthdate: blob.birthdate, status: blob.status, backgroundColor: blob.backgroundColor, medication: blob.medication, temperature: blob.temperature, temperatures: blob.temperatures, weights: blob.weights, pulses: blob.pulses, blood_pressures: blob.blood_pressures, finishedTasks: finishedTasks }, function () {
	          return _this.forceUpdate();
	        });
	      }).catch(function (error) {
	        return _this.setState({ error: true });
	      });
	    };
	
	    _this.checkFinishedTasksStatus = function (blob) {
	      var finishedTasks = { missed: false, pending: false };
	      blob.medication.forEach(function (med) {
	        if (med.missed.length > 0) finishedTasks.missed = true;
	        if (med.pending.length > 0) finishedTasks.pending = true;
	      });
	
	      if (blob.temperatures.pending.length > 0) finishedTasks.pending = true;
	      if (blob.temperatures.missed.length > 0) finishedTasks.missed = true;
	
	      if (blob.blood_pressures.pending.length > 0) finishedTasks.pending = true;
	      if (blob.blood_pressures.missed.length > 0) finishedTasks.missed = true;
	
	      if (blob.weights.pending.length > 0) finishedTasks.pending = true;
	      if (blob.weights.missed.length > 0) finishedTasks.missed = true;
	
	      if (blob.pulses.pending.length > 0) finishedTasks.pending = true;
	      if (blob.pulses.missed.length > 0) finishedTasks.missed = true;
	
	      blob.medication.forEach(function (med) {
	        if (med.pending.length > 0) finishedTasks.pending = true;
	        if (med.missed.length > 0) finishedTasks.missed = true;
	      });
	
	      return finishedTasks;
	    };
	
	    _this.is_there_missed_med = function () {
	      var bool_missed = false;
	      var bool_pending = false;
	
	      _this.state.medication.forEach(function (med) {
	        if (med.pending.length > 0) bool_pending = true;
	        if (med.missed.length > 0) bool_missed = true;
	      });
	
	      return { missed: bool_missed, pending: bool_pending };
	    };
	
	    _this.state = {
	      error: false,
	      isLoaded: false,
	
	      finishedTasks: true,
	
	      medication_bool: false,
	      temprature_bool: false,
	      weight_bool: false,
	      blood_pressure_bool: false,
	      pulse_bool: false,
	
	      birthdate: '',
	      status: '',
	      backgroundColor: '',
	      medication: [],
	      missedMedication: [],
	      pendingMedication: [],
	      temperature: [],
	      temperatures: {},
	      weights: {},
	      pulses: {},
	      blood_pressures: {},
	      chatWindow: false
	    };
	
	    _this.removeMedFromPending = _this.removeMedFromPending.bind(_this);
	    return _this;
	  }
	
	  _createClass(Patient, [{
	    key: 'componentDidMount',
	    value: function componentDidMount() {
	      this.get_health();
	    }
	  }, {
	    key: 'removeMedFromPending',
	    value: function removeMedFromPending(med_title) {
	      var pendingMedication = this.state.pendingMedication;
	      var index = pendingMedication.findIndex(function (x) {
	        return x.title === med_title;
	      });
	      if (index !== -1 && index !== undefined) pendingMedication.splice(index, 1);
	      this.setState({ pendingMedication: pendingMedication });
	    }
	  }, {
	    key: 'render',
	    value: function render() {
	      var _this2 = this;
	
	      document.title = "Homecare App";
	
	      if (!this.state.isLoaded) {
	        return _react2.default.createElement('p', null);
	      }
	
	      if (this.state.chatWindow) {
	        return _react2.default.createElement(_Chat2.default, null);
	      }
	
	      if (this.state.medication_bool) {
	        return _react2.default.createElement(_Medication2.default, { medication: this.state.medication, missedMedication: this.state.missedMedication, username: this.props.user.username, removeMedFromPending: this.removeMedFromPending, backToDashboard: function backToDashboard(e) {
	            return _this2.setState({ medication_bool: false });
	          }, get_health: this.get_health, is_there_missed_med: this.is_there_missed_med });
	      }
	
	      if (this.state.temprature_bool) {
	        return _react2.default.createElement(_Temperature2.default, { temperature: this.state.temperature, temperatures: this.state.temperatures, pendingMedication: this.state.pendingMedication, username: this.props.user.username, removeMedFromPending: this.removeMedFromPending, backToDashboard: function backToDashboard(e) {
	            return _this2.setState({ temprature_bool: false });
	          }, get_health: this.get_health });
	      }
	
	      if (this.state.weight_bool) {
	        return _react2.default.createElement(_Weight2.default, { weights: this.state.weights, username: this.props.user.username, backToDashboard: function backToDashboard(e) {
	            return _this2.setState({ weight_bool: false });
	          }, get_health: this.get_health });
	      }
	
	      if (this.state.blood_pressure_bool) {
	        return _react2.default.createElement(_BloodPressure2.default, { blood_pressures: this.state.blood_pressures, username: this.props.user.username, backToDashboard: function backToDashboard(e) {
	            return _this2.setState({ blood_pressure_bool: false });
	          }, get_health: this.get_health });
	      }
	
	      if (this.state.pulse_bool) {
	        return _react2.default.createElement(_Pulse2.default, { pulses: this.state.pulses, username: this.props.user.username, backToDashboard: function backToDashboard(e) {
	            return _this2.setState({ pulse_bool: false });
	          }, get_health: this.get_health });
	      }
	
	      return _react2.default.createElement(
	        'div',
	        { className: 'container-fluid', style: { backgroundColor: '#f7f7f7', marginTop: '-20px', paddingTop: '30px' } },
	        _react2.default.createElement('img', { src: _logout2.default, alt: 'logout', className: 'patient_logout', onClick: function onClick(e) {
	            return _this2.props.logout(e);
	          } }),
	        _react2.default.createElement(
	          'div',
	          null,
	          _react2.default.createElement('img', { src: _User_icon_BLACK2.default, alt: 'logout', className: 'user_icon' }),
	          _react2.default.createElement(
	            'p',
	            { className: 'patient_hello' },
	            this.props.user.name
	          ),
	          _react2.default.createElement(
	            'p',
	            { className: 'patient_birthday' },
	            ("0" + (new Date(this.state.birthdate).getMonth() + 1)).slice(-2),
	            ' - ',
	            new Date(this.state.birthdate).getFullYear()
	          )
	        ),
	        this.state.finishedTasks.missed > 0 ? _react2.default.createElement(
	          'div',
	          { className: 'patient_health_status', style: { backgroundColor: '#ff918ba6' } },
	          _react2.default.createElement(
	            'h3',
	            { className: 'patient_status' },
	            'You have missed to add some data.'
	          ),
	          _react2.default.createElement(
	            'p',
	            { className: 'patient_status_task' },
	            'Make sure you add  your data at the right time!'
	          )
	        ) : null,
	        this.state.finishedTasks.pending > 0 && !this.state.finishedTasks.missed ? _react2.default.createElement(
	          'div',
	          { className: 'patient_health_status', style: { backgroundColor: '#ffc459a1' } },
	          _react2.default.createElement(
	            'h3',
	            { className: 'patient_status' },
	            'You have some pending tasks for today.'
	          ),
	          _react2.default.createElement(
	            'p',
	            { className: 'patient_status_task' },
	            'Make sure you add  your data at the right time!'
	          )
	        ) : null,
	        _react2.default.createElement(
	          'p',
	          { className: 'patient_tasks' },
	          'Tasks'
	        ),
	        _react2.default.createElement(
	          'div',
	          { className: 'row' },
	          _react2.default.createElement(
	            'div',
	            { className: 'col-6' },
	            _react2.default.createElement(
	              'div',
	              { className: 'patient_task_buble_container' },
	              _react2.default.createElement(
	                'div',
	                { className: ' patient_task_buble', onClick: function onClick(e) {
	                    return _this2.setState({ medication_bool: true });
	                  } },
	                _react2.default.createElement('img', { src: _tasks_pill2.default, alt: 'logout', className: 'tasks_pill' }),
	                _react2.default.createElement(
	                  'p',
	                  { className: 'patient_tasks_title' },
	                  ' Medication'
	                ),
	                this.is_there_missed_med().missed ? _react2.default.createElement(
	                  'p',
	                  { className: 'patient_tasks_subtitle', style: { color: 'red' } },
	                  'Missed tasks'
	                ) : null,
	                !this.is_there_missed_med().missed && this.is_there_missed_med().pending ? _react2.default.createElement(
	                  'p',
	                  { className: 'patient_tasks_subtitle', style: { color: '#f58900' } },
	                  'Pending task'
	                ) : null,
	                !this.is_there_missed_med().missed && !this.is_there_missed_med().pending ? _react2.default.createElement(
	                  'p',
	                  { className: 'patient_tasks_subtitle' },
	                  ' Task completed'
	                ) : null
	              )
	            )
	          ),
	          _react2.default.createElement(
	            'div',
	            { className: 'col-6' },
	            _react2.default.createElement(
	              'div',
	              { className: 'patient_task_buble_container' },
	              _react2.default.createElement(
	                'div',
	                { className: ' patient_task_buble', onClick: function onClick(e) {
	                    return _this2.setState({ temprature_bool: true });
	                  } },
	                _react2.default.createElement('img', { src: _tasks_temperature2.default, alt: 'logout', className: 'tasks_pill' }),
	                _react2.default.createElement(
	                  'p',
	                  { className: 'patient_tasks_title' },
	                  'Temperature'
	                ),
	                this.state.temperatures.missed.length > 0 ? _react2.default.createElement(
	                  'p',
	                  { className: 'patient_tasks_subtitle', style: { color: 'red' } },
	                  'Missed tasks'
	                ) : null,
	                this.state.temperatures.missed.length === 0 && this.state.temperatures.pending.length > 0 ? _react2.default.createElement(
	                  'p',
	                  { className: 'patient_tasks_subtitle', style: { color: '#f58900' } },
	                  'Pending task'
	                ) : null,
	                this.state.temperatures.missed.length === 0 && this.state.temperatures.pending.length === 0 ? _react2.default.createElement(
	                  'p',
	                  { className: 'patient_tasks_subtitle' },
	                  ' Task completed'
	                ) : null
	              )
	            )
	          )
	        ),
	        _react2.default.createElement(
	          'div',
	          { className: 'row' },
	          _react2.default.createElement(
	            'div',
	            { className: 'col-6' },
	            _react2.default.createElement(
	              'div',
	              { className: 'patient_task_buble_container' },
	              _react2.default.createElement(
	                'div',
	                { className: ' patient_task_buble', onClick: function onClick(e) {
	                    return _this2.setState({ blood_pressure_bool: true });
	                  } },
	                _react2.default.createElement('img', { src: _blood_pressure2.default, alt: 'logout', className: 'tasks_pill' }),
	                _react2.default.createElement(
	                  'p',
	                  { className: 'patient_tasks_title' },
	                  ' Blood Pressure'
	                ),
	                this.state.blood_pressures.missed.length > 0 ? _react2.default.createElement(
	                  'p',
	                  { className: 'patient_tasks_subtitle', style: { color: 'red' } },
	                  'Missed tasks'
	                ) : null,
	                this.state.blood_pressures.missed.length === 0 && this.state.blood_pressures.pending.length > 0 ? _react2.default.createElement(
	                  'p',
	                  { className: 'patient_tasks_subtitle', style: { color: '#f58900' } },
	                  'Pending task'
	                ) : null,
	                this.state.blood_pressures.missed.length === 0 && this.state.blood_pressures.pending.length === 0 ? _react2.default.createElement(
	                  'p',
	                  { className: 'patient_tasks_subtitle' },
	                  ' Task completed'
	                ) : null
	              )
	            )
	          ),
	          _react2.default.createElement(
	            'div',
	            { className: 'col-6' },
	            _react2.default.createElement(
	              'div',
	              { className: 'patient_task_buble_container' },
	              _react2.default.createElement(
	                'div',
	                { className: ' patient_task_buble', onClick: function onClick(e) {
	                    return _this2.setState({ pulse_bool: true });
	                  } },
	                _react2.default.createElement('img', { src: _heart_rate2.default, alt: 'logout', className: 'tasks_pill' }),
	                _react2.default.createElement(
	                  'p',
	                  { className: 'patient_tasks_title' },
	                  'Pulse'
	                ),
	                this.state.pulses.missed.length > 0 ? _react2.default.createElement(
	                  'p',
	                  { className: 'patient_tasks_subtitle', style: { color: 'red' } },
	                  'Missed tasks'
	                ) : null,
	                this.state.pulses.missed.length === 0 && this.state.pulses.pending.length > 0 ? _react2.default.createElement(
	                  'p',
	                  { className: 'patient_tasks_subtitle', style: { color: '#f58900' } },
	                  'Pending task'
	                ) : null,
	                this.state.pulses.missed.length === 0 && this.state.pulses.pending.length === 0 ? _react2.default.createElement(
	                  'p',
	                  { className: 'patient_tasks_subtitle' },
	                  ' Task completed'
	                ) : null
	              )
	            )
	          )
	        ),
	        _react2.default.createElement(
	          'div',
	          { className: 'row', style: { marginBottom: '20px' } },
	          _react2.default.createElement(
	            'div',
	            { className: 'col-6' },
	            _react2.default.createElement(
	              'div',
	              { className: 'patient_task_buble_container' },
	              _react2.default.createElement(
	                'div',
	                { className: ' patient_task_buble', onClick: function onClick(e) {
	                    return _this2.setState({ weight_bool: true });
	                  } },
	                _react2.default.createElement('img', { src: _weightClipartBlackAndWhite2.default, alt: 'logout', className: 'tasks_pill' }),
	                _react2.default.createElement(
	                  'p',
	                  { className: 'patient_tasks_title' },
	                  ' Weight'
	                ),
	                this.state.weights.missed.length > 0 ? _react2.default.createElement(
	                  'p',
	                  { className: 'patient_tasks_subtitle', style: { color: 'red' } },
	                  'Missed tasks'
	                ) : null,
	                this.state.weights.missed.length === 0 && this.state.weights.pending.length > 0 ? _react2.default.createElement(
	                  'p',
	                  { className: 'patient_tasks_subtitle', style: { color: '#f58900' } },
	                  'Pending task'
	                ) : null,
	                this.state.weights.missed.length === 0 && this.state.weights.pending.length === 0 ? _react2.default.createElement(
	                  'p',
	                  { className: 'patient_tasks_subtitle' },
	                  ' Task completed'
	                ) : null
	              )
	            )
	          )
	        ),
	        _react2.default.createElement(
	          'div',
	          { className: 'row', style: { height: '90px' } },
	          _react2.default.createElement('div', { className: 'col-6' })
	        ),
	        _react2.default.createElement(
	          'div',
	          { className: 'navbar row' },
	          _react2.default.createElement(
	            'div',
	            { className: ' col-4' },
	            _react2.default.createElement('img', { src: _Home_botton2.default, alt: 'home', className: 'menu_logo' }),
	            _react2.default.createElement(
	              'a',
	              { href: '#home' },
	              'Home'
	            )
	          ),
	          _react2.default.createElement(
	            'div',
	            { className: ' col-4', onClick: function onClick(e) {
	                return _this2.setState({ chatWindow: true });
	              } },
	            _react2.default.createElement('img', { src: _Chat_menu2.default, alt: 'History', className: 'menu_logo' }),
	            _react2.default.createElement(
	              'a',
	              { href: '#chat' },
	              'Chat'
	            )
	          ),
	          _react2.default.createElement(
	            'div',
	            { className: ' col-4' },
	            _react2.default.createElement('img', { src: _settings_wheel2.default, alt: 'Settings', className: 'menu_logo' }),
	            _react2.default.createElement(
	              'a',
	              { href: '#Settings', style: { textAlign: 'center' } },
	              'Settings'
	            )
	          )
	        )
	      );
	    }
	  }]);
	
	  return Patient;
	}(_react2.default.PureComponent);
	
	exports.default = Patient;

/***/ },
/* 282 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	
	var _Patient = __webpack_require__(281);
	
	Object.defineProperty(exports, 'default', {
	  enumerable: true,
	  get: function get() {
	    return _interopRequireDefault(_Patient).default;
	  }
	});

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/***/ },
/* 283 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	var _react = __webpack_require__(2);
	
	var _react2 = _interopRequireDefault(_react);
	
	var _reactDom = __webpack_require__(58);
	
	var _reactDom2 = _interopRequireDefault(_reactDom);
	
	var _App = __webpack_require__(201);
	
	var _App2 = _interopRequireDefault(_App);
	
	__webpack_require__(284);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	_reactDom2.default.render(_react2.default.createElement(_App2.default, null), document.getElementById('root'));

/***/ },
/* 284 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	var _socket = __webpack_require__(425);
	
	var _socket2 = _interopRequireDefault(_socket);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	var socket = (0, _socket2.default)('ws://localhost:5000');
	
	socket.on('connect', function () {
	    console.log('socket connected with sockID:', socket.id); // 标识socket session独一无二的符号，在客户端连接到服务端被设置
	});
	
	socket.on('recieveMsg', function (data) {
	    console.log('browser get msg:', data);
	});
	socket.emit('sendMsg', { name: 'Tom', data: Date.now() });
	console.log('browser send to server', { name: 'Tom', data: Date.now() });

/***/ },
/* 285 */
/***/ function(module, exports) {

	
	/**
	 * Expose `Backoff`.
	 */
	
	module.exports = Backoff;
	
	/**
	 * Initialize backoff timer with `opts`.
	 *
	 * - `min` initial timeout in milliseconds [100]
	 * - `max` max timeout [10000]
	 * - `jitter` [0]
	 * - `factor` [2]
	 *
	 * @param {Object} opts
	 * @api public
	 */
	
	function Backoff(opts) {
	  opts = opts || {};
	  this.ms = opts.min || 100;
	  this.max = opts.max || 10000;
	  this.factor = opts.factor || 2;
	  this.jitter = opts.jitter > 0 && opts.jitter <= 1 ? opts.jitter : 0;
	  this.attempts = 0;
	}
	
	/**
	 * Return the backoff duration.
	 *
	 * @return {Number}
	 * @api public
	 */
	
	Backoff.prototype.duration = function(){
	  var ms = this.ms * Math.pow(this.factor, this.attempts++);
	  if (this.jitter) {
	    var rand =  Math.random();
	    var deviation = Math.floor(rand * this.jitter * ms);
	    ms = (Math.floor(rand * 10) & 1) == 0  ? ms - deviation : ms + deviation;
	  }
	  return Math.min(ms, this.max) | 0;
	};
	
	/**
	 * Reset the number of attempts.
	 *
	 * @api public
	 */
	
	Backoff.prototype.reset = function(){
	  this.attempts = 0;
	};
	
	/**
	 * Set the minimum duration
	 *
	 * @api public
	 */
	
	Backoff.prototype.setMin = function(min){
	  this.ms = min;
	};
	
	/**
	 * Set the maximum duration
	 *
	 * @api public
	 */
	
	Backoff.prototype.setMax = function(max){
	  this.max = max;
	};
	
	/**
	 * Set the jitter
	 *
	 * @api public
	 */
	
	Backoff.prototype.setJitter = function(jitter){
	  this.jitter = jitter;
	};
	


/***/ },
/* 286 */
/***/ function(module, exports) {

	/*
	 * base64-arraybuffer
	 * https://github.com/niklasvh/base64-arraybuffer
	 *
	 * Copyright (c) 2012 Niklas von Hertzen
	 * Licensed under the MIT license.
	 */
	(function(chars){
	  "use strict";
	
	  exports.encode = function(arraybuffer) {
	    var bytes = new Uint8Array(arraybuffer),
	    i, len = bytes.length, base64 = "";
	
	    for (i = 0; i < len; i+=3) {
	      base64 += chars[bytes[i] >> 2];
	      base64 += chars[((bytes[i] & 3) << 4) | (bytes[i + 1] >> 4)];
	      base64 += chars[((bytes[i + 1] & 15) << 2) | (bytes[i + 2] >> 6)];
	      base64 += chars[bytes[i + 2] & 63];
	    }
	
	    if ((len % 3) === 2) {
	      base64 = base64.substring(0, base64.length - 1) + "=";
	    } else if (len % 3 === 1) {
	      base64 = base64.substring(0, base64.length - 2) + "==";
	    }
	
	    return base64;
	  };
	
	  exports.decode =  function(base64) {
	    var bufferLength = base64.length * 0.75,
	    len = base64.length, i, p = 0,
	    encoded1, encoded2, encoded3, encoded4;
	
	    if (base64[base64.length - 1] === "=") {
	      bufferLength--;
	      if (base64[base64.length - 2] === "=") {
	        bufferLength--;
	      }
	    }
	
	    var arraybuffer = new ArrayBuffer(bufferLength),
	    bytes = new Uint8Array(arraybuffer);
	
	    for (i = 0; i < len; i+=4) {
	      encoded1 = chars.indexOf(base64[i]);
	      encoded2 = chars.indexOf(base64[i+1]);
	      encoded3 = chars.indexOf(base64[i+2]);
	      encoded4 = chars.indexOf(base64[i+3]);
	
	      bytes[p++] = (encoded1 << 2) | (encoded2 >> 4);
	      bytes[p++] = ((encoded2 & 15) << 4) | (encoded3 >> 2);
	      bytes[p++] = ((encoded3 & 3) << 6) | (encoded4 & 63);
	    }
	
	    return arraybuffer;
	  };
	})("ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/");


/***/ },
/* 287 */
/***/ function(module, exports) {

	'use strict'
	
	exports.byteLength = byteLength
	exports.toByteArray = toByteArray
	exports.fromByteArray = fromByteArray
	
	var lookup = []
	var revLookup = []
	var Arr = typeof Uint8Array !== 'undefined' ? Uint8Array : Array
	
	var code = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/'
	for (var i = 0, len = code.length; i < len; ++i) {
	  lookup[i] = code[i]
	  revLookup[code.charCodeAt(i)] = i
	}
	
	// Support decoding URL-safe base64 strings, as Node.js does.
	// See: https://en.wikipedia.org/wiki/Base64#URL_applications
	revLookup['-'.charCodeAt(0)] = 62
	revLookup['_'.charCodeAt(0)] = 63
	
	function getLens (b64) {
	  var len = b64.length
	
	  if (len % 4 > 0) {
	    throw new Error('Invalid string. Length must be a multiple of 4')
	  }
	
	  // Trim off extra bytes after placeholder bytes are found
	  // See: https://github.com/beatgammit/base64-js/issues/42
	  var validLen = b64.indexOf('=')
	  if (validLen === -1) validLen = len
	
	  var placeHoldersLen = validLen === len
	    ? 0
	    : 4 - (validLen % 4)
	
	  return [validLen, placeHoldersLen]
	}
	
	// base64 is 4/3 + up to two characters of the original data
	function byteLength (b64) {
	  var lens = getLens(b64)
	  var validLen = lens[0]
	  var placeHoldersLen = lens[1]
	  return ((validLen + placeHoldersLen) * 3 / 4) - placeHoldersLen
	}
	
	function _byteLength (b64, validLen, placeHoldersLen) {
	  return ((validLen + placeHoldersLen) * 3 / 4) - placeHoldersLen
	}
	
	function toByteArray (b64) {
	  var tmp
	  var lens = getLens(b64)
	  var validLen = lens[0]
	  var placeHoldersLen = lens[1]
	
	  var arr = new Arr(_byteLength(b64, validLen, placeHoldersLen))
	
	  var curByte = 0
	
	  // if there are placeholders, only get up to the last complete 4 chars
	  var len = placeHoldersLen > 0
	    ? validLen - 4
	    : validLen
	
	  var i
	  for (i = 0; i < len; i += 4) {
	    tmp =
	      (revLookup[b64.charCodeAt(i)] << 18) |
	      (revLookup[b64.charCodeAt(i + 1)] << 12) |
	      (revLookup[b64.charCodeAt(i + 2)] << 6) |
	      revLookup[b64.charCodeAt(i + 3)]
	    arr[curByte++] = (tmp >> 16) & 0xFF
	    arr[curByte++] = (tmp >> 8) & 0xFF
	    arr[curByte++] = tmp & 0xFF
	  }
	
	  if (placeHoldersLen === 2) {
	    tmp =
	      (revLookup[b64.charCodeAt(i)] << 2) |
	      (revLookup[b64.charCodeAt(i + 1)] >> 4)
	    arr[curByte++] = tmp & 0xFF
	  }
	
	  if (placeHoldersLen === 1) {
	    tmp =
	      (revLookup[b64.charCodeAt(i)] << 10) |
	      (revLookup[b64.charCodeAt(i + 1)] << 4) |
	      (revLookup[b64.charCodeAt(i + 2)] >> 2)
	    arr[curByte++] = (tmp >> 8) & 0xFF
	    arr[curByte++] = tmp & 0xFF
	  }
	
	  return arr
	}
	
	function tripletToBase64 (num) {
	  return lookup[num >> 18 & 0x3F] +
	    lookup[num >> 12 & 0x3F] +
	    lookup[num >> 6 & 0x3F] +
	    lookup[num & 0x3F]
	}
	
	function encodeChunk (uint8, start, end) {
	  var tmp
	  var output = []
	  for (var i = start; i < end; i += 3) {
	    tmp =
	      ((uint8[i] << 16) & 0xFF0000) +
	      ((uint8[i + 1] << 8) & 0xFF00) +
	      (uint8[i + 2] & 0xFF)
	    output.push(tripletToBase64(tmp))
	  }
	  return output.join('')
	}
	
	function fromByteArray (uint8) {
	  var tmp
	  var len = uint8.length
	  var extraBytes = len % 3 // if we have 1 byte left, pad 2 bytes
	  var parts = []
	  var maxChunkLength = 16383 // must be multiple of 3
	
	  // go through the array every three bytes, we'll deal with trailing stuff later
	  for (var i = 0, len2 = len - extraBytes; i < len2; i += maxChunkLength) {
	    parts.push(encodeChunk(
	      uint8, i, (i + maxChunkLength) > len2 ? len2 : (i + maxChunkLength)
	    ))
	  }
	
	  // pad the end with zeros, but make sure to not forget the extra bytes
	  if (extraBytes === 1) {
	    tmp = uint8[len - 1]
	    parts.push(
	      lookup[tmp >> 2] +
	      lookup[(tmp << 4) & 0x3F] +
	      '=='
	    )
	  } else if (extraBytes === 2) {
	    tmp = (uint8[len - 2] << 8) + uint8[len - 1]
	    parts.push(
	      lookup[tmp >> 10] +
	      lookup[(tmp >> 4) & 0x3F] +
	      lookup[(tmp << 2) & 0x3F] +
	      '='
	    )
	  }
	
	  return parts.join('')
	}


/***/ },
/* 288 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(global) {/*!
	 * The buffer module from node.js, for the browser.
	 *
	 * @author   Feross Aboukhadijeh <http://feross.org>
	 * @license  MIT
	 */
	/* eslint-disable no-proto */
	
	'use strict'
	
	var base64 = __webpack_require__(287)
	var ieee754 = __webpack_require__(398)
	var isArray = __webpack_require__(399)
	
	exports.Buffer = Buffer
	exports.SlowBuffer = SlowBuffer
	exports.INSPECT_MAX_BYTES = 50
	
	/**
	 * If `Buffer.TYPED_ARRAY_SUPPORT`:
	 *   === true    Use Uint8Array implementation (fastest)
	 *   === false   Use Object implementation (most compatible, even IE6)
	 *
	 * Browsers that support typed arrays are IE 10+, Firefox 4+, Chrome 7+, Safari 5.1+,
	 * Opera 11.6+, iOS 4.2+.
	 *
	 * Due to various browser bugs, sometimes the Object implementation will be used even
	 * when the browser supports typed arrays.
	 *
	 * Note:
	 *
	 *   - Firefox 4-29 lacks support for adding new properties to `Uint8Array` instances,
	 *     See: https://bugzilla.mozilla.org/show_bug.cgi?id=695438.
	 *
	 *   - Chrome 9-10 is missing the `TypedArray.prototype.subarray` function.
	 *
	 *   - IE10 has a broken `TypedArray.prototype.subarray` function which returns arrays of
	 *     incorrect length in some situations.
	
	 * We detect these buggy browsers and set `Buffer.TYPED_ARRAY_SUPPORT` to `false` so they
	 * get the Object implementation, which is slower but behaves correctly.
	 */
	Buffer.TYPED_ARRAY_SUPPORT = global.TYPED_ARRAY_SUPPORT !== undefined
	  ? global.TYPED_ARRAY_SUPPORT
	  : typedArraySupport()
	
	/*
	 * Export kMaxLength after typed array support is determined.
	 */
	exports.kMaxLength = kMaxLength()
	
	function typedArraySupport () {
	  try {
	    var arr = new Uint8Array(1)
	    arr.__proto__ = {__proto__: Uint8Array.prototype, foo: function () { return 42 }}
	    return arr.foo() === 42 && // typed array instances can be augmented
	        typeof arr.subarray === 'function' && // chrome 9-10 lack `subarray`
	        arr.subarray(1, 1).byteLength === 0 // ie10 has broken `subarray`
	  } catch (e) {
	    return false
	  }
	}
	
	function kMaxLength () {
	  return Buffer.TYPED_ARRAY_SUPPORT
	    ? 0x7fffffff
	    : 0x3fffffff
	}
	
	function createBuffer (that, length) {
	  if (kMaxLength() < length) {
	    throw new RangeError('Invalid typed array length')
	  }
	  if (Buffer.TYPED_ARRAY_SUPPORT) {
	    // Return an augmented `Uint8Array` instance, for best performance
	    that = new Uint8Array(length)
	    that.__proto__ = Buffer.prototype
	  } else {
	    // Fallback: Return an object instance of the Buffer class
	    if (that === null) {
	      that = new Buffer(length)
	    }
	    that.length = length
	  }
	
	  return that
	}
	
	/**
	 * The Buffer constructor returns instances of `Uint8Array` that have their
	 * prototype changed to `Buffer.prototype`. Furthermore, `Buffer` is a subclass of
	 * `Uint8Array`, so the returned instances will have all the node `Buffer` methods
	 * and the `Uint8Array` methods. Square bracket notation works as expected -- it
	 * returns a single octet.
	 *
	 * The `Uint8Array` prototype remains unmodified.
	 */
	
	function Buffer (arg, encodingOrOffset, length) {
	  if (!Buffer.TYPED_ARRAY_SUPPORT && !(this instanceof Buffer)) {
	    return new Buffer(arg, encodingOrOffset, length)
	  }
	
	  // Common case.
	  if (typeof arg === 'number') {
	    if (typeof encodingOrOffset === 'string') {
	      throw new Error(
	        'If encoding is specified then the first argument must be a string'
	      )
	    }
	    return allocUnsafe(this, arg)
	  }
	  return from(this, arg, encodingOrOffset, length)
	}
	
	Buffer.poolSize = 8192 // not used by this implementation
	
	// TODO: Legacy, not needed anymore. Remove in next major version.
	Buffer._augment = function (arr) {
	  arr.__proto__ = Buffer.prototype
	  return arr
	}
	
	function from (that, value, encodingOrOffset, length) {
	  if (typeof value === 'number') {
	    throw new TypeError('"value" argument must not be a number')
	  }
	
	  if (typeof ArrayBuffer !== 'undefined' && value instanceof ArrayBuffer) {
	    return fromArrayBuffer(that, value, encodingOrOffset, length)
	  }
	
	  if (typeof value === 'string') {
	    return fromString(that, value, encodingOrOffset)
	  }
	
	  return fromObject(that, value)
	}
	
	/**
	 * Functionally equivalent to Buffer(arg, encoding) but throws a TypeError
	 * if value is a number.
	 * Buffer.from(str[, encoding])
	 * Buffer.from(array)
	 * Buffer.from(buffer)
	 * Buffer.from(arrayBuffer[, byteOffset[, length]])
	 **/
	Buffer.from = function (value, encodingOrOffset, length) {
	  return from(null, value, encodingOrOffset, length)
	}
	
	if (Buffer.TYPED_ARRAY_SUPPORT) {
	  Buffer.prototype.__proto__ = Uint8Array.prototype
	  Buffer.__proto__ = Uint8Array
	  if (typeof Symbol !== 'undefined' && Symbol.species &&
	      Buffer[Symbol.species] === Buffer) {
	    // Fix subarray() in ES2016. See: https://github.com/feross/buffer/pull/97
	    Object.defineProperty(Buffer, Symbol.species, {
	      value: null,
	      configurable: true
	    })
	  }
	}
	
	function assertSize (size) {
	  if (typeof size !== 'number') {
	    throw new TypeError('"size" argument must be a number')
	  } else if (size < 0) {
	    throw new RangeError('"size" argument must not be negative')
	  }
	}
	
	function alloc (that, size, fill, encoding) {
	  assertSize(size)
	  if (size <= 0) {
	    return createBuffer(that, size)
	  }
	  if (fill !== undefined) {
	    // Only pay attention to encoding if it's a string. This
	    // prevents accidentally sending in a number that would
	    // be interpretted as a start offset.
	    return typeof encoding === 'string'
	      ? createBuffer(that, size).fill(fill, encoding)
	      : createBuffer(that, size).fill(fill)
	  }
	  return createBuffer(that, size)
	}
	
	/**
	 * Creates a new filled Buffer instance.
	 * alloc(size[, fill[, encoding]])
	 **/
	Buffer.alloc = function (size, fill, encoding) {
	  return alloc(null, size, fill, encoding)
	}
	
	function allocUnsafe (that, size) {
	  assertSize(size)
	  that = createBuffer(that, size < 0 ? 0 : checked(size) | 0)
	  if (!Buffer.TYPED_ARRAY_SUPPORT) {
	    for (var i = 0; i < size; ++i) {
	      that[i] = 0
	    }
	  }
	  return that
	}
	
	/**
	 * Equivalent to Buffer(num), by default creates a non-zero-filled Buffer instance.
	 * */
	Buffer.allocUnsafe = function (size) {
	  return allocUnsafe(null, size)
	}
	/**
	 * Equivalent to SlowBuffer(num), by default creates a non-zero-filled Buffer instance.
	 */
	Buffer.allocUnsafeSlow = function (size) {
	  return allocUnsafe(null, size)
	}
	
	function fromString (that, string, encoding) {
	  if (typeof encoding !== 'string' || encoding === '') {
	    encoding = 'utf8'
	  }
	
	  if (!Buffer.isEncoding(encoding)) {
	    throw new TypeError('"encoding" must be a valid string encoding')
	  }
	
	  var length = byteLength(string, encoding) | 0
	  that = createBuffer(that, length)
	
	  var actual = that.write(string, encoding)
	
	  if (actual !== length) {
	    // Writing a hex string, for example, that contains invalid characters will
	    // cause everything after the first invalid character to be ignored. (e.g.
	    // 'abxxcd' will be treated as 'ab')
	    that = that.slice(0, actual)
	  }
	
	  return that
	}
	
	function fromArrayLike (that, array) {
	  var length = array.length < 0 ? 0 : checked(array.length) | 0
	  that = createBuffer(that, length)
	  for (var i = 0; i < length; i += 1) {
	    that[i] = array[i] & 255
	  }
	  return that
	}
	
	function fromArrayBuffer (that, array, byteOffset, length) {
	  array.byteLength // this throws if `array` is not a valid ArrayBuffer
	
	  if (byteOffset < 0 || array.byteLength < byteOffset) {
	    throw new RangeError('\'offset\' is out of bounds')
	  }
	
	  if (array.byteLength < byteOffset + (length || 0)) {
	    throw new RangeError('\'length\' is out of bounds')
	  }
	
	  if (byteOffset === undefined && length === undefined) {
	    array = new Uint8Array(array)
	  } else if (length === undefined) {
	    array = new Uint8Array(array, byteOffset)
	  } else {
	    array = new Uint8Array(array, byteOffset, length)
	  }
	
	  if (Buffer.TYPED_ARRAY_SUPPORT) {
	    // Return an augmented `Uint8Array` instance, for best performance
	    that = array
	    that.__proto__ = Buffer.prototype
	  } else {
	    // Fallback: Return an object instance of the Buffer class
	    that = fromArrayLike(that, array)
	  }
	  return that
	}
	
	function fromObject (that, obj) {
	  if (Buffer.isBuffer(obj)) {
	    var len = checked(obj.length) | 0
	    that = createBuffer(that, len)
	
	    if (that.length === 0) {
	      return that
	    }
	
	    obj.copy(that, 0, 0, len)
	    return that
	  }
	
	  if (obj) {
	    if ((typeof ArrayBuffer !== 'undefined' &&
	        obj.buffer instanceof ArrayBuffer) || 'length' in obj) {
	      if (typeof obj.length !== 'number' || isnan(obj.length)) {
	        return createBuffer(that, 0)
	      }
	      return fromArrayLike(that, obj)
	    }
	
	    if (obj.type === 'Buffer' && isArray(obj.data)) {
	      return fromArrayLike(that, obj.data)
	    }
	  }
	
	  throw new TypeError('First argument must be a string, Buffer, ArrayBuffer, Array, or array-like object.')
	}
	
	function checked (length) {
	  // Note: cannot use `length < kMaxLength()` here because that fails when
	  // length is NaN (which is otherwise coerced to zero.)
	  if (length >= kMaxLength()) {
	    throw new RangeError('Attempt to allocate Buffer larger than maximum ' +
	                         'size: 0x' + kMaxLength().toString(16) + ' bytes')
	  }
	  return length | 0
	}
	
	function SlowBuffer (length) {
	  if (+length != length) { // eslint-disable-line eqeqeq
	    length = 0
	  }
	  return Buffer.alloc(+length)
	}
	
	Buffer.isBuffer = function isBuffer (b) {
	  return !!(b != null && b._isBuffer)
	}
	
	Buffer.compare = function compare (a, b) {
	  if (!Buffer.isBuffer(a) || !Buffer.isBuffer(b)) {
	    throw new TypeError('Arguments must be Buffers')
	  }
	
	  if (a === b) return 0
	
	  var x = a.length
	  var y = b.length
	
	  for (var i = 0, len = Math.min(x, y); i < len; ++i) {
	    if (a[i] !== b[i]) {
	      x = a[i]
	      y = b[i]
	      break
	    }
	  }
	
	  if (x < y) return -1
	  if (y < x) return 1
	  return 0
	}
	
	Buffer.isEncoding = function isEncoding (encoding) {
	  switch (String(encoding).toLowerCase()) {
	    case 'hex':
	    case 'utf8':
	    case 'utf-8':
	    case 'ascii':
	    case 'latin1':
	    case 'binary':
	    case 'base64':
	    case 'ucs2':
	    case 'ucs-2':
	    case 'utf16le':
	    case 'utf-16le':
	      return true
	    default:
	      return false
	  }
	}
	
	Buffer.concat = function concat (list, length) {
	  if (!isArray(list)) {
	    throw new TypeError('"list" argument must be an Array of Buffers')
	  }
	
	  if (list.length === 0) {
	    return Buffer.alloc(0)
	  }
	
	  var i
	  if (length === undefined) {
	    length = 0
	    for (i = 0; i < list.length; ++i) {
	      length += list[i].length
	    }
	  }
	
	  var buffer = Buffer.allocUnsafe(length)
	  var pos = 0
	  for (i = 0; i < list.length; ++i) {
	    var buf = list[i]
	    if (!Buffer.isBuffer(buf)) {
	      throw new TypeError('"list" argument must be an Array of Buffers')
	    }
	    buf.copy(buffer, pos)
	    pos += buf.length
	  }
	  return buffer
	}
	
	function byteLength (string, encoding) {
	  if (Buffer.isBuffer(string)) {
	    return string.length
	  }
	  if (typeof ArrayBuffer !== 'undefined' && typeof ArrayBuffer.isView === 'function' &&
	      (ArrayBuffer.isView(string) || string instanceof ArrayBuffer)) {
	    return string.byteLength
	  }
	  if (typeof string !== 'string') {
	    string = '' + string
	  }
	
	  var len = string.length
	  if (len === 0) return 0
	
	  // Use a for loop to avoid recursion
	  var loweredCase = false
	  for (;;) {
	    switch (encoding) {
	      case 'ascii':
	      case 'latin1':
	      case 'binary':
	        return len
	      case 'utf8':
	      case 'utf-8':
	      case undefined:
	        return utf8ToBytes(string).length
	      case 'ucs2':
	      case 'ucs-2':
	      case 'utf16le':
	      case 'utf-16le':
	        return len * 2
	      case 'hex':
	        return len >>> 1
	      case 'base64':
	        return base64ToBytes(string).length
	      default:
	        if (loweredCase) return utf8ToBytes(string).length // assume utf8
	        encoding = ('' + encoding).toLowerCase()
	        loweredCase = true
	    }
	  }
	}
	Buffer.byteLength = byteLength
	
	function slowToString (encoding, start, end) {
	  var loweredCase = false
	
	  // No need to verify that "this.length <= MAX_UINT32" since it's a read-only
	  // property of a typed array.
	
	  // This behaves neither like String nor Uint8Array in that we set start/end
	  // to their upper/lower bounds if the value passed is out of range.
	  // undefined is handled specially as per ECMA-262 6th Edition,
	  // Section 13.3.3.7 Runtime Semantics: KeyedBindingInitialization.
	  if (start === undefined || start < 0) {
	    start = 0
	  }
	  // Return early if start > this.length. Done here to prevent potential uint32
	  // coercion fail below.
	  if (start > this.length) {
	    return ''
	  }
	
	  if (end === undefined || end > this.length) {
	    end = this.length
	  }
	
	  if (end <= 0) {
	    return ''
	  }
	
	  // Force coersion to uint32. This will also coerce falsey/NaN values to 0.
	  end >>>= 0
	  start >>>= 0
	
	  if (end <= start) {
	    return ''
	  }
	
	  if (!encoding) encoding = 'utf8'
	
	  while (true) {
	    switch (encoding) {
	      case 'hex':
	        return hexSlice(this, start, end)
	
	      case 'utf8':
	      case 'utf-8':
	        return utf8Slice(this, start, end)
	
	      case 'ascii':
	        return asciiSlice(this, start, end)
	
	      case 'latin1':
	      case 'binary':
	        return latin1Slice(this, start, end)
	
	      case 'base64':
	        return base64Slice(this, start, end)
	
	      case 'ucs2':
	      case 'ucs-2':
	      case 'utf16le':
	      case 'utf-16le':
	        return utf16leSlice(this, start, end)
	
	      default:
	        if (loweredCase) throw new TypeError('Unknown encoding: ' + encoding)
	        encoding = (encoding + '').toLowerCase()
	        loweredCase = true
	    }
	  }
	}
	
	// The property is used by `Buffer.isBuffer` and `is-buffer` (in Safari 5-7) to detect
	// Buffer instances.
	Buffer.prototype._isBuffer = true
	
	function swap (b, n, m) {
	  var i = b[n]
	  b[n] = b[m]
	  b[m] = i
	}
	
	Buffer.prototype.swap16 = function swap16 () {
	  var len = this.length
	  if (len % 2 !== 0) {
	    throw new RangeError('Buffer size must be a multiple of 16-bits')
	  }
	  for (var i = 0; i < len; i += 2) {
	    swap(this, i, i + 1)
	  }
	  return this
	}
	
	Buffer.prototype.swap32 = function swap32 () {
	  var len = this.length
	  if (len % 4 !== 0) {
	    throw new RangeError('Buffer size must be a multiple of 32-bits')
	  }
	  for (var i = 0; i < len; i += 4) {
	    swap(this, i, i + 3)
	    swap(this, i + 1, i + 2)
	  }
	  return this
	}
	
	Buffer.prototype.swap64 = function swap64 () {
	  var len = this.length
	  if (len % 8 !== 0) {
	    throw new RangeError('Buffer size must be a multiple of 64-bits')
	  }
	  for (var i = 0; i < len; i += 8) {
	    swap(this, i, i + 7)
	    swap(this, i + 1, i + 6)
	    swap(this, i + 2, i + 5)
	    swap(this, i + 3, i + 4)
	  }
	  return this
	}
	
	Buffer.prototype.toString = function toString () {
	  var length = this.length | 0
	  if (length === 0) return ''
	  if (arguments.length === 0) return utf8Slice(this, 0, length)
	  return slowToString.apply(this, arguments)
	}
	
	Buffer.prototype.equals = function equals (b) {
	  if (!Buffer.isBuffer(b)) throw new TypeError('Argument must be a Buffer')
	  if (this === b) return true
	  return Buffer.compare(this, b) === 0
	}
	
	Buffer.prototype.inspect = function inspect () {
	  var str = ''
	  var max = exports.INSPECT_MAX_BYTES
	  if (this.length > 0) {
	    str = this.toString('hex', 0, max).match(/.{2}/g).join(' ')
	    if (this.length > max) str += ' ... '
	  }
	  return '<Buffer ' + str + '>'
	}
	
	Buffer.prototype.compare = function compare (target, start, end, thisStart, thisEnd) {
	  if (!Buffer.isBuffer(target)) {
	    throw new TypeError('Argument must be a Buffer')
	  }
	
	  if (start === undefined) {
	    start = 0
	  }
	  if (end === undefined) {
	    end = target ? target.length : 0
	  }
	  if (thisStart === undefined) {
	    thisStart = 0
	  }
	  if (thisEnd === undefined) {
	    thisEnd = this.length
	  }
	
	  if (start < 0 || end > target.length || thisStart < 0 || thisEnd > this.length) {
	    throw new RangeError('out of range index')
	  }
	
	  if (thisStart >= thisEnd && start >= end) {
	    return 0
	  }
	  if (thisStart >= thisEnd) {
	    return -1
	  }
	  if (start >= end) {
	    return 1
	  }
	
	  start >>>= 0
	  end >>>= 0
	  thisStart >>>= 0
	  thisEnd >>>= 0
	
	  if (this === target) return 0
	
	  var x = thisEnd - thisStart
	  var y = end - start
	  var len = Math.min(x, y)
	
	  var thisCopy = this.slice(thisStart, thisEnd)
	  var targetCopy = target.slice(start, end)
	
	  for (var i = 0; i < len; ++i) {
	    if (thisCopy[i] !== targetCopy[i]) {
	      x = thisCopy[i]
	      y = targetCopy[i]
	      break
	    }
	  }
	
	  if (x < y) return -1
	  if (y < x) return 1
	  return 0
	}
	
	// Finds either the first index of `val` in `buffer` at offset >= `byteOffset`,
	// OR the last index of `val` in `buffer` at offset <= `byteOffset`.
	//
	// Arguments:
	// - buffer - a Buffer to search
	// - val - a string, Buffer, or number
	// - byteOffset - an index into `buffer`; will be clamped to an int32
	// - encoding - an optional encoding, relevant is val is a string
	// - dir - true for indexOf, false for lastIndexOf
	function bidirectionalIndexOf (buffer, val, byteOffset, encoding, dir) {
	  // Empty buffer means no match
	  if (buffer.length === 0) return -1
	
	  // Normalize byteOffset
	  if (typeof byteOffset === 'string') {
	    encoding = byteOffset
	    byteOffset = 0
	  } else if (byteOffset > 0x7fffffff) {
	    byteOffset = 0x7fffffff
	  } else if (byteOffset < -0x80000000) {
	    byteOffset = -0x80000000
	  }
	  byteOffset = +byteOffset  // Coerce to Number.
	  if (isNaN(byteOffset)) {
	    // byteOffset: it it's undefined, null, NaN, "foo", etc, search whole buffer
	    byteOffset = dir ? 0 : (buffer.length - 1)
	  }
	
	  // Normalize byteOffset: negative offsets start from the end of the buffer
	  if (byteOffset < 0) byteOffset = buffer.length + byteOffset
	  if (byteOffset >= buffer.length) {
	    if (dir) return -1
	    else byteOffset = buffer.length - 1
	  } else if (byteOffset < 0) {
	    if (dir) byteOffset = 0
	    else return -1
	  }
	
	  // Normalize val
	  if (typeof val === 'string') {
	    val = Buffer.from(val, encoding)
	  }
	
	  // Finally, search either indexOf (if dir is true) or lastIndexOf
	  if (Buffer.isBuffer(val)) {
	    // Special case: looking for empty string/buffer always fails
	    if (val.length === 0) {
	      return -1
	    }
	    return arrayIndexOf(buffer, val, byteOffset, encoding, dir)
	  } else if (typeof val === 'number') {
	    val = val & 0xFF // Search for a byte value [0-255]
	    if (Buffer.TYPED_ARRAY_SUPPORT &&
	        typeof Uint8Array.prototype.indexOf === 'function') {
	      if (dir) {
	        return Uint8Array.prototype.indexOf.call(buffer, val, byteOffset)
	      } else {
	        return Uint8Array.prototype.lastIndexOf.call(buffer, val, byteOffset)
	      }
	    }
	    return arrayIndexOf(buffer, [ val ], byteOffset, encoding, dir)
	  }
	
	  throw new TypeError('val must be string, number or Buffer')
	}
	
	function arrayIndexOf (arr, val, byteOffset, encoding, dir) {
	  var indexSize = 1
	  var arrLength = arr.length
	  var valLength = val.length
	
	  if (encoding !== undefined) {
	    encoding = String(encoding).toLowerCase()
	    if (encoding === 'ucs2' || encoding === 'ucs-2' ||
	        encoding === 'utf16le' || encoding === 'utf-16le') {
	      if (arr.length < 2 || val.length < 2) {
	        return -1
	      }
	      indexSize = 2
	      arrLength /= 2
	      valLength /= 2
	      byteOffset /= 2
	    }
	  }
	
	  function read (buf, i) {
	    if (indexSize === 1) {
	      return buf[i]
	    } else {
	      return buf.readUInt16BE(i * indexSize)
	    }
	  }
	
	  var i
	  if (dir) {
	    var foundIndex = -1
	    for (i = byteOffset; i < arrLength; i++) {
	      if (read(arr, i) === read(val, foundIndex === -1 ? 0 : i - foundIndex)) {
	        if (foundIndex === -1) foundIndex = i
	        if (i - foundIndex + 1 === valLength) return foundIndex * indexSize
	      } else {
	        if (foundIndex !== -1) i -= i - foundIndex
	        foundIndex = -1
	      }
	    }
	  } else {
	    if (byteOffset + valLength > arrLength) byteOffset = arrLength - valLength
	    for (i = byteOffset; i >= 0; i--) {
	      var found = true
	      for (var j = 0; j < valLength; j++) {
	        if (read(arr, i + j) !== read(val, j)) {
	          found = false
	          break
	        }
	      }
	      if (found) return i
	    }
	  }
	
	  return -1
	}
	
	Buffer.prototype.includes = function includes (val, byteOffset, encoding) {
	  return this.indexOf(val, byteOffset, encoding) !== -1
	}
	
	Buffer.prototype.indexOf = function indexOf (val, byteOffset, encoding) {
	  return bidirectionalIndexOf(this, val, byteOffset, encoding, true)
	}
	
	Buffer.prototype.lastIndexOf = function lastIndexOf (val, byteOffset, encoding) {
	  return bidirectionalIndexOf(this, val, byteOffset, encoding, false)
	}
	
	function hexWrite (buf, string, offset, length) {
	  offset = Number(offset) || 0
	  var remaining = buf.length - offset
	  if (!length) {
	    length = remaining
	  } else {
	    length = Number(length)
	    if (length > remaining) {
	      length = remaining
	    }
	  }
	
	  // must be an even number of digits
	  var strLen = string.length
	  if (strLen % 2 !== 0) throw new TypeError('Invalid hex string')
	
	  if (length > strLen / 2) {
	    length = strLen / 2
	  }
	  for (var i = 0; i < length; ++i) {
	    var parsed = parseInt(string.substr(i * 2, 2), 16)
	    if (isNaN(parsed)) return i
	    buf[offset + i] = parsed
	  }
	  return i
	}
	
	function utf8Write (buf, string, offset, length) {
	  return blitBuffer(utf8ToBytes(string, buf.length - offset), buf, offset, length)
	}
	
	function asciiWrite (buf, string, offset, length) {
	  return blitBuffer(asciiToBytes(string), buf, offset, length)
	}
	
	function latin1Write (buf, string, offset, length) {
	  return asciiWrite(buf, string, offset, length)
	}
	
	function base64Write (buf, string, offset, length) {
	  return blitBuffer(base64ToBytes(string), buf, offset, length)
	}
	
	function ucs2Write (buf, string, offset, length) {
	  return blitBuffer(utf16leToBytes(string, buf.length - offset), buf, offset, length)
	}
	
	Buffer.prototype.write = function write (string, offset, length, encoding) {
	  // Buffer#write(string)
	  if (offset === undefined) {
	    encoding = 'utf8'
	    length = this.length
	    offset = 0
	  // Buffer#write(string, encoding)
	  } else if (length === undefined && typeof offset === 'string') {
	    encoding = offset
	    length = this.length
	    offset = 0
	  // Buffer#write(string, offset[, length][, encoding])
	  } else if (isFinite(offset)) {
	    offset = offset | 0
	    if (isFinite(length)) {
	      length = length | 0
	      if (encoding === undefined) encoding = 'utf8'
	    } else {
	      encoding = length
	      length = undefined
	    }
	  // legacy write(string, encoding, offset, length) - remove in v0.13
	  } else {
	    throw new Error(
	      'Buffer.write(string, encoding, offset[, length]) is no longer supported'
	    )
	  }
	
	  var remaining = this.length - offset
	  if (length === undefined || length > remaining) length = remaining
	
	  if ((string.length > 0 && (length < 0 || offset < 0)) || offset > this.length) {
	    throw new RangeError('Attempt to write outside buffer bounds')
	  }
	
	  if (!encoding) encoding = 'utf8'
	
	  var loweredCase = false
	  for (;;) {
	    switch (encoding) {
	      case 'hex':
	        return hexWrite(this, string, offset, length)
	
	      case 'utf8':
	      case 'utf-8':
	        return utf8Write(this, string, offset, length)
	
	      case 'ascii':
	        return asciiWrite(this, string, offset, length)
	
	      case 'latin1':
	      case 'binary':
	        return latin1Write(this, string, offset, length)
	
	      case 'base64':
	        // Warning: maxLength not taken into account in base64Write
	        return base64Write(this, string, offset, length)
	
	      case 'ucs2':
	      case 'ucs-2':
	      case 'utf16le':
	      case 'utf-16le':
	        return ucs2Write(this, string, offset, length)
	
	      default:
	        if (loweredCase) throw new TypeError('Unknown encoding: ' + encoding)
	        encoding = ('' + encoding).toLowerCase()
	        loweredCase = true
	    }
	  }
	}
	
	Buffer.prototype.toJSON = function toJSON () {
	  return {
	    type: 'Buffer',
	    data: Array.prototype.slice.call(this._arr || this, 0)
	  }
	}
	
	function base64Slice (buf, start, end) {
	  if (start === 0 && end === buf.length) {
	    return base64.fromByteArray(buf)
	  } else {
	    return base64.fromByteArray(buf.slice(start, end))
	  }
	}
	
	function utf8Slice (buf, start, end) {
	  end = Math.min(buf.length, end)
	  var res = []
	
	  var i = start
	  while (i < end) {
	    var firstByte = buf[i]
	    var codePoint = null
	    var bytesPerSequence = (firstByte > 0xEF) ? 4
	      : (firstByte > 0xDF) ? 3
	      : (firstByte > 0xBF) ? 2
	      : 1
	
	    if (i + bytesPerSequence <= end) {
	      var secondByte, thirdByte, fourthByte, tempCodePoint
	
	      switch (bytesPerSequence) {
	        case 1:
	          if (firstByte < 0x80) {
	            codePoint = firstByte
	          }
	          break
	        case 2:
	          secondByte = buf[i + 1]
	          if ((secondByte & 0xC0) === 0x80) {
	            tempCodePoint = (firstByte & 0x1F) << 0x6 | (secondByte & 0x3F)
	            if (tempCodePoint > 0x7F) {
	              codePoint = tempCodePoint
	            }
	          }
	          break
	        case 3:
	          secondByte = buf[i + 1]
	          thirdByte = buf[i + 2]
	          if ((secondByte & 0xC0) === 0x80 && (thirdByte & 0xC0) === 0x80) {
	            tempCodePoint = (firstByte & 0xF) << 0xC | (secondByte & 0x3F) << 0x6 | (thirdByte & 0x3F)
	            if (tempCodePoint > 0x7FF && (tempCodePoint < 0xD800 || tempCodePoint > 0xDFFF)) {
	              codePoint = tempCodePoint
	            }
	          }
	          break
	        case 4:
	          secondByte = buf[i + 1]
	          thirdByte = buf[i + 2]
	          fourthByte = buf[i + 3]
	          if ((secondByte & 0xC0) === 0x80 && (thirdByte & 0xC0) === 0x80 && (fourthByte & 0xC0) === 0x80) {
	            tempCodePoint = (firstByte & 0xF) << 0x12 | (secondByte & 0x3F) << 0xC | (thirdByte & 0x3F) << 0x6 | (fourthByte & 0x3F)
	            if (tempCodePoint > 0xFFFF && tempCodePoint < 0x110000) {
	              codePoint = tempCodePoint
	            }
	          }
	      }
	    }
	
	    if (codePoint === null) {
	      // we did not generate a valid codePoint so insert a
	      // replacement char (U+FFFD) and advance only 1 byte
	      codePoint = 0xFFFD
	      bytesPerSequence = 1
	    } else if (codePoint > 0xFFFF) {
	      // encode to utf16 (surrogate pair dance)
	      codePoint -= 0x10000
	      res.push(codePoint >>> 10 & 0x3FF | 0xD800)
	      codePoint = 0xDC00 | codePoint & 0x3FF
	    }
	
	    res.push(codePoint)
	    i += bytesPerSequence
	  }
	
	  return decodeCodePointsArray(res)
	}
	
	// Based on http://stackoverflow.com/a/22747272/680742, the browser with
	// the lowest limit is Chrome, with 0x10000 args.
	// We go 1 magnitude less, for safety
	var MAX_ARGUMENTS_LENGTH = 0x1000
	
	function decodeCodePointsArray (codePoints) {
	  var len = codePoints.length
	  if (len <= MAX_ARGUMENTS_LENGTH) {
	    return String.fromCharCode.apply(String, codePoints) // avoid extra slice()
	  }
	
	  // Decode in chunks to avoid "call stack size exceeded".
	  var res = ''
	  var i = 0
	  while (i < len) {
	    res += String.fromCharCode.apply(
	      String,
	      codePoints.slice(i, i += MAX_ARGUMENTS_LENGTH)
	    )
	  }
	  return res
	}
	
	function asciiSlice (buf, start, end) {
	  var ret = ''
	  end = Math.min(buf.length, end)
	
	  for (var i = start; i < end; ++i) {
	    ret += String.fromCharCode(buf[i] & 0x7F)
	  }
	  return ret
	}
	
	function latin1Slice (buf, start, end) {
	  var ret = ''
	  end = Math.min(buf.length, end)
	
	  for (var i = start; i < end; ++i) {
	    ret += String.fromCharCode(buf[i])
	  }
	  return ret
	}
	
	function hexSlice (buf, start, end) {
	  var len = buf.length
	
	  if (!start || start < 0) start = 0
	  if (!end || end < 0 || end > len) end = len
	
	  var out = ''
	  for (var i = start; i < end; ++i) {
	    out += toHex(buf[i])
	  }
	  return out
	}
	
	function utf16leSlice (buf, start, end) {
	  var bytes = buf.slice(start, end)
	  var res = ''
	  for (var i = 0; i < bytes.length; i += 2) {
	    res += String.fromCharCode(bytes[i] + bytes[i + 1] * 256)
	  }
	  return res
	}
	
	Buffer.prototype.slice = function slice (start, end) {
	  var len = this.length
	  start = ~~start
	  end = end === undefined ? len : ~~end
	
	  if (start < 0) {
	    start += len
	    if (start < 0) start = 0
	  } else if (start > len) {
	    start = len
	  }
	
	  if (end < 0) {
	    end += len
	    if (end < 0) end = 0
	  } else if (end > len) {
	    end = len
	  }
	
	  if (end < start) end = start
	
	  var newBuf
	  if (Buffer.TYPED_ARRAY_SUPPORT) {
	    newBuf = this.subarray(start, end)
	    newBuf.__proto__ = Buffer.prototype
	  } else {
	    var sliceLen = end - start
	    newBuf = new Buffer(sliceLen, undefined)
	    for (var i = 0; i < sliceLen; ++i) {
	      newBuf[i] = this[i + start]
	    }
	  }
	
	  return newBuf
	}
	
	/*
	 * Need to make sure that buffer isn't trying to write out of bounds.
	 */
	function checkOffset (offset, ext, length) {
	  if ((offset % 1) !== 0 || offset < 0) throw new RangeError('offset is not uint')
	  if (offset + ext > length) throw new RangeError('Trying to access beyond buffer length')
	}
	
	Buffer.prototype.readUIntLE = function readUIntLE (offset, byteLength, noAssert) {
	  offset = offset | 0
	  byteLength = byteLength | 0
	  if (!noAssert) checkOffset(offset, byteLength, this.length)
	
	  var val = this[offset]
	  var mul = 1
	  var i = 0
	  while (++i < byteLength && (mul *= 0x100)) {
	    val += this[offset + i] * mul
	  }
	
	  return val
	}
	
	Buffer.prototype.readUIntBE = function readUIntBE (offset, byteLength, noAssert) {
	  offset = offset | 0
	  byteLength = byteLength | 0
	  if (!noAssert) {
	    checkOffset(offset, byteLength, this.length)
	  }
	
	  var val = this[offset + --byteLength]
	  var mul = 1
	  while (byteLength > 0 && (mul *= 0x100)) {
	    val += this[offset + --byteLength] * mul
	  }
	
	  return val
	}
	
	Buffer.prototype.readUInt8 = function readUInt8 (offset, noAssert) {
	  if (!noAssert) checkOffset(offset, 1, this.length)
	  return this[offset]
	}
	
	Buffer.prototype.readUInt16LE = function readUInt16LE (offset, noAssert) {
	  if (!noAssert) checkOffset(offset, 2, this.length)
	  return this[offset] | (this[offset + 1] << 8)
	}
	
	Buffer.prototype.readUInt16BE = function readUInt16BE (offset, noAssert) {
	  if (!noAssert) checkOffset(offset, 2, this.length)
	  return (this[offset] << 8) | this[offset + 1]
	}
	
	Buffer.prototype.readUInt32LE = function readUInt32LE (offset, noAssert) {
	  if (!noAssert) checkOffset(offset, 4, this.length)
	
	  return ((this[offset]) |
	      (this[offset + 1] << 8) |
	      (this[offset + 2] << 16)) +
	      (this[offset + 3] * 0x1000000)
	}
	
	Buffer.prototype.readUInt32BE = function readUInt32BE (offset, noAssert) {
	  if (!noAssert) checkOffset(offset, 4, this.length)
	
	  return (this[offset] * 0x1000000) +
	    ((this[offset + 1] << 16) |
	    (this[offset + 2] << 8) |
	    this[offset + 3])
	}
	
	Buffer.prototype.readIntLE = function readIntLE (offset, byteLength, noAssert) {
	  offset = offset | 0
	  byteLength = byteLength | 0
	  if (!noAssert) checkOffset(offset, byteLength, this.length)
	
	  var val = this[offset]
	  var mul = 1
	  var i = 0
	  while (++i < byteLength && (mul *= 0x100)) {
	    val += this[offset + i] * mul
	  }
	  mul *= 0x80
	
	  if (val >= mul) val -= Math.pow(2, 8 * byteLength)
	
	  return val
	}
	
	Buffer.prototype.readIntBE = function readIntBE (offset, byteLength, noAssert) {
	  offset = offset | 0
	  byteLength = byteLength | 0
	  if (!noAssert) checkOffset(offset, byteLength, this.length)
	
	  var i = byteLength
	  var mul = 1
	  var val = this[offset + --i]
	  while (i > 0 && (mul *= 0x100)) {
	    val += this[offset + --i] * mul
	  }
	  mul *= 0x80
	
	  if (val >= mul) val -= Math.pow(2, 8 * byteLength)
	
	  return val
	}
	
	Buffer.prototype.readInt8 = function readInt8 (offset, noAssert) {
	  if (!noAssert) checkOffset(offset, 1, this.length)
	  if (!(this[offset] & 0x80)) return (this[offset])
	  return ((0xff - this[offset] + 1) * -1)
	}
	
	Buffer.prototype.readInt16LE = function readInt16LE (offset, noAssert) {
	  if (!noAssert) checkOffset(offset, 2, this.length)
	  var val = this[offset] | (this[offset + 1] << 8)
	  return (val & 0x8000) ? val | 0xFFFF0000 : val
	}
	
	Buffer.prototype.readInt16BE = function readInt16BE (offset, noAssert) {
	  if (!noAssert) checkOffset(offset, 2, this.length)
	  var val = this[offset + 1] | (this[offset] << 8)
	  return (val & 0x8000) ? val | 0xFFFF0000 : val
	}
	
	Buffer.prototype.readInt32LE = function readInt32LE (offset, noAssert) {
	  if (!noAssert) checkOffset(offset, 4, this.length)
	
	  return (this[offset]) |
	    (this[offset + 1] << 8) |
	    (this[offset + 2] << 16) |
	    (this[offset + 3] << 24)
	}
	
	Buffer.prototype.readInt32BE = function readInt32BE (offset, noAssert) {
	  if (!noAssert) checkOffset(offset, 4, this.length)
	
	  return (this[offset] << 24) |
	    (this[offset + 1] << 16) |
	    (this[offset + 2] << 8) |
	    (this[offset + 3])
	}
	
	Buffer.prototype.readFloatLE = function readFloatLE (offset, noAssert) {
	  if (!noAssert) checkOffset(offset, 4, this.length)
	  return ieee754.read(this, offset, true, 23, 4)
	}
	
	Buffer.prototype.readFloatBE = function readFloatBE (offset, noAssert) {
	  if (!noAssert) checkOffset(offset, 4, this.length)
	  return ieee754.read(this, offset, false, 23, 4)
	}
	
	Buffer.prototype.readDoubleLE = function readDoubleLE (offset, noAssert) {
	  if (!noAssert) checkOffset(offset, 8, this.length)
	  return ieee754.read(this, offset, true, 52, 8)
	}
	
	Buffer.prototype.readDoubleBE = function readDoubleBE (offset, noAssert) {
	  if (!noAssert) checkOffset(offset, 8, this.length)
	  return ieee754.read(this, offset, false, 52, 8)
	}
	
	function checkInt (buf, value, offset, ext, max, min) {
	  if (!Buffer.isBuffer(buf)) throw new TypeError('"buffer" argument must be a Buffer instance')
	  if (value > max || value < min) throw new RangeError('"value" argument is out of bounds')
	  if (offset + ext > buf.length) throw new RangeError('Index out of range')
	}
	
	Buffer.prototype.writeUIntLE = function writeUIntLE (value, offset, byteLength, noAssert) {
	  value = +value
	  offset = offset | 0
	  byteLength = byteLength | 0
	  if (!noAssert) {
	    var maxBytes = Math.pow(2, 8 * byteLength) - 1
	    checkInt(this, value, offset, byteLength, maxBytes, 0)
	  }
	
	  var mul = 1
	  var i = 0
	  this[offset] = value & 0xFF
	  while (++i < byteLength && (mul *= 0x100)) {
	    this[offset + i] = (value / mul) & 0xFF
	  }
	
	  return offset + byteLength
	}
	
	Buffer.prototype.writeUIntBE = function writeUIntBE (value, offset, byteLength, noAssert) {
	  value = +value
	  offset = offset | 0
	  byteLength = byteLength | 0
	  if (!noAssert) {
	    var maxBytes = Math.pow(2, 8 * byteLength) - 1
	    checkInt(this, value, offset, byteLength, maxBytes, 0)
	  }
	
	  var i = byteLength - 1
	  var mul = 1
	  this[offset + i] = value & 0xFF
	  while (--i >= 0 && (mul *= 0x100)) {
	    this[offset + i] = (value / mul) & 0xFF
	  }
	
	  return offset + byteLength
	}
	
	Buffer.prototype.writeUInt8 = function writeUInt8 (value, offset, noAssert) {
	  value = +value
	  offset = offset | 0
	  if (!noAssert) checkInt(this, value, offset, 1, 0xff, 0)
	  if (!Buffer.TYPED_ARRAY_SUPPORT) value = Math.floor(value)
	  this[offset] = (value & 0xff)
	  return offset + 1
	}
	
	function objectWriteUInt16 (buf, value, offset, littleEndian) {
	  if (value < 0) value = 0xffff + value + 1
	  for (var i = 0, j = Math.min(buf.length - offset, 2); i < j; ++i) {
	    buf[offset + i] = (value & (0xff << (8 * (littleEndian ? i : 1 - i)))) >>>
	      (littleEndian ? i : 1 - i) * 8
	  }
	}
	
	Buffer.prototype.writeUInt16LE = function writeUInt16LE (value, offset, noAssert) {
	  value = +value
	  offset = offset | 0
	  if (!noAssert) checkInt(this, value, offset, 2, 0xffff, 0)
	  if (Buffer.TYPED_ARRAY_SUPPORT) {
	    this[offset] = (value & 0xff)
	    this[offset + 1] = (value >>> 8)
	  } else {
	    objectWriteUInt16(this, value, offset, true)
	  }
	  return offset + 2
	}
	
	Buffer.prototype.writeUInt16BE = function writeUInt16BE (value, offset, noAssert) {
	  value = +value
	  offset = offset | 0
	  if (!noAssert) checkInt(this, value, offset, 2, 0xffff, 0)
	  if (Buffer.TYPED_ARRAY_SUPPORT) {
	    this[offset] = (value >>> 8)
	    this[offset + 1] = (value & 0xff)
	  } else {
	    objectWriteUInt16(this, value, offset, false)
	  }
	  return offset + 2
	}
	
	function objectWriteUInt32 (buf, value, offset, littleEndian) {
	  if (value < 0) value = 0xffffffff + value + 1
	  for (var i = 0, j = Math.min(buf.length - offset, 4); i < j; ++i) {
	    buf[offset + i] = (value >>> (littleEndian ? i : 3 - i) * 8) & 0xff
	  }
	}
	
	Buffer.prototype.writeUInt32LE = function writeUInt32LE (value, offset, noAssert) {
	  value = +value
	  offset = offset | 0
	  if (!noAssert) checkInt(this, value, offset, 4, 0xffffffff, 0)
	  if (Buffer.TYPED_ARRAY_SUPPORT) {
	    this[offset + 3] = (value >>> 24)
	    this[offset + 2] = (value >>> 16)
	    this[offset + 1] = (value >>> 8)
	    this[offset] = (value & 0xff)
	  } else {
	    objectWriteUInt32(this, value, offset, true)
	  }
	  return offset + 4
	}
	
	Buffer.prototype.writeUInt32BE = function writeUInt32BE (value, offset, noAssert) {
	  value = +value
	  offset = offset | 0
	  if (!noAssert) checkInt(this, value, offset, 4, 0xffffffff, 0)
	  if (Buffer.TYPED_ARRAY_SUPPORT) {
	    this[offset] = (value >>> 24)
	    this[offset + 1] = (value >>> 16)
	    this[offset + 2] = (value >>> 8)
	    this[offset + 3] = (value & 0xff)
	  } else {
	    objectWriteUInt32(this, value, offset, false)
	  }
	  return offset + 4
	}
	
	Buffer.prototype.writeIntLE = function writeIntLE (value, offset, byteLength, noAssert) {
	  value = +value
	  offset = offset | 0
	  if (!noAssert) {
	    var limit = Math.pow(2, 8 * byteLength - 1)
	
	    checkInt(this, value, offset, byteLength, limit - 1, -limit)
	  }
	
	  var i = 0
	  var mul = 1
	  var sub = 0
	  this[offset] = value & 0xFF
	  while (++i < byteLength && (mul *= 0x100)) {
	    if (value < 0 && sub === 0 && this[offset + i - 1] !== 0) {
	      sub = 1
	    }
	    this[offset + i] = ((value / mul) >> 0) - sub & 0xFF
	  }
	
	  return offset + byteLength
	}
	
	Buffer.prototype.writeIntBE = function writeIntBE (value, offset, byteLength, noAssert) {
	  value = +value
	  offset = offset | 0
	  if (!noAssert) {
	    var limit = Math.pow(2, 8 * byteLength - 1)
	
	    checkInt(this, value, offset, byteLength, limit - 1, -limit)
	  }
	
	  var i = byteLength - 1
	  var mul = 1
	  var sub = 0
	  this[offset + i] = value & 0xFF
	  while (--i >= 0 && (mul *= 0x100)) {
	    if (value < 0 && sub === 0 && this[offset + i + 1] !== 0) {
	      sub = 1
	    }
	    this[offset + i] = ((value / mul) >> 0) - sub & 0xFF
	  }
	
	  return offset + byteLength
	}
	
	Buffer.prototype.writeInt8 = function writeInt8 (value, offset, noAssert) {
	  value = +value
	  offset = offset | 0
	  if (!noAssert) checkInt(this, value, offset, 1, 0x7f, -0x80)
	  if (!Buffer.TYPED_ARRAY_SUPPORT) value = Math.floor(value)
	  if (value < 0) value = 0xff + value + 1
	  this[offset] = (value & 0xff)
	  return offset + 1
	}
	
	Buffer.prototype.writeInt16LE = function writeInt16LE (value, offset, noAssert) {
	  value = +value
	  offset = offset | 0
	  if (!noAssert) checkInt(this, value, offset, 2, 0x7fff, -0x8000)
	  if (Buffer.TYPED_ARRAY_SUPPORT) {
	    this[offset] = (value & 0xff)
	    this[offset + 1] = (value >>> 8)
	  } else {
	    objectWriteUInt16(this, value, offset, true)
	  }
	  return offset + 2
	}
	
	Buffer.prototype.writeInt16BE = function writeInt16BE (value, offset, noAssert) {
	  value = +value
	  offset = offset | 0
	  if (!noAssert) checkInt(this, value, offset, 2, 0x7fff, -0x8000)
	  if (Buffer.TYPED_ARRAY_SUPPORT) {
	    this[offset] = (value >>> 8)
	    this[offset + 1] = (value & 0xff)
	  } else {
	    objectWriteUInt16(this, value, offset, false)
	  }
	  return offset + 2
	}
	
	Buffer.prototype.writeInt32LE = function writeInt32LE (value, offset, noAssert) {
	  value = +value
	  offset = offset | 0
	  if (!noAssert) checkInt(this, value, offset, 4, 0x7fffffff, -0x80000000)
	  if (Buffer.TYPED_ARRAY_SUPPORT) {
	    this[offset] = (value & 0xff)
	    this[offset + 1] = (value >>> 8)
	    this[offset + 2] = (value >>> 16)
	    this[offset + 3] = (value >>> 24)
	  } else {
	    objectWriteUInt32(this, value, offset, true)
	  }
	  return offset + 4
	}
	
	Buffer.prototype.writeInt32BE = function writeInt32BE (value, offset, noAssert) {
	  value = +value
	  offset = offset | 0
	  if (!noAssert) checkInt(this, value, offset, 4, 0x7fffffff, -0x80000000)
	  if (value < 0) value = 0xffffffff + value + 1
	  if (Buffer.TYPED_ARRAY_SUPPORT) {
	    this[offset] = (value >>> 24)
	    this[offset + 1] = (value >>> 16)
	    this[offset + 2] = (value >>> 8)
	    this[offset + 3] = (value & 0xff)
	  } else {
	    objectWriteUInt32(this, value, offset, false)
	  }
	  return offset + 4
	}
	
	function checkIEEE754 (buf, value, offset, ext, max, min) {
	  if (offset + ext > buf.length) throw new RangeError('Index out of range')
	  if (offset < 0) throw new RangeError('Index out of range')
	}
	
	function writeFloat (buf, value, offset, littleEndian, noAssert) {
	  if (!noAssert) {
	    checkIEEE754(buf, value, offset, 4, 3.4028234663852886e+38, -3.4028234663852886e+38)
	  }
	  ieee754.write(buf, value, offset, littleEndian, 23, 4)
	  return offset + 4
	}
	
	Buffer.prototype.writeFloatLE = function writeFloatLE (value, offset, noAssert) {
	  return writeFloat(this, value, offset, true, noAssert)
	}
	
	Buffer.prototype.writeFloatBE = function writeFloatBE (value, offset, noAssert) {
	  return writeFloat(this, value, offset, false, noAssert)
	}
	
	function writeDouble (buf, value, offset, littleEndian, noAssert) {
	  if (!noAssert) {
	    checkIEEE754(buf, value, offset, 8, 1.7976931348623157E+308, -1.7976931348623157E+308)
	  }
	  ieee754.write(buf, value, offset, littleEndian, 52, 8)
	  return offset + 8
	}
	
	Buffer.prototype.writeDoubleLE = function writeDoubleLE (value, offset, noAssert) {
	  return writeDouble(this, value, offset, true, noAssert)
	}
	
	Buffer.prototype.writeDoubleBE = function writeDoubleBE (value, offset, noAssert) {
	  return writeDouble(this, value, offset, false, noAssert)
	}
	
	// copy(targetBuffer, targetStart=0, sourceStart=0, sourceEnd=buffer.length)
	Buffer.prototype.copy = function copy (target, targetStart, start, end) {
	  if (!start) start = 0
	  if (!end && end !== 0) end = this.length
	  if (targetStart >= target.length) targetStart = target.length
	  if (!targetStart) targetStart = 0
	  if (end > 0 && end < start) end = start
	
	  // Copy 0 bytes; we're done
	  if (end === start) return 0
	  if (target.length === 0 || this.length === 0) return 0
	
	  // Fatal error conditions
	  if (targetStart < 0) {
	    throw new RangeError('targetStart out of bounds')
	  }
	  if (start < 0 || start >= this.length) throw new RangeError('sourceStart out of bounds')
	  if (end < 0) throw new RangeError('sourceEnd out of bounds')
	
	  // Are we oob?
	  if (end > this.length) end = this.length
	  if (target.length - targetStart < end - start) {
	    end = target.length - targetStart + start
	  }
	
	  var len = end - start
	  var i
	
	  if (this === target && start < targetStart && targetStart < end) {
	    // descending copy from end
	    for (i = len - 1; i >= 0; --i) {
	      target[i + targetStart] = this[i + start]
	    }
	  } else if (len < 1000 || !Buffer.TYPED_ARRAY_SUPPORT) {
	    // ascending copy from start
	    for (i = 0; i < len; ++i) {
	      target[i + targetStart] = this[i + start]
	    }
	  } else {
	    Uint8Array.prototype.set.call(
	      target,
	      this.subarray(start, start + len),
	      targetStart
	    )
	  }
	
	  return len
	}
	
	// Usage:
	//    buffer.fill(number[, offset[, end]])
	//    buffer.fill(buffer[, offset[, end]])
	//    buffer.fill(string[, offset[, end]][, encoding])
	Buffer.prototype.fill = function fill (val, start, end, encoding) {
	  // Handle string cases:
	  if (typeof val === 'string') {
	    if (typeof start === 'string') {
	      encoding = start
	      start = 0
	      end = this.length
	    } else if (typeof end === 'string') {
	      encoding = end
	      end = this.length
	    }
	    if (val.length === 1) {
	      var code = val.charCodeAt(0)
	      if (code < 256) {
	        val = code
	      }
	    }
	    if (encoding !== undefined && typeof encoding !== 'string') {
	      throw new TypeError('encoding must be a string')
	    }
	    if (typeof encoding === 'string' && !Buffer.isEncoding(encoding)) {
	      throw new TypeError('Unknown encoding: ' + encoding)
	    }
	  } else if (typeof val === 'number') {
	    val = val & 255
	  }
	
	  // Invalid ranges are not set to a default, so can range check early.
	  if (start < 0 || this.length < start || this.length < end) {
	    throw new RangeError('Out of range index')
	  }
	
	  if (end <= start) {
	    return this
	  }
	
	  start = start >>> 0
	  end = end === undefined ? this.length : end >>> 0
	
	  if (!val) val = 0
	
	  var i
	  if (typeof val === 'number') {
	    for (i = start; i < end; ++i) {
	      this[i] = val
	    }
	  } else {
	    var bytes = Buffer.isBuffer(val)
	      ? val
	      : utf8ToBytes(new Buffer(val, encoding).toString())
	    var len = bytes.length
	    for (i = 0; i < end - start; ++i) {
	      this[i + start] = bytes[i % len]
	    }
	  }
	
	  return this
	}
	
	// HELPER FUNCTIONS
	// ================
	
	var INVALID_BASE64_RE = /[^+\/0-9A-Za-z-_]/g
	
	function base64clean (str) {
	  // Node strips out invalid characters like \n and \t from the string, base64-js does not
	  str = stringtrim(str).replace(INVALID_BASE64_RE, '')
	  // Node converts strings with length < 2 to ''
	  if (str.length < 2) return ''
	  // Node allows for non-padded base64 strings (missing trailing ===), base64-js does not
	  while (str.length % 4 !== 0) {
	    str = str + '='
	  }
	  return str
	}
	
	function stringtrim (str) {
	  if (str.trim) return str.trim()
	  return str.replace(/^\s+|\s+$/g, '')
	}
	
	function toHex (n) {
	  if (n < 16) return '0' + n.toString(16)
	  return n.toString(16)
	}
	
	function utf8ToBytes (string, units) {
	  units = units || Infinity
	  var codePoint
	  var length = string.length
	  var leadSurrogate = null
	  var bytes = []
	
	  for (var i = 0; i < length; ++i) {
	    codePoint = string.charCodeAt(i)
	
	    // is surrogate component
	    if (codePoint > 0xD7FF && codePoint < 0xE000) {
	      // last char was a lead
	      if (!leadSurrogate) {
	        // no lead yet
	        if (codePoint > 0xDBFF) {
	          // unexpected trail
	          if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)
	          continue
	        } else if (i + 1 === length) {
	          // unpaired lead
	          if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)
	          continue
	        }
	
	        // valid lead
	        leadSurrogate = codePoint
	
	        continue
	      }
	
	      // 2 leads in a row
	      if (codePoint < 0xDC00) {
	        if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)
	        leadSurrogate = codePoint
	        continue
	      }
	
	      // valid surrogate pair
	      codePoint = (leadSurrogate - 0xD800 << 10 | codePoint - 0xDC00) + 0x10000
	    } else if (leadSurrogate) {
	      // valid bmp char, but last char was a lead
	      if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)
	    }
	
	    leadSurrogate = null
	
	    // encode utf8
	    if (codePoint < 0x80) {
	      if ((units -= 1) < 0) break
	      bytes.push(codePoint)
	    } else if (codePoint < 0x800) {
	      if ((units -= 2) < 0) break
	      bytes.push(
	        codePoint >> 0x6 | 0xC0,
	        codePoint & 0x3F | 0x80
	      )
	    } else if (codePoint < 0x10000) {
	      if ((units -= 3) < 0) break
	      bytes.push(
	        codePoint >> 0xC | 0xE0,
	        codePoint >> 0x6 & 0x3F | 0x80,
	        codePoint & 0x3F | 0x80
	      )
	    } else if (codePoint < 0x110000) {
	      if ((units -= 4) < 0) break
	      bytes.push(
	        codePoint >> 0x12 | 0xF0,
	        codePoint >> 0xC & 0x3F | 0x80,
	        codePoint >> 0x6 & 0x3F | 0x80,
	        codePoint & 0x3F | 0x80
	      )
	    } else {
	      throw new Error('Invalid code point')
	    }
	  }
	
	  return bytes
	}
	
	function asciiToBytes (str) {
	  var byteArray = []
	  for (var i = 0; i < str.length; ++i) {
	    // Node's code seems to be doing this and not & 0x7F..
	    byteArray.push(str.charCodeAt(i) & 0xFF)
	  }
	  return byteArray
	}
	
	function utf16leToBytes (str, units) {
	  var c, hi, lo
	  var byteArray = []
	  for (var i = 0; i < str.length; ++i) {
	    if ((units -= 2) < 0) break
	
	    c = str.charCodeAt(i)
	    hi = c >> 8
	    lo = c % 256
	    byteArray.push(lo)
	    byteArray.push(hi)
	  }
	
	  return byteArray
	}
	
	function base64ToBytes (str) {
	  return base64.toByteArray(base64clean(str))
	}
	
	function blitBuffer (src, dst, offset, length) {
	  for (var i = 0; i < length; ++i) {
	    if ((i + offset >= dst.length) || (i >= src.length)) break
	    dst[i + offset] = src[i]
	  }
	  return i
	}
	
	function isnan (val) {
	  return val !== val // eslint-disable-line no-self-compare
	}
	
	/* WEBPACK VAR INJECTION */}.call(exports, (function() { return this; }())))

/***/ },
/* 289 */
/***/ function(module, exports, __webpack_require__) {

	
	/*
	* Licensed to the Apache Software Foundation (ASF) under one
	* or more contributor license agreements.  See the NOTICE file
	* distributed with this work for additional information
	* regarding copyright ownership.  The ASF licenses this file
	* to you under the Apache License, Version 2.0 (the
	* "License"); you may not use this file except in compliance
	* with the License.  You may obtain a copy of the License at
	*
	*   http://www.apache.org/licenses/LICENSE-2.0
	*
	* Unless required by applicable law or agreed to in writing,
	* software distributed under the License is distributed on an
	* "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
	* KIND, either express or implied.  See the License for the
	* specific language governing permissions and limitations
	* under the License.
	*/
	
	
	
	/**
	 * AUTO-GENERATED FILE. DO NOT MODIFY.
	 */
	
	"use strict";
	
	exports.__esModule = true;
	
	var echarts = __webpack_require__(6);
	
	echarts.registerAction({
	  type: 'changeAxisOrder',
	  event: 'changeAxisOrder',
	  update: 'update'
	}, function (payload, ecModel) {
	  var componentType = payload.componentType || 'series';
	  ecModel.eachComponent({
	    mainType: componentType,
	    query: payload
	  }, function (componentModel) {
	    if (payload.sortInfo) {
	      componentModel.axis.setCategorySortInfo(payload.sortInfo);
	    }
	  });
	});

/***/ },
/* 290 */
/***/ function(module, exports, __webpack_require__) {

	
	/*
	* Licensed to the Apache Software Foundation (ASF) under one
	* or more contributor license agreements.  See the NOTICE file
	* distributed with this work for additional information
	* regarding copyright ownership.  The ASF licenses this file
	* to you under the Apache License, Version 2.0 (the
	* "License"); you may not use this file except in compliance
	* with the License.  You may obtain a copy of the License at
	*
	*   http://www.apache.org/licenses/LICENSE-2.0
	*
	* Unless required by applicable law or agreed to in writing,
	* software distributed under the License is distributed on an
	* "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
	* KIND, either express or implied.  See the License for the
	* specific language governing permissions and limitations
	* under the License.
	*/
	
	
	
	/**
	 * AUTO-GENERATED FILE. DO NOT MODIFY.
	 */
	
	"use strict";
	
	exports.__esModule = true;
	
	var tslib_1 = __webpack_require__(3);
	
	var BaseBarSeries_1 = __webpack_require__(292);
	
	var Series_1 = __webpack_require__(68);
	
	var component_1 = __webpack_require__(41);
	
	var BarSeriesModel = function (_super) {
	  tslib_1.__extends(BarSeriesModel, _super);
	
	  function BarSeriesModel() {
	    var _this = _super !== null && _super.apply(this, arguments) || this;
	
	    _this.type = BarSeriesModel.type;
	    return _this;
	  }
	
	  BarSeriesModel.prototype.getProgressive = function () {
	    return this.get('large') ? this.get('progressive') : false;
	  };
	
	  BarSeriesModel.prototype.getProgressiveThreshold = function () {
	    var progressiveThreshold = this.get('progressiveThreshold');
	    var largeThreshold = this.get('largeThreshold');
	
	    if (largeThreshold > progressiveThreshold) {
	      progressiveThreshold = largeThreshold;
	    }
	
	    return progressiveThreshold;
	  };
	
	  BarSeriesModel.prototype.brushSelector = function (dataIndex, data, selectors) {
	    return selectors.rect(data.getItemLayout(dataIndex));
	  };
	
	  BarSeriesModel.type = 'series.bar';
	  BarSeriesModel.dependencies = ['grid', 'polar'];
	  BarSeriesModel.defaultOption = component_1.inheritDefaultOption(BaseBarSeries_1["default"].defaultOption, {
	    clip: true,
	    roundCap: false,
	    showBackground: false,
	    backgroundStyle: {
	      color: 'rgba(180, 180, 180, 0.2)',
	      borderColor: null,
	      borderWidth: 0,
	      borderType: 'solid',
	      borderRadius: 0,
	      shadowBlur: 0,
	      shadowColor: null,
	      shadowOffsetX: 0,
	      shadowOffsetY: 0,
	      opacity: 1
	    },
	    select: {
	      itemStyle: {
	        borderColor: '#212121'
	      }
	    },
	    realtimeSort: false
	  });
	  return BarSeriesModel;
	}(BaseBarSeries_1["default"]);
	
	Series_1["default"].registerClass(BarSeriesModel);
	exports["default"] = BarSeriesModel;

/***/ },
/* 291 */
/***/ function(module, exports, __webpack_require__) {

	
	/*
	* Licensed to the Apache Software Foundation (ASF) under one
	* or more contributor license agreements.  See the NOTICE file
	* distributed with this work for additional information
	* regarding copyright ownership.  The ASF licenses this file
	* to you under the Apache License, Version 2.0 (the
	* "License"); you may not use this file except in compliance
	* with the License.  You may obtain a copy of the License at
	*
	*   http://www.apache.org/licenses/LICENSE-2.0
	*
	* Unless required by applicable law or agreed to in writing,
	* software distributed under the License is distributed on an
	* "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
	* KIND, either express or implied.  See the License for the
	* specific language governing permissions and limitations
	* under the License.
	*/
	
	
	
	/**
	 * AUTO-GENERATED FILE. DO NOT MODIFY.
	 */
	
	"use strict";
	
	exports.__esModule = true;
	
	var tslib_1 = __webpack_require__(3);
	
	var Path_1 = __webpack_require__(8);
	
	var Group_1 = __webpack_require__(51);
	
	var util_1 = __webpack_require__(1);
	
	var graphic_1 = __webpack_require__(7);
	
	var innerStore_1 = __webpack_require__(21);
	
	var states_1 = __webpack_require__(22);
	
	var labelStyle_1 = __webpack_require__(20);
	
	var throttle_1 = __webpack_require__(56);
	
	var createClipPathFromCoordSys_1 = __webpack_require__(128);
	
	var sausage_1 = __webpack_require__(375);
	
	var Chart_1 = __webpack_require__(96);
	
	var CoordinateSystem_1 = __webpack_require__(87);
	
	var labelHelper_1 = __webpack_require__(83);
	
	var BAR_BORDER_WIDTH_QUERY = ['itemStyle', 'borderWidth'];
	var BAR_BORDER_RADIUS_QUERY = ['itemStyle', 'borderRadius'];
	var _eventPos = [0, 0];
	var mathMax = Math.max;
	var mathMin = Math.min;
	
	function getClipArea(coord, data) {
	  var coordSysClipArea = coord.getArea && coord.getArea();
	
	  if (CoordinateSystem_1.isCoordinateSystemType(coord, 'cartesian2d')) {
	    var baseAxis = coord.getBaseAxis();
	
	    if (baseAxis.type !== 'category' || !baseAxis.onBand) {
	      var expandWidth = data.getLayout('bandWidth');
	
	      if (baseAxis.isHorizontal()) {
	        coordSysClipArea.x -= expandWidth;
	        coordSysClipArea.width += expandWidth * 2;
	      } else {
	        coordSysClipArea.y -= expandWidth;
	        coordSysClipArea.height += expandWidth * 2;
	      }
	    }
	  }
	
	  return coordSysClipArea;
	}
	
	var BarView = function (_super) {
	  tslib_1.__extends(BarView, _super);
	
	  function BarView() {
	    var _this = _super.call(this) || this;
	
	    _this.type = BarView.type;
	    _this._isFirstFrame = true;
	    return _this;
	  }
	
	  BarView.prototype.render = function (seriesModel, ecModel, api, payload) {
	    this._model = seriesModel;
	    this.removeOnRenderedListener(api);
	
	    this._updateDrawMode(seriesModel);
	
	    var coordinateSystemType = seriesModel.get('coordinateSystem');
	
	    if (coordinateSystemType === 'cartesian2d' || coordinateSystemType === 'polar') {
	      this._isLargeDraw ? this._renderLarge(seriesModel, ecModel, api) : this._renderNormal(seriesModel, ecModel, api, payload);
	    } else if (false) {
	      console.warn('Only cartesian2d and polar supported for bar.');
	    }
	  };
	
	  BarView.prototype.incrementalPrepareRender = function (seriesModel) {
	    this._clear();
	
	    this._updateDrawMode(seriesModel);
	
	    this._updateLargeClip(seriesModel);
	  };
	
	  BarView.prototype.incrementalRender = function (params, seriesModel) {
	    this._incrementalRenderLarge(params, seriesModel);
	  };
	
	  BarView.prototype._updateDrawMode = function (seriesModel) {
	    var isLargeDraw = seriesModel.pipelineContext.large;
	
	    if (this._isLargeDraw == null || isLargeDraw !== this._isLargeDraw) {
	      this._isLargeDraw = isLargeDraw;
	
	      this._clear();
	    }
	  };
	
	  BarView.prototype._renderNormal = function (seriesModel, ecModel, api, payload) {
	    var _this = this;
	
	    var group = this.group;
	    var data = seriesModel.getData();
	    var oldData = this._data;
	    var coord = seriesModel.coordinateSystem;
	    var baseAxis = coord.getBaseAxis();
	    var isHorizontalOrRadial;
	
	    if (coord.type === 'cartesian2d') {
	      isHorizontalOrRadial = baseAxis.isHorizontal();
	    } else if (coord.type === 'polar') {
	      isHorizontalOrRadial = baseAxis.dim === 'angle';
	    }
	
	    var animationModel = seriesModel.isAnimationEnabled() ? seriesModel : null;
	    var axis2DModel = baseAxis.model;
	    var realtimeSort = seriesModel.get('realtimeSort');
	
	    if (realtimeSort && data.count()) {
	      if (this._isFirstFrame) {
	        this._initSort(data, isHorizontalOrRadial, baseAxis, api);
	
	        this._isFirstFrame = false;
	        return;
	      } else {
	        this._onRendered = function () {
	          var orderMap = function (idx) {
	            var el = data.getItemGraphicEl(idx);
	
	            if (el) {
	              var shape = el.shape;
	              return (isHorizontalOrRadial ? shape.y + shape.height : shape.x + shape.width) || 0;
	            } else {
	              return 0;
	            }
	          };
	
	          _this._updateSort(data, orderMap, baseAxis, api);
	        };
	
	        api.getZr().on('rendered', this._onRendered);
	      }
	    }
	
	    var needsClip = seriesModel.get('clip', true) || realtimeSort;
	    var coordSysClipArea = getClipArea(coord, data);
	    group.removeClipPath();
	    var roundCap = seriesModel.get('roundCap', true);
	    var drawBackground = seriesModel.get('showBackground', true);
	    var backgroundModel = seriesModel.getModel('backgroundStyle');
	    var barBorderRadius = backgroundModel.get('borderRadius') || 0;
	    var bgEls = [];
	    var oldBgEls = this._backgroundEls;
	    var isInitSort = payload && payload.isInitSort;
	    var isChangeOrder = payload && payload.type === 'changeAxisOrder';
	
	    function createBackground(dataIndex) {
	      var bgLayout = getLayout[coord.type](data, dataIndex);
	      var bgEl = createBackgroundEl(coord, isHorizontalOrRadial, bgLayout);
	      bgEl.useStyle(backgroundModel.getItemStyle());
	
	      if (coord.type === 'cartesian2d') {
	        bgEl.setShape('r', barBorderRadius);
	      }
	
	      bgEls[dataIndex] = bgEl;
	      return bgEl;
	    }
	
	    ;
	    data.diff(oldData).add(function (dataIndex) {
	      var itemModel = data.getItemModel(dataIndex);
	      var layout = getLayout[coord.type](data, dataIndex, itemModel);
	
	      if (drawBackground) {
	        createBackground(dataIndex);
	      }
	
	      if (!data.hasValue(dataIndex)) {
	        return;
	      }
	
	      var isClipped = false;
	
	      if (needsClip) {
	        isClipped = clip[coord.type](coordSysClipArea, layout);
	      }
	
	      var el = elementCreator[coord.type](seriesModel, data, dataIndex, layout, isHorizontalOrRadial, animationModel, baseAxis.model, false, roundCap);
	      updateStyle(el, data, dataIndex, itemModel, layout, seriesModel, isHorizontalOrRadial, coord.type === 'polar');
	
	      if (isInitSort) {
	        el.attr({
	          shape: layout
	        });
	      } else if (realtimeSort) {
	        updateRealtimeAnimation(seriesModel, axis2DModel, animationModel, el, layout, dataIndex, isHorizontalOrRadial, false, false);
	      } else {
	        graphic_1.initProps(el, {
	          shape: layout
	        }, seriesModel, dataIndex);
	      }
	
	      data.setItemGraphicEl(dataIndex, el);
	      group.add(el);
	      el.ignore = isClipped;
	    }).update(function (newIndex, oldIndex) {
	      var itemModel = data.getItemModel(newIndex);
	      var layout = getLayout[coord.type](data, newIndex, itemModel);
	
	      if (drawBackground) {
	        var bgEl = void 0;
	
	        if (oldBgEls.length === 0) {
	          bgEl = createBackground(oldIndex);
	        } else {
	          bgEl = oldBgEls[oldIndex];
	          bgEl.useStyle(backgroundModel.getItemStyle());
	
	          if (coord.type === 'cartesian2d') {
	            bgEl.setShape('r', barBorderRadius);
	          }
	
	          bgEls[newIndex] = bgEl;
	        }
	
	        var bgLayout = getLayout[coord.type](data, newIndex);
	        var shape = createBackgroundShape(isHorizontalOrRadial, bgLayout, coord);
	        graphic_1.updateProps(bgEl, {
	          shape: shape
	        }, animationModel, newIndex);
	      }
	
	      var el = oldData.getItemGraphicEl(oldIndex);
	
	      if (!data.hasValue(newIndex)) {
	        group.remove(el);
	        el = null;
	        return;
	      }
	
	      var isClipped = false;
	
	      if (needsClip) {
	        isClipped = clip[coord.type](coordSysClipArea, layout);
	
	        if (isClipped) {
	          group.remove(el);
	        }
	      }
	
	      if (!el) {
	        el = elementCreator[coord.type](seriesModel, data, newIndex, layout, isHorizontalOrRadial, animationModel, baseAxis.model, !!el, roundCap);
	      }
	
	      if (!isChangeOrder) {
	        updateStyle(el, data, newIndex, itemModel, layout, seriesModel, isHorizontalOrRadial, coord.type === 'polar');
	      }
	
	      if (isInitSort) {
	        el.attr({
	          shape: layout
	        });
	      } else if (realtimeSort) {
	        updateRealtimeAnimation(seriesModel, axis2DModel, animationModel, el, layout, newIndex, isHorizontalOrRadial, true, isChangeOrder);
	      } else {
	        graphic_1.updateProps(el, {
	          shape: layout
	        }, seriesModel, newIndex, null);
	      }
	
	      data.setItemGraphicEl(newIndex, el);
	      el.ignore = isClipped;
	      group.add(el);
	    }).remove(function (dataIndex) {
	      var el = oldData.getItemGraphicEl(dataIndex);
	      el && graphic_1.removeElementWithFadeOut(el, seriesModel, dataIndex);
	    }).execute();
	    var bgGroup = this._backgroundGroup || (this._backgroundGroup = new Group_1["default"]());
	    bgGroup.removeAll();
	
	    for (var i = 0; i < bgEls.length; ++i) {
	      bgGroup.add(bgEls[i]);
	    }
	
	    group.add(bgGroup);
	    this._backgroundEls = bgEls;
	    this._data = data;
	  };
	
	  BarView.prototype._renderLarge = function (seriesModel, ecModel, api) {
	    this._clear();
	
	    createLarge(seriesModel, this.group);
	
	    this._updateLargeClip(seriesModel);
	  };
	
	  BarView.prototype._incrementalRenderLarge = function (params, seriesModel) {
	    this._removeBackground();
	
	    createLarge(seriesModel, this.group, true);
	  };
	
	  BarView.prototype._updateLargeClip = function (seriesModel) {
	    var clipPath = seriesModel.get('clip', true) ? createClipPathFromCoordSys_1.createClipPath(seriesModel.coordinateSystem, false, seriesModel) : null;
	
	    if (clipPath) {
	      this.group.setClipPath(clipPath);
	    } else {
	      this.group.removeClipPath();
	    }
	  };
	
	  BarView.prototype._dataSort = function (data, idxMap) {
	    var info = [];
	    data.each(function (idx) {
	      info.push({
	        mappedValue: idxMap(idx),
	        ordinalNumber: idx,
	        beforeSortIndex: null
	      });
	    });
	    info.sort(function (a, b) {
	      return b.mappedValue - a.mappedValue;
	    });
	
	    for (var i = 0; i < info.length; ++i) {
	      info[info[i].ordinalNumber].beforeSortIndex = i;
	    }
	
	    return util_1.map(info, function (item) {
	      return {
	        ordinalNumber: item.ordinalNumber,
	        beforeSortIndex: item.beforeSortIndex
	      };
	    });
	  };
	
	  BarView.prototype._isDataOrderChanged = function (data, orderMap, oldOrder) {
	    var oldCount = oldOrder ? oldOrder.length : 0;
	
	    if (oldCount !== data.count()) {
	      return true;
	    }
	
	    var lastValue = Number.MAX_VALUE;
	
	    for (var i = 0; i < oldOrder.length; ++i) {
	      var value = orderMap(oldOrder[i].ordinalNumber);
	
	      if (value > lastValue) {
	        return true;
	      }
	
	      lastValue = value;
	    }
	
	    return false;
	  };
	
	  BarView.prototype._updateSort = function (data, orderMap, baseAxis, api) {
	    var oldOrder = baseAxis.scale.getCategorySortInfo();
	
	    var isOrderChanged = this._isDataOrderChanged(data, orderMap, oldOrder);
	
	    if (isOrderChanged) {
	      var newOrder = this._dataSort(data, orderMap);
	
	      var extent = baseAxis.scale.getExtent();
	
	      for (var i = extent[0]; i < extent[1]; ++i) {
	        if (!oldOrder[i] || oldOrder[i].ordinalNumber !== newOrder[i].ordinalNumber) {
	          this.removeOnRenderedListener(api);
	          var action = {
	            type: 'changeAxisOrder',
	            componentType: baseAxis.dim + 'Axis',
	            axisId: baseAxis.index,
	            sortInfo: newOrder
	          };
	          api.dispatchAction(action);
	          break;
	        }
	      }
	    }
	  };
	
	  BarView.prototype._initSort = function (data, isHorizontal, baseAxis, api) {
	    var action = {
	      type: 'changeAxisOrder',
	      componentType: baseAxis.dim + 'Axis',
	      isInitSort: true,
	      axisId: baseAxis.index,
	      sortInfo: this._dataSort(data, function (idx) {
	        return parseFloat(data.get(isHorizontal ? 'y' : 'x', idx)) || 0;
	      })
	    };
	    api.dispatchAction(action);
	  };
	
	  BarView.prototype.remove = function (ecModel, api) {
	    this._clear(this._model);
	
	    this.removeOnRenderedListener(api);
	  };
	
	  BarView.prototype.dispose = function (ecModel, api) {
	    this.removeOnRenderedListener(api);
	  };
	
	  BarView.prototype.removeOnRenderedListener = function (api) {
	    if (this._onRendered) {
	      api.getZr().off('rendered', this._onRendered);
	      this._onRendered = null;
	    }
	  };
	
	  BarView.prototype._clear = function (model) {
	    var group = this.group;
	    var data = this._data;
	
	    if (model && model.isAnimationEnabled() && data && !this._isLargeDraw) {
	      this._removeBackground();
	
	      this._backgroundEls = [];
	      data.eachItemGraphicEl(function (el) {
	        graphic_1.removeElementWithFadeOut(el, model, innerStore_1.getECData(el).dataIndex);
	      });
	    } else {
	      group.removeAll();
	    }
	
	    this._data = null;
	    this._isFirstFrame = true;
	  };
	
	  BarView.prototype._removeBackground = function () {
	    this.group.remove(this._backgroundGroup);
	    this._backgroundGroup = null;
	  };
	
	  BarView.type = 'bar';
	  return BarView;
	}(Chart_1["default"]);
	
	var clip = {
	  cartesian2d: function (coordSysBoundingRect, layout) {
	    var signWidth = layout.width < 0 ? -1 : 1;
	    var signHeight = layout.height < 0 ? -1 : 1;
	
	    if (signWidth < 0) {
	      layout.x += layout.width;
	      layout.width = -layout.width;
	    }
	
	    if (signHeight < 0) {
	      layout.y += layout.height;
	      layout.height = -layout.height;
	    }
	
	    var x = mathMax(layout.x, coordSysBoundingRect.x);
	    var x2 = mathMin(layout.x + layout.width, coordSysBoundingRect.x + coordSysBoundingRect.width);
	    var y = mathMax(layout.y, coordSysBoundingRect.y);
	    var y2 = mathMin(layout.y + layout.height, coordSysBoundingRect.y + coordSysBoundingRect.height);
	    layout.x = x;
	    layout.y = y;
	    layout.width = x2 - x;
	    layout.height = y2 - y;
	    var clipped = layout.width < 0 || layout.height < 0;
	
	    if (signWidth < 0) {
	      layout.x += layout.width;
	      layout.width = -layout.width;
	    }
	
	    if (signHeight < 0) {
	      layout.y += layout.height;
	      layout.height = -layout.height;
	    }
	
	    return clipped;
	  },
	  polar: function (coordSysClipArea, layout) {
	    var signR = layout.r0 <= layout.r ? 1 : -1;
	
	    if (signR < 0) {
	      var tmp = layout.r;
	      layout.r = layout.r0;
	      layout.r0 = tmp;
	    }
	
	    var r = mathMin(layout.r, coordSysClipArea.r);
	    var r0 = mathMax(layout.r0, coordSysClipArea.r0);
	    layout.r = r;
	    layout.r0 = r0;
	    var clipped = r - r0 < 0;
	
	    if (signR < 0) {
	      var tmp = layout.r;
	      layout.r = layout.r0;
	      layout.r0 = tmp;
	    }
	
	    return clipped;
	  }
	};
	var elementCreator = {
	  cartesian2d: function (seriesModel, data, newIndex, layout, isHorizontal, animationModel, axisModel, isUpdate, roundCap) {
	    var rect = new graphic_1.Rect({
	      shape: util_1.extend({}, layout),
	      z2: 1
	    });
	    rect.__dataIndex = newIndex;
	    rect.name = 'item';
	
	    if (animationModel) {
	      var rectShape = rect.shape;
	      var animateProperty = isHorizontal ? 'height' : 'width';
	      rectShape[animateProperty] = 0;
	    }
	
	    return rect;
	  },
	  polar: function (seriesModel, data, newIndex, layout, isRadial, animationModel, axisModel, isUpdate, roundCap) {
	    var clockwise = layout.startAngle < layout.endAngle;
	    var ShapeClass = !isRadial && roundCap ? sausage_1["default"] : graphic_1.Sector;
	    var sector = new ShapeClass({
	      shape: util_1.defaults({
	        clockwise: clockwise
	      }, layout),
	      z2: 1
	    });
	    sector.name = 'item';
	
	    if (animationModel) {
	      var sectorShape = sector.shape;
	      var animateProperty = isRadial ? 'r' : 'endAngle';
	      var animateTarget = {};
	      sectorShape[animateProperty] = isRadial ? 0 : layout.startAngle;
	      animateTarget[animateProperty] = layout[animateProperty];
	      (isUpdate ? graphic_1.updateProps : graphic_1.initProps)(sector, {
	        shape: animateTarget
	      }, animationModel);
	    }
	
	    return sector;
	  }
	};
	
	function updateRealtimeAnimation(seriesModel, axisModel, animationModel, el, layout, newIndex, isHorizontal, isUpdate, isChangeOrder) {
	  if (animationModel || axisModel) {
	    var seriesTarget = void 0;
	    var axisTarget = void 0;
	
	    if (isHorizontal) {
	      axisTarget = {
	        x: layout.x,
	        width: layout.width
	      };
	      seriesTarget = {
	        y: layout.y,
	        height: layout.height
	      };
	    } else {
	      axisTarget = {
	        y: layout.y,
	        height: layout.height
	      };
	      seriesTarget = {
	        x: layout.x,
	        width: layout.width
	      };
	    }
	
	    if (!isChangeOrder) {
	      (isUpdate ? graphic_1.updateProps : graphic_1.initProps)(el, {
	        shape: seriesTarget
	      }, seriesModel, newIndex, null);
	    }
	
	    (isUpdate ? graphic_1.updateProps : graphic_1.initProps)(el, {
	      shape: axisTarget
	    }, axisModel, newIndex);
	  }
	}
	
	var getLayout = {
	  cartesian2d: function (data, dataIndex, itemModel) {
	    var layout = data.getItemLayout(dataIndex);
	    var fixedLineWidth = itemModel ? getLineWidth(itemModel, layout) : 0;
	    var signX = layout.width > 0 ? 1 : -1;
	    var signY = layout.height > 0 ? 1 : -1;
	    return {
	      x: layout.x + signX * fixedLineWidth / 2,
	      y: layout.y + signY * fixedLineWidth / 2,
	      width: layout.width - signX * fixedLineWidth,
	      height: layout.height - signY * fixedLineWidth
	    };
	  },
	  polar: function (data, dataIndex, itemModel) {
	    var layout = data.getItemLayout(dataIndex);
	    return {
	      cx: layout.cx,
	      cy: layout.cy,
	      r0: layout.r0,
	      r: layout.r,
	      startAngle: layout.startAngle,
	      endAngle: layout.endAngle
	    };
	  }
	};
	
	function isZeroOnPolar(layout) {
	  return layout.startAngle != null && layout.endAngle != null && layout.startAngle === layout.endAngle;
	}
	
	function updateStyle(el, data, dataIndex, itemModel, layout, seriesModel, isHorizontal, isPolar) {
	  var style = data.getItemVisual(dataIndex, 'style');
	
	  if (!isPolar) {
	    el.setShape('r', itemModel.get(BAR_BORDER_RADIUS_QUERY) || 0);
	  }
	
	  el.useStyle(style);
	  var cursorStyle = itemModel.getShallow('cursor');
	  cursorStyle && el.attr('cursor', cursorStyle);
	
	  if (!isPolar) {
	    var labelPositionOutside = isHorizontal ? layout.height > 0 ? 'bottom' : 'top' : layout.width > 0 ? 'left' : 'right';
	    var labelStatesModels = labelStyle_1.getLabelStatesModels(itemModel);
	    labelStyle_1.setLabelStyle(el, labelStatesModels, {
	      labelFetcher: seriesModel,
	      labelDataIndex: dataIndex,
	      defaultText: labelHelper_1.getDefaultLabel(seriesModel.getData(), dataIndex),
	      inheritColor: style.fill,
	      defaultOpacity: style.opacity,
	      defaultOutsidePosition: labelPositionOutside
	    });
	    var label = el.getTextContent();
	    labelStyle_1.setLabelValueAnimation(label, labelStatesModels, seriesModel.getRawValue(dataIndex), function (value) {
	      return labelHelper_1.getDefaultInterpolatedLabel(data, value);
	    });
	  }
	
	  var emphasisModel = itemModel.getModel(['emphasis']);
	  states_1.enableHoverEmphasis(el, emphasisModel.get('focus'), emphasisModel.get('blurScope'));
	  states_1.setStatesStylesFromModel(el, itemModel);
	
	  if (isZeroOnPolar(layout)) {
	    el.style.fill = 'none';
	    el.style.stroke = 'none';
	    util_1.each(el.states, function (state) {
	      if (state.style) {
	        state.style.fill = state.style.stroke = 'none';
	      }
	    });
	  }
	}
	
	function getLineWidth(itemModel, rawLayout) {
	  var lineWidth = itemModel.get(BAR_BORDER_WIDTH_QUERY) || 0;
	  var width = isNaN(rawLayout.width) ? Number.MAX_VALUE : Math.abs(rawLayout.width);
	  var height = isNaN(rawLayout.height) ? Number.MAX_VALUE : Math.abs(rawLayout.height);
	  return Math.min(lineWidth, width, height);
	}
	
	var LagePathShape = function () {
	  function LagePathShape() {}
	
	  return LagePathShape;
	}();
	
	var LargePath = function (_super) {
	  tslib_1.__extends(LargePath, _super);
	
	  function LargePath(opts) {
	    var _this = _super.call(this, opts) || this;
	
	    _this.type = 'largeBar';
	    return _this;
	  }
	
	  ;
	
	  LargePath.prototype.getDefaultShape = function () {
	    return new LagePathShape();
	  };
	
	  LargePath.prototype.buildPath = function (ctx, shape) {
	    var points = shape.points;
	    var startPoint = this.__startPoint;
	    var baseDimIdx = this.__baseDimIdx;
	
	    for (var i = 0; i < points.length; i += 2) {
	      startPoint[baseDimIdx] = points[i + baseDimIdx];
	      ctx.moveTo(startPoint[0], startPoint[1]);
	      ctx.lineTo(points[i], points[i + 1]);
	    }
	  };
	
	  return LargePath;
	}(Path_1["default"]);
	
	function createLarge(seriesModel, group, incremental) {
	  var data = seriesModel.getData();
	  var startPoint = [];
	  var baseDimIdx = data.getLayout('valueAxisHorizontal') ? 1 : 0;
	  startPoint[1 - baseDimIdx] = data.getLayout('valueAxisStart');
	  var largeDataIndices = data.getLayout('largeDataIndices');
	  var barWidth = data.getLayout('barWidth');
	  var backgroundModel = seriesModel.getModel('backgroundStyle');
	  var drawBackground = seriesModel.get('showBackground', true);
	
	  if (drawBackground) {
	    var points = data.getLayout('largeBackgroundPoints');
	    var backgroundStartPoint = [];
	    backgroundStartPoint[1 - baseDimIdx] = data.getLayout('backgroundStart');
	    var bgEl = new LargePath({
	      shape: {
	        points: points
	      },
	      incremental: !!incremental,
	      silent: true,
	      z2: 0
	    });
	    bgEl.__startPoint = backgroundStartPoint;
	    bgEl.__baseDimIdx = baseDimIdx;
	    bgEl.__largeDataIndices = largeDataIndices;
	    bgEl.__barWidth = barWidth;
	    setLargeBackgroundStyle(bgEl, backgroundModel, data);
	    group.add(bgEl);
	  }
	
	  var el = new LargePath({
	    shape: {
	      points: data.getLayout('largePoints')
	    },
	    incremental: !!incremental
	  });
	  el.__startPoint = startPoint;
	  el.__baseDimIdx = baseDimIdx;
	  el.__largeDataIndices = largeDataIndices;
	  el.__barWidth = barWidth;
	  group.add(el);
	  setLargeStyle(el, seriesModel, data);
	  innerStore_1.getECData(el).seriesIndex = seriesModel.seriesIndex;
	
	  if (!seriesModel.get('silent')) {
	    el.on('mousedown', largePathUpdateDataIndex);
	    el.on('mousemove', largePathUpdateDataIndex);
	  }
	}
	
	var largePathUpdateDataIndex = throttle_1.throttle(function (event) {
	  var largePath = this;
	  var dataIndex = largePathFindDataIndex(largePath, event.offsetX, event.offsetY);
	  innerStore_1.getECData(largePath).dataIndex = dataIndex >= 0 ? dataIndex : null;
	}, 30, false);
	
	function largePathFindDataIndex(largePath, x, y) {
	  var baseDimIdx = largePath.__baseDimIdx;
	  var valueDimIdx = 1 - baseDimIdx;
	  var points = largePath.shape.points;
	  var largeDataIndices = largePath.__largeDataIndices;
	  var barWidthHalf = Math.abs(largePath.__barWidth / 2);
	  var startValueVal = largePath.__startPoint[valueDimIdx];
	  _eventPos[0] = x;
	  _eventPos[1] = y;
	  var pointerBaseVal = _eventPos[baseDimIdx];
	  var pointerValueVal = _eventPos[1 - baseDimIdx];
	  var baseLowerBound = pointerBaseVal - barWidthHalf;
	  var baseUpperBound = pointerBaseVal + barWidthHalf;
	
	  for (var i = 0, len = points.length / 2; i < len; i++) {
	    var ii = i * 2;
	    var barBaseVal = points[ii + baseDimIdx];
	    var barValueVal = points[ii + valueDimIdx];
	
	    if (barBaseVal >= baseLowerBound && barBaseVal <= baseUpperBound && (startValueVal <= barValueVal ? pointerValueVal >= startValueVal && pointerValueVal <= barValueVal : pointerValueVal >= barValueVal && pointerValueVal <= startValueVal)) {
	      return largeDataIndices[i];
	    }
	  }
	
	  return -1;
	}
	
	function setLargeStyle(el, seriesModel, data) {
	  var globalStyle = data.getVisual('style');
	  el.useStyle(util_1.extend({}, globalStyle));
	  el.style.fill = null;
	  el.style.stroke = globalStyle.fill;
	  el.style.lineWidth = data.getLayout('barWidth');
	}
	
	function setLargeBackgroundStyle(el, backgroundModel, data) {
	  var borderColor = backgroundModel.get('borderColor') || backgroundModel.get('color');
	  var itemStyle = backgroundModel.getItemStyle();
	  el.useStyle(itemStyle);
	  el.style.fill = null;
	  el.style.stroke = borderColor;
	  el.style.lineWidth = data.getLayout('barWidth');
	}
	
	function createBackgroundShape(isHorizontalOrRadial, layout, coord) {
	  if (CoordinateSystem_1.isCoordinateSystemType(coord, 'cartesian2d')) {
	    var rectShape = layout;
	    var coordLayout = coord.getArea();
	    return {
	      x: isHorizontalOrRadial ? rectShape.x : coordLayout.x,
	      y: isHorizontalOrRadial ? coordLayout.y : rectShape.y,
	      width: isHorizontalOrRadial ? rectShape.width : coordLayout.width,
	      height: isHorizontalOrRadial ? coordLayout.height : rectShape.height
	    };
	  } else {
	    var coordLayout = coord.getArea();
	    var sectorShape = layout;
	    return {
	      cx: coordLayout.cx,
	      cy: coordLayout.cy,
	      r0: isHorizontalOrRadial ? coordLayout.r0 : sectorShape.r0,
	      r: isHorizontalOrRadial ? coordLayout.r : sectorShape.r,
	      startAngle: isHorizontalOrRadial ? sectorShape.startAngle : 0,
	      endAngle: isHorizontalOrRadial ? sectorShape.endAngle : Math.PI * 2
	    };
	  }
	}
	
	function createBackgroundEl(coord, isHorizontalOrRadial, layout) {
	  var ElementClz = coord.type === 'polar' ? graphic_1.Sector : graphic_1.Rect;
	  return new ElementClz({
	    shape: createBackgroundShape(isHorizontalOrRadial, layout, coord),
	    silent: true,
	    z2: 0
	  });
	}
	
	Chart_1["default"].registerClass(BarView);
	exports["default"] = BarView;

/***/ },
/* 292 */
/***/ function(module, exports, __webpack_require__) {

	
	/*
	* Licensed to the Apache Software Foundation (ASF) under one
	* or more contributor license agreements.  See the NOTICE file
	* distributed with this work for additional information
	* regarding copyright ownership.  The ASF licenses this file
	* to you under the Apache License, Version 2.0 (the
	* "License"); you may not use this file except in compliance
	* with the License.  You may obtain a copy of the License at
	*
	*   http://www.apache.org/licenses/LICENSE-2.0
	*
	* Unless required by applicable law or agreed to in writing,
	* software distributed under the License is distributed on an
	* "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
	* KIND, either express or implied.  See the License for the
	* specific language governing permissions and limitations
	* under the License.
	*/
	
	
	
	/**
	 * AUTO-GENERATED FILE. DO NOT MODIFY.
	 */
	
	"use strict";
	
	exports.__esModule = true;
	
	var tslib_1 = __webpack_require__(3);
	
	var Series_1 = __webpack_require__(68);
	
	var createListFromArray_1 = __webpack_require__(129);
	
	var BaseBarSeriesModel = function (_super) {
	  tslib_1.__extends(BaseBarSeriesModel, _super);
	
	  function BaseBarSeriesModel() {
	    var _this = _super !== null && _super.apply(this, arguments) || this;
	
	    _this.type = BaseBarSeriesModel.type;
	    return _this;
	  }
	
	  BaseBarSeriesModel.prototype.getInitialData = function (option, ecModel) {
	    return createListFromArray_1["default"](this.getSource(), this, {
	      useEncodeDefaulter: true
	    });
	  };
	
	  BaseBarSeriesModel.prototype.getMarkerPosition = function (value) {
	    var coordSys = this.coordinateSystem;
	
	    if (coordSys) {
	      var pt = coordSys.dataToPoint(coordSys.clampData(value));
	      var data = this.getData();
	      var offset = data.getLayout('offset');
	      var size = data.getLayout('size');
	      var offsetIndex = coordSys.getBaseAxis().isHorizontal() ? 0 : 1;
	      pt[offsetIndex] += offset + size / 2;
	      return pt;
	    }
	
	    return [NaN, NaN];
	  };
	
	  BaseBarSeriesModel.type = 'series.__base_bar__';
	  BaseBarSeriesModel.defaultOption = {
	    zlevel: 0,
	    z: 2,
	    coordinateSystem: 'cartesian2d',
	    legendHoverLink: true,
	    barMinHeight: 0,
	    barMinAngle: 0,
	    large: false,
	    largeThreshold: 400,
	    progressive: 3e3,
	    progressiveChunkMode: 'mod'
	  };
	  return BaseBarSeriesModel;
	}(Series_1["default"]);
	
	Series_1["default"].registerClass(BaseBarSeriesModel);
	exports["default"] = BaseBarSeriesModel;

/***/ },
/* 293 */
/***/ function(module, exports, __webpack_require__) {

	
	/*
	* Licensed to the Apache Software Foundation (ASF) under one
	* or more contributor license agreements.  See the NOTICE file
	* distributed with this work for additional information
	* regarding copyright ownership.  The ASF licenses this file
	* to you under the Apache License, Version 2.0 (the
	* "License"); you may not use this file except in compliance
	* with the License.  You may obtain a copy of the License at
	*
	*   http://www.apache.org/licenses/LICENSE-2.0
	*
	* Unless required by applicable law or agreed to in writing,
	* software distributed under the License is distributed on an
	* "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
	* KIND, either express or implied.  See the License for the
	* specific language governing permissions and limitations
	* under the License.
	*/
	
	
	
	/**
	 * AUTO-GENERATED FILE. DO NOT MODIFY.
	 */
	
	"use strict";
	
	exports.__esModule = true;
	
	var tslib_1 = __webpack_require__(3);
	
	var zrUtil = __webpack_require__(1);
	
	var vector = __webpack_require__(11);
	
	var symbolUtil = __webpack_require__(48);
	
	var LinePath_1 = __webpack_require__(295);
	
	var graphic = __webpack_require__(7);
	
	var states_1 = __webpack_require__(22);
	
	var labelStyle_1 = __webpack_require__(20);
	
	var number_1 = __webpack_require__(9);
	
	var SYMBOL_CATEGORIES = ['fromSymbol', 'toSymbol'];
	
	function makeSymbolTypeKey(symbolCategory) {
	  return '_' + symbolCategory + 'Type';
	}
	
	function createSymbol(name, lineData, idx) {
	  var symbolType = lineData.getItemVisual(idx, name);
	
	  if (!symbolType || symbolType === 'none') {
	    return;
	  }
	
	  var symbolSize = lineData.getItemVisual(idx, name + 'Size');
	  var symbolRotate = lineData.getItemVisual(idx, name + 'Rotate');
	  var symbolSizeArr = zrUtil.isArray(symbolSize) ? symbolSize : [symbolSize, symbolSize];
	  var symbolPath = symbolUtil.createSymbol(symbolType, -symbolSizeArr[0] / 2, -symbolSizeArr[1] / 2, symbolSizeArr[0], symbolSizeArr[1]);
	  symbolPath.__specifiedRotation = symbolRotate == null || isNaN(symbolRotate) ? void 0 : +symbolRotate * Math.PI / 180 || 0;
	  symbolPath.name = name;
	  return symbolPath;
	}
	
	function createLine(points) {
	  var line = new LinePath_1["default"]({
	    name: 'line',
	    subPixelOptimize: true
	  });
	  setLinePoints(line.shape, points);
	  return line;
	}
	
	function setLinePoints(targetShape, points) {
	  targetShape.x1 = points[0][0];
	  targetShape.y1 = points[0][1];
	  targetShape.x2 = points[1][0];
	  targetShape.y2 = points[1][1];
	  targetShape.percent = 1;
	  var cp1 = points[2];
	
	  if (cp1) {
	    targetShape.cpx1 = cp1[0];
	    targetShape.cpy1 = cp1[1];
	  } else {
	    targetShape.cpx1 = NaN;
	    targetShape.cpy1 = NaN;
	  }
	}
	
	var Line = function (_super) {
	  tslib_1.__extends(Line, _super);
	
	  function Line(lineData, idx, seriesScope) {
	    var _this = _super.call(this) || this;
	
	    _this._createLine(lineData, idx, seriesScope);
	
	    return _this;
	  }
	
	  Line.prototype._createLine = function (lineData, idx, seriesScope) {
	    var seriesModel = lineData.hostModel;
	    var linePoints = lineData.getItemLayout(idx);
	    var line = createLine(linePoints);
	    line.shape.percent = 0;
	    graphic.initProps(line, {
	      shape: {
	        percent: 1
	      }
	    }, seriesModel, idx);
	    this.add(line);
	    zrUtil.each(SYMBOL_CATEGORIES, function (symbolCategory) {
	      var symbol = createSymbol(symbolCategory, lineData, idx);
	      this.add(symbol);
	      this[makeSymbolTypeKey(symbolCategory)] = lineData.getItemVisual(idx, symbolCategory);
	    }, this);
	
	    this._updateCommonStl(lineData, idx, seriesScope);
	  };
	
	  Line.prototype.updateData = function (lineData, idx, seriesScope) {
	    var seriesModel = lineData.hostModel;
	    var line = this.childOfName('line');
	    var linePoints = lineData.getItemLayout(idx);
	    var target = {
	      shape: {}
	    };
	    setLinePoints(target.shape, linePoints);
	    graphic.updateProps(line, target, seriesModel, idx);
	    zrUtil.each(SYMBOL_CATEGORIES, function (symbolCategory) {
	      var symbolType = lineData.getItemVisual(idx, symbolCategory);
	      var key = makeSymbolTypeKey(symbolCategory);
	
	      if (this[key] !== symbolType) {
	        this.remove(this.childOfName(symbolCategory));
	        var symbol = createSymbol(symbolCategory, lineData, idx);
	        this.add(symbol);
	      }
	
	      this[key] = symbolType;
	    }, this);
	
	    this._updateCommonStl(lineData, idx, seriesScope);
	  };
	
	  ;
	
	  Line.prototype.getLinePath = function () {
	    return this.childAt(0);
	  };
	
	  Line.prototype._updateCommonStl = function (lineData, idx, seriesScope) {
	    var seriesModel = lineData.hostModel;
	    var line = this.childOfName('line');
	    var emphasisLineStyle = seriesScope && seriesScope.emphasisLineStyle;
	    var blurLineStyle = seriesScope && seriesScope.blurLineStyle;
	    var selectLineStyle = seriesScope && seriesScope.selectLineStyle;
	    var labelStatesModels = seriesScope && seriesScope.labelStatesModels;
	
	    if (!seriesScope || lineData.hasItemOption) {
	      var itemModel = lineData.getItemModel(idx);
	      emphasisLineStyle = itemModel.getModel(['emphasis', 'lineStyle']).getLineStyle();
	      blurLineStyle = itemModel.getModel(['blur', 'lineStyle']).getLineStyle();
	      selectLineStyle = itemModel.getModel(['select', 'lineStyle']).getLineStyle();
	      labelStatesModels = labelStyle_1.getLabelStatesModels(itemModel);
	    }
	
	    var lineStyle = lineData.getItemVisual(idx, 'style');
	    var visualColor = lineStyle.stroke;
	    line.useStyle(lineStyle);
	    line.style.fill = null;
	    line.style.strokeNoScale = true;
	    line.ensureState('emphasis').style = emphasisLineStyle;
	    line.ensureState('blur').style = blurLineStyle;
	    line.ensureState('select').style = selectLineStyle;
	    zrUtil.each(SYMBOL_CATEGORIES, function (symbolCategory) {
	      var symbol = this.childOfName(symbolCategory);
	
	      if (symbol) {
	        symbol.setColor(visualColor);
	        symbol.style.opacity = lineStyle.opacity;
	
	        for (var i = 0; i < states_1.SPECIAL_STATES.length; i++) {
	          var stateName = states_1.SPECIAL_STATES[i];
	          var lineState = line.getState(stateName);
	
	          if (lineState) {
	            var lineStateStyle = lineState.style || {};
	            var state = symbol.ensureState(stateName);
	            var stateStyle = state.style || (state.style = {});
	
	            if (lineStateStyle.stroke != null) {
	              stateStyle[symbol.__isEmptyBrush ? 'stroke' : 'fill'] = lineStateStyle.stroke;
	            }
	
	            if (lineStateStyle.opacity != null) {
	              stateStyle.opacity = lineStateStyle.opacity;
	            }
	          }
	        }
	
	        symbol.markRedraw();
	      }
	    }, this);
	    var rawVal = seriesModel.getRawValue(idx);
	    labelStyle_1.setLabelStyle(this, labelStatesModels, {
	      labelDataIndex: idx,
	      labelFetcher: {
	        getFormattedLabel: function (dataIndex, stateName) {
	          return seriesModel.getFormattedLabel(dataIndex, stateName, lineData.dataType);
	        }
	      },
	      inheritColor: visualColor || '#000',
	      defaultOpacity: lineStyle.opacity,
	      defaultText: (rawVal == null ? lineData.getName(idx) : isFinite(rawVal) ? number_1.round(rawVal) : rawVal) + ''
	    });
	    var label = this.getTextContent();
	
	    if (label) {
	      var labelNormalModel = labelStatesModels.normal;
	      label.__align = label.style.align;
	      label.__verticalAlign = label.style.verticalAlign;
	      label.__position = labelNormalModel.get('position') || 'middle';
	      var distance = labelNormalModel.get('distance');
	
	      if (!zrUtil.isArray(distance)) {
	        distance = [distance, distance];
	      }
	
	      label.__labelDistance = distance;
	    }
	
	    this.setTextConfig({
	      position: null,
	      local: true,
	      inside: false
	    });
	    states_1.enableHoverEmphasis(this);
	  };
	
	  Line.prototype.highlight = function () {
	    states_1.enterEmphasis(this);
	  };
	
	  Line.prototype.downplay = function () {
	    states_1.leaveEmphasis(this);
	  };
	
	  Line.prototype.updateLayout = function (lineData, idx) {
	    this.setLinePoints(lineData.getItemLayout(idx));
	  };
	
	  Line.prototype.setLinePoints = function (points) {
	    var linePath = this.childOfName('line');
	    setLinePoints(linePath.shape, points);
	    linePath.dirty();
	  };
	
	  Line.prototype.beforeUpdate = function () {
	    var lineGroup = this;
	    var symbolFrom = lineGroup.childOfName('fromSymbol');
	    var symbolTo = lineGroup.childOfName('toSymbol');
	    var label = lineGroup.getTextContent();
	
	    if (!symbolFrom && !symbolTo && (!label || label.ignore)) {
	      return;
	    }
	
	    var invScale = 1;
	    var parentNode = this.parent;
	
	    while (parentNode) {
	      if (parentNode.scaleX) {
	        invScale /= parentNode.scaleX;
	      }
	
	      parentNode = parentNode.parent;
	    }
	
	    var line = lineGroup.childOfName('line');
	
	    if (!this.__dirty && !line.__dirty) {
	      return;
	    }
	
	    var percent = line.shape.percent;
	    var fromPos = line.pointAt(0);
	    var toPos = line.pointAt(percent);
	    var d = vector.sub([], toPos, fromPos);
	    vector.normalize(d, d);
	
	    function setSymbolRotation(symbol, percent) {
	      var specifiedRotation = symbol.__specifiedRotation;
	
	      if (specifiedRotation == null) {
	        var tangent = line.tangentAt(percent);
	        symbol.attr('rotation', (percent === 1 ? -1 : 1) * Math.PI / 2 - Math.atan2(tangent[1], tangent[0]));
	      } else {
	        symbol.attr('rotation', specifiedRotation);
	      }
	    }
	
	    if (symbolFrom) {
	      symbolFrom.setPosition(fromPos);
	      setSymbolRotation(symbolFrom, 0);
	      symbolFrom.scaleX = symbolFrom.scaleY = invScale * percent;
	      symbolFrom.markRedraw();
	    }
	
	    if (symbolTo) {
	      symbolTo.setPosition(toPos);
	      setSymbolRotation(symbolTo, 1);
	      symbolTo.scaleX = symbolTo.scaleY = invScale * percent;
	      symbolTo.markRedraw();
	    }
	
	    if (label && !label.ignore) {
	      label.x = label.y = 0;
	      label.originX = label.originY = 0;
	      var textAlign = void 0;
	      var textVerticalAlign = void 0;
	      var distance = label.__labelDistance;
	      var distanceX = distance[0] * invScale;
	      var distanceY = distance[1] * invScale;
	      var halfPercent = percent / 2;
	      var tangent = line.tangentAt(halfPercent);
	      var n = [tangent[1], -tangent[0]];
	      var cp = line.pointAt(halfPercent);
	
	      if (n[1] > 0) {
	        n[0] = -n[0];
	        n[1] = -n[1];
	      }
	
	      var dir = tangent[0] < 0 ? -1 : 1;
	
	      if (label.__position !== 'start' && label.__position !== 'end') {
	        var rotation = -Math.atan2(tangent[1], tangent[0]);
	
	        if (toPos[0] < fromPos[0]) {
	          rotation = Math.PI + rotation;
	        }
	
	        label.rotation = rotation;
	      }
	
	      var dy = void 0;
	
	      switch (label.__position) {
	        case 'insideStartTop':
	        case 'insideMiddleTop':
	        case 'insideEndTop':
	        case 'middle':
	          dy = -distanceY;
	          textVerticalAlign = 'bottom';
	          break;
	
	        case 'insideStartBottom':
	        case 'insideMiddleBottom':
	        case 'insideEndBottom':
	          dy = distanceY;
	          textVerticalAlign = 'top';
	          break;
	
	        default:
	          dy = 0;
	          textVerticalAlign = 'middle';
	      }
	
	      switch (label.__position) {
	        case 'end':
	          label.x = d[0] * distanceX + toPos[0];
	          label.y = d[1] * distanceY + toPos[1];
	          textAlign = d[0] > 0.8 ? 'left' : d[0] < -0.8 ? 'right' : 'center';
	          textVerticalAlign = d[1] > 0.8 ? 'top' : d[1] < -0.8 ? 'bottom' : 'middle';
	          break;
	
	        case 'start':
	          label.x = -d[0] * distanceX + fromPos[0];
	          label.y = -d[1] * distanceY + fromPos[1];
	          textAlign = d[0] > 0.8 ? 'right' : d[0] < -0.8 ? 'left' : 'center';
	          textVerticalAlign = d[1] > 0.8 ? 'bottom' : d[1] < -0.8 ? 'top' : 'middle';
	          break;
	
	        case 'insideStartTop':
	        case 'insideStart':
	        case 'insideStartBottom':
	          label.x = distanceX * dir + fromPos[0];
	          label.y = fromPos[1] + dy;
	          textAlign = tangent[0] < 0 ? 'right' : 'left';
	          label.originX = -distanceX * dir;
	          label.originY = -dy;
	          break;
	
	        case 'insideMiddleTop':
	        case 'insideMiddle':
	        case 'insideMiddleBottom':
	        case 'middle':
	          label.x = cp[0];
	          label.y = cp[1] + dy;
	          textAlign = 'center';
	          label.originY = -dy;
	          break;
	
	        case 'insideEndTop':
	        case 'insideEnd':
	        case 'insideEndBottom':
	          label.x = -distanceX * dir + toPos[0];
	          label.y = toPos[1] + dy;
	          textAlign = tangent[0] >= 0 ? 'right' : 'left';
	          label.originX = distanceX * dir;
	          label.originY = -dy;
	          break;
	      }
	
	      label.scaleX = label.scaleY = invScale;
	      label.setStyle({
	        verticalAlign: label.__verticalAlign || textVerticalAlign,
	        align: label.__align || textAlign
	      });
	    }
	  };
	
	  return Line;
	}(graphic.Group);
	
	exports["default"] = Line;

/***/ },
/* 294 */
/***/ function(module, exports, __webpack_require__) {

	
	/*
	* Licensed to the Apache Software Foundation (ASF) under one
	* or more contributor license agreements.  See the NOTICE file
	* distributed with this work for additional information
	* regarding copyright ownership.  The ASF licenses this file
	* to you under the Apache License, Version 2.0 (the
	* "License"); you may not use this file except in compliance
	* with the License.  You may obtain a copy of the License at
	*
	*   http://www.apache.org/licenses/LICENSE-2.0
	*
	* Unless required by applicable law or agreed to in writing,
	* software distributed under the License is distributed on an
	* "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
	* KIND, either express or implied.  See the License for the
	* specific language governing permissions and limitations
	* under the License.
	*/
	
	
	
	/**
	 * AUTO-GENERATED FILE. DO NOT MODIFY.
	 */
	
	"use strict";
	
	exports.__esModule = true;
	
	var graphic = __webpack_require__(7);
	
	var Line_1 = __webpack_require__(293);
	
	var labelStyle_1 = __webpack_require__(20);
	
	var LineDraw = function () {
	  function LineDraw(LineCtor) {
	    this.group = new graphic.Group();
	    this._LineCtor = LineCtor || Line_1["default"];
	  }
	
	  LineDraw.prototype.isPersistent = function () {
	    return true;
	  };
	
	  ;
	
	  LineDraw.prototype.updateData = function (lineData) {
	    var _this = this;
	
	    var lineDraw = this;
	    var group = lineDraw.group;
	    var oldLineData = lineDraw._lineData;
	    lineDraw._lineData = lineData;
	
	    if (!oldLineData) {
	      group.removeAll();
	    }
	
	    var seriesScope = makeSeriesScope(lineData);
	    lineData.diff(oldLineData).add(function (idx) {
	      _this._doAdd(lineData, idx, seriesScope);
	    }).update(function (newIdx, oldIdx) {
	      _this._doUpdate(oldLineData, lineData, oldIdx, newIdx, seriesScope);
	    }).remove(function (idx) {
	      group.remove(oldLineData.getItemGraphicEl(idx));
	    }).execute();
	  };
	
	  ;
	
	  LineDraw.prototype.updateLayout = function () {
	    var lineData = this._lineData;
	
	    if (!lineData) {
	      return;
	    }
	
	    lineData.eachItemGraphicEl(function (el, idx) {
	      el.updateLayout(lineData, idx);
	    }, this);
	  };
	
	  ;
	
	  LineDraw.prototype.incrementalPrepareUpdate = function (lineData) {
	    this._seriesScope = makeSeriesScope(lineData);
	    this._lineData = null;
	    this.group.removeAll();
	  };
	
	  ;
	
	  LineDraw.prototype.incrementalUpdate = function (taskParams, lineData) {
	    function updateIncrementalAndHover(el) {
	      if (!el.isGroup && !isEffectObject(el)) {
	        el.incremental = true;
	        el.ensureState('emphasis').hoverLayer = true;
	      }
	    }
	
	    for (var idx = taskParams.start; idx < taskParams.end; idx++) {
	      var itemLayout = lineData.getItemLayout(idx);
	
	      if (lineNeedsDraw(itemLayout)) {
	        var el = new this._LineCtor(lineData, idx, this._seriesScope);
	        el.traverse(updateIncrementalAndHover);
	        this.group.add(el);
	        lineData.setItemGraphicEl(idx, el);
	      }
	    }
	  };
	
	  ;
	
	  LineDraw.prototype.remove = function () {
	    this.group.removeAll();
	  };
	
	  ;
	
	  LineDraw.prototype._doAdd = function (lineData, idx, seriesScope) {
	    var itemLayout = lineData.getItemLayout(idx);
	
	    if (!lineNeedsDraw(itemLayout)) {
	      return;
	    }
	
	    var el = new this._LineCtor(lineData, idx, seriesScope);
	    lineData.setItemGraphicEl(idx, el);
	    this.group.add(el);
	  };
	
	  LineDraw.prototype._doUpdate = function (oldLineData, newLineData, oldIdx, newIdx, seriesScope) {
	    var itemEl = oldLineData.getItemGraphicEl(oldIdx);
	
	    if (!lineNeedsDraw(newLineData.getItemLayout(newIdx))) {
	      this.group.remove(itemEl);
	      return;
	    }
	
	    if (!itemEl) {
	      itemEl = new this._LineCtor(newLineData, newIdx, seriesScope);
	    } else {
	      itemEl.updateData(newLineData, newIdx, seriesScope);
	    }
	
	    newLineData.setItemGraphicEl(newIdx, itemEl);
	    this.group.add(itemEl);
	  };
	
	  return LineDraw;
	}();
	
	function isEffectObject(el) {
	  return el.animators && el.animators.length > 0;
	}
	
	function makeSeriesScope(lineData) {
	  var hostModel = lineData.hostModel;
	  return {
	    lineStyle: hostModel.getModel('lineStyle').getLineStyle(),
	    emphasisLineStyle: hostModel.getModel(['emphasis', 'lineStyle']).getLineStyle(),
	    blurLineStyle: hostModel.getModel(['blur', 'lineStyle']).getLineStyle(),
	    selectLineStyle: hostModel.getModel(['select', 'lineStyle']).getLineStyle(),
	    labelStatesModels: labelStyle_1.getLabelStatesModels(hostModel)
	  };
	}
	
	function isPointNaN(pt) {
	  return isNaN(pt[0]) || isNaN(pt[1]);
	}
	
	function lineNeedsDraw(pts) {
	  return !isPointNaN(pts[0]) && !isPointNaN(pts[1]);
	}
	
	exports["default"] = LineDraw;

/***/ },
/* 295 */
/***/ function(module, exports, __webpack_require__) {

	
	/*
	* Licensed to the Apache Software Foundation (ASF) under one
	* or more contributor license agreements.  See the NOTICE file
	* distributed with this work for additional information
	* regarding copyright ownership.  The ASF licenses this file
	* to you under the Apache License, Version 2.0 (the
	* "License"); you may not use this file except in compliance
	* with the License.  You may obtain a copy of the License at
	*
	*   http://www.apache.org/licenses/LICENSE-2.0
	*
	* Unless required by applicable law or agreed to in writing,
	* software distributed under the License is distributed on an
	* "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
	* KIND, either express or implied.  See the License for the
	* specific language governing permissions and limitations
	* under the License.
	*/
	
	
	
	/**
	 * AUTO-GENERATED FILE. DO NOT MODIFY.
	 */
	
	"use strict";
	
	exports.__esModule = true;
	
	var tslib_1 = __webpack_require__(3);
	
	var graphic = __webpack_require__(7);
	
	var vec2 = __webpack_require__(11);
	
	var straightLineProto = graphic.Line.prototype;
	var bezierCurveProto = graphic.BezierCurve.prototype;
	
	var StraightLineShape = function () {
	  function StraightLineShape() {
	    this.x1 = 0;
	    this.y1 = 0;
	    this.x2 = 0;
	    this.y2 = 0;
	    this.percent = 1;
	  }
	
	  return StraightLineShape;
	}();
	
	var CurveShape = function (_super) {
	  tslib_1.__extends(CurveShape, _super);
	
	  function CurveShape() {
	    return _super !== null && _super.apply(this, arguments) || this;
	  }
	
	  return CurveShape;
	}(StraightLineShape);
	
	function isStraightLine(shape) {
	  return isNaN(+shape.cpx1) || isNaN(+shape.cpy1);
	}
	
	var ECLinePath = function (_super) {
	  tslib_1.__extends(ECLinePath, _super);
	
	  function ECLinePath(opts) {
	    var _this = _super.call(this, opts) || this;
	
	    _this.type = 'ec-line';
	    return _this;
	  }
	
	  ECLinePath.prototype.getDefaultStyle = function () {
	    return {
	      stroke: '#000',
	      fill: null
	    };
	  };
	
	  ECLinePath.prototype.getDefaultShape = function () {
	    return new StraightLineShape();
	  };
	
	  ECLinePath.prototype.buildPath = function (ctx, shape) {
	    if (isStraightLine(shape)) {
	      straightLineProto.buildPath.call(this, ctx, shape);
	    } else {
	      bezierCurveProto.buildPath.call(this, ctx, shape);
	    }
	  };
	
	  ECLinePath.prototype.pointAt = function (t) {
	    if (isStraightLine(this.shape)) {
	      return straightLineProto.pointAt.call(this, t);
	    } else {
	      return bezierCurveProto.pointAt.call(this, t);
	    }
	  };
	
	  ECLinePath.prototype.tangentAt = function (t) {
	    var shape = this.shape;
	    var p = isStraightLine(shape) ? [shape.x2 - shape.x1, shape.y2 - shape.y1] : bezierCurveProto.tangentAt.call(this, t);
	    return vec2.normalize(p, p);
	  };
	
	  return ECLinePath;
	}(graphic.Path);
	
	exports["default"] = ECLinePath;

/***/ },
/* 296 */
/***/ function(module, exports, __webpack_require__) {

	
	/*
	* Licensed to the Apache Software Foundation (ASF) under one
	* or more contributor license agreements.  See the NOTICE file
	* distributed with this work for additional information
	* regarding copyright ownership.  The ASF licenses this file
	* to you under the Apache License, Version 2.0 (the
	* "License"); you may not use this file except in compliance
	* with the License.  You may obtain a copy of the License at
	*
	*   http://www.apache.org/licenses/LICENSE-2.0
	*
	* Unless required by applicable law or agreed to in writing,
	* software distributed under the License is distributed on an
	* "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
	* KIND, either express or implied.  See the License for the
	* specific language governing permissions and limitations
	* under the License.
	*/
	
	
	
	/**
	 * AUTO-GENERATED FILE. DO NOT MODIFY.
	 */
	
	"use strict";
	
	exports.__esModule = true;
	
	var graphic = __webpack_require__(7);
	
	var Symbol_1 = __webpack_require__(127);
	
	var util_1 = __webpack_require__(1);
	
	var labelStyle_1 = __webpack_require__(20);
	
	function symbolNeedsDraw(data, point, idx, opt) {
	  return point && !isNaN(point[0]) && !isNaN(point[1]) && !(opt.isIgnore && opt.isIgnore(idx)) && !(opt.clipShape && !opt.clipShape.contain(point[0], point[1])) && data.getItemVisual(idx, 'symbol') !== 'none';
	}
	
	function normalizeUpdateOpt(opt) {
	  if (opt != null && !util_1.isObject(opt)) {
	    opt = {
	      isIgnore: opt
	    };
	  }
	
	  return opt || {};
	}
	
	function makeSeriesScope(data) {
	  var seriesModel = data.hostModel;
	  var emphasisModel = seriesModel.getModel('emphasis');
	  return {
	    emphasisItemStyle: emphasisModel.getModel('itemStyle').getItemStyle(),
	    blurItemStyle: seriesModel.getModel(['blur', 'itemStyle']).getItemStyle(),
	    selectItemStyle: seriesModel.getModel(['select', 'itemStyle']).getItemStyle(),
	    focus: emphasisModel.get('focus'),
	    blurScope: emphasisModel.get('blurScope'),
	    symbolRotate: seriesModel.get('symbolRotate'),
	    symbolOffset: seriesModel.get('symbolOffset'),
	    hoverScale: emphasisModel.get('scale'),
	    labelStatesModels: labelStyle_1.getLabelStatesModels(seriesModel),
	    cursorStyle: seriesModel.get('cursor')
	  };
	}
	
	var SymbolDraw = function () {
	  function SymbolDraw(SymbolCtor) {
	    this.group = new graphic.Group();
	    this._SymbolCtor = SymbolCtor || Symbol_1["default"];
	  }
	
	  SymbolDraw.prototype.updateData = function (data, opt) {
	    opt = normalizeUpdateOpt(opt);
	    var group = this.group;
	    var seriesModel = data.hostModel;
	    var oldData = this._data;
	    var SymbolCtor = this._SymbolCtor;
	    var disableAnimation = opt.disableAnimation;
	    var seriesScope = makeSeriesScope(data);
	    var symbolUpdateOpt = {
	      disableAnimation: disableAnimation
	    };
	
	    var getSymbolPoint = opt.getSymbolPoint || function (idx) {
	      return data.getItemLayout(idx);
	    };
	
	    if (!oldData) {
	      group.removeAll();
	    }
	
	    data.diff(oldData).add(function (newIdx) {
	      var point = getSymbolPoint(newIdx);
	
	      if (symbolNeedsDraw(data, point, newIdx, opt)) {
	        var symbolEl = new SymbolCtor(data, newIdx, seriesScope, symbolUpdateOpt);
	        symbolEl.setPosition(point);
	        data.setItemGraphicEl(newIdx, symbolEl);
	        group.add(symbolEl);
	      }
	    }).update(function (newIdx, oldIdx) {
	      var symbolEl = oldData.getItemGraphicEl(oldIdx);
	      var point = getSymbolPoint(newIdx);
	
	      if (!symbolNeedsDraw(data, point, newIdx, opt)) {
	        group.remove(symbolEl);
	        return;
	      }
	
	      if (!symbolEl) {
	        symbolEl = new SymbolCtor(data, newIdx);
	        symbolEl.setPosition(point);
	      } else {
	        symbolEl.updateData(data, newIdx, seriesScope, symbolUpdateOpt);
	        var target = {
	          x: point[0],
	          y: point[1]
	        };
	        disableAnimation ? symbolEl.attr(target) : graphic.updateProps(symbolEl, target, seriesModel);
	      }
	
	      group.add(symbolEl);
	      data.setItemGraphicEl(newIdx, symbolEl);
	    }).remove(function (oldIdx) {
	      var el = oldData.getItemGraphicEl(oldIdx);
	      el && el.fadeOut(function () {
	        group.remove(el);
	      });
	    }).execute();
	    this._getSymbolPoint = getSymbolPoint;
	    this._data = data;
	  };
	
	  ;
	
	  SymbolDraw.prototype.isPersistent = function () {
	    return true;
	  };
	
	  ;
	
	  SymbolDraw.prototype.updateLayout = function () {
	    var _this = this;
	
	    var data = this._data;
	
	    if (data) {
	      data.eachItemGraphicEl(function (el, idx) {
	        var point = _this._getSymbolPoint(idx);
	
	        el.setPosition(point);
	        el.markRedraw();
	      });
	    }
	  };
	
	  ;
	
	  SymbolDraw.prototype.incrementalPrepareUpdate = function (data) {
	    this._seriesScope = makeSeriesScope(data);
	    this._data = null;
	    this.group.removeAll();
	  };
	
	  ;
	
	  SymbolDraw.prototype.incrementalUpdate = function (taskParams, data, opt) {
	    opt = normalizeUpdateOpt(opt);
	
	    function updateIncrementalAndHover(el) {
	      if (!el.isGroup) {
	        el.incremental = true;
	        el.ensureState('emphasis').hoverLayer = true;
	      }
	    }
	
	    for (var idx = taskParams.start; idx < taskParams.end; idx++) {
	      var point = data.getItemLayout(idx);
	
	      if (symbolNeedsDraw(data, point, idx, opt)) {
	        var el = new this._SymbolCtor(data, idx, this._seriesScope);
	        el.traverse(updateIncrementalAndHover);
	        el.setPosition(point);
	        this.group.add(el);
	        data.setItemGraphicEl(idx, el);
	      }
	    }
	  };
	
	  ;
	
	  SymbolDraw.prototype.remove = function (enableAnimation) {
	    var group = this.group;
	    var data = this._data;
	
	    if (data && enableAnimation) {
	      data.eachItemGraphicEl(function (el) {
	        el.fadeOut(function () {
	          group.remove(el);
	        });
	      });
	    } else {
	      group.removeAll();
	    }
	  };
	
	  ;
	  return SymbolDraw;
	}();
	
	exports["default"] = SymbolDraw;

/***/ },
/* 297 */
/***/ function(module, exports, __webpack_require__) {

	
	/*
	* Licensed to the Apache Software Foundation (ASF) under one
	* or more contributor license agreements.  See the NOTICE file
	* distributed with this work for additional information
	* regarding copyright ownership.  The ASF licenses this file
	* to you under the Apache License, Version 2.0 (the
	* "License"); you may not use this file except in compliance
	* with the License.  You may obtain a copy of the License at
	*
	*   http://www.apache.org/licenses/LICENSE-2.0
	*
	* Unless required by applicable law or agreed to in writing,
	* software distributed under the License is distributed on an
	* "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
	* KIND, either express or implied.  See the License for the
	* specific language governing permissions and limitations
	* under the License.
	*/
	
	
	
	/**
	 * AUTO-GENERATED FILE. DO NOT MODIFY.
	 */
	
	"use strict";
	
	exports.__esModule = true;
	
	var tslib_1 = __webpack_require__(3);
	
	var createListFromArray_1 = __webpack_require__(129);
	
	var Series_1 = __webpack_require__(68);
	
	var LineSeriesModel = function (_super) {
	  tslib_1.__extends(LineSeriesModel, _super);
	
	  function LineSeriesModel() {
	    var _this = _super !== null && _super.apply(this, arguments) || this;
	
	    _this.type = LineSeriesModel.type;
	    _this.hasSymbolVisual = true;
	    _this.legendSymbol = 'line';
	    return _this;
	  }
	
	  LineSeriesModel.prototype.getInitialData = function (option) {
	    if (false) {
	      var coordSys = option.coordinateSystem;
	
	      if (coordSys !== 'polar' && coordSys !== 'cartesian2d') {
	        throw new Error('Line not support coordinateSystem besides cartesian and polar');
	      }
	    }
	
	    return createListFromArray_1["default"](this.getSource(), this, {
	      useEncodeDefaulter: true
	    });
	  };
	
	  LineSeriesModel.type = 'series.line';
	  LineSeriesModel.dependencies = ['grid', 'polar'];
	  LineSeriesModel.defaultOption = {
	    zlevel: 0,
	    z: 3,
	    coordinateSystem: 'cartesian2d',
	    legendHoverLink: true,
	    clip: true,
	    label: {
	      position: 'top'
	    },
	    endLabel: {
	      show: false,
	      valueAnimation: true,
	      distance: 8
	    },
	    lineStyle: {
	      width: 2,
	      type: 'solid'
	    },
	    emphasis: {
	      scale: true,
	      lineStyle: {
	        width: 'bolder'
	      }
	    },
	    step: false,
	    smooth: false,
	    smoothMonotone: null,
	    symbol: 'emptyCircle',
	    symbolSize: 4,
	    symbolRotate: null,
	    showSymbol: true,
	    showAllSymbol: 'auto',
	    connectNulls: false,
	    sampling: 'none',
	    animationEasing: 'linear',
	    progressive: 0,
	    hoverLayerThreshold: Infinity
	  };
	  return LineSeriesModel;
	}(Series_1["default"]);
	
	Series_1["default"].registerClass(LineSeriesModel);
	exports["default"] = LineSeriesModel;

/***/ },
/* 298 */
/***/ function(module, exports, __webpack_require__) {

	
	/*
	* Licensed to the Apache Software Foundation (ASF) under one
	* or more contributor license agreements.  See the NOTICE file
	* distributed with this work for additional information
	* regarding copyright ownership.  The ASF licenses this file
	* to you under the Apache License, Version 2.0 (the
	* "License"); you may not use this file except in compliance
	* with the License.  You may obtain a copy of the License at
	*
	*   http://www.apache.org/licenses/LICENSE-2.0
	*
	* Unless required by applicable law or agreed to in writing,
	* software distributed under the License is distributed on an
	* "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
	* KIND, either express or implied.  See the License for the
	* specific language governing permissions and limitations
	* under the License.
	*/
	
	
	
	/**
	 * AUTO-GENERATED FILE. DO NOT MODIFY.
	 */
	
	"use strict";
	
	exports.__esModule = true;
	
	var tslib_1 = __webpack_require__(3);
	
	var zrUtil = __webpack_require__(1);
	
	var SymbolDraw_1 = __webpack_require__(296);
	
	var Symbol_1 = __webpack_require__(127);
	
	var lineAnimationDiff_1 = __webpack_require__(299);
	
	var graphic = __webpack_require__(7);
	
	var modelUtil = __webpack_require__(4);
	
	var poly_1 = __webpack_require__(300);
	
	var Chart_1 = __webpack_require__(96);
	
	var helper_1 = __webpack_require__(130);
	
	var createClipPathFromCoordSys_1 = __webpack_require__(128);
	
	var CoordinateSystem_1 = __webpack_require__(87);
	
	var states_1 = __webpack_require__(22);
	
	var labelStyle_1 = __webpack_require__(20);
	
	var labelHelper_1 = __webpack_require__(83);
	
	var innerStore_1 = __webpack_require__(21);
	
	var vendor_1 = __webpack_require__(95);
	
	function isPointsSame(points1, points2) {
	  if (points1.length !== points2.length) {
	    return;
	  }
	
	  for (var i = 0; i < points1.length; i++) {
	    if (points1[i] !== points2[i]) {
	      return;
	    }
	  }
	
	  return true;
	}
	
	function bboxFromPoints(points) {
	  var minX = Infinity;
	  var minY = Infinity;
	  var maxX = -Infinity;
	  var maxY = -Infinity;
	
	  for (var i = 0; i < points.length;) {
	    var x = points[i++];
	    var y = points[i++];
	
	    if (!isNaN(x)) {
	      minX = Math.min(x, minX);
	      maxX = Math.max(x, maxX);
	    }
	
	    if (!isNaN(y)) {
	      minY = Math.min(y, minY);
	      maxY = Math.max(y, maxY);
	    }
	  }
	
	  return [[minX, minY], [maxX, maxY]];
	}
	
	function getBoundingDiff(points1, points2) {
	  var _a = bboxFromPoints(points1),
	      min1 = _a[0],
	      max1 = _a[1];
	
	  var _b = bboxFromPoints(points2),
	      min2 = _b[0],
	      max2 = _b[1];
	
	  return Math.max(Math.abs(min1[0] - min2[0]), Math.abs(min1[1] - min2[1]), Math.abs(max1[0] - max2[0]), Math.abs(max1[1] - max2[1]));
	}
	
	function getSmooth(smooth) {
	  return typeof smooth === 'number' ? smooth : smooth ? 0.5 : 0;
	}
	
	function getStackedOnPoints(coordSys, data, dataCoordInfo) {
	  if (!dataCoordInfo.valueDim) {
	    return [];
	  }
	
	  var len = data.count();
	  var points = vendor_1.createFloat32Array(len * 2);
	
	  for (var idx = 0; idx < len; idx++) {
	    var pt = helper_1.getStackedOnPoint(dataCoordInfo, coordSys, data, idx);
	    points[idx * 2] = pt[0];
	    points[idx * 2 + 1] = pt[1];
	  }
	
	  return points;
	}
	
	function turnPointsIntoStep(points, coordSys, stepTurnAt) {
	  var baseAxis = coordSys.getBaseAxis();
	  var baseIndex = baseAxis.dim === 'x' || baseAxis.dim === 'radius' ? 0 : 1;
	  var stepPoints = [];
	  var i = 0;
	  var stepPt = [];
	  var pt = [];
	  var nextPt = [];
	
	  for (; i < points.length - 2; i += 2) {
	    nextPt[0] = points[i + 2];
	    nextPt[1] = points[i + 3];
	    pt[0] = points[i];
	    pt[1] = points[i + 1];
	    stepPoints.push(pt[0], pt[1]);
	
	    switch (stepTurnAt) {
	      case 'end':
	        stepPt[baseIndex] = nextPt[baseIndex];
	        stepPt[1 - baseIndex] = pt[1 - baseIndex];
	        stepPoints.push(stepPt[0], stepPt[1]);
	        break;
	
	      case 'middle':
	        var middle = (pt[baseIndex] + nextPt[baseIndex]) / 2;
	        var stepPt2 = [];
	        stepPt[baseIndex] = stepPt2[baseIndex] = middle;
	        stepPt[1 - baseIndex] = pt[1 - baseIndex];
	        stepPt2[1 - baseIndex] = nextPt[1 - baseIndex];
	        stepPoints.push(stepPt[0], stepPt[1]);
	        stepPoints.push(stepPt2[0], stepPt2[1]);
	        break;
	
	      default:
	        stepPt[baseIndex] = pt[baseIndex];
	        stepPt[1 - baseIndex] = nextPt[1 - baseIndex];
	        stepPoints.push(stepPt[0], stepPt[1]);
	    }
	  }
	
	  stepPoints.push(points[i++], points[i++]);
	  return stepPoints;
	}
	
	function getVisualGradient(data, coordSys) {
	  var visualMetaList = data.getVisual('visualMeta');
	
	  if (!visualMetaList || !visualMetaList.length || !data.count()) {
	    return;
	  }
	
	  if (coordSys.type !== 'cartesian2d') {
	    if (false) {
	      console.warn('Visual map on line style is only supported on cartesian2d.');
	    }
	
	    return;
	  }
	
	  var coordDim;
	  var visualMeta;
	
	  for (var i = visualMetaList.length - 1; i >= 0; i--) {
	    var dimIndex = visualMetaList[i].dimension;
	    var dimName = data.dimensions[dimIndex];
	    var dimInfo = data.getDimensionInfo(dimName);
	    coordDim = dimInfo && dimInfo.coordDim;
	
	    if (coordDim === 'x' || coordDim === 'y') {
	      visualMeta = visualMetaList[i];
	      break;
	    }
	  }
	
	  if (!visualMeta) {
	    if (false) {
	      console.warn('Visual map on line style only support x or y dimension.');
	    }
	
	    return;
	  }
	
	  var axis = coordSys.getAxis(coordDim);
	  var colorStops = zrUtil.map(visualMeta.stops, function (stop) {
	    return {
	      offset: 0,
	      coord: axis.toGlobalCoord(axis.dataToCoord(stop.value)),
	      color: stop.color
	    };
	  });
	  var stopLen = colorStops.length;
	  var outerColors = visualMeta.outerColors.slice();
	
	  if (stopLen && colorStops[0].coord > colorStops[stopLen - 1].coord) {
	    colorStops.reverse();
	    outerColors.reverse();
	  }
	
	  var tinyExtent = 10;
	  var minCoord = colorStops[0].coord - tinyExtent;
	  var maxCoord = colorStops[stopLen - 1].coord + tinyExtent;
	  var coordSpan = maxCoord - minCoord;
	
	  if (coordSpan < 1e-3) {
	    return 'transparent';
	  }
	
	  zrUtil.each(colorStops, function (stop) {
	    stop.offset = (stop.coord - minCoord) / coordSpan;
	  });
	  colorStops.push({
	    offset: stopLen ? colorStops[stopLen - 1].offset : 0.5,
	    color: outerColors[1] || 'transparent'
	  });
	  colorStops.unshift({
	    offset: stopLen ? colorStops[0].offset : 0.5,
	    color: outerColors[0] || 'transparent'
	  });
	  var gradient = new graphic.LinearGradient(0, 0, 0, 0, colorStops, true);
	  gradient[coordDim] = minCoord;
	  gradient[coordDim + '2'] = maxCoord;
	  return gradient;
	}
	
	function getIsIgnoreFunc(seriesModel, data, coordSys) {
	  var showAllSymbol = seriesModel.get('showAllSymbol');
	  var isAuto = showAllSymbol === 'auto';
	
	  if (showAllSymbol && !isAuto) {
	    return;
	  }
	
	  var categoryAxis = coordSys.getAxesByScale('ordinal')[0];
	
	  if (!categoryAxis) {
	    return;
	  }
	
	  if (isAuto && canShowAllSymbolForCategory(categoryAxis, data)) {
	    return;
	  }
	
	  var categoryDataDim = data.mapDimension(categoryAxis.dim);
	  var labelMap = {};
	  zrUtil.each(categoryAxis.getViewLabels(), function (labelItem) {
	    labelMap[labelItem.tickValue] = 1;
	  });
	  return function (dataIndex) {
	    return !labelMap.hasOwnProperty(data.get(categoryDataDim, dataIndex));
	  };
	}
	
	function canShowAllSymbolForCategory(categoryAxis, data) {
	  var axisExtent = categoryAxis.getExtent();
	  var availSize = Math.abs(axisExtent[1] - axisExtent[0]) / categoryAxis.scale.count();
	  isNaN(availSize) && (availSize = 0);
	  var dataLen = data.count();
	  var step = Math.max(1, Math.round(dataLen / 5));
	
	  for (var dataIndex = 0; dataIndex < dataLen; dataIndex += step) {
	    if (Symbol_1["default"].getSymbolSize(data, dataIndex)[categoryAxis.isHorizontal() ? 1 : 0] * 1.5 > availSize) {
	      return false;
	    }
	  }
	
	  return true;
	}
	
	function isPointNull(x, y) {
	  return isNaN(x) || isNaN(y);
	}
	
	function getLastIndexNotNull(points) {
	  var len = points.length / 2;
	
	  for (; len > 0; len--) {
	    if (!isPointNull(points[len * 2 - 2], points[len * 2 - 1])) {
	      break;
	    }
	  }
	
	  return len - 1;
	}
	
	function getPointAtIndex(points, idx) {
	  return [points[idx * 2], points[idx * 2 + 1]];
	}
	
	function getIndexRange(points, xOrY, dim) {
	  var len = points.length / 2;
	  var dimIdx = dim === 'x' ? 0 : 1;
	  var a;
	  var b;
	  var prevIndex = 0;
	  var nextIndex = -1;
	
	  for (var i = 0; i < len; i++) {
	    b = points[i * 2 + dimIdx];
	
	    if (isNaN(b) || isNaN(points[i * 2 + 1 - dimIdx])) {
	      continue;
	    }
	
	    if (i === 0) {
	      a = b;
	      continue;
	    }
	
	    if (a <= xOrY && b >= xOrY || a >= xOrY && b <= xOrY) {
	      nextIndex = i;
	      break;
	    }
	
	    prevIndex = i;
	    a = b;
	  }
	
	  return {
	    range: [prevIndex, nextIndex],
	    t: (xOrY - a) / (b - a)
	  };
	}
	
	function createLineClipPath(lineView, coordSys, hasAnimation, seriesModel) {
	  if (CoordinateSystem_1.isCoordinateSystemType(coordSys, 'cartesian2d')) {
	    var endLabelModel_1 = seriesModel.getModel('endLabel');
	    var showEndLabel = endLabelModel_1.get('show');
	    var valueAnimation_1 = endLabelModel_1.get('valueAnimation');
	    var data_1 = seriesModel.getData();
	    var labelAnimationRecord_1 = {
	      lastFrameIndex: 0
	    };
	    var during = showEndLabel ? function (percent, clipRect) {
	      lineView._endLabelOnDuring(percent, clipRect, data_1, labelAnimationRecord_1, valueAnimation_1, endLabelModel_1, coordSys);
	    } : null;
	    var isHorizontal = coordSys.getBaseAxis().isHorizontal();
	    var clipPath = createClipPathFromCoordSys_1.createGridClipPath(coordSys, hasAnimation, seriesModel, function () {
	      var endLabel = lineView._endLabel;
	
	      if (endLabel && hasAnimation) {
	        if (labelAnimationRecord_1.originalX != null) {
	          endLabel.attr({
	            x: labelAnimationRecord_1.originalX,
	            y: labelAnimationRecord_1.originalY
	          });
	        }
	      }
	    }, during);
	
	    if (!seriesModel.get('clip', true)) {
	      var rectShape = clipPath.shape;
	      var expandSize = Math.max(rectShape.width, rectShape.height);
	
	      if (isHorizontal) {
	        rectShape.y -= expandSize;
	        rectShape.height += expandSize * 2;
	      } else {
	        rectShape.x -= expandSize;
	        rectShape.width += expandSize * 2;
	      }
	    }
	
	    if (during) {
	      during(1, clipPath);
	    }
	
	    return clipPath;
	  } else {
	    if (false) {
	      if (seriesModel.get(['endLabel', 'show'])) {
	        console.warn('endLabel is not supported for lines in polar systems.');
	      }
	    }
	
	    return createClipPathFromCoordSys_1.createPolarClipPath(coordSys, hasAnimation, seriesModel);
	  }
	}
	
	function getEndLabelStateSpecified(endLabelModel, coordSys) {
	  var baseAxis = coordSys.getBaseAxis();
	  var isHorizontal = baseAxis.isHorizontal();
	  var isBaseInversed = baseAxis.inverse;
	  var align = isHorizontal ? isBaseInversed ? 'right' : 'left' : 'center';
	  var verticalAlign = isHorizontal ? 'middle' : isBaseInversed ? 'top' : 'bottom';
	  return {
	    normal: {
	      align: endLabelModel.get('align') || align,
	      verticalAlign: endLabelModel.get('verticalAlign') || verticalAlign,
	      padding: endLabelModel.get('distance') || 0
	    }
	  };
	}
	
	var LineView = function (_super) {
	  tslib_1.__extends(LineView, _super);
	
	  function LineView() {
	    return _super !== null && _super.apply(this, arguments) || this;
	  }
	
	  LineView.prototype.init = function () {
	    var lineGroup = new graphic.Group();
	    var symbolDraw = new SymbolDraw_1["default"]();
	    this.group.add(symbolDraw.group);
	    this._symbolDraw = symbolDraw;
	    this._lineGroup = lineGroup;
	  };
	
	  LineView.prototype.render = function (seriesModel, ecModel, api) {
	    var _this = this;
	
	    var coordSys = seriesModel.coordinateSystem;
	    var group = this.group;
	    var data = seriesModel.getData();
	    var lineStyleModel = seriesModel.getModel('lineStyle');
	    var areaStyleModel = seriesModel.getModel('areaStyle');
	    var points = data.getLayout('points') || [];
	    var isCoordSysPolar = coordSys.type === 'polar';
	    var prevCoordSys = this._coordSys;
	    var symbolDraw = this._symbolDraw;
	    var polyline = this._polyline;
	    var polygon = this._polygon;
	    var lineGroup = this._lineGroup;
	    var hasAnimation = seriesModel.get('animation');
	    var isAreaChart = !areaStyleModel.isEmpty();
	    var valueOrigin = areaStyleModel.get('origin');
	    var dataCoordInfo = helper_1.prepareDataCoordInfo(coordSys, data, valueOrigin);
	    var stackedOnPoints = isAreaChart && getStackedOnPoints(coordSys, data, dataCoordInfo);
	    var showSymbol = seriesModel.get('showSymbol');
	    var isIgnoreFunc = showSymbol && !isCoordSysPolar && getIsIgnoreFunc(seriesModel, data, coordSys);
	    var oldData = this._data;
	    oldData && oldData.eachItemGraphicEl(function (el, idx) {
	      if (el.__temp) {
	        group.remove(el);
	        oldData.setItemGraphicEl(idx, null);
	      }
	    });
	
	    if (!showSymbol) {
	      symbolDraw.remove();
	    }
	
	    group.add(lineGroup);
	    var step = !isCoordSysPolar ? seriesModel.get('step') : false;
	    var clipShapeForSymbol;
	
	    if (coordSys && coordSys.getArea && seriesModel.get('clip', true)) {
	      clipShapeForSymbol = coordSys.getArea();
	
	      if (clipShapeForSymbol.width != null) {
	        clipShapeForSymbol.x -= 0.1;
	        clipShapeForSymbol.y -= 0.1;
	        clipShapeForSymbol.width += 0.2;
	        clipShapeForSymbol.height += 0.2;
	      } else if (clipShapeForSymbol.r0) {
	        clipShapeForSymbol.r0 -= 0.5;
	        clipShapeForSymbol.r += 0.5;
	      }
	    }
	
	    this._clipShapeForSymbol = clipShapeForSymbol;
	
	    if (!(polyline && prevCoordSys.type === coordSys.type && step === this._step)) {
	      showSymbol && symbolDraw.updateData(data, {
	        isIgnore: isIgnoreFunc,
	        clipShape: clipShapeForSymbol,
	        disableAnimation: true,
	        getSymbolPoint: function (idx) {
	          return [points[idx * 2], points[idx * 2 + 1]];
	        }
	      });
	      hasAnimation && this._initSymbolLabelAnimation(data, coordSys, clipShapeForSymbol);
	
	      if (step) {
	        points = turnPointsIntoStep(points, coordSys, step);
	
	        if (stackedOnPoints) {
	          stackedOnPoints = turnPointsIntoStep(stackedOnPoints, coordSys, step);
	        }
	      }
	
	      polyline = this._newPolyline(points);
	
	      if (isAreaChart) {
	        polygon = this._newPolygon(points, stackedOnPoints);
	      }
	
	      if (!isCoordSysPolar) {
	        this._initOrUpdateEndLabel(seriesModel, coordSys);
	      }
	
	      lineGroup.setClipPath(createLineClipPath(this, coordSys, true, seriesModel));
	    } else {
	      if (isAreaChart && !polygon) {
	        polygon = this._newPolygon(points, stackedOnPoints);
	      } else if (polygon && !isAreaChart) {
	        lineGroup.remove(polygon);
	        polygon = this._polygon = null;
	      }
	
	      if (!isCoordSysPolar) {
	        this._initOrUpdateEndLabel(seriesModel, coordSys);
	      }
	
	      lineGroup.setClipPath(createLineClipPath(this, coordSys, false, seriesModel));
	      showSymbol && symbolDraw.updateData(data, {
	        isIgnore: isIgnoreFunc,
	        clipShape: clipShapeForSymbol,
	        disableAnimation: true,
	        getSymbolPoint: function (idx) {
	          return [points[idx * 2], points[idx * 2 + 1]];
	        }
	      });
	
	      if (!isPointsSame(this._stackedOnPoints, stackedOnPoints) || !isPointsSame(this._points, points)) {
	        if (hasAnimation) {
	          this._doUpdateAnimation(data, stackedOnPoints, coordSys, api, step, valueOrigin);
	        } else {
	          if (step) {
	            points = turnPointsIntoStep(points, coordSys, step);
	
	            if (stackedOnPoints) {
	              stackedOnPoints = turnPointsIntoStep(stackedOnPoints, coordSys, step);
	            }
	          }
	
	          polyline.setShape({
	            points: points
	          });
	          polygon && polygon.setShape({
	            points: points,
	            stackedOnPoints: stackedOnPoints
	          });
	        }
	      }
	    }
	
	    var visualColor = getVisualGradient(data, coordSys) || data.getVisual('style')[data.getVisual('drawType')];
	    var focus = seriesModel.get(['emphasis', 'focus']);
	    var blurScope = seriesModel.get(['emphasis', 'blurScope']);
	    polyline.useStyle(zrUtil.defaults(lineStyleModel.getLineStyle(), {
	      fill: 'none',
	      stroke: visualColor,
	      lineJoin: 'bevel'
	    }));
	    states_1.setStatesStylesFromModel(polyline, seriesModel, 'lineStyle');
	
	    if (polyline.style.lineWidth > 0 && seriesModel.get(['emphasis', 'lineStyle', 'width']) === 'bolder') {
	      var emphasisLineStyle = polyline.getState('emphasis').style;
	      emphasisLineStyle.lineWidth = polyline.style.lineWidth + 1;
	    }
	
	    innerStore_1.getECData(polyline).seriesIndex = seriesModel.seriesIndex;
	    states_1.enableHoverEmphasis(polyline, focus, blurScope);
	    var smooth = getSmooth(seriesModel.get('smooth'));
	    var smoothMonotone = seriesModel.get('smoothMonotone');
	    var connectNulls = seriesModel.get('connectNulls');
	    polyline.setShape({
	      smooth: smooth,
	      smoothMonotone: smoothMonotone,
	      connectNulls: connectNulls
	    });
	
	    if (polygon) {
	      var stackedOnSeries = data.getCalculationInfo('stackedOnSeries');
	      var stackedOnSmooth = 0;
	      polygon.useStyle(zrUtil.defaults(areaStyleModel.getAreaStyle(), {
	        fill: visualColor,
	        opacity: 0.7,
	        lineJoin: 'bevel',
	        decal: data.getVisual('style').decal
	      }));
	
	      if (stackedOnSeries) {
	        stackedOnSmooth = getSmooth(stackedOnSeries.get('smooth'));
	      }
	
	      polygon.setShape({
	        smooth: smooth,
	        stackedOnSmooth: stackedOnSmooth,
	        smoothMonotone: smoothMonotone,
	        connectNulls: connectNulls
	      });
	      states_1.setStatesStylesFromModel(polygon, seriesModel, 'areaStyle');
	      innerStore_1.getECData(polygon).seriesIndex = seriesModel.seriesIndex;
	      states_1.enableHoverEmphasis(polygon, focus, blurScope);
	    }
	
	    var changePolyState = function (toState) {
	      _this._changePolyState(toState);
	    };
	
	    data.eachItemGraphicEl(function (el) {
	      el && (el.onHoverStateChange = changePolyState);
	    });
	    this._polyline.onHoverStateChange = changePolyState;
	    this._data = data;
	    this._coordSys = coordSys;
	    this._stackedOnPoints = stackedOnPoints;
	    this._points = points;
	    this._step = step;
	    this._valueOrigin = valueOrigin;
	  };
	
	  LineView.prototype.dispose = function () {};
	
	  LineView.prototype.highlight = function (seriesModel, ecModel, api, payload) {
	    var data = seriesModel.getData();
	    var dataIndex = modelUtil.queryDataIndex(data, payload);
	
	    this._changePolyState('emphasis');
	
	    if (!(dataIndex instanceof Array) && dataIndex != null && dataIndex >= 0) {
	      var points = data.getLayout('points');
	      var symbol = data.getItemGraphicEl(dataIndex);
	
	      if (!symbol) {
	        var x = points[dataIndex * 2];
	        var y = points[dataIndex * 2 + 1];
	
	        if (isNaN(x) || isNaN(y)) {
	          return;
	        }
	
	        if (this._clipShapeForSymbol && !this._clipShapeForSymbol.contain(x, y)) {
	          return;
	        }
	
	        symbol = new Symbol_1["default"](data, dataIndex);
	        symbol.x = x;
	        symbol.y = y;
	        symbol.setZ(seriesModel.get('zlevel'), seriesModel.get('z'));
	        symbol.__temp = true;
	        data.setItemGraphicEl(dataIndex, symbol);
	        symbol.stopSymbolAnimation(true);
	        this.group.add(symbol);
	      }
	
	      symbol.highlight();
	    } else {
	      Chart_1["default"].prototype.highlight.call(this, seriesModel, ecModel, api, payload);
	    }
	  };
	
	  LineView.prototype.downplay = function (seriesModel, ecModel, api, payload) {
	    var data = seriesModel.getData();
	    var dataIndex = modelUtil.queryDataIndex(data, payload);
	
	    this._changePolyState('normal');
	
	    if (dataIndex != null && dataIndex >= 0) {
	      var symbol = data.getItemGraphicEl(dataIndex);
	
	      if (symbol) {
	        if (symbol.__temp) {
	          data.setItemGraphicEl(dataIndex, null);
	          this.group.remove(symbol);
	        } else {
	          symbol.downplay();
	        }
	      }
	    } else {
	      Chart_1["default"].prototype.downplay.call(this, seriesModel, ecModel, api, payload);
	    }
	  };
	
	  LineView.prototype._changePolyState = function (toState) {
	    var polygon = this._polygon;
	    states_1.setStatesFlag(this._polyline, toState);
	    polygon && states_1.setStatesFlag(polygon, toState);
	  };
	
	  LineView.prototype._newPolyline = function (points) {
	    var polyline = this._polyline;
	
	    if (polyline) {
	      this._lineGroup.remove(polyline);
	    }
	
	    polyline = new poly_1.ECPolyline({
	      shape: {
	        points: points
	      },
	      segmentIgnoreThreshold: 2,
	      z2: 10
	    });
	
	    this._lineGroup.add(polyline);
	
	    this._polyline = polyline;
	    return polyline;
	  };
	
	  LineView.prototype._newPolygon = function (points, stackedOnPoints) {
	    var polygon = this._polygon;
	
	    if (polygon) {
	      this._lineGroup.remove(polygon);
	    }
	
	    polygon = new poly_1.ECPolygon({
	      shape: {
	        points: points,
	        stackedOnPoints: stackedOnPoints
	      },
	      segmentIgnoreThreshold: 2
	    });
	
	    this._lineGroup.add(polygon);
	
	    this._polygon = polygon;
	    return polygon;
	  };
	
	  LineView.prototype._initSymbolLabelAnimation = function (data, coordSys, clipShape) {
	    var isHorizontalOrRadial;
	    var isCoordSysPolar;
	    var baseAxis = coordSys.getBaseAxis();
	    var isAxisInverse = baseAxis.inverse;
	
	    if (coordSys.type === 'cartesian2d') {
	      isHorizontalOrRadial = baseAxis.isHorizontal();
	      isCoordSysPolar = false;
	    } else if (coordSys.type === 'polar') {
	      isHorizontalOrRadial = baseAxis.dim === 'angle';
	      isCoordSysPolar = true;
	    }
	
	    var seriesModel = data.hostModel;
	    var seriesDuration = seriesModel.get('animationDuration');
	
	    if (typeof seriesDuration === 'function') {
	      seriesDuration = seriesDuration(null);
	    }
	
	    var seriesDalay = seriesModel.get('animationDelay') || 0;
	    var seriesDalayValue = typeof seriesDalay === 'function' ? seriesDalay(null) : seriesDalay;
	    data.eachItemGraphicEl(function (symbol, idx) {
	      var el = symbol;
	
	      if (el) {
	        var point = [symbol.x, symbol.y];
	        var start = void 0;
	        var end = void 0;
	        var current = void 0;
	
	        if (isCoordSysPolar) {
	          var polarClip = clipShape;
	          var coord = coordSys.pointToCoord(point);
	
	          if (isHorizontalOrRadial) {
	            start = polarClip.startAngle;
	            end = polarClip.endAngle;
	            current = -coord[1] / 180 * Math.PI;
	          } else {
	            start = polarClip.r0;
	            end = polarClip.r;
	            current = coord[0];
	          }
	        } else {
	          var gridClip = clipShape;
	
	          if (isHorizontalOrRadial) {
	            start = gridClip.x;
	            end = gridClip.x + gridClip.width;
	            current = symbol.x;
	          } else {
	            start = gridClip.y + gridClip.height;
	            end = gridClip.y;
	            current = symbol.y;
	          }
	        }
	
	        var ratio = end === start ? 0 : (current - start) / (end - start);
	
	        if (isAxisInverse) {
	          ratio = 1 - ratio;
	        }
	
	        var delay = typeof seriesDalay === 'function' ? seriesDalay(idx) : seriesDuration * ratio + seriesDalayValue;
	        var symbolPath = el.getSymbolPath();
	        var text = symbolPath.getTextContent();
	        el.attr({
	          scaleX: 0,
	          scaleY: 0
	        });
	        el.animateTo({
	          scaleX: 1,
	          scaleY: 1
	        }, {
	          duration: 200,
	          delay: delay
	        });
	
	        if (text) {
	          text.animateFrom({
	            style: {
	              opacity: 0
	            }
	          }, {
	            duration: 300,
	            delay: delay
	          });
	        }
	
	        symbolPath.disableLabelAnimation = true;
	      }
	    });
	  };
	
	  LineView.prototype._initOrUpdateEndLabel = function (seriesModel, coordSys) {
	    var endLabelModel = seriesModel.getModel('endLabel');
	
	    if (endLabelModel.get('show')) {
	      var data_2 = seriesModel.getData();
	      var polyline = this._polyline;
	      var endLabel = this._endLabel;
	
	      if (!endLabel) {
	        endLabel = this._endLabel = new graphic.Text({
	          z2: 200
	        });
	        endLabel.ignoreClip = true;
	        polyline.setTextContent(this._endLabel);
	        polyline.disableLabelAnimation = true;
	      }
	
	      var dataIndex = getLastIndexNotNull(data_2.getLayout('points'));
	
	      if (dataIndex >= 0) {
	        labelStyle_1.setLabelStyle(endLabel, labelStyle_1.getLabelStatesModels(seriesModel, 'endLabel'), {
	          labelFetcher: seriesModel,
	          labelDataIndex: dataIndex,
	          defaultText: function (dataIndex, opt, overrideValue) {
	            return overrideValue ? labelHelper_1.getDefaultInterpolatedLabel(data_2, overrideValue) : labelHelper_1.getDefaultLabel(data_2, dataIndex);
	          },
	          enableTextSetter: true
	        }, getEndLabelStateSpecified(endLabelModel, coordSys));
	      }
	    } else if (this._endLabel) {
	      this._polyline.removeTextContent();
	
	      this._endLabel = null;
	    }
	  };
	
	  LineView.prototype._endLabelOnDuring = function (percent, clipRect, data, animationRecord, valueAnimation, endLabelModel, coordSys) {
	    var endLabel = this._endLabel;
	    var polyline = this._polyline;
	
	    if (endLabel) {
	      if (percent < 1 && animationRecord.originalX == null) {
	        animationRecord.originalX = endLabel.x;
	        animationRecord.originalY = endLabel.y;
	      }
	
	      var points = data.getLayout('points');
	      var seriesModel = data.hostModel;
	      var connectNulls = seriesModel.get('connectNulls');
	      var precision = endLabelModel.get('precision');
	      var baseAxis = coordSys.getBaseAxis();
	      var isHorizontal = baseAxis.isHorizontal();
	      var isBaseInversed = baseAxis.inverse;
	      var clipShape = clipRect.shape;
	      var xOrY = isBaseInversed ? isHorizontal ? clipShape.x : clipShape.y + clipShape.height : isHorizontal ? clipShape.x + clipShape.width : clipShape.y;
	      var dim = isHorizontal ? 'x' : 'y';
	      var dataIndexRange = getIndexRange(points, xOrY, dim);
	      var indices = dataIndexRange.range;
	      var diff = indices[1] - indices[0];
	      var value = void 0;
	
	      if (diff >= 1) {
	        if (diff > 1 && !connectNulls) {
	          var pt = getPointAtIndex(points, indices[0]);
	          endLabel.attr({
	            x: pt[0],
	            y: pt[1]
	          });
	          valueAnimation && (value = seriesModel.getRawValue(indices[0]));
	        } else {
	          var pt = polyline.getPointOn(xOrY, dim);
	          pt && endLabel.attr({
	            x: pt[0],
	            y: pt[1]
	          });
	          var startValue = seriesModel.getRawValue(indices[0]);
	          var endValue = seriesModel.getRawValue(indices[1]);
	          valueAnimation && (value = modelUtil.interpolateRawValues(data, precision, startValue, endValue, dataIndexRange.t));
	        }
	
	        animationRecord.lastFrameIndex = indices[0];
	      } else {
	        var idx = percent === 1 || animationRecord.lastFrameIndex > 0 ? indices[0] : 0;
	        var pt = getPointAtIndex(points, idx);
	        valueAnimation && (value = seriesModel.getRawValue(idx));
	        endLabel.attr({
	          x: pt[0],
	          y: pt[1]
	        });
	      }
	
	      if (valueAnimation) {
	        labelStyle_1.labelInner(endLabel).setLabelText(value);
	      }
	    }
	  };
	
	  LineView.prototype._doUpdateAnimation = function (data, stackedOnPoints, coordSys, api, step, valueOrigin) {
	    var polyline = this._polyline;
	    var polygon = this._polygon;
	    var seriesModel = data.hostModel;
	    var diff = lineAnimationDiff_1["default"](this._data, data, this._stackedOnPoints, stackedOnPoints, this._coordSys, coordSys, this._valueOrigin, valueOrigin);
	    var current = diff.current;
	    var stackedOnCurrent = diff.stackedOnCurrent;
	    var next = diff.next;
	    var stackedOnNext = diff.stackedOnNext;
	
	    if (step) {
	      current = turnPointsIntoStep(diff.current, coordSys, step);
	      stackedOnCurrent = turnPointsIntoStep(diff.stackedOnCurrent, coordSys, step);
	      next = turnPointsIntoStep(diff.next, coordSys, step);
	      stackedOnNext = turnPointsIntoStep(diff.stackedOnNext, coordSys, step);
	    }
	
	    if (getBoundingDiff(current, next) > 3000 || polygon && getBoundingDiff(stackedOnCurrent, stackedOnNext) > 3000) {
	      polyline.setShape({
	        points: next
	      });
	
	      if (polygon) {
	        polygon.setShape({
	          points: next,
	          stackedOnPoints: stackedOnNext
	        });
	      }
	
	      return;
	    }
	
	    polyline.shape.__points = diff.current;
	    polyline.shape.points = current;
	    var target = {
	      shape: {
	        points: next
	      }
	    };
	
	    if (diff.current !== current) {
	      target.shape.__points = diff.next;
	    }
	
	    polyline.stopAnimation();
	    graphic.updateProps(polyline, target, seriesModel);
	
	    if (polygon) {
	      polygon.setShape({
	        points: current,
	        stackedOnPoints: stackedOnCurrent
	      });
	      polygon.stopAnimation();
	      graphic.updateProps(polygon, {
	        shape: {
	          stackedOnPoints: stackedOnNext
	        }
	      }, seriesModel);
	
	      if (polyline.shape.points !== polygon.shape.points) {
	        polygon.shape.points = polyline.shape.points;
	      }
	    }
	
	    var updatedDataInfo = [];
	    var diffStatus = diff.status;
	
	    for (var i = 0; i < diffStatus.length; i++) {
	      var cmd = diffStatus[i].cmd;
	
	      if (cmd === '=') {
	        var el = data.getItemGraphicEl(diffStatus[i].idx1);
	
	        if (el) {
	          updatedDataInfo.push({
	            el: el,
	            ptIdx: i
	          });
	        }
	      }
	    }
	
	    if (polyline.animators && polyline.animators.length) {
	      polyline.animators[0].during(function () {
	        polygon && polygon.dirtyShape();
	        var points = polyline.shape.__points;
	
	        for (var i = 0; i < updatedDataInfo.length; i++) {
	          var el = updatedDataInfo[i].el;
	          var offset = updatedDataInfo[i].ptIdx * 2;
	          el.x = points[offset];
	          el.y = points[offset + 1];
	          el.markRedraw();
	        }
	      });
	    }
	  };
	
	  LineView.prototype.remove = function (ecModel) {
	    var group = this.group;
	    var oldData = this._data;
	
	    this._lineGroup.removeAll();
	
	    this._symbolDraw.remove(true);
	
	    oldData && oldData.eachItemGraphicEl(function (el, idx) {
	      if (el.__temp) {
	        group.remove(el);
	        oldData.setItemGraphicEl(idx, null);
	      }
	    });
	    this._polyline = this._polygon = this._coordSys = this._points = this._stackedOnPoints = this._endLabel = this._data = null;
	  };
	
	  LineView.type = 'line';
	  return LineView;
	}(Chart_1["default"]);
	
	Chart_1["default"].registerClass(LineView);
	exports["default"] = Chart_1["default"];

/***/ },
/* 299 */
/***/ function(module, exports, __webpack_require__) {

	
	/*
	* Licensed to the Apache Software Foundation (ASF) under one
	* or more contributor license agreements.  See the NOTICE file
	* distributed with this work for additional information
	* regarding copyright ownership.  The ASF licenses this file
	* to you under the Apache License, Version 2.0 (the
	* "License"); you may not use this file except in compliance
	* with the License.  You may obtain a copy of the License at
	*
	*   http://www.apache.org/licenses/LICENSE-2.0
	*
	* Unless required by applicable law or agreed to in writing,
	* software distributed under the License is distributed on an
	* "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
	* KIND, either express or implied.  See the License for the
	* specific language governing permissions and limitations
	* under the License.
	*/
	
	
	
	/**
	 * AUTO-GENERATED FILE. DO NOT MODIFY.
	 */
	
	"use strict";
	
	exports.__esModule = true;
	
	var helper_1 = __webpack_require__(130);
	
	var vendor_1 = __webpack_require__(95);
	
	function diffData(oldData, newData) {
	  var diffResult = [];
	  newData.diff(oldData).add(function (idx) {
	    diffResult.push({
	      cmd: '+',
	      idx: idx
	    });
	  }).update(function (newIdx, oldIdx) {
	    diffResult.push({
	      cmd: '=',
	      idx: oldIdx,
	      idx1: newIdx
	    });
	  }).remove(function (idx) {
	    diffResult.push({
	      cmd: '-',
	      idx: idx
	    });
	  }).execute();
	  return diffResult;
	}
	
	function lineAnimationDiff(oldData, newData, oldStackedOnPoints, newStackedOnPoints, oldCoordSys, newCoordSys, oldValueOrigin, newValueOrigin) {
	  var diff = diffData(oldData, newData);
	  var currPoints = [];
	  var nextPoints = [];
	  var currStackedPoints = [];
	  var nextStackedPoints = [];
	  var status = [];
	  var sortedIndices = [];
	  var rawIndices = [];
	  var newDataOldCoordInfo = helper_1.prepareDataCoordInfo(oldCoordSys, newData, oldValueOrigin);
	  var oldDataNewCoordInfo = helper_1.prepareDataCoordInfo(newCoordSys, oldData, newValueOrigin);
	  var oldPoints = oldData.getLayout('points') || [];
	  var newPoints = newData.getLayout('points') || [];
	
	  for (var i = 0; i < diff.length; i++) {
	    var diffItem = diff[i];
	    var pointAdded = true;
	    var oldIdx2 = void 0;
	    var newIdx2 = void 0;
	
	    switch (diffItem.cmd) {
	      case '=':
	        oldIdx2 = diffItem.idx * 2;
	        newIdx2 = diffItem.idx1 * 2;
	        var currentX = oldPoints[oldIdx2];
	        var currentY = oldPoints[oldIdx2 + 1];
	        var nextX = newPoints[newIdx2];
	        var nextY = newPoints[newIdx2 + 1];
	
	        if (isNaN(currentX) || isNaN(currentY)) {
	          currentX = nextX;
	          currentY = nextY;
	        }
	
	        currPoints.push(currentX, currentY);
	        nextPoints.push(nextX, nextY);
	        currStackedPoints.push(oldStackedOnPoints[oldIdx2], oldStackedOnPoints[oldIdx2 + 1]);
	        nextStackedPoints.push(newStackedOnPoints[newIdx2], newStackedOnPoints[newIdx2 + 1]);
	        rawIndices.push(newData.getRawIndex(diffItem.idx1));
	        break;
	
	      case '+':
	        var newIdx = diffItem.idx;
	        var newDataDimsForPoint = newDataOldCoordInfo.dataDimsForPoint;
	        var oldPt = oldCoordSys.dataToPoint([newData.get(newDataDimsForPoint[0], newIdx), newData.get(newDataDimsForPoint[1], newIdx)]);
	        newIdx2 = newIdx * 2;
	        currPoints.push(oldPt[0], oldPt[1]);
	        nextPoints.push(newPoints[newIdx2], newPoints[newIdx2 + 1]);
	        var stackedOnPoint = helper_1.getStackedOnPoint(newDataOldCoordInfo, oldCoordSys, newData, newIdx);
	        currStackedPoints.push(stackedOnPoint[0], stackedOnPoint[1]);
	        nextStackedPoints.push(newStackedOnPoints[newIdx2], newStackedOnPoints[newIdx2 + 1]);
	        rawIndices.push(newData.getRawIndex(newIdx));
	        break;
	
	      case '-':
	        var oldIdx = diffItem.idx;
	        var rawIndex = oldData.getRawIndex(oldIdx);
	        var oldDataDimsForPoint = oldDataNewCoordInfo.dataDimsForPoint;
	        oldIdx2 = oldIdx * 2;
	
	        if (rawIndex !== oldIdx) {
	          var newPt = newCoordSys.dataToPoint([oldData.get(oldDataDimsForPoint[0], oldIdx), oldData.get(oldDataDimsForPoint[1], oldIdx)]);
	          var newStackedOnPt = helper_1.getStackedOnPoint(oldDataNewCoordInfo, newCoordSys, oldData, oldIdx);
	          currPoints.push(oldPoints[oldIdx2], oldPoints[oldIdx2 + 1]);
	          nextPoints.push(newPt[0], newPt[1]);
	          currStackedPoints.push(oldStackedOnPoints[oldIdx2], oldStackedOnPoints[oldIdx2 + 1]);
	          nextStackedPoints.push(newStackedOnPt[0], newStackedOnPt[1]);
	          rawIndices.push(rawIndex);
	        } else {
	          pointAdded = false;
	        }
	
	    }
	
	    if (pointAdded) {
	      status.push(diffItem);
	      sortedIndices.push(sortedIndices.length);
	    }
	  }
	
	  sortedIndices.sort(function (a, b) {
	    return rawIndices[a] - rawIndices[b];
	  });
	  var len = currPoints.length;
	  var sortedCurrPoints = vendor_1.createFloat32Array(len);
	  var sortedNextPoints = vendor_1.createFloat32Array(len);
	  var sortedCurrStackedPoints = vendor_1.createFloat32Array(len);
	  var sortedNextStackedPoints = vendor_1.createFloat32Array(len);
	  var sortedStatus = [];
	
	  for (var i = 0; i < sortedIndices.length; i++) {
	    var idx = sortedIndices[i];
	    var i2 = i * 2;
	    var idx2 = idx * 2;
	    sortedCurrPoints[i2] = currPoints[idx2];
	    sortedCurrPoints[i2 + 1] = currPoints[idx2 + 1];
	    sortedNextPoints[i2] = nextPoints[idx2];
	    sortedNextPoints[i2 + 1] = nextPoints[idx2 + 1];
	    sortedCurrStackedPoints[i2] = currStackedPoints[idx2];
	    sortedCurrStackedPoints[i2 + 1] = currStackedPoints[idx2 + 1];
	    sortedNextStackedPoints[i2] = nextStackedPoints[idx2];
	    sortedNextStackedPoints[i2 + 1] = nextStackedPoints[idx2 + 1];
	    sortedStatus[i] = status[idx];
	  }
	
	  return {
	    current: sortedCurrPoints,
	    next: sortedNextPoints,
	    stackedOnCurrent: sortedCurrStackedPoints,
	    stackedOnNext: sortedNextStackedPoints,
	    status: sortedStatus
	  };
	}
	
	exports["default"] = lineAnimationDiff;

/***/ },
/* 300 */
/***/ function(module, exports, __webpack_require__) {

	
	/*
	* Licensed to the Apache Software Foundation (ASF) under one
	* or more contributor license agreements.  See the NOTICE file
	* distributed with this work for additional information
	* regarding copyright ownership.  The ASF licenses this file
	* to you under the Apache License, Version 2.0 (the
	* "License"); you may not use this file except in compliance
	* with the License.  You may obtain a copy of the License at
	*
	*   http://www.apache.org/licenses/LICENSE-2.0
	*
	* Unless required by applicable law or agreed to in writing,
	* software distributed under the License is distributed on an
	* "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
	* KIND, either express or implied.  See the License for the
	* specific language governing permissions and limitations
	* under the License.
	*/
	
	
	
	/**
	 * AUTO-GENERATED FILE. DO NOT MODIFY.
	 */
	
	"use strict";
	
	exports.__esModule = true;
	
	var tslib_1 = __webpack_require__(3);
	
	var Path_1 = __webpack_require__(8);
	
	var PathProxy_1 = __webpack_require__(32);
	
	var curve_1 = __webpack_require__(33);
	
	var mathMin = Math.min;
	var mathMax = Math.max;
	
	function isPointNull(x, y) {
	  return isNaN(x) || isNaN(y);
	}
	
	function drawSegment(ctx, points, start, segLen, allLen, dir, smooth, smoothMonotone, connectNulls) {
	  var prevX;
	  var prevY;
	  var cpx0;
	  var cpy0;
	  var cpx1;
	  var cpy1;
	  var idx = start;
	  var k = 0;
	
	  for (; k < segLen; k++) {
	    var x = points[idx * 2];
	    var y = points[idx * 2 + 1];
	
	    if (idx >= allLen || idx < 0) {
	      break;
	    }
	
	    if (isPointNull(x, y)) {
	      if (connectNulls) {
	        idx += dir;
	        continue;
	      }
	
	      break;
	    }
	
	    if (idx === start) {
	      ctx[dir > 0 ? 'moveTo' : 'lineTo'](x, y);
	      cpx0 = x;
	      cpy0 = y;
	    } else {
	      var dx = x - prevX;
	      var dy = y - prevY;
	
	      if (dx * dx + dy * dy < 0.5) {
	        idx += dir;
	        continue;
	      }
	
	      if (smooth > 0) {
	        var nextIdx = idx + dir;
	        var nextX = points[nextIdx * 2];
	        var nextY = points[nextIdx * 2 + 1];
	        var tmpK = k + 1;
	
	        if (connectNulls) {
	          while (isPointNull(nextX, nextY) && tmpK < segLen) {
	            tmpK++;
	            nextIdx += dir;
	            nextX = points[nextIdx * 2];
	            nextY = points[nextIdx * 2 + 1];
	          }
	        }
	
	        var ratioNextSeg = 0.5;
	        var vx = 0;
	        var vy = 0;
	        var nextCpx0 = void 0;
	        var nextCpy0 = void 0;
	
	        if (tmpK >= segLen || isPointNull(nextX, nextY)) {
	          cpx1 = x;
	          cpy1 = y;
	        } else {
	          vx = nextX - prevX;
	          vy = nextY - prevY;
	          var dx0 = x - prevX;
	          var dx1 = nextX - x;
	          var dy0 = y - prevY;
	          var dy1 = nextY - y;
	          var lenPrevSeg = void 0;
	          var lenNextSeg = void 0;
	
	          if (smoothMonotone === 'x') {
	            lenPrevSeg = Math.abs(dx0);
	            lenNextSeg = Math.abs(dx1);
	            cpx1 = x - lenPrevSeg * smooth;
	            cpy1 = y;
	            nextCpx0 = x + lenPrevSeg * smooth;
	            nextCpy0 = y;
	          } else if (smoothMonotone === 'y') {
	            lenPrevSeg = Math.abs(dy0);
	            lenNextSeg = Math.abs(dy1);
	            cpx1 = x;
	            cpy1 = y - lenPrevSeg * smooth;
	            nextCpx0 = x;
	            nextCpy0 = y + lenPrevSeg * smooth;
	          } else {
	            lenPrevSeg = Math.sqrt(dx0 * dx0 + dy0 * dy0);
	            lenNextSeg = Math.sqrt(dx1 * dx1 + dy1 * dy1);
	            ratioNextSeg = lenNextSeg / (lenNextSeg + lenPrevSeg);
	            cpx1 = x - vx * smooth * (1 - ratioNextSeg);
	            cpy1 = y - vy * smooth * (1 - ratioNextSeg);
	            nextCpx0 = x + vx * smooth * ratioNextSeg;
	            nextCpy0 = y + vy * smooth * ratioNextSeg;
	            nextCpx0 = mathMin(nextCpx0, mathMax(nextX, x));
	            nextCpy0 = mathMin(nextCpy0, mathMax(nextY, y));
	            nextCpx0 = mathMax(nextCpx0, mathMin(nextX, x));
	            nextCpy0 = mathMax(nextCpy0, mathMin(nextY, y));
	            vx = nextCpx0 - x;
	            vy = nextCpy0 - y;
	            cpx1 = x - vx * lenPrevSeg / lenNextSeg;
	            cpy1 = y - vy * lenPrevSeg / lenNextSeg;
	            cpx1 = mathMin(cpx1, mathMax(prevX, x));
	            cpy1 = mathMin(cpy1, mathMax(prevY, y));
	            cpx1 = mathMax(cpx1, mathMin(prevX, x));
	            cpy1 = mathMax(cpy1, mathMin(prevY, y));
	            vx = x - cpx1;
	            vy = y - cpy1;
	            nextCpx0 = x + vx * lenNextSeg / lenPrevSeg;
	            nextCpy0 = y + vy * lenNextSeg / lenPrevSeg;
	          }
	        }
	
	        ctx.bezierCurveTo(cpx0, cpy0, cpx1, cpy1, x, y);
	        cpx0 = nextCpx0;
	        cpy0 = nextCpy0;
	      } else {
	        ctx.lineTo(x, y);
	      }
	    }
	
	    prevX = x;
	    prevY = y;
	    idx += dir;
	  }
	
	  return k;
	}
	
	var ECPolylineShape = function () {
	  function ECPolylineShape() {
	    this.smooth = 0;
	    this.smoothConstraint = true;
	  }
	
	  return ECPolylineShape;
	}();
	
	var ECPolyline = function (_super) {
	  tslib_1.__extends(ECPolyline, _super);
	
	  function ECPolyline(opts) {
	    var _this = _super.call(this, opts) || this;
	
	    _this.type = 'ec-polyline';
	    return _this;
	  }
	
	  ECPolyline.prototype.getDefaultStyle = function () {
	    return {
	      stroke: '#000',
	      fill: null
	    };
	  };
	
	  ECPolyline.prototype.getDefaultShape = function () {
	    return new ECPolylineShape();
	  };
	
	  ECPolyline.prototype.buildPath = function (ctx, shape) {
	    var points = shape.points;
	    var i = 0;
	    var len = points.length / 2;
	
	    if (shape.connectNulls) {
	      for (; len > 0; len--) {
	        if (!isPointNull(points[len * 2 - 2], points[len * 2 - 1])) {
	          break;
	        }
	      }
	
	      for (; i < len; i++) {
	        if (!isPointNull(points[i * 2], points[i * 2 + 1])) {
	          break;
	        }
	      }
	    }
	
	    while (i < len) {
	      i += drawSegment(ctx, points, i, len, len, 1, shape.smooth, shape.smoothMonotone, shape.connectNulls) + 1;
	    }
	  };
	
	  ECPolyline.prototype.getPointOn = function (xOrY, dim) {
	    if (!this.path) {
	      this.createPathProxy();
	      this.buildPath(this.path, this.shape);
	    }
	
	    var path = this.path;
	    var data = path.data;
	    var CMD = PathProxy_1["default"].CMD;
	    var x0;
	    var y0;
	    var isDimX = dim === 'x';
	    var roots = [];
	
	    for (var i = 0; i < data.length;) {
	      var cmd = data[i++];
	      var x = void 0;
	      var y = void 0;
	      var x2 = void 0;
	      var y2 = void 0;
	      var x3 = void 0;
	      var y3 = void 0;
	      var t = void 0;
	
	      switch (cmd) {
	        case CMD.M:
	          x0 = data[i++];
	          y0 = data[i++];
	          break;
	
	        case CMD.L:
	          x = data[i++];
	          y = data[i++];
	          t = isDimX ? (xOrY - x0) / (x - x0) : (xOrY - y0) / (y - y0);
	
	          if (t <= 1 && t >= 0) {
	            var val = isDimX ? (y - y0) * t + y0 : (x - x0) * t + x0;
	            return isDimX ? [xOrY, val] : [val, xOrY];
	          }
	
	          x0 = x;
	          y0 = y;
	          break;
	
	        case CMD.C:
	          x = data[i++];
	          y = data[i++];
	          x2 = data[i++];
	          y2 = data[i++];
	          x3 = data[i++];
	          y3 = data[i++];
	          var nRoot = isDimX ? curve_1.cubicRootAt(x0, x, x2, x3, xOrY, roots) : curve_1.cubicRootAt(y0, y, y2, y3, xOrY, roots);
	
	          if (nRoot > 0) {
	            for (var i_1 = 0; i_1 < nRoot; i_1++) {
	              var t_1 = roots[i_1];
	
	              if (t_1 <= 1 && t_1 >= 0) {
	                var val = isDimX ? curve_1.cubicAt(y0, y, y2, y3, t_1) : curve_1.cubicAt(x0, x, x2, x3, t_1);
	                return isDimX ? [xOrY, val] : [val, xOrY];
	              }
	            }
	          }
	
	          x0 = x3;
	          y0 = y3;
	          break;
	      }
	    }
	  };
	
	  return ECPolyline;
	}(Path_1["default"]);
	
	exports.ECPolyline = ECPolyline;
	
	var ECPolygonShape = function (_super) {
	  tslib_1.__extends(ECPolygonShape, _super);
	
	  function ECPolygonShape() {
	    return _super !== null && _super.apply(this, arguments) || this;
	  }
	
	  return ECPolygonShape;
	}(ECPolylineShape);
	
	var ECPolygon = function (_super) {
	  tslib_1.__extends(ECPolygon, _super);
	
	  function ECPolygon(opts) {
	    var _this = _super.call(this, opts) || this;
	
	    _this.type = 'ec-polygon';
	    return _this;
	  }
	
	  ECPolygon.prototype.getDefaultShape = function () {
	    return new ECPolygonShape();
	  };
	
	  ECPolygon.prototype.buildPath = function (ctx, shape) {
	    var points = shape.points;
	    var stackedOnPoints = shape.stackedOnPoints;
	    var i = 0;
	    var len = points.length / 2;
	    var smoothMonotone = shape.smoothMonotone;
	
	    if (shape.connectNulls) {
	      for (; len > 0; len--) {
	        if (!isPointNull(points[len * 2 - 2], points[len * 2 - 1])) {
	          break;
	        }
	      }
	
	      for (; i < len; i++) {
	        if (!isPointNull(points[i * 2], points[i * 2 + 1])) {
	          break;
	        }
	      }
	    }
	
	    while (i < len) {
	      var k = drawSegment(ctx, points, i, len, len, 1, shape.smooth, smoothMonotone, shape.connectNulls);
	      drawSegment(ctx, stackedOnPoints, i + k - 1, k, len, -1, shape.stackedOnSmooth, smoothMonotone, shape.connectNulls);
	      i += k + 1;
	      ctx.closePath();
	    }
	  };
	
	  return ECPolygon;
	}(Path_1["default"]);
	
	exports.ECPolygon = ECPolygon;

/***/ },
/* 301 */
/***/ function(module, exports, __webpack_require__) {

	
	/*
	* Licensed to the Apache Software Foundation (ASF) under one
	* or more contributor license agreements.  See the NOTICE file
	* distributed with this work for additional information
	* regarding copyright ownership.  The ASF licenses this file
	* to you under the Apache License, Version 2.0 (the
	* "License"); you may not use this file except in compliance
	* with the License.  You may obtain a copy of the License at
	*
	*   http://www.apache.org/licenses/LICENSE-2.0
	*
	* Unless required by applicable law or agreed to in writing,
	* software distributed under the License is distributed on an
	* "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
	* KIND, either express or implied.  See the License for the
	* specific language governing permissions and limitations
	* under the License.
	*/
	
	
	
	/**
	 * AUTO-GENERATED FILE. DO NOT MODIFY.
	 */
	
	"use strict";
	
	exports.__esModule = true;
	
	__webpack_require__(142);
	
	__webpack_require__(302);

/***/ },
/* 302 */
/***/ function(module, exports, __webpack_require__) {

	
	/*
	* Licensed to the Apache Software Foundation (ASF) under one
	* or more contributor license agreements.  See the NOTICE file
	* distributed with this work for additional information
	* regarding copyright ownership.  The ASF licenses this file
	* to you under the Apache License, Version 2.0 (the
	* "License"); you may not use this file except in compliance
	* with the License.  You may obtain a copy of the License at
	*
	*   http://www.apache.org/licenses/LICENSE-2.0
	*
	* Unless required by applicable law or agreed to in writing,
	* software distributed under the License is distributed on an
	* "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
	* KIND, either express or implied.  See the License for the
	* specific language governing permissions and limitations
	* under the License.
	*/
	
	
	
	/**
	 * AUTO-GENERATED FILE. DO NOT MODIFY.
	 */
	
	"use strict";
	
	exports.__esModule = true;
	
	var tslib_1 = __webpack_require__(3);
	
	var zrUtil = __webpack_require__(1);
	
	var graphic = __webpack_require__(7);
	
	var AxisBuilder_1 = __webpack_require__(131);
	
	var AxisView_1 = __webpack_require__(132);
	
	var cartesianAxisHelper = __webpack_require__(67);
	
	var axisSplitHelper_1 = __webpack_require__(303);
	
	var Component_1 = __webpack_require__(18);
	
	var axisBuilderAttrs = ['axisLine', 'axisTickLabel', 'axisName'];
	var selfBuilderAttrs = ['splitArea', 'splitLine', 'minorSplitLine'];
	
	var CartesianAxisView = function (_super) {
	  tslib_1.__extends(CartesianAxisView, _super);
	
	  function CartesianAxisView() {
	    var _this = _super !== null && _super.apply(this, arguments) || this;
	
	    _this.type = CartesianAxisView.type;
	    _this.axisPointerClass = 'CartesianAxisPointer';
	    return _this;
	  }
	
	  CartesianAxisView.prototype.render = function (axisModel, ecModel, api, payload) {
	    this.group.removeAll();
	    var oldAxisGroup = this._axisGroup;
	    this._axisGroup = new graphic.Group();
	    this.group.add(this._axisGroup);
	
	    if (!axisModel.get('show')) {
	      return;
	    }
	
	    var gridModel = axisModel.getCoordSysModel();
	    var layout = cartesianAxisHelper.layout(gridModel, axisModel);
	    var axisBuilder = new AxisBuilder_1["default"](axisModel, zrUtil.extend({
	      handleAutoShown: function (elementType) {
	        var cartesians = gridModel.coordinateSystem.getCartesians();
	
	        for (var i = 0; i < cartesians.length; i++) {
	          var otherAxisType = cartesians[i].getOtherAxis(axisModel.axis).type;
	
	          if (otherAxisType === 'value' || otherAxisType === 'log') {
	            return true;
	          }
	        }
	
	        return false;
	      }
	    }, layout));
	    zrUtil.each(axisBuilderAttrs, axisBuilder.add, axisBuilder);
	
	    this._axisGroup.add(axisBuilder.getGroup());
	
	    zrUtil.each(selfBuilderAttrs, function (name) {
	      if (axisModel.get([name, 'show'])) {
	        axisElementBuilders[name](this, this._axisGroup, axisModel, gridModel);
	      }
	    }, this);
	    graphic.groupTransition(oldAxisGroup, this._axisGroup, axisModel);
	
	    _super.prototype.render.call(this, axisModel, ecModel, api, payload);
	  };
	
	  CartesianAxisView.prototype.remove = function () {
	    axisSplitHelper_1.rectCoordAxisHandleRemove(this);
	  };
	
	  CartesianAxisView.type = 'cartesianAxis';
	  return CartesianAxisView;
	}(AxisView_1["default"]);
	
	var axisElementBuilders = {
	  splitLine: function (axisView, axisGroup, axisModel, gridModel) {
	    var axis = axisModel.axis;
	
	    if (axis.scale.isBlank()) {
	      return;
	    }
	
	    var splitLineModel = axisModel.getModel('splitLine');
	    var lineStyleModel = splitLineModel.getModel('lineStyle');
	    var lineColors = lineStyleModel.get('color');
	    lineColors = zrUtil.isArray(lineColors) ? lineColors : [lineColors];
	    var gridRect = gridModel.coordinateSystem.getRect();
	    var isHorizontal = axis.isHorizontal();
	    var lineCount = 0;
	    var ticksCoords = axis.getTicksCoords({
	      tickModel: splitLineModel
	    });
	    var p1 = [];
	    var p2 = [];
	    var lineStyle = lineStyleModel.getLineStyle();
	
	    for (var i = 0; i < ticksCoords.length; i++) {
	      var tickCoord = axis.toGlobalCoord(ticksCoords[i].coord);
	
	      if (isHorizontal) {
	        p1[0] = tickCoord;
	        p1[1] = gridRect.y;
	        p2[0] = tickCoord;
	        p2[1] = gridRect.y + gridRect.height;
	      } else {
	        p1[0] = gridRect.x;
	        p1[1] = tickCoord;
	        p2[0] = gridRect.x + gridRect.width;
	        p2[1] = tickCoord;
	      }
	
	      var colorIndex = lineCount++ % lineColors.length;
	      var tickValue = ticksCoords[i].tickValue;
	      axisGroup.add(new graphic.Line({
	        anid: tickValue != null ? 'line_' + ticksCoords[i].tickValue : null,
	        subPixelOptimize: true,
	        autoBatch: true,
	        shape: {
	          x1: p1[0],
	          y1: p1[1],
	          x2: p2[0],
	          y2: p2[1]
	        },
	        style: zrUtil.defaults({
	          stroke: lineColors[colorIndex]
	        }, lineStyle),
	        silent: true
	      }));
	    }
	  },
	  minorSplitLine: function (axisView, axisGroup, axisModel, gridModel) {
	    var axis = axisModel.axis;
	    var minorSplitLineModel = axisModel.getModel('minorSplitLine');
	    var lineStyleModel = minorSplitLineModel.getModel('lineStyle');
	    var gridRect = gridModel.coordinateSystem.getRect();
	    var isHorizontal = axis.isHorizontal();
	    var minorTicksCoords = axis.getMinorTicksCoords();
	
	    if (!minorTicksCoords.length) {
	      return;
	    }
	
	    var p1 = [];
	    var p2 = [];
	    var lineStyle = lineStyleModel.getLineStyle();
	
	    for (var i = 0; i < minorTicksCoords.length; i++) {
	      for (var k = 0; k < minorTicksCoords[i].length; k++) {
	        var tickCoord = axis.toGlobalCoord(minorTicksCoords[i][k].coord);
	
	        if (isHorizontal) {
	          p1[0] = tickCoord;
	          p1[1] = gridRect.y;
	          p2[0] = tickCoord;
	          p2[1] = gridRect.y + gridRect.height;
	        } else {
	          p1[0] = gridRect.x;
	          p1[1] = tickCoord;
	          p2[0] = gridRect.x + gridRect.width;
	          p2[1] = tickCoord;
	        }
	
	        axisGroup.add(new graphic.Line({
	          anid: 'minor_line_' + minorTicksCoords[i][k].tickValue,
	          subPixelOptimize: true,
	          autoBatch: true,
	          shape: {
	            x1: p1[0],
	            y1: p1[1],
	            x2: p2[0],
	            y2: p2[1]
	          },
	          style: lineStyle,
	          silent: true
	        }));
	      }
	    }
	  },
	  splitArea: function (axisView, axisGroup, axisModel, gridModel) {
	    axisSplitHelper_1.rectCoordAxisBuildSplitArea(axisView, axisGroup, axisModel, gridModel);
	  }
	};
	
	var CartesianXAxisView = function (_super) {
	  tslib_1.__extends(CartesianXAxisView, _super);
	
	  function CartesianXAxisView() {
	    var _this = _super !== null && _super.apply(this, arguments) || this;
	
	    _this.type = CartesianXAxisView.type;
	    return _this;
	  }
	
	  CartesianXAxisView.type = 'xAxis';
	  return CartesianXAxisView;
	}(CartesianAxisView);
	
	var CartesianYAxisView = function (_super) {
	  tslib_1.__extends(CartesianYAxisView, _super);
	
	  function CartesianYAxisView() {
	    var _this = _super !== null && _super.apply(this, arguments) || this;
	
	    _this.type = CartesianXAxisView.type;
	    return _this;
	  }
	
	  CartesianYAxisView.type = 'yAxis';
	  return CartesianYAxisView;
	}(CartesianAxisView);
	
	Component_1["default"].registerClass(CartesianXAxisView);
	Component_1["default"].registerClass(CartesianYAxisView);
	exports["default"] = CartesianAxisView;

/***/ },
/* 303 */
/***/ function(module, exports, __webpack_require__) {

	
	/*
	* Licensed to the Apache Software Foundation (ASF) under one
	* or more contributor license agreements.  See the NOTICE file
	* distributed with this work for additional information
	* regarding copyright ownership.  The ASF licenses this file
	* to you under the Apache License, Version 2.0 (the
	* "License"); you may not use this file except in compliance
	* with the License.  You may obtain a copy of the License at
	*
	*   http://www.apache.org/licenses/LICENSE-2.0
	*
	* Unless required by applicable law or agreed to in writing,
	* software distributed under the License is distributed on an
	* "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
	* KIND, either express or implied.  See the License for the
	* specific language governing permissions and limitations
	* under the License.
	*/
	
	
	
	/**
	 * AUTO-GENERATED FILE. DO NOT MODIFY.
	 */
	
	"use strict";
	
	exports.__esModule = true;
	
	var zrUtil = __webpack_require__(1);
	
	var graphic = __webpack_require__(7);
	
	var model_1 = __webpack_require__(4);
	
	var inner = model_1.makeInner();
	
	function rectCoordAxisBuildSplitArea(axisView, axisGroup, axisModel, gridModel) {
	  var axis = axisModel.axis;
	
	  if (axis.scale.isBlank()) {
	    return;
	  }
	
	  var splitAreaModel = axisModel.getModel('splitArea');
	  var areaStyleModel = splitAreaModel.getModel('areaStyle');
	  var areaColors = areaStyleModel.get('color');
	  var gridRect = gridModel.coordinateSystem.getRect();
	  var ticksCoords = axis.getTicksCoords({
	    tickModel: splitAreaModel,
	    clamp: true
	  });
	
	  if (!ticksCoords.length) {
	    return;
	  }
	
	  var areaColorsLen = areaColors.length;
	  var lastSplitAreaColors = inner(axisView).splitAreaColors;
	  var newSplitAreaColors = zrUtil.createHashMap();
	  var colorIndex = 0;
	
	  if (lastSplitAreaColors) {
	    for (var i = 0; i < ticksCoords.length; i++) {
	      var cIndex = lastSplitAreaColors.get(ticksCoords[i].tickValue);
	
	      if (cIndex != null) {
	        colorIndex = (cIndex + (areaColorsLen - 1) * i) % areaColorsLen;
	        break;
	      }
	    }
	  }
	
	  var prev = axis.toGlobalCoord(ticksCoords[0].coord);
	  var areaStyle = areaStyleModel.getAreaStyle();
	  areaColors = zrUtil.isArray(areaColors) ? areaColors : [areaColors];
	
	  for (var i = 1; i < ticksCoords.length; i++) {
	    var tickCoord = axis.toGlobalCoord(ticksCoords[i].coord);
	    var x = void 0;
	    var y = void 0;
	    var width = void 0;
	    var height = void 0;
	
	    if (axis.isHorizontal()) {
	      x = prev;
	      y = gridRect.y;
	      width = tickCoord - x;
	      height = gridRect.height;
	      prev = x + width;
	    } else {
	      x = gridRect.x;
	      y = prev;
	      width = gridRect.width;
	      height = tickCoord - y;
	      prev = y + height;
	    }
	
	    var tickValue = ticksCoords[i - 1].tickValue;
	    tickValue != null && newSplitAreaColors.set(tickValue, colorIndex);
	    axisGroup.add(new graphic.Rect({
	      anid: tickValue != null ? 'area_' + tickValue : null,
	      shape: {
	        x: x,
	        y: y,
	        width: width,
	        height: height
	      },
	      style: zrUtil.defaults({
	        fill: areaColors[colorIndex]
	      }, areaStyle),
	      autoBatch: true,
	      silent: true
	    }));
	    colorIndex = (colorIndex + 1) % areaColorsLen;
	  }
	
	  inner(axisView).splitAreaColors = newSplitAreaColors;
	}
	
	exports.rectCoordAxisBuildSplitArea = rectCoordAxisBuildSplitArea;
	
	function rectCoordAxisHandleRemove(axisView) {
	  inner(axisView).splitAreaColors = null;
	}
	
	exports.rectCoordAxisHandleRemove = rectCoordAxisHandleRemove;

/***/ },
/* 304 */
/***/ function(module, exports, __webpack_require__) {

	
	/*
	* Licensed to the Apache Software Foundation (ASF) under one
	* or more contributor license agreements.  See the NOTICE file
	* distributed with this work for additional information
	* regarding copyright ownership.  The ASF licenses this file
	* to you under the Apache License, Version 2.0 (the
	* "License"); you may not use this file except in compliance
	* with the License.  You may obtain a copy of the License at
	*
	*   http://www.apache.org/licenses/LICENSE-2.0
	*
	* Unless required by applicable law or agreed to in writing,
	* software distributed under the License is distributed on an
	* "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
	* KIND, either express or implied.  See the License for the
	* specific language governing permissions and limitations
	* under the License.
	*/
	
	
	
	/**
	 * AUTO-GENERATED FILE. DO NOT MODIFY.
	 */
	
	"use strict";
	
	exports.__esModule = true;
	
	var tslib_1 = __webpack_require__(3);
	
	var Component_1 = __webpack_require__(10);
	
	var AxisPointerModel = function (_super) {
	  tslib_1.__extends(AxisPointerModel, _super);
	
	  function AxisPointerModel() {
	    var _this = _super !== null && _super.apply(this, arguments) || this;
	
	    _this.type = AxisPointerModel.type;
	    return _this;
	  }
	
	  AxisPointerModel.type = 'axisPointer';
	  AxisPointerModel.defaultOption = {
	    show: 'auto',
	    zlevel: 0,
	    z: 50,
	    type: 'line',
	    snap: false,
	    triggerTooltip: true,
	    value: null,
	    status: null,
	    link: [],
	    animation: null,
	    animationDurationUpdate: 200,
	    lineStyle: {
	      color: '#B9BEC9',
	      width: 1,
	      type: 'dashed'
	    },
	    shadowStyle: {
	      color: 'rgba(210,219,238,0.2)'
	    },
	    label: {
	      show: true,
	      formatter: null,
	      precision: 'auto',
	      margin: 3,
	      color: '#fff',
	      padding: [5, 7, 5, 7],
	      backgroundColor: 'auto',
	      borderColor: null,
	      borderWidth: 0,
	      borderRadius: 3
	    },
	    handle: {
	      show: false,
	      icon: 'M10.7,11.9v-1.3H9.3v1.3c-4.9,0.3-8.8,4.4-8.8,9.4c0,5,3.9,9.1,8.8,9.4h1.3c4.9-0.3,8.8-4.4,8.8-9.4C19.5,16.3,15.6,12.2,10.7,11.9z M13.3,24.4H6.7v-1.2h6.6z M13.3,22H6.7v-1.2h6.6z M13.3,19.6H6.7v-1.2h6.6z',
	      size: 45,
	      margin: 50,
	      color: '#333',
	      shadowBlur: 3,
	      shadowColor: '#aaa',
	      shadowOffsetX: 0,
	      shadowOffsetY: 2,
	      throttle: 40
	    }
	  };
	  return AxisPointerModel;
	}(Component_1["default"]);
	
	exports["default"] = AxisPointerModel;

/***/ },
/* 305 */
/***/ function(module, exports, __webpack_require__) {

	
	/*
	* Licensed to the Apache Software Foundation (ASF) under one
	* or more contributor license agreements.  See the NOTICE file
	* distributed with this work for additional information
	* regarding copyright ownership.  The ASF licenses this file
	* to you under the Apache License, Version 2.0 (the
	* "License"); you may not use this file except in compliance
	* with the License.  You may obtain a copy of the License at
	*
	*   http://www.apache.org/licenses/LICENSE-2.0
	*
	* Unless required by applicable law or agreed to in writing,
	* software distributed under the License is distributed on an
	* "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
	* KIND, either express or implied.  See the License for the
	* specific language governing permissions and limitations
	* under the License.
	*/
	
	
	
	/**
	 * AUTO-GENERATED FILE. DO NOT MODIFY.
	 */
	
	"use strict";
	
	exports.__esModule = true;
	
	var tslib_1 = __webpack_require__(3);
	
	var globalListener = __webpack_require__(136);
	
	var Component_1 = __webpack_require__(18);
	
	var AxisPointerView = function (_super) {
	  tslib_1.__extends(AxisPointerView, _super);
	
	  function AxisPointerView() {
	    var _this = _super !== null && _super.apply(this, arguments) || this;
	
	    _this.type = AxisPointerView.type;
	    return _this;
	  }
	
	  AxisPointerView.prototype.render = function (globalAxisPointerModel, ecModel, api) {
	    var globalTooltipModel = ecModel.getComponent('tooltip');
	    var triggerOn = globalAxisPointerModel.get('triggerOn') || globalTooltipModel && globalTooltipModel.get('triggerOn') || 'mousemove|click';
	    globalListener.register('axisPointer', api, function (currTrigger, e, dispatchAction) {
	      if (triggerOn !== 'none' && (currTrigger === 'leave' || triggerOn.indexOf(currTrigger) >= 0)) {
	        dispatchAction({
	          type: 'updateAxisPointer',
	          currTrigger: currTrigger,
	          x: e && e.offsetX,
	          y: e && e.offsetY
	        });
	      }
	    });
	  };
	
	  AxisPointerView.prototype.remove = function (ecModel, api) {
	    globalListener.unregister('axisPointer', api);
	  };
	
	  AxisPointerView.prototype.dispose = function (ecModel, api) {
	    globalListener.unregister('axisPointer', api);
	  };
	
	  AxisPointerView.type = 'axisPointer';
	  return AxisPointerView;
	}(Component_1["default"]);
	
	Component_1["default"].registerClass(AxisPointerView);
	exports["default"] = AxisPointerView;

/***/ },
/* 306 */
/***/ function(module, exports, __webpack_require__) {

	
	/*
	* Licensed to the Apache Software Foundation (ASF) under one
	* or more contributor license agreements.  See the NOTICE file
	* distributed with this work for additional information
	* regarding copyright ownership.  The ASF licenses this file
	* to you under the Apache License, Version 2.0 (the
	* "License"); you may not use this file except in compliance
	* with the License.  You may obtain a copy of the License at
	*
	*   http://www.apache.org/licenses/LICENSE-2.0
	*
	* Unless required by applicable law or agreed to in writing,
	* software distributed under the License is distributed on an
	* "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
	* KIND, either express or implied.  See the License for the
	* specific language governing permissions and limitations
	* under the License.
	*/
	
	
	
	/**
	 * AUTO-GENERATED FILE. DO NOT MODIFY.
	 */
	
	"use strict";
	
	exports.__esModule = true;
	
	var zrUtil = __webpack_require__(1);
	
	var graphic = __webpack_require__(7);
	
	var axisPointerModelHelper = __webpack_require__(63);
	
	var eventTool = __webpack_require__(42);
	
	var throttleUtil = __webpack_require__(56);
	
	var model_1 = __webpack_require__(4);
	
	var inner = model_1.makeInner();
	var clone = zrUtil.clone;
	var bind = zrUtil.bind;
	
	var BaseAxisPointer = function () {
	  function BaseAxisPointer() {
	    this._dragging = false;
	    this.animationThreshold = 15;
	  }
	
	  BaseAxisPointer.prototype.render = function (axisModel, axisPointerModel, api, forceRender) {
	    var value = axisPointerModel.get('value');
	    var status = axisPointerModel.get('status');
	    this._axisModel = axisModel;
	    this._axisPointerModel = axisPointerModel;
	    this._api = api;
	
	    if (!forceRender && this._lastValue === value && this._lastStatus === status) {
	      return;
	    }
	
	    this._lastValue = value;
	    this._lastStatus = status;
	    var group = this._group;
	    var handle = this._handle;
	
	    if (!status || status === 'hide') {
	      group && group.hide();
	      handle && handle.hide();
	      return;
	    }
	
	    group && group.show();
	    handle && handle.show();
	    var elOption = {};
	    this.makeElOption(elOption, value, axisModel, axisPointerModel, api);
	    var graphicKey = elOption.graphicKey;
	
	    if (graphicKey !== this._lastGraphicKey) {
	      this.clear(api);
	    }
	
	    this._lastGraphicKey = graphicKey;
	    var moveAnimation = this._moveAnimation = this.determineAnimation(axisModel, axisPointerModel);
	
	    if (!group) {
	      group = this._group = new graphic.Group();
	      this.createPointerEl(group, elOption, axisModel, axisPointerModel);
	      this.createLabelEl(group, elOption, axisModel, axisPointerModel);
	      api.getZr().add(group);
	    } else {
	      var doUpdateProps = zrUtil.curry(updateProps, axisPointerModel, moveAnimation);
	      this.updatePointerEl(group, elOption, doUpdateProps);
	      this.updateLabelEl(group, elOption, doUpdateProps, axisPointerModel);
	    }
	
	    updateMandatoryProps(group, axisPointerModel, true);
	
	    this._renderHandle(value);
	  };
	
	  BaseAxisPointer.prototype.remove = function (api) {
	    this.clear(api);
	  };
	
	  BaseAxisPointer.prototype.dispose = function (api) {
	    this.clear(api);
	  };
	
	  BaseAxisPointer.prototype.determineAnimation = function (axisModel, axisPointerModel) {
	    var animation = axisPointerModel.get('animation');
	    var axis = axisModel.axis;
	    var isCategoryAxis = axis.type === 'category';
	    var useSnap = axisPointerModel.get('snap');
	
	    if (!useSnap && !isCategoryAxis) {
	      return false;
	    }
	
	    if (animation === 'auto' || animation == null) {
	      var animationThreshold = this.animationThreshold;
	
	      if (isCategoryAxis && axis.getBandWidth() > animationThreshold) {
	        return true;
	      }
	
	      if (useSnap) {
	        var seriesDataCount = axisPointerModelHelper.getAxisInfo(axisModel).seriesDataCount;
	        var axisExtent = axis.getExtent();
	        return Math.abs(axisExtent[0] - axisExtent[1]) / seriesDataCount > animationThreshold;
	      }
	
	      return false;
	    }
	
	    return animation === true;
	  };
	
	  BaseAxisPointer.prototype.makeElOption = function (elOption, value, axisModel, axisPointerModel, api) {};
	
	  BaseAxisPointer.prototype.createPointerEl = function (group, elOption, axisModel, axisPointerModel) {
	    var pointerOption = elOption.pointer;
	
	    if (pointerOption) {
	      var pointerEl = inner(group).pointerEl = new graphic[pointerOption.type](clone(elOption.pointer));
	      group.add(pointerEl);
	    }
	  };
	
	  BaseAxisPointer.prototype.createLabelEl = function (group, elOption, axisModel, axisPointerModel) {
	    if (elOption.label) {
	      var labelEl = inner(group).labelEl = new graphic.Text(clone(elOption.label));
	      group.add(labelEl);
	      updateLabelShowHide(labelEl, axisPointerModel);
	    }
	  };
	
	  BaseAxisPointer.prototype.updatePointerEl = function (group, elOption, updateProps) {
	    var pointerEl = inner(group).pointerEl;
	
	    if (pointerEl && elOption.pointer) {
	      pointerEl.setStyle(elOption.pointer.style);
	      updateProps(pointerEl, {
	        shape: elOption.pointer.shape
	      });
	    }
	  };
	
	  BaseAxisPointer.prototype.updateLabelEl = function (group, elOption, updateProps, axisPointerModel) {
	    var labelEl = inner(group).labelEl;
	
	    if (labelEl) {
	      labelEl.setStyle(elOption.label.style);
	      updateProps(labelEl, {
	        x: elOption.label.x,
	        y: elOption.label.y
	      });
	      updateLabelShowHide(labelEl, axisPointerModel);
	    }
	  };
	
	  BaseAxisPointer.prototype._renderHandle = function (value) {
	    if (this._dragging || !this.updateHandleTransform) {
	      return;
	    }
	
	    var axisPointerModel = this._axisPointerModel;
	
	    var zr = this._api.getZr();
	
	    var handle = this._handle;
	    var handleModel = axisPointerModel.getModel('handle');
	    var status = axisPointerModel.get('status');
	
	    if (!handleModel.get('show') || !status || status === 'hide') {
	      handle && zr.remove(handle);
	      this._handle = null;
	      return;
	    }
	
	    var isInit;
	
	    if (!this._handle) {
	      isInit = true;
	      handle = this._handle = graphic.createIcon(handleModel.get('icon'), {
	        cursor: 'move',
	        draggable: true,
	        onmousemove: function (e) {
	          eventTool.stop(e.event);
	        },
	        onmousedown: bind(this._onHandleDragMove, this, 0, 0),
	        drift: bind(this._onHandleDragMove, this),
	        ondragend: bind(this._onHandleDragEnd, this)
	      });
	      zr.add(handle);
	    }
	
	    updateMandatoryProps(handle, axisPointerModel, false);
	    handle.setStyle(handleModel.getItemStyle(null, ['color', 'borderColor', 'borderWidth', 'opacity', 'shadowColor', 'shadowBlur', 'shadowOffsetX', 'shadowOffsetY']));
	    var handleSize = handleModel.get('size');
	
	    if (!zrUtil.isArray(handleSize)) {
	      handleSize = [handleSize, handleSize];
	    }
	
	    handle.scaleX = handleSize[0] / 2;
	    handle.scaleY = handleSize[1] / 2;
	    throttleUtil.createOrUpdate(this, '_doDispatchAxisPointer', handleModel.get('throttle') || 0, 'fixRate');
	
	    this._moveHandleToValue(value, isInit);
	  };
	
	  BaseAxisPointer.prototype._moveHandleToValue = function (value, isInit) {
	    updateProps(this._axisPointerModel, !isInit && this._moveAnimation, this._handle, getHandleTransProps(this.getHandleTransform(value, this._axisModel, this._axisPointerModel)));
	  };
	
	  BaseAxisPointer.prototype._onHandleDragMove = function (dx, dy) {
	    var handle = this._handle;
	
	    if (!handle) {
	      return;
	    }
	
	    this._dragging = true;
	    var trans = this.updateHandleTransform(getHandleTransProps(handle), [dx, dy], this._axisModel, this._axisPointerModel);
	    this._payloadInfo = trans;
	    handle.stopAnimation();
	    handle.attr(getHandleTransProps(trans));
	    inner(handle).lastProp = null;
	
	    this._doDispatchAxisPointer();
	  };
	
	  BaseAxisPointer.prototype._doDispatchAxisPointer = function () {
	    var handle = this._handle;
	
	    if (!handle) {
	      return;
	    }
	
	    var payloadInfo = this._payloadInfo;
	    var axisModel = this._axisModel;
	
	    this._api.dispatchAction({
	      type: 'updateAxisPointer',
	      x: payloadInfo.cursorPoint[0],
	      y: payloadInfo.cursorPoint[1],
	      tooltipOption: payloadInfo.tooltipOption,
	      axesInfo: [{
	        axisDim: axisModel.axis.dim,
	        axisIndex: axisModel.componentIndex
	      }]
	    });
	  };
	
	  BaseAxisPointer.prototype._onHandleDragEnd = function () {
	    this._dragging = false;
	    var handle = this._handle;
	
	    if (!handle) {
	      return;
	    }
	
	    var value = this._axisPointerModel.get('value');
	
	    this._moveHandleToValue(value);
	
	    this._api.dispatchAction({
	      type: 'hideTip'
	    });
	  };
	
	  BaseAxisPointer.prototype.clear = function (api) {
	    this._lastValue = null;
	    this._lastStatus = null;
	    var zr = api.getZr();
	    var group = this._group;
	    var handle = this._handle;
	
	    if (zr && group) {
	      this._lastGraphicKey = null;
	      group && zr.remove(group);
	      handle && zr.remove(handle);
	      this._group = null;
	      this._handle = null;
	      this._payloadInfo = null;
	    }
	  };
	
	  BaseAxisPointer.prototype.doClear = function () {};
	
	  BaseAxisPointer.prototype.buildLabel = function (xy, wh, xDimIndex) {
	    xDimIndex = xDimIndex || 0;
	    return {
	      x: xy[xDimIndex],
	      y: xy[1 - xDimIndex],
	      width: wh[xDimIndex],
	      height: wh[1 - xDimIndex]
	    };
	  };
	
	  return BaseAxisPointer;
	}();
	
	function updateProps(animationModel, moveAnimation, el, props) {
	  if (!propsEqual(inner(el).lastProp, props)) {
	    inner(el).lastProp = props;
	    moveAnimation ? graphic.updateProps(el, props, animationModel) : (el.stopAnimation(), el.attr(props));
	  }
	}
	
	function propsEqual(lastProps, newProps) {
	  if (zrUtil.isObject(lastProps) && zrUtil.isObject(newProps)) {
	    var equals_1 = true;
	    zrUtil.each(newProps, function (item, key) {
	      equals_1 = equals_1 && propsEqual(lastProps[key], item);
	    });
	    return !!equals_1;
	  } else {
	    return lastProps === newProps;
	  }
	}
	
	function updateLabelShowHide(labelEl, axisPointerModel) {
	  labelEl[axisPointerModel.get(['label', 'show']) ? 'show' : 'hide']();
	}
	
	function getHandleTransProps(trans) {
	  return {
	    x: trans.x || 0,
	    y: trans.y || 0,
	    rotation: trans.rotation || 0
	  };
	}
	
	function updateMandatoryProps(group, axisPointerModel, silent) {
	  var z = axisPointerModel.get('z');
	  var zlevel = axisPointerModel.get('zlevel');
	  group && group.traverse(function (el) {
	    if (el.type !== 'group') {
	      z != null && (el.z = z);
	      zlevel != null && (el.zlevel = zlevel);
	      el.silent = silent;
	    }
	  });
	}
	
	exports["default"] = BaseAxisPointer;

/***/ },
/* 307 */
/***/ function(module, exports, __webpack_require__) {

	
	/*
	* Licensed to the Apache Software Foundation (ASF) under one
	* or more contributor license agreements.  See the NOTICE file
	* distributed with this work for additional information
	* regarding copyright ownership.  The ASF licenses this file
	* to you under the Apache License, Version 2.0 (the
	* "License"); you may not use this file except in compliance
	* with the License.  You may obtain a copy of the License at
	*
	*   http://www.apache.org/licenses/LICENSE-2.0
	*
	* Unless required by applicable law or agreed to in writing,
	* software distributed under the License is distributed on an
	* "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
	* KIND, either express or implied.  See the License for the
	* specific language governing permissions and limitations
	* under the License.
	*/
	
	
	
	/**
	 * AUTO-GENERATED FILE. DO NOT MODIFY.
	 */
	
	"use strict";
	
	exports.__esModule = true;
	
	var model_1 = __webpack_require__(4);
	
	var modelHelper = __webpack_require__(63);
	
	var findPointFromSeries_1 = __webpack_require__(135);
	
	var util_1 = __webpack_require__(1);
	
	var inner = model_1.makeInner();
	
	function axisTrigger(payload, ecModel, api) {
	  var currTrigger = payload.currTrigger;
	  var point = [payload.x, payload.y];
	  var finder = payload;
	  var dispatchAction = payload.dispatchAction || util_1.bind(api.dispatchAction, api);
	  var coordSysAxesInfo = ecModel.getComponent('axisPointer').coordSysAxesInfo;
	
	  if (!coordSysAxesInfo) {
	    return;
	  }
	
	  if (illegalPoint(point)) {
	    point = findPointFromSeries_1["default"]({
	      seriesIndex: finder.seriesIndex,
	      dataIndex: finder.dataIndex
	    }, ecModel).point;
	  }
	
	  var isIllegalPoint = illegalPoint(point);
	  var inputAxesInfo = finder.axesInfo;
	  var axesInfo = coordSysAxesInfo.axesInfo;
	  var shouldHide = currTrigger === 'leave' || illegalPoint(point);
	  var outputPayload = {};
	  var showValueMap = {};
	  var dataByCoordSys = {
	    list: [],
	    map: {}
	  };
	  var updaters = {
	    showPointer: util_1.curry(showPointer, showValueMap),
	    showTooltip: util_1.curry(showTooltip, dataByCoordSys)
	  };
	  util_1.each(coordSysAxesInfo.coordSysMap, function (coordSys, coordSysKey) {
	    var coordSysContainsPoint = isIllegalPoint || coordSys.containPoint(point);
	    util_1.each(coordSysAxesInfo.coordSysAxesInfo[coordSysKey], function (axisInfo, key) {
	      var axis = axisInfo.axis;
	      var inputAxisInfo = findInputAxisInfo(inputAxesInfo, axisInfo);
	
	      if (!shouldHide && coordSysContainsPoint && (!inputAxesInfo || inputAxisInfo)) {
	        var val = inputAxisInfo && inputAxisInfo.value;
	
	        if (val == null && !isIllegalPoint) {
	          val = axis.pointToData(point);
	        }
	
	        val != null && processOnAxis(axisInfo, val, updaters, false, outputPayload);
	      }
	    });
	  });
	  var linkTriggers = {};
	  util_1.each(axesInfo, function (tarAxisInfo, tarKey) {
	    var linkGroup = tarAxisInfo.linkGroup;
	
	    if (linkGroup && !showValueMap[tarKey]) {
	      util_1.each(linkGroup.axesInfo, function (srcAxisInfo, srcKey) {
	        var srcValItem = showValueMap[srcKey];
	
	        if (srcAxisInfo !== tarAxisInfo && srcValItem) {
	          var val = srcValItem.value;
	          linkGroup.mapper && (val = tarAxisInfo.axis.scale.parse(linkGroup.mapper(val, makeMapperParam(srcAxisInfo), makeMapperParam(tarAxisInfo))));
	          linkTriggers[tarAxisInfo.key] = val;
	        }
	      });
	    }
	  });
	  util_1.each(linkTriggers, function (val, tarKey) {
	    processOnAxis(axesInfo[tarKey], val, updaters, true, outputPayload);
	  });
	  updateModelActually(showValueMap, axesInfo, outputPayload);
	  dispatchTooltipActually(dataByCoordSys, point, payload, dispatchAction);
	  dispatchHighDownActually(axesInfo, dispatchAction, api);
	  return outputPayload;
	}
	
	exports["default"] = axisTrigger;
	
	function processOnAxis(axisInfo, newValue, updaters, noSnap, outputFinder) {
	  var axis = axisInfo.axis;
	
	  if (axis.scale.isBlank() || !axis.containData(newValue)) {
	    return;
	  }
	
	  if (!axisInfo.involveSeries) {
	    updaters.showPointer(axisInfo, newValue);
	    return;
	  }
	
	  var payloadInfo = buildPayloadsBySeries(newValue, axisInfo);
	  var payloadBatch = payloadInfo.payloadBatch;
	  var snapToValue = payloadInfo.snapToValue;
	
	  if (payloadBatch[0] && outputFinder.seriesIndex == null) {
	    util_1.extend(outputFinder, payloadBatch[0]);
	  }
	
	  if (!noSnap && axisInfo.snap) {
	    if (axis.containData(snapToValue) && snapToValue != null) {
	      newValue = snapToValue;
	    }
	  }
	
	  updaters.showPointer(axisInfo, newValue, payloadBatch);
	  updaters.showTooltip(axisInfo, payloadInfo, snapToValue);
	}
	
	function buildPayloadsBySeries(value, axisInfo) {
	  var axis = axisInfo.axis;
	  var dim = axis.dim;
	  var snapToValue = value;
	  var payloadBatch = [];
	  var minDist = Number.MAX_VALUE;
	  var minDiff = -1;
	  util_1.each(axisInfo.seriesModels, function (series, idx) {
	    var dataDim = series.getData().mapDimensionsAll(dim);
	    var seriesNestestValue;
	    var dataIndices;
	
	    if (series.getAxisTooltipData) {
	      var result = series.getAxisTooltipData(dataDim, value, axis);
	      dataIndices = result.dataIndices;
	      seriesNestestValue = result.nestestValue;
	    } else {
	      dataIndices = series.getData().indicesOfNearest(dataDim[0], value, axis.type === 'category' ? 0.5 : null);
	
	      if (!dataIndices.length) {
	        return;
	      }
	
	      seriesNestestValue = series.getData().get(dataDim[0], dataIndices[0]);
	    }
	
	    if (seriesNestestValue == null || !isFinite(seriesNestestValue)) {
	      return;
	    }
	
	    var diff = value - seriesNestestValue;
	    var dist = Math.abs(diff);
	
	    if (dist <= minDist) {
	      if (dist < minDist || diff >= 0 && minDiff < 0) {
	        minDist = dist;
	        minDiff = diff;
	        snapToValue = seriesNestestValue;
	        payloadBatch.length = 0;
	      }
	
	      util_1.each(dataIndices, function (dataIndex) {
	        payloadBatch.push({
	          seriesIndex: series.seriesIndex,
	          dataIndexInside: dataIndex,
	          dataIndex: series.getData().getRawIndex(dataIndex)
	        });
	      });
	    }
	  });
	  return {
	    payloadBatch: payloadBatch,
	    snapToValue: snapToValue
	  };
	}
	
	function showPointer(showValueMap, axisInfo, value, payloadBatch) {
	  showValueMap[axisInfo.key] = {
	    value: value,
	    payloadBatch: payloadBatch
	  };
	}
	
	function showTooltip(dataByCoordSys, axisInfo, payloadInfo, value) {
	  var payloadBatch = payloadInfo.payloadBatch;
	  var axis = axisInfo.axis;
	  var axisModel = axis.model;
	  var axisPointerModel = axisInfo.axisPointerModel;
	
	  if (!axisInfo.triggerTooltip || !payloadBatch.length) {
	    return;
	  }
	
	  var coordSysModel = axisInfo.coordSys.model;
	  var coordSysKey = modelHelper.makeKey(coordSysModel);
	  var coordSysItem = dataByCoordSys.map[coordSysKey];
	
	  if (!coordSysItem) {
	    coordSysItem = dataByCoordSys.map[coordSysKey] = {
	      coordSysId: coordSysModel.id,
	      coordSysIndex: coordSysModel.componentIndex,
	      coordSysType: coordSysModel.type,
	      coordSysMainType: coordSysModel.mainType,
	      dataByAxis: []
	    };
	    dataByCoordSys.list.push(coordSysItem);
	  }
	
	  coordSysItem.dataByAxis.push({
	    axisDim: axis.dim,
	    axisIndex: axisModel.componentIndex,
	    axisType: axisModel.type,
	    axisId: axisModel.id,
	    value: value,
	    valueLabelOpt: {
	      precision: axisPointerModel.get(['label', 'precision']),
	      formatter: axisPointerModel.get(['label', 'formatter'])
	    },
	    seriesDataIndices: payloadBatch.slice()
	  });
	}
	
	function updateModelActually(showValueMap, axesInfo, outputPayload) {
	  var outputAxesInfo = outputPayload.axesInfo = [];
	  util_1.each(axesInfo, function (axisInfo, key) {
	    var option = axisInfo.axisPointerModel.option;
	    var valItem = showValueMap[key];
	
	    if (valItem) {
	      !axisInfo.useHandle && (option.status = 'show');
	      option.value = valItem.value;
	      option.seriesDataIndices = (valItem.payloadBatch || []).slice();
	    } else {
	      !axisInfo.useHandle && (option.status = 'hide');
	    }
	
	    option.status === 'show' && outputAxesInfo.push({
	      axisDim: axisInfo.axis.dim,
	      axisIndex: axisInfo.axis.model.componentIndex,
	      value: option.value
	    });
	  });
	}
	
	function dispatchTooltipActually(dataByCoordSys, point, payload, dispatchAction) {
	  if (illegalPoint(point) || !dataByCoordSys.list.length) {
	    dispatchAction({
	      type: 'hideTip'
	    });
	    return;
	  }
	
	  var sampleItem = ((dataByCoordSys.list[0].dataByAxis[0] || {}).seriesDataIndices || [])[0] || {};
	  dispatchAction({
	    type: 'showTip',
	    escapeConnect: true,
	    x: point[0],
	    y: point[1],
	    tooltipOption: payload.tooltipOption,
	    position: payload.position,
	    dataIndexInside: sampleItem.dataIndexInside,
	    dataIndex: sampleItem.dataIndex,
	    seriesIndex: sampleItem.seriesIndex,
	    dataByCoordSys: dataByCoordSys.list
	  });
	}
	
	function dispatchHighDownActually(axesInfo, dispatchAction, api) {
	  var zr = api.getZr();
	  var highDownKey = 'axisPointerLastHighlights';
	  var lastHighlights = inner(zr)[highDownKey] || {};
	  var newHighlights = inner(zr)[highDownKey] = {};
	  util_1.each(axesInfo, function (axisInfo, key) {
	    var option = axisInfo.axisPointerModel.option;
	    option.status === 'show' && util_1.each(option.seriesDataIndices, function (batchItem) {
	      var key = batchItem.seriesIndex + ' | ' + batchItem.dataIndex;
	      newHighlights[key] = batchItem;
	    });
	  });
	  var toHighlight = [];
	  var toDownplay = [];
	  util_1.each(lastHighlights, function (batchItem, key) {
	    !newHighlights[key] && toDownplay.push(batchItem);
	  });
	  util_1.each(newHighlights, function (batchItem, key) {
	    !lastHighlights[key] && toHighlight.push(batchItem);
	  });
	  toDownplay.length && api.dispatchAction({
	    type: 'downplay',
	    escapeConnect: true,
	    notBlur: true,
	    batch: toDownplay
	  });
	  toHighlight.length && api.dispatchAction({
	    type: 'highlight',
	    escapeConnect: true,
	    notBlur: true,
	    batch: toHighlight
	  });
	}
	
	function findInputAxisInfo(inputAxesInfo, axisInfo) {
	  for (var i = 0; i < (inputAxesInfo || []).length; i++) {
	    var inputAxisInfo = inputAxesInfo[i];
	
	    if (axisInfo.axis.dim === inputAxisInfo.axisDim && axisInfo.axis.model.componentIndex === inputAxisInfo.axisIndex) {
	      return inputAxisInfo;
	    }
	  }
	}
	
	function makeMapperParam(axisInfo) {
	  var axisModel = axisInfo.axis.model;
	  var item = {};
	  var dim = item.axisDim = axisInfo.axis.dim;
	  item.axisIndex = item[dim + 'AxisIndex'] = axisModel.componentIndex;
	  item.axisName = item[dim + 'AxisName'] = axisModel.name;
	  item.axisId = item[dim + 'AxisId'] = axisModel.id;
	  return item;
	}
	
	function illegalPoint(point) {
	  return !point || point[0] == null || isNaN(point[0]) || point[1] == null || isNaN(point[1]);
	}

/***/ },
/* 308 */
/***/ function(module, exports, __webpack_require__) {

	
	/*
	* Licensed to the Apache Software Foundation (ASF) under one
	* or more contributor license agreements.  See the NOTICE file
	* distributed with this work for additional information
	* regarding copyright ownership.  The ASF licenses this file
	* to you under the Apache License, Version 2.0 (the
	* "License"); you may not use this file except in compliance
	* with the License.  You may obtain a copy of the License at
	*
	*   http://www.apache.org/licenses/LICENSE-2.0
	*
	* Unless required by applicable law or agreed to in writing,
	* software distributed under the License is distributed on an
	* "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
	* KIND, either express or implied.  See the License for the
	* specific language governing permissions and limitations
	* under the License.
	*/
	
	
	
	/**
	 * AUTO-GENERATED FILE. DO NOT MODIFY.
	 */
	
	"use strict";
	
	exports.__esModule = true;
	
	var zrUtil = __webpack_require__(1);
	
	var numberUtil = __webpack_require__(9);
	
	var sliderMove_1 = __webpack_require__(85);
	
	var axisHelper_1 = __webpack_require__(39);
	
	var scaleRawExtentInfo_1 = __webpack_require__(88);
	
	var helper_1 = __webpack_require__(45);
	
	var model_1 = __webpack_require__(4);
	
	var each = zrUtil.each;
	var asc = numberUtil.asc;
	
	var AxisProxy = function () {
	  function AxisProxy(dimName, axisIndex, dataZoomModel, ecModel) {
	    this._dimName = dimName;
	    this._axisIndex = axisIndex;
	    this.ecModel = ecModel;
	    this._dataZoomModel = dataZoomModel;
	  }
	
	  AxisProxy.prototype.hostedBy = function (dataZoomModel) {
	    return this._dataZoomModel === dataZoomModel;
	  };
	
	  AxisProxy.prototype.getDataValueWindow = function () {
	    return this._valueWindow.slice();
	  };
	
	  AxisProxy.prototype.getDataPercentWindow = function () {
	    return this._percentWindow.slice();
	  };
	
	  AxisProxy.prototype.getTargetSeriesModels = function () {
	    var seriesModels = [];
	    this.ecModel.eachSeries(function (seriesModel) {
	      if (helper_1.isCoordSupported(seriesModel)) {
	        var axisMainType = helper_1.getAxisMainType(this._dimName);
	        var axisModel = seriesModel.getReferringComponents(axisMainType, model_1.SINGLE_REFERRING).models[0];
	
	        if (axisModel && this._axisIndex === axisModel.componentIndex) {
	          seriesModels.push(seriesModel);
	        }
	      }
	    }, this);
	    return seriesModels;
	  };
	
	  AxisProxy.prototype.getAxisModel = function () {
	    return this.ecModel.getComponent(this._dimName + 'Axis', this._axisIndex);
	  };
	
	  AxisProxy.prototype.getMinMaxSpan = function () {
	    return zrUtil.clone(this._minMaxSpan);
	  };
	
	  AxisProxy.prototype.calculateDataWindow = function (opt) {
	    var dataExtent = this._dataExtent;
	    var axisModel = this.getAxisModel();
	    var scale = axisModel.axis.scale;
	
	    var rangePropMode = this._dataZoomModel.getRangePropMode();
	
	    var percentExtent = [0, 100];
	    var percentWindow = [];
	    var valueWindow = [];
	    var hasPropModeValue;
	    each(['start', 'end'], function (prop, idx) {
	      var boundPercent = opt[prop];
	      var boundValue = opt[prop + 'Value'];
	
	      if (rangePropMode[idx] === 'percent') {
	        boundPercent == null && (boundPercent = percentExtent[idx]);
	        boundValue = scale.parse(numberUtil.linearMap(boundPercent, percentExtent, dataExtent));
	      } else {
	        hasPropModeValue = true;
	        boundValue = boundValue == null ? dataExtent[idx] : scale.parse(boundValue);
	        boundPercent = numberUtil.linearMap(boundValue, dataExtent, percentExtent);
	      }
	
	      valueWindow[idx] = boundValue;
	      percentWindow[idx] = boundPercent;
	    });
	    asc(valueWindow);
	    asc(percentWindow);
	    var spans = this._minMaxSpan;
	    hasPropModeValue ? restrictSet(valueWindow, percentWindow, dataExtent, percentExtent, false) : restrictSet(percentWindow, valueWindow, percentExtent, dataExtent, true);
	
	    function restrictSet(fromWindow, toWindow, fromExtent, toExtent, toValue) {
	      var suffix = toValue ? 'Span' : 'ValueSpan';
	      sliderMove_1["default"](0, fromWindow, fromExtent, 'all', spans['min' + suffix], spans['max' + suffix]);
	
	      for (var i = 0; i < 2; i++) {
	        toWindow[i] = numberUtil.linearMap(fromWindow[i], fromExtent, toExtent, true);
	        toValue && (toWindow[i] = scale.parse(toWindow[i]));
	      }
	    }
	
	    return {
	      valueWindow: valueWindow,
	      percentWindow: percentWindow
	    };
	  };
	
	  AxisProxy.prototype.reset = function (dataZoomModel) {
	    if (dataZoomModel !== this._dataZoomModel) {
	      return;
	    }
	
	    var targetSeries = this.getTargetSeriesModels();
	    this._dataExtent = calculateDataExtent(this, this._dimName, targetSeries);
	
	    this._updateMinMaxSpan();
	
	    var dataWindow = this.calculateDataWindow(dataZoomModel.settledOption);
	    this._valueWindow = dataWindow.valueWindow;
	    this._percentWindow = dataWindow.percentWindow;
	
	    this._setAxisModel();
	  };
	
	  AxisProxy.prototype.filterData = function (dataZoomModel, api) {
	    if (dataZoomModel !== this._dataZoomModel) {
	      return;
	    }
	
	    var axisDim = this._dimName;
	    var seriesModels = this.getTargetSeriesModels();
	    var filterMode = dataZoomModel.get('filterMode');
	    var valueWindow = this._valueWindow;
	
	    if (filterMode === 'none') {
	      return;
	    }
	
	    each(seriesModels, function (seriesModel) {
	      var seriesData = seriesModel.getData();
	      var dataDims = seriesData.mapDimensionsAll(axisDim);
	
	      if (!dataDims.length) {
	        return;
	      }
	
	      if (filterMode === 'weakFilter') {
	        seriesData.filterSelf(function (dataIndex) {
	          var leftOut;
	          var rightOut;
	          var hasValue;
	
	          for (var i = 0; i < dataDims.length; i++) {
	            var value = seriesData.get(dataDims[i], dataIndex);
	            var thisHasValue = !isNaN(value);
	            var thisLeftOut = value < valueWindow[0];
	            var thisRightOut = value > valueWindow[1];
	
	            if (thisHasValue && !thisLeftOut && !thisRightOut) {
	              return true;
	            }
	
	            thisHasValue && (hasValue = true);
	            thisLeftOut && (leftOut = true);
	            thisRightOut && (rightOut = true);
	          }
	
	          return hasValue && leftOut && rightOut;
	        });
	      } else {
	        each(dataDims, function (dim) {
	          if (filterMode === 'empty') {
	            seriesModel.setData(seriesData = seriesData.map(dim, function (value) {
	              return !isInWindow(value) ? NaN : value;
	            }));
	          } else {
	            var range = {};
	            range[dim] = valueWindow;
	            seriesData.selectRange(range);
	          }
	        });
	      }
	
	      each(dataDims, function (dim) {
	        seriesData.setApproximateExtent(valueWindow, dim);
	      });
	    });
	
	    function isInWindow(value) {
	      return value >= valueWindow[0] && value <= valueWindow[1];
	    }
	  };
	
	  AxisProxy.prototype._updateMinMaxSpan = function () {
	    var minMaxSpan = this._minMaxSpan = {};
	    var dataZoomModel = this._dataZoomModel;
	    var dataExtent = this._dataExtent;
	    each(['min', 'max'], function (minMax) {
	      var percentSpan = dataZoomModel.get(minMax + 'Span');
	      var valueSpan = dataZoomModel.get(minMax + 'ValueSpan');
	      valueSpan != null && (valueSpan = this.getAxisModel().axis.scale.parse(valueSpan));
	
	      if (valueSpan != null) {
	        percentSpan = numberUtil.linearMap(dataExtent[0] + valueSpan, dataExtent, [0, 100], true);
	      } else if (percentSpan != null) {
	        valueSpan = numberUtil.linearMap(percentSpan, [0, 100], dataExtent, true) - dataExtent[0];
	      }
	
	      minMaxSpan[minMax + 'Span'] = percentSpan;
	      minMaxSpan[minMax + 'ValueSpan'] = valueSpan;
	    }, this);
	  };
	
	  AxisProxy.prototype._setAxisModel = function () {
	    var axisModel = this.getAxisModel();
	    var percentWindow = this._percentWindow;
	    var valueWindow = this._valueWindow;
	
	    if (!percentWindow) {
	      return;
	    }
	
	    var precision = numberUtil.getPixelPrecision(valueWindow, [0, 500]);
	    precision = Math.min(precision, 20);
	    var rawExtentInfo = axisModel.axis.scale.rawExtentInfo;
	
	    if (percentWindow[0] !== 0) {
	      rawExtentInfo.setDeterminedMinMax('min', +valueWindow[0].toFixed(precision));
	    }
	
	    if (percentWindow[1] !== 100) {
	      rawExtentInfo.setDeterminedMinMax('max', +valueWindow[1].toFixed(precision));
	    }
	
	    rawExtentInfo.freeze();
	  };
	
	  return AxisProxy;
	}();
	
	function calculateDataExtent(axisProxy, axisDim, seriesModels) {
	  var dataExtent = [Infinity, -Infinity];
	  each(seriesModels, function (seriesModel) {
	    axisHelper_1.unionAxisExtentFromData(dataExtent, seriesModel.getData(), axisDim);
	  });
	  var axisModel = axisProxy.getAxisModel();
	  var rawExtentResult = scaleRawExtentInfo_1.ensureScaleRawExtentInfo(axisModel.axis.scale, axisModel, dataExtent).calculate();
	  return [rawExtentResult.min, rawExtentResult.max];
	}
	
	exports["default"] = AxisProxy;

/***/ },
/* 309 */
/***/ function(module, exports, __webpack_require__) {

	
	/*
	* Licensed to the Apache Software Foundation (ASF) under one
	* or more contributor license agreements.  See the NOTICE file
	* distributed with this work for additional information
	* regarding copyright ownership.  The ASF licenses this file
	* to you under the Apache License, Version 2.0 (the
	* "License"); you may not use this file except in compliance
	* with the License.  You may obtain a copy of the License at
	*
	*   http://www.apache.org/licenses/LICENSE-2.0
	*
	* Unless required by applicable law or agreed to in writing,
	* software distributed under the License is distributed on an
	* "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
	* KIND, either express or implied.  See the License for the
	* specific language governing permissions and limitations
	* under the License.
	*/
	
	
	
	/**
	 * AUTO-GENERATED FILE. DO NOT MODIFY.
	 */
	
	"use strict";
	
	exports.__esModule = true;
	
	var tslib_1 = __webpack_require__(3);
	
	var DataZoomModel_1 = __webpack_require__(65);
	
	var Component_1 = __webpack_require__(10);
	
	var component_1 = __webpack_require__(41);
	
	var InsideZoomModel = function (_super) {
	  tslib_1.__extends(InsideZoomModel, _super);
	
	  function InsideZoomModel() {
	    var _this = _super !== null && _super.apply(this, arguments) || this;
	
	    _this.type = InsideZoomModel.type;
	    return _this;
	  }
	
	  InsideZoomModel.type = 'dataZoom.inside';
	  InsideZoomModel.defaultOption = component_1.inheritDefaultOption(DataZoomModel_1["default"].defaultOption, {
	    disabled: false,
	    zoomLock: false,
	    zoomOnMouseWheel: true,
	    moveOnMouseMove: true,
	    moveOnMouseWheel: false,
	    preventDefaultMouseMove: true
	  });
	  return InsideZoomModel;
	}(DataZoomModel_1["default"]);
	
	Component_1["default"].registerClass(InsideZoomModel);
	exports["default"] = InsideZoomModel;

/***/ },
/* 310 */
/***/ function(module, exports, __webpack_require__) {

	
	/*
	* Licensed to the Apache Software Foundation (ASF) under one
	* or more contributor license agreements.  See the NOTICE file
	* distributed with this work for additional information
	* regarding copyright ownership.  The ASF licenses this file
	* to you under the Apache License, Version 2.0 (the
	* "License"); you may not use this file except in compliance
	* with the License.  You may obtain a copy of the License at
	*
	*   http://www.apache.org/licenses/LICENSE-2.0
	*
	* Unless required by applicable law or agreed to in writing,
	* software distributed under the License is distributed on an
	* "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
	* KIND, either express or implied.  See the License for the
	* specific language governing permissions and limitations
	* under the License.
	*/
	
	
	
	/**
	 * AUTO-GENERATED FILE. DO NOT MODIFY.
	 */
	
	"use strict";
	
	exports.__esModule = true;
	
	var tslib_1 = __webpack_require__(3);
	
	var DataZoomView_1 = __webpack_require__(66);
	
	var sliderMove_1 = __webpack_require__(85);
	
	var roams = __webpack_require__(313);
	
	var Component_1 = __webpack_require__(18);
	
	var util_1 = __webpack_require__(1);
	
	var InsideZoomView = function (_super) {
	  tslib_1.__extends(InsideZoomView, _super);
	
	  function InsideZoomView() {
	    var _this = _super !== null && _super.apply(this, arguments) || this;
	
	    _this.type = 'dataZoom.inside';
	    return _this;
	  }
	
	  InsideZoomView.prototype.render = function (dataZoomModel, ecModel, api) {
	    _super.prototype.render.apply(this, arguments);
	
	    if (dataZoomModel.noTarget()) {
	      this._clear();
	
	      return;
	    }
	
	    this.range = dataZoomModel.getPercentRange();
	    roams.setViewInfoToCoordSysRecord(api, dataZoomModel, {
	      pan: util_1.bind(getRangeHandlers.pan, this),
	      zoom: util_1.bind(getRangeHandlers.zoom, this),
	      scrollMove: util_1.bind(getRangeHandlers.scrollMove, this)
	    });
	  };
	
	  InsideZoomView.prototype.dispose = function () {
	    this._clear();
	
	    _super.prototype.dispose.apply(this, arguments);
	  };
	
	  InsideZoomView.prototype._clear = function () {
	    roams.disposeCoordSysRecordIfNeeded(this.api, this.dataZoomModel);
	    this.range = null;
	  };
	
	  InsideZoomView.type = 'dataZoom.inside';
	  return InsideZoomView;
	}(DataZoomView_1["default"]);
	
	var getRangeHandlers = {
	  zoom: function (coordSysInfo, coordSysMainType, controller, e) {
	    var lastRange = this.range;
	    var range = lastRange.slice();
	    var axisModel = coordSysInfo.axisModels[0];
	
	    if (!axisModel) {
	      return;
	    }
	
	    var directionInfo = getDirectionInfo[coordSysMainType](null, [e.originX, e.originY], axisModel, controller, coordSysInfo);
	    var percentPoint = (directionInfo.signal > 0 ? directionInfo.pixelStart + directionInfo.pixelLength - directionInfo.pixel : directionInfo.pixel - directionInfo.pixelStart) / directionInfo.pixelLength * (range[1] - range[0]) + range[0];
	    var scale = Math.max(1 / e.scale, 0);
	    range[0] = (range[0] - percentPoint) * scale + percentPoint;
	    range[1] = (range[1] - percentPoint) * scale + percentPoint;
	    var minMaxSpan = this.dataZoomModel.findRepresentativeAxisProxy().getMinMaxSpan();
	    sliderMove_1["default"](0, range, [0, 100], 0, minMaxSpan.minSpan, minMaxSpan.maxSpan);
	    this.range = range;
	
	    if (lastRange[0] !== range[0] || lastRange[1] !== range[1]) {
	      return range;
	    }
	  },
	  pan: makeMover(function (range, axisModel, coordSysInfo, coordSysMainType, controller, e) {
	    var directionInfo = getDirectionInfo[coordSysMainType]([e.oldX, e.oldY], [e.newX, e.newY], axisModel, controller, coordSysInfo);
	    return directionInfo.signal * (range[1] - range[0]) * directionInfo.pixel / directionInfo.pixelLength;
	  }),
	  scrollMove: makeMover(function (range, axisModel, coordSysInfo, coordSysMainType, controller, e) {
	    var directionInfo = getDirectionInfo[coordSysMainType]([0, 0], [e.scrollDelta, e.scrollDelta], axisModel, controller, coordSysInfo);
	    return directionInfo.signal * (range[1] - range[0]) * e.scrollDelta;
	  })
	};
	
	function makeMover(getPercentDelta) {
	  return function (coordSysInfo, coordSysMainType, controller, e) {
	    var lastRange = this.range;
	    var range = lastRange.slice();
	    var axisModel = coordSysInfo.axisModels[0];
	
	    if (!axisModel) {
	      return;
	    }
	
	    var percentDelta = getPercentDelta(range, axisModel, coordSysInfo, coordSysMainType, controller, e);
	    sliderMove_1["default"](percentDelta, range, [0, 100], 'all');
	    this.range = range;
	
	    if (lastRange[0] !== range[0] || lastRange[1] !== range[1]) {
	      return range;
	    }
	  };
	}
	
	var getDirectionInfo = {
	  grid: function (oldPoint, newPoint, axisModel, controller, coordSysInfo) {
	    var axis = axisModel.axis;
	    var ret = {};
	    var rect = coordSysInfo.model.coordinateSystem.getRect();
	    oldPoint = oldPoint || [0, 0];
	
	    if (axis.dim === 'x') {
	      ret.pixel = newPoint[0] - oldPoint[0];
	      ret.pixelLength = rect.width;
	      ret.pixelStart = rect.x;
	      ret.signal = axis.inverse ? 1 : -1;
	    } else {
	      ret.pixel = newPoint[1] - oldPoint[1];
	      ret.pixelLength = rect.height;
	      ret.pixelStart = rect.y;
	      ret.signal = axis.inverse ? -1 : 1;
	    }
	
	    return ret;
	  },
	  polar: function (oldPoint, newPoint, axisModel, controller, coordSysInfo) {
	    var axis = axisModel.axis;
	    var ret = {};
	    var polar = coordSysInfo.model.coordinateSystem;
	    var radiusExtent = polar.getRadiusAxis().getExtent();
	    var angleExtent = polar.getAngleAxis().getExtent();
	    oldPoint = oldPoint ? polar.pointToCoord(oldPoint) : [0, 0];
	    newPoint = polar.pointToCoord(newPoint);
	
	    if (axisModel.mainType === 'radiusAxis') {
	      ret.pixel = newPoint[0] - oldPoint[0];
	      ret.pixelLength = radiusExtent[1] - radiusExtent[0];
	      ret.pixelStart = radiusExtent[0];
	      ret.signal = axis.inverse ? 1 : -1;
	    } else {
	      ret.pixel = newPoint[1] - oldPoint[1];
	      ret.pixelLength = angleExtent[1] - angleExtent[0];
	      ret.pixelStart = angleExtent[0];
	      ret.signal = axis.inverse ? -1 : 1;
	    }
	
	    return ret;
	  },
	  singleAxis: function (oldPoint, newPoint, axisModel, controller, coordSysInfo) {
	    var axis = axisModel.axis;
	    var rect = coordSysInfo.model.coordinateSystem.getRect();
	    var ret = {};
	    oldPoint = oldPoint || [0, 0];
	
	    if (axis.orient === 'horizontal') {
	      ret.pixel = newPoint[0] - oldPoint[0];
	      ret.pixelLength = rect.width;
	      ret.pixelStart = rect.x;
	      ret.signal = axis.inverse ? 1 : -1;
	    } else {
	      ret.pixel = newPoint[1] - oldPoint[1];
	      ret.pixelLength = rect.height;
	      ret.pixelStart = rect.y;
	      ret.signal = axis.inverse ? -1 : 1;
	    }
	
	    return ret;
	  }
	};
	Component_1["default"].registerClass(InsideZoomView);
	exports["default"] = InsideZoomView;

/***/ },
/* 311 */
/***/ function(module, exports, __webpack_require__) {

	
	/*
	* Licensed to the Apache Software Foundation (ASF) under one
	* or more contributor license agreements.  See the NOTICE file
	* distributed with this work for additional information
	* regarding copyright ownership.  The ASF licenses this file
	* to you under the Apache License, Version 2.0 (the
	* "License"); you may not use this file except in compliance
	* with the License.  You may obtain a copy of the License at
	*
	*   http://www.apache.org/licenses/LICENSE-2.0
	*
	* Unless required by applicable law or agreed to in writing,
	* software distributed under the License is distributed on an
	* "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
	* KIND, either express or implied.  See the License for the
	* specific language governing permissions and limitations
	* under the License.
	*/
	
	
	
	/**
	 * AUTO-GENERATED FILE. DO NOT MODIFY.
	 */
	
	"use strict";
	
	exports.__esModule = true;
	
	var tslib_1 = __webpack_require__(3);
	
	var DataZoomModel_1 = __webpack_require__(65);
	
	var Component_1 = __webpack_require__(10);
	
	var component_1 = __webpack_require__(41);
	
	var SliderZoomModel = function (_super) {
	  tslib_1.__extends(SliderZoomModel, _super);
	
	  function SliderZoomModel() {
	    var _this = _super !== null && _super.apply(this, arguments) || this;
	
	    _this.type = SliderZoomModel.type;
	    return _this;
	  }
	
	  SliderZoomModel.type = 'dataZoom.slider';
	  SliderZoomModel.layoutMode = 'box';
	  SliderZoomModel.defaultOption = component_1.inheritDefaultOption(DataZoomModel_1["default"].defaultOption, {
	    show: true,
	    right: 'ph',
	    top: 'ph',
	    width: 'ph',
	    height: 'ph',
	    left: null,
	    bottom: null,
	    borderColor: '#d2dbee',
	    borderRadius: 3,
	    backgroundColor: 'rgba(47,69,84,0)',
	    dataBackground: {
	      lineStyle: {
	        color: '#d2dbee',
	        width: 0.5
	      },
	      areaStyle: {
	        color: '#d2dbee',
	        opacity: 0.2
	      }
	    },
	    selectedDataBackground: {
	      lineStyle: {
	        color: '#8fb0f7',
	        width: 0.5
	      },
	      areaStyle: {
	        color: '#8fb0f7',
	        opacity: 0.2
	      }
	    },
	    fillerColor: 'rgba(135,175,274,0.2)',
	    handleIcon: 'path://M-9.35,34.56V42m0-40V9.5m-2,0h4a2,2,0,0,1,2,2v21a2,2,0,0,1-2,2h-4a2,2,0,0,1-2-2v-21A2,2,0,0,1-11.35,9.5Z',
	    handleSize: '100%',
	    handleStyle: {
	      color: '#fff',
	      borderColor: '#ACB8D1'
	    },
	    moveHandleSize: 7,
	    moveHandleIcon: 'path://M-320.9-50L-320.9-50c18.1,0,27.1,9,27.1,27.1V85.7c0,18.1-9,27.1-27.1,27.1l0,0c-18.1,0-27.1-9-27.1-27.1V-22.9C-348-41-339-50-320.9-50z M-212.3-50L-212.3-50c18.1,0,27.1,9,27.1,27.1V85.7c0,18.1-9,27.1-27.1,27.1l0,0c-18.1,0-27.1-9-27.1-27.1V-22.9C-239.4-41-230.4-50-212.3-50z M-103.7-50L-103.7-50c18.1,0,27.1,9,27.1,27.1V85.7c0,18.1-9,27.1-27.1,27.1l0,0c-18.1,0-27.1-9-27.1-27.1V-22.9C-130.9-41-121.8-50-103.7-50z',
	    moveHandleStyle: {
	      color: '#D2DBEE',
	      opacity: 0.7
	    },
	    showDetail: true,
	    showDataShadow: 'auto',
	    realtime: true,
	    zoomLock: false,
	    textStyle: {
	      color: '#6E7079'
	    },
	    brushSelect: true,
	    brushStyle: {
	      color: 'rgba(135,175,274,0.15)'
	    },
	    emphasis: {
	      handleStyle: {
	        borderColor: '#8FB0F7'
	      },
	      moveHandleStyle: {
	        color: '#8FB0F7'
	      }
	    }
	  });
	  return SliderZoomModel;
	}(DataZoomModel_1["default"]);
	
	Component_1["default"].registerClass(SliderZoomModel);
	exports["default"] = SliderZoomModel;

/***/ },
/* 312 */
/***/ function(module, exports, __webpack_require__) {

	
	/*
	* Licensed to the Apache Software Foundation (ASF) under one
	* or more contributor license agreements.  See the NOTICE file
	* distributed with this work for additional information
	* regarding copyright ownership.  The ASF licenses this file
	* to you under the Apache License, Version 2.0 (the
	* "License"); you may not use this file except in compliance
	* with the License.  You may obtain a copy of the License at
	*
	*   http://www.apache.org/licenses/LICENSE-2.0
	*
	* Unless required by applicable law or agreed to in writing,
	* software distributed under the License is distributed on an
	* "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
	* KIND, either express or implied.  See the License for the
	* specific language governing permissions and limitations
	* under the License.
	*/
	
	
	
	/**
	 * AUTO-GENERATED FILE. DO NOT MODIFY.
	 */
	
	"use strict";
	
	exports.__esModule = true;
	
	var tslib_1 = __webpack_require__(3);
	
	var util_1 = __webpack_require__(1);
	
	var eventTool = __webpack_require__(42);
	
	var graphic = __webpack_require__(7);
	
	var throttle = __webpack_require__(56);
	
	var DataZoomView_1 = __webpack_require__(66);
	
	var number_1 = __webpack_require__(9);
	
	var layout = __webpack_require__(30);
	
	var sliderMove_1 = __webpack_require__(85);
	
	var Component_1 = __webpack_require__(18);
	
	var helper_1 = __webpack_require__(45);
	
	var states_1 = __webpack_require__(22);
	
	var symbol_1 = __webpack_require__(48);
	
	var log_1 = __webpack_require__(12);
	
	var Rect = graphic.Rect;
	var DEFAULT_LOCATION_EDGE_GAP = 7;
	var DEFAULT_FRAME_BORDER_WIDTH = 1;
	var DEFAULT_FILLER_SIZE = 30;
	var DEFAULT_MOVE_HANDLE_SIZE = 7;
	var HORIZONTAL = 'horizontal';
	var VERTICAL = 'vertical';
	var LABEL_GAP = 5;
	var SHOW_DATA_SHADOW_SERIES_TYPE = ['line', 'bar', 'candlestick', 'scatter'];
	var REALTIME_ANIMATION_CONFIG = {
	  easing: 'cubicOut',
	  duration: 100
	};
	
	var SliderZoomView = function (_super) {
	  tslib_1.__extends(SliderZoomView, _super);
	
	  function SliderZoomView() {
	    var _this = _super !== null && _super.apply(this, arguments) || this;
	
	    _this.type = SliderZoomView.type;
	    _this._displayables = {};
	    return _this;
	  }
	
	  SliderZoomView.prototype.init = function (ecModel, api) {
	    this.api = api;
	    this._onBrush = util_1.bind(this._onBrush, this);
	    this._onBrushEnd = util_1.bind(this._onBrushEnd, this);
	  };
	
	  SliderZoomView.prototype.render = function (dataZoomModel, ecModel, api, payload) {
	    _super.prototype.render.apply(this, arguments);
	
	    throttle.createOrUpdate(this, '_dispatchZoomAction', dataZoomModel.get('throttle'), 'fixRate');
	    this._orient = dataZoomModel.getOrient();
	
	    if (dataZoomModel.get('show') === false) {
	      this.group.removeAll();
	      return;
	    }
	
	    if (dataZoomModel.noTarget()) {
	      this._clear();
	
	      this.group.removeAll();
	      return;
	    }
	
	    if (!payload || payload.type !== 'dataZoom' || payload.from !== this.uid) {
	      this._buildView();
	    }
	
	    this._updateView();
	  };
	
	  SliderZoomView.prototype.dispose = function () {
	    this._clear();
	
	    _super.prototype.dispose.apply(this, arguments);
	  };
	
	  SliderZoomView.prototype._clear = function () {
	    throttle.clear(this, '_dispatchZoomAction');
	    var zr = this.api.getZr();
	    zr.off('mousemove', this._onBrush);
	    zr.off('mouseup', this._onBrushEnd);
	  };
	
	  SliderZoomView.prototype._buildView = function () {
	    var thisGroup = this.group;
	    thisGroup.removeAll();
	    this._brushing = false;
	    this._displayables.brushRect = null;
	
	    this._resetLocation();
	
	    this._resetInterval();
	
	    var barGroup = this._displayables.sliderGroup = new graphic.Group();
	
	    this._renderBackground();
	
	    this._renderHandle();
	
	    this._renderDataShadow();
	
	    thisGroup.add(barGroup);
	
	    this._positionGroup();
	  };
	
	  SliderZoomView.prototype._resetLocation = function () {
	    var dataZoomModel = this.dataZoomModel;
	    var api = this.api;
	    var showMoveHandle = dataZoomModel.get('brushSelect');
	    var moveHandleSize = showMoveHandle ? DEFAULT_MOVE_HANDLE_SIZE : 0;
	
	    var coordRect = this._findCoordRect();
	
	    var ecSize = {
	      width: api.getWidth(),
	      height: api.getHeight()
	    };
	    var positionInfo = this._orient === HORIZONTAL ? {
	      right: ecSize.width - coordRect.x - coordRect.width,
	      top: ecSize.height - DEFAULT_FILLER_SIZE - DEFAULT_LOCATION_EDGE_GAP - moveHandleSize,
	      width: coordRect.width,
	      height: DEFAULT_FILLER_SIZE
	    } : {
	      right: DEFAULT_LOCATION_EDGE_GAP,
	      top: coordRect.y,
	      width: DEFAULT_FILLER_SIZE,
	      height: coordRect.height
	    };
	    var layoutParams = layout.getLayoutParams(dataZoomModel.option);
	    util_1.each(['right', 'top', 'width', 'height'], function (name) {
	      if (layoutParams[name] === 'ph') {
	        layoutParams[name] = positionInfo[name];
	      }
	    });
	    var layoutRect = layout.getLayoutRect(layoutParams, ecSize);
	    this._location = {
	      x: layoutRect.x,
	      y: layoutRect.y
	    };
	    this._size = [layoutRect.width, layoutRect.height];
	    this._orient === VERTICAL && this._size.reverse();
	  };
	
	  SliderZoomView.prototype._positionGroup = function () {
	    var thisGroup = this.group;
	    var location = this._location;
	    var orient = this._orient;
	    var targetAxisModel = this.dataZoomModel.getFirstTargetAxisModel();
	    var inverse = targetAxisModel && targetAxisModel.get('inverse');
	    var sliderGroup = this._displayables.sliderGroup;
	    var otherAxisInverse = (this._dataShadowInfo || {}).otherAxisInverse;
	    sliderGroup.attr(orient === HORIZONTAL && !inverse ? {
	      scaleY: otherAxisInverse ? 1 : -1,
	      scaleX: 1
	    } : orient === HORIZONTAL && inverse ? {
	      scaleY: otherAxisInverse ? 1 : -1,
	      scaleX: -1
	    } : orient === VERTICAL && !inverse ? {
	      scaleY: otherAxisInverse ? -1 : 1,
	      scaleX: 1,
	      rotation: Math.PI / 2
	    } : {
	      scaleY: otherAxisInverse ? -1 : 1,
	      scaleX: -1,
	      rotation: Math.PI / 2
	    });
	    var rect = thisGroup.getBoundingRect([sliderGroup]);
	    thisGroup.x = location.x - rect.x;
	    thisGroup.y = location.y - rect.y;
	    thisGroup.markRedraw();
	  };
	
	  SliderZoomView.prototype._getViewExtent = function () {
	    return [0, this._size[0]];
	  };
	
	  SliderZoomView.prototype._renderBackground = function () {
	    var dataZoomModel = this.dataZoomModel;
	    var size = this._size;
	    var barGroup = this._displayables.sliderGroup;
	    var brushSelect = dataZoomModel.get('brushSelect');
	    barGroup.add(new Rect({
	      silent: true,
	      shape: {
	        x: 0,
	        y: 0,
	        width: size[0],
	        height: size[1]
	      },
	      style: {
	        fill: dataZoomModel.get('backgroundColor')
	      },
	      z2: -40
	    }));
	    var clickPanel = new Rect({
	      shape: {
	        x: 0,
	        y: 0,
	        width: size[0],
	        height: size[1]
	      },
	      style: {
	        fill: 'transparent'
	      },
	      z2: 0,
	      onclick: util_1.bind(this._onClickPanel, this)
	    });
	    var zr = this.api.getZr();
	
	    if (brushSelect) {
	      clickPanel.on('mousedown', this._onBrushStart, this);
	      clickPanel.cursor = 'crosshair';
	      zr.on('mousemove', this._onBrush);
	      zr.on('mouseup', this._onBrushEnd);
	    } else {
	      zr.off('mousemove', this._onBrush);
	      zr.off('mouseup', this._onBrushEnd);
	    }
	
	    barGroup.add(clickPanel);
	  };
	
	  SliderZoomView.prototype._renderDataShadow = function () {
	    var info = this._dataShadowInfo = this._prepareDataShadowInfo();
	
	    this._displayables.dataShadowSegs = [];
	
	    if (!info) {
	      return;
	    }
	
	    var size = this._size;
	    var seriesModel = info.series;
	    var data = seriesModel.getRawData();
	    var otherDim = seriesModel.getShadowDim ? seriesModel.getShadowDim() : info.otherDim;
	
	    if (otherDim == null) {
	      return;
	    }
	
	    var otherDataExtent = data.getDataExtent(otherDim);
	    var otherOffset = (otherDataExtent[1] - otherDataExtent[0]) * 0.3;
	    otherDataExtent = [otherDataExtent[0] - otherOffset, otherDataExtent[1] + otherOffset];
	    var otherShadowExtent = [0, size[1]];
	    var thisShadowExtent = [0, size[0]];
	    var areaPoints = [[size[0], 0], [0, 0]];
	    var linePoints = [];
	    var step = thisShadowExtent[1] / (data.count() - 1);
	    var thisCoord = 0;
	    var stride = Math.round(data.count() / size[0]);
	    var lastIsEmpty;
	    data.each([otherDim], function (value, index) {
	      if (stride > 0 && index % stride) {
	        thisCoord += step;
	        return;
	      }
	
	      var isEmpty = value == null || isNaN(value) || value === '';
	      var otherCoord = isEmpty ? 0 : number_1.linearMap(value, otherDataExtent, otherShadowExtent, true);
	
	      if (isEmpty && !lastIsEmpty && index) {
	        areaPoints.push([areaPoints[areaPoints.length - 1][0], 0]);
	        linePoints.push([linePoints[linePoints.length - 1][0], 0]);
	      } else if (!isEmpty && lastIsEmpty) {
	        areaPoints.push([thisCoord, 0]);
	        linePoints.push([thisCoord, 0]);
	      }
	
	      areaPoints.push([thisCoord, otherCoord]);
	      linePoints.push([thisCoord, otherCoord]);
	      thisCoord += step;
	      lastIsEmpty = isEmpty;
	    });
	    var dataZoomModel = this.dataZoomModel;
	
	    function createDataShadowGroup(isSelectedArea) {
	      var model = dataZoomModel.getModel(isSelectedArea ? 'selectedDataBackground' : 'dataBackground');
	      var group = new graphic.Group();
	      var polygon = new graphic.Polygon({
	        shape: {
	          points: areaPoints
	        },
	        segmentIgnoreThreshold: 1,
	        style: model.getModel('areaStyle').getAreaStyle(),
	        silent: true,
	        z2: -20
	      });
	      var polyline = new graphic.Polyline({
	        shape: {
	          points: linePoints
	        },
	        segmentIgnoreThreshold: 1,
	        style: model.getModel('lineStyle').getLineStyle(),
	        silent: true,
	        z2: -19
	      });
	      group.add(polygon);
	      group.add(polyline);
	      return group;
	    }
	
	    for (var i = 0; i < 3; i++) {
	      var group = createDataShadowGroup(i === 1);
	
	      this._displayables.sliderGroup.add(group);
	
	      this._displayables.dataShadowSegs.push(group);
	    }
	  };
	
	  SliderZoomView.prototype._prepareDataShadowInfo = function () {
	    var dataZoomModel = this.dataZoomModel;
	    var showDataShadow = dataZoomModel.get('showDataShadow');
	
	    if (showDataShadow === false) {
	      return;
	    }
	
	    var result;
	    var ecModel = this.ecModel;
	    dataZoomModel.eachTargetAxis(function (axisDim, axisIndex) {
	      var seriesModels = dataZoomModel.getAxisProxy(axisDim, axisIndex).getTargetSeriesModels();
	      util_1.each(seriesModels, function (seriesModel) {
	        if (result) {
	          return;
	        }
	
	        if (showDataShadow !== true && util_1.indexOf(SHOW_DATA_SHADOW_SERIES_TYPE, seriesModel.get('type')) < 0) {
	          return;
	        }
	
	        var thisAxis = ecModel.getComponent(helper_1.getAxisMainType(axisDim), axisIndex).axis;
	        var otherDim = getOtherDim(axisDim);
	        var otherAxisInverse;
	        var coordSys = seriesModel.coordinateSystem;
	
	        if (otherDim != null && coordSys.getOtherAxis) {
	          otherAxisInverse = coordSys.getOtherAxis(thisAxis).inverse;
	        }
	
	        otherDim = seriesModel.getData().mapDimension(otherDim);
	        result = {
	          thisAxis: thisAxis,
	          series: seriesModel,
	          thisDim: axisDim,
	          otherDim: otherDim,
	          otherAxisInverse: otherAxisInverse
	        };
	      }, this);
	    }, this);
	    return result;
	  };
	
	  SliderZoomView.prototype._renderHandle = function () {
	    var thisGroup = this.group;
	    var displayables = this._displayables;
	    var handles = displayables.handles = [null, null];
	    var handleLabels = displayables.handleLabels = [null, null];
	    var sliderGroup = this._displayables.sliderGroup;
	    var size = this._size;
	    var dataZoomModel = this.dataZoomModel;
	    var api = this.api;
	    var borderRadius = dataZoomModel.get('borderRadius') || 0;
	    var brushSelect = dataZoomModel.get('brushSelect');
	    var filler = displayables.filler = new Rect({
	      silent: brushSelect,
	      style: {
	        fill: dataZoomModel.get('fillerColor')
	      },
	      textConfig: {
	        position: 'inside'
	      }
	    });
	    sliderGroup.add(filler);
	    sliderGroup.add(new Rect({
	      silent: true,
	      subPixelOptimize: true,
	      shape: {
	        x: 0,
	        y: 0,
	        width: size[0],
	        height: size[1],
	        r: borderRadius
	      },
	      style: {
	        stroke: dataZoomModel.get('dataBackgroundColor') || dataZoomModel.get('borderColor'),
	        lineWidth: DEFAULT_FRAME_BORDER_WIDTH,
	        fill: 'rgba(0,0,0,0)'
	      }
	    }));
	    util_1.each([0, 1], function (handleIndex) {
	      var iconStr = dataZoomModel.get('handleIcon');
	
	      if (!symbol_1.symbolBuildProxies[iconStr] && iconStr.indexOf('path://') < 0) {
	        iconStr = 'path://' + iconStr;
	
	        if (false) {
	          log_1.deprecateLog('handleIcon now needs \'path://\' prefix when using a path string');
	        }
	      }
	
	      var path = symbol_1.createSymbol(iconStr, -1, 0, 2, 2, null, true);
	      path.attr({
	        cursor: getCursor(this._orient),
	        draggable: true,
	        drift: util_1.bind(this._onDragMove, this, handleIndex),
	        ondragend: util_1.bind(this._onDragEnd, this),
	        onmouseover: util_1.bind(this._showDataInfo, this, true),
	        onmouseout: util_1.bind(this._showDataInfo, this, false),
	        z2: 5
	      });
	      var bRect = path.getBoundingRect();
	      var handleSize = dataZoomModel.get('handleSize');
	      this._handleHeight = number_1.parsePercent(handleSize, this._size[1]);
	      this._handleWidth = bRect.width / bRect.height * this._handleHeight;
	      path.setStyle(dataZoomModel.getModel('handleStyle').getItemStyle());
	      path.style.strokeNoScale = true;
	      path.rectHover = true;
	      path.ensureState('emphasis').style = dataZoomModel.getModel(['emphasis', 'handleStyle']).getItemStyle();
	      states_1.enableHoverEmphasis(path);
	      var handleColor = dataZoomModel.get('handleColor');
	
	      if (handleColor != null) {
	        path.style.fill = handleColor;
	      }
	
	      sliderGroup.add(handles[handleIndex] = path);
	      var textStyleModel = dataZoomModel.getModel('textStyle');
	      thisGroup.add(handleLabels[handleIndex] = new graphic.Text({
	        silent: true,
	        invisible: true,
	        style: {
	          x: 0,
	          y: 0,
	          text: '',
	          verticalAlign: 'middle',
	          align: 'center',
	          fill: textStyleModel.getTextColor(),
	          font: textStyleModel.getFont()
	        },
	        z2: 10
	      }));
	    }, this);
	    var actualMoveZone = filler;
	
	    if (brushSelect) {
	      var moveHandleHeight = number_1.parsePercent(dataZoomModel.get('moveHandleSize'), size[1]);
	      var moveHandle_1 = displayables.moveHandle = new graphic.Rect({
	        style: dataZoomModel.getModel('moveHandleStyle').getItemStyle(),
	        silent: true,
	        shape: {
	          r: [0, 0, 2, 2],
	          y: size[1] - 0.5,
	          height: moveHandleHeight
	        }
	      });
	      var iconSize = moveHandleHeight * 0.8;
	      var moveHandleIcon = displayables.moveHandleIcon = symbol_1.createSymbol(dataZoomModel.get('moveHandleIcon'), -iconSize / 2, -iconSize / 2, iconSize, iconSize, '#fff', true);
	      moveHandleIcon.silent = true;
	      moveHandleIcon.y = size[1] + moveHandleHeight / 2 - 0.5;
	      moveHandle_1.ensureState('emphasis').style = dataZoomModel.getModel(['emphasis', 'moveHandleStyle']).getItemStyle();
	      var moveZoneExpandSize = Math.min(size[1] / 2, Math.max(moveHandleHeight, 10));
	      actualMoveZone = displayables.moveZone = new graphic.Rect({
	        invisible: true,
	        shape: {
	          y: size[1] - moveZoneExpandSize,
	          height: moveHandleHeight + moveZoneExpandSize
	        }
	      });
	      actualMoveZone.on('mouseover', function () {
	        api.enterEmphasis(moveHandle_1);
	      }).on('mouseout', function () {
	        api.leaveEmphasis(moveHandle_1);
	      });
	      sliderGroup.add(moveHandle_1);
	      sliderGroup.add(moveHandleIcon);
	      sliderGroup.add(actualMoveZone);
	    }
	
	    actualMoveZone.attr({
	      draggable: true,
	      cursor: getCursor(this._orient),
	      drift: util_1.bind(this._onDragMove, this, 'all'),
	      ondragstart: util_1.bind(this._showDataInfo, this, true),
	      ondragend: util_1.bind(this._onDragEnd, this),
	      onmouseover: util_1.bind(this._showDataInfo, this, true),
	      onmouseout: util_1.bind(this._showDataInfo, this, false)
	    });
	  };
	
	  SliderZoomView.prototype._resetInterval = function () {
	    var range = this._range = this.dataZoomModel.getPercentRange();
	
	    var viewExtent = this._getViewExtent();
	
	    this._handleEnds = [number_1.linearMap(range[0], [0, 100], viewExtent, true), number_1.linearMap(range[1], [0, 100], viewExtent, true)];
	  };
	
	  SliderZoomView.prototype._updateInterval = function (handleIndex, delta) {
	    var dataZoomModel = this.dataZoomModel;
	    var handleEnds = this._handleEnds;
	
	    var viewExtend = this._getViewExtent();
	
	    var minMaxSpan = dataZoomModel.findRepresentativeAxisProxy().getMinMaxSpan();
	    var percentExtent = [0, 100];
	    sliderMove_1["default"](delta, handleEnds, viewExtend, dataZoomModel.get('zoomLock') ? 'all' : handleIndex, minMaxSpan.minSpan != null ? number_1.linearMap(minMaxSpan.minSpan, percentExtent, viewExtend, true) : null, minMaxSpan.maxSpan != null ? number_1.linearMap(minMaxSpan.maxSpan, percentExtent, viewExtend, true) : null);
	    var lastRange = this._range;
	    var range = this._range = number_1.asc([number_1.linearMap(handleEnds[0], viewExtend, percentExtent, true), number_1.linearMap(handleEnds[1], viewExtend, percentExtent, true)]);
	    return !lastRange || lastRange[0] !== range[0] || lastRange[1] !== range[1];
	  };
	
	  SliderZoomView.prototype._updateView = function (nonRealtime) {
	    var displaybles = this._displayables;
	    var handleEnds = this._handleEnds;
	    var handleInterval = number_1.asc(handleEnds.slice());
	    var size = this._size;
	    util_1.each([0, 1], function (handleIndex) {
	      var handle = displaybles.handles[handleIndex];
	      var handleHeight = this._handleHeight;
	      handle.attr({
	        scaleX: handleHeight / 2,
	        scaleY: handleHeight / 2,
	        x: handleEnds[handleIndex] + (handleIndex ? -1 : 1),
	        y: size[1] / 2 - handleHeight / 2
	      });
	    }, this);
	    displaybles.filler.setShape({
	      x: handleInterval[0],
	      y: 0,
	      width: handleInterval[1] - handleInterval[0],
	      height: size[1]
	    });
	    var viewExtent = {
	      x: handleInterval[0],
	      width: handleInterval[1] - handleInterval[0]
	    };
	
	    if (displaybles.moveHandle) {
	      displaybles.moveHandle.setShape(viewExtent);
	      displaybles.moveZone.setShape(viewExtent);
	      displaybles.moveZone.getBoundingRect();
	      displaybles.moveHandleIcon && displaybles.moveHandleIcon.attr('x', viewExtent.x + viewExtent.width / 2);
	    }
	
	    var dataShadowSegs = displaybles.dataShadowSegs;
	    var segIntervals = [0, handleInterval[0], handleInterval[1], size[0]];
	
	    for (var i = 0; i < dataShadowSegs.length; i++) {
	      var segGroup = dataShadowSegs[i];
	      var clipPath = segGroup.getClipPath();
	
	      if (!clipPath) {
	        clipPath = new graphic.Rect();
	        segGroup.setClipPath(clipPath);
	      }
	
	      clipPath.setShape({
	        x: segIntervals[i],
	        y: 0,
	        width: segIntervals[i + 1] - segIntervals[i],
	        height: size[1]
	      });
	    }
	
	    this._updateDataInfo(nonRealtime);
	  };
	
	  SliderZoomView.prototype._updateDataInfo = function (nonRealtime) {
	    var dataZoomModel = this.dataZoomModel;
	    var displaybles = this._displayables;
	    var handleLabels = displaybles.handleLabels;
	    var orient = this._orient;
	    var labelTexts = ['', ''];
	
	    if (dataZoomModel.get('showDetail')) {
	      var axisProxy = dataZoomModel.findRepresentativeAxisProxy();
	
	      if (axisProxy) {
	        var axis = axisProxy.getAxisModel().axis;
	        var range = this._range;
	        var dataInterval = nonRealtime ? axisProxy.calculateDataWindow({
	          start: range[0],
	          end: range[1]
	        }).valueWindow : axisProxy.getDataValueWindow();
	        labelTexts = [this._formatLabel(dataInterval[0], axis), this._formatLabel(dataInterval[1], axis)];
	      }
	    }
	
	    var orderedHandleEnds = number_1.asc(this._handleEnds.slice());
	    setLabel.call(this, 0);
	    setLabel.call(this, 1);
	
	    function setLabel(handleIndex) {
	      var barTransform = graphic.getTransform(displaybles.handles[handleIndex].parent, this.group);
	      var direction = graphic.transformDirection(handleIndex === 0 ? 'right' : 'left', barTransform);
	      var offset = this._handleWidth / 2 + LABEL_GAP;
	      var textPoint = graphic.applyTransform([orderedHandleEnds[handleIndex] + (handleIndex === 0 ? -offset : offset), this._size[1] / 2], barTransform);
	      handleLabels[handleIndex].setStyle({
	        x: textPoint[0],
	        y: textPoint[1],
	        verticalAlign: orient === HORIZONTAL ? 'middle' : direction,
	        align: orient === HORIZONTAL ? direction : 'center',
	        text: labelTexts[handleIndex]
	      });
	    }
	  };
	
	  SliderZoomView.prototype._formatLabel = function (value, axis) {
	    var dataZoomModel = this.dataZoomModel;
	    var labelFormatter = dataZoomModel.get('labelFormatter');
	    var labelPrecision = dataZoomModel.get('labelPrecision');
	
	    if (labelPrecision == null || labelPrecision === 'auto') {
	      labelPrecision = axis.getPixelPrecision();
	    }
	
	    var valueStr = value == null || isNaN(value) ? '' : axis.type === 'category' || axis.type === 'time' ? axis.scale.getLabel({
	      value: Math.round(value)
	    }) : value.toFixed(Math.min(labelPrecision, 20));
	    return util_1.isFunction(labelFormatter) ? labelFormatter(value, valueStr) : util_1.isString(labelFormatter) ? labelFormatter.replace('{value}', valueStr) : valueStr;
	  };
	
	  SliderZoomView.prototype._showDataInfo = function (showOrHide) {
	    showOrHide = this._dragging || showOrHide;
	    var displayables = this._displayables;
	    var handleLabels = displayables.handleLabels;
	    handleLabels[0].attr('invisible', !showOrHide);
	    handleLabels[1].attr('invisible', !showOrHide);
	    displayables.moveHandle && this.api[showOrHide ? 'enterEmphasis' : 'leaveEmphasis'](displayables.moveHandle, 1);
	  };
	
	  SliderZoomView.prototype._onDragMove = function (handleIndex, dx, dy, event) {
	    this._dragging = true;
	    eventTool.stop(event.event);
	
	    var barTransform = this._displayables.sliderGroup.getLocalTransform();
	
	    var vertex = graphic.applyTransform([dx, dy], barTransform, true);
	
	    var changed = this._updateInterval(handleIndex, vertex[0]);
	
	    var realtime = this.dataZoomModel.get('realtime');
	
	    this._updateView(!realtime);
	
	    changed && realtime && this._dispatchZoomAction(true);
	  };
	
	  SliderZoomView.prototype._onDragEnd = function () {
	    this._dragging = false;
	
	    this._showDataInfo(false);
	
	    var realtime = this.dataZoomModel.get('realtime');
	    !realtime && this._dispatchZoomAction(false);
	  };
	
	  SliderZoomView.prototype._onClickPanel = function (e) {
	    var size = this._size;
	
	    var localPoint = this._displayables.sliderGroup.transformCoordToLocal(e.offsetX, e.offsetY);
	
	    if (localPoint[0] < 0 || localPoint[0] > size[0] || localPoint[1] < 0 || localPoint[1] > size[1]) {
	      return;
	    }
	
	    var handleEnds = this._handleEnds;
	    var center = (handleEnds[0] + handleEnds[1]) / 2;
	
	    var changed = this._updateInterval('all', localPoint[0] - center);
	
	    this._updateView();
	
	    changed && this._dispatchZoomAction(false);
	  };
	
	  SliderZoomView.prototype._onBrushStart = function (e) {
	    var x = e.offsetX;
	    var y = e.offsetY;
	    this._brushStart = new graphic.Point(x, y);
	    this._brushing = true;
	    this._brushStartTime = +new Date();
	  };
	
	  SliderZoomView.prototype._onBrushEnd = function (e) {
	    if (!this._brushing) {
	      return;
	    }
	
	    var brushRect = this._displayables.brushRect;
	    this._brushing = false;
	
	    if (!brushRect) {
	      return;
	    }
	
	    brushRect.attr('ignore', true);
	    var brushShape = brushRect.shape;
	    var brushEndTime = +new Date();
	
	    if (brushEndTime - this._brushStartTime < 200 && Math.abs(brushShape.width) < 5) {
	      return;
	    }
	
	    var viewExtend = this._getViewExtent();
	
	    var percentExtent = [0, 100];
	    this._range = number_1.asc([number_1.linearMap(brushShape.x, viewExtend, percentExtent, true), number_1.linearMap(brushShape.x + brushShape.width, viewExtend, percentExtent, true)]);
	    this._handleEnds = [brushShape.x, brushShape.x + brushShape.width];
	
	    this._updateView();
	
	    this._dispatchZoomAction(false);
	  };
	
	  SliderZoomView.prototype._onBrush = function (e) {
	    if (this._brushing) {
	      eventTool.stop(e.event);
	
	      this._updateBrushRect(e.offsetX, e.offsetY);
	    }
	  };
	
	  SliderZoomView.prototype._updateBrushRect = function (mouseX, mouseY) {
	    var displayables = this._displayables;
	    var dataZoomModel = this.dataZoomModel;
	    var brushRect = displayables.brushRect;
	
	    if (!brushRect) {
	      brushRect = displayables.brushRect = new Rect({
	        silent: true,
	        style: dataZoomModel.getModel('brushStyle').getItemStyle()
	      });
	      displayables.sliderGroup.add(brushRect);
	    }
	
	    brushRect.attr('ignore', false);
	    var brushStart = this._brushStart;
	    var sliderGroup = this._displayables.sliderGroup;
	    var endPoint = sliderGroup.transformCoordToLocal(mouseX, mouseY);
	    var startPoint = sliderGroup.transformCoordToLocal(brushStart.x, brushStart.y);
	    var size = this._size;
	    endPoint[0] = Math.max(Math.min(size[0], endPoint[0]), 0);
	    brushRect.setShape({
	      x: startPoint[0],
	      y: 0,
	      width: endPoint[0] - startPoint[0],
	      height: size[1]
	    });
	  };
	
	  SliderZoomView.prototype._dispatchZoomAction = function (realtime) {
	    var range = this._range;
	    this.api.dispatchAction({
	      type: 'dataZoom',
	      from: this.uid,
	      dataZoomId: this.dataZoomModel.id,
	      animation: realtime ? REALTIME_ANIMATION_CONFIG : null,
	      start: range[0],
	      end: range[1]
	    });
	  };
	
	  SliderZoomView.prototype._findCoordRect = function () {
	    var rect;
	    var coordSysInfoList = helper_1.collectReferCoordSysModelInfo(this.dataZoomModel).infoList;
	
	    if (!rect && coordSysInfoList.length) {
	      var coordSys = coordSysInfoList[0].model.coordinateSystem;
	      rect = coordSys.getRect && coordSys.getRect();
	    }
	
	    if (!rect) {
	      var width = this.api.getWidth();
	      var height = this.api.getHeight();
	      rect = {
	        x: width * 0.2,
	        y: height * 0.2,
	        width: width * 0.6,
	        height: height * 0.6
	      };
	    }
	
	    return rect;
	  };
	
	  SliderZoomView.type = 'dataZoom.slider';
	  return SliderZoomView;
	}(DataZoomView_1["default"]);
	
	function getOtherDim(thisDim) {
	  var map = {
	    x: 'y',
	    y: 'x',
	    radius: 'angle',
	    angle: 'radius'
	  };
	  return map[thisDim];
	}
	
	function getCursor(orient) {
	  return orient === 'vertical' ? 'ns-resize' : 'ew-resize';
	}
	
	Component_1["default"].registerClass(SliderZoomView);
	exports["default"] = SliderZoomView;

/***/ },
/* 313 */
/***/ function(module, exports, __webpack_require__) {

	
	/*
	* Licensed to the Apache Software Foundation (ASF) under one
	* or more contributor license agreements.  See the NOTICE file
	* distributed with this work for additional information
	* regarding copyright ownership.  The ASF licenses this file
	* to you under the Apache License, Version 2.0 (the
	* "License"); you may not use this file except in compliance
	* with the License.  You may obtain a copy of the License at
	*
	*   http://www.apache.org/licenses/LICENSE-2.0
	*
	* Unless required by applicable law or agreed to in writing,
	* software distributed under the License is distributed on an
	* "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
	* KIND, either express or implied.  See the License for the
	* specific language governing permissions and limitations
	* under the License.
	*/
	
	
	
	/**
	 * AUTO-GENERATED FILE. DO NOT MODIFY.
	 */
	
	"use strict";
	
	exports.__esModule = true;
	
	var echarts = __webpack_require__(6);
	
	var RoamController_1 = __webpack_require__(317);
	
	var throttleUtil = __webpack_require__(56);
	
	var model_1 = __webpack_require__(4);
	
	var util_1 = __webpack_require__(1);
	
	var helper_1 = __webpack_require__(45);
	
	var inner = model_1.makeInner();
	echarts.registerProcessor(echarts.PRIORITY.PROCESSOR.FILTER, function (ecModel, api) {
	  var apiInner = inner(api);
	  var coordSysRecordMap = apiInner.coordSysRecordMap || (apiInner.coordSysRecordMap = util_1.createHashMap());
	  coordSysRecordMap.each(function (coordSysRecord) {
	    coordSysRecord.dataZoomInfoMap = null;
	  });
	  ecModel.eachComponent({
	    mainType: 'dataZoom',
	    subType: 'inside'
	  }, function (dataZoomModel) {
	    var dzReferCoordSysWrap = helper_1.collectReferCoordSysModelInfo(dataZoomModel);
	    util_1.each(dzReferCoordSysWrap.infoList, function (dzCoordSysInfo) {
	      var coordSysUid = dzCoordSysInfo.model.uid;
	      var coordSysRecord = coordSysRecordMap.get(coordSysUid) || coordSysRecordMap.set(coordSysUid, createCoordSysRecord(api, dzCoordSysInfo.model));
	      var dataZoomInfoMap = coordSysRecord.dataZoomInfoMap || (coordSysRecord.dataZoomInfoMap = util_1.createHashMap());
	      dataZoomInfoMap.set(dataZoomModel.uid, {
	        dzReferCoordSysInfo: dzCoordSysInfo,
	        model: dataZoomModel,
	        getRange: null
	      });
	    });
	  });
	  coordSysRecordMap.each(function (coordSysRecord) {
	    var controller = coordSysRecord.controller;
	    var firstDzInfo;
	    var dataZoomInfoMap = coordSysRecord.dataZoomInfoMap;
	
	    if (dataZoomInfoMap) {
	      var firstDzKey = dataZoomInfoMap.keys()[0];
	
	      if (firstDzKey != null) {
	        firstDzInfo = dataZoomInfoMap.get(firstDzKey);
	      }
	    }
	
	    if (!firstDzInfo) {
	      disposeCoordSysRecord(coordSysRecordMap, coordSysRecord);
	      return;
	    }
	
	    var controllerParams = mergeControllerParams(dataZoomInfoMap);
	    controller.enable(controllerParams.controlType, controllerParams.opt);
	    controller.setPointerChecker(coordSysRecord.containsPoint);
	    throttleUtil.createOrUpdate(coordSysRecord, 'dispatchAction', firstDzInfo.model.get('throttle', true), 'fixRate');
	  });
	});
	
	function setViewInfoToCoordSysRecord(api, dataZoomModel, getRange) {
	  inner(api).coordSysRecordMap.each(function (coordSysRecord) {
	    var dzInfo = coordSysRecord.dataZoomInfoMap.get(dataZoomModel.uid);
	
	    if (dzInfo) {
	      dzInfo.getRange = getRange;
	    }
	  });
	}
	
	exports.setViewInfoToCoordSysRecord = setViewInfoToCoordSysRecord;
	
	function disposeCoordSysRecordIfNeeded(api, dataZoomModel) {
	  var coordSysRecordMap = inner(api).coordSysRecordMap;
	  var coordSysKeyArr = coordSysRecordMap.keys();
	
	  for (var i = 0; i < coordSysKeyArr.length; i++) {
	    var coordSysKey = coordSysKeyArr[i];
	    var coordSysRecord = coordSysRecordMap.get(coordSysKey);
	    var dataZoomInfoMap = coordSysRecord.dataZoomInfoMap;
	
	    if (dataZoomInfoMap) {
	      var dzUid = dataZoomModel.uid;
	      var dzInfo = dataZoomInfoMap.get(dzUid);
	
	      if (dzInfo) {
	        dataZoomInfoMap.removeKey(dzUid);
	
	        if (!dataZoomInfoMap.keys().length) {
	          disposeCoordSysRecord(coordSysRecordMap, coordSysRecord);
	        }
	      }
	    }
	  }
	}
	
	exports.disposeCoordSysRecordIfNeeded = disposeCoordSysRecordIfNeeded;
	
	function disposeCoordSysRecord(coordSysRecordMap, coordSysRecord) {
	  if (coordSysRecord) {
	    coordSysRecordMap.removeKey(coordSysRecord.model.uid);
	    var controller = coordSysRecord.controller;
	    controller && controller.dispose();
	  }
	}
	
	function createCoordSysRecord(api, coordSysModel) {
	  var coordSysRecord = {
	    model: coordSysModel,
	    containsPoint: util_1.curry(containsPoint, coordSysModel),
	    dispatchAction: util_1.curry(dispatchAction, api),
	    dataZoomInfoMap: null,
	    controller: null
	  };
	  var controller = coordSysRecord.controller = new RoamController_1["default"](api.getZr());
	  util_1.each(['pan', 'zoom', 'scrollMove'], function (eventName) {
	    controller.on(eventName, function (event) {
	      var batch = [];
	      coordSysRecord.dataZoomInfoMap.each(function (dzInfo) {
	        if (!event.isAvailableBehavior(dzInfo.model.option)) {
	          return;
	        }
	
	        var method = (dzInfo.getRange || {})[eventName];
	        var range = method && method(dzInfo.dzReferCoordSysInfo, coordSysRecord.model.mainType, coordSysRecord.controller, event);
	        !dzInfo.model.get('disabled', true) && range && batch.push({
	          dataZoomId: dzInfo.model.id,
	          start: range[0],
	          end: range[1]
	        });
	      });
	      batch.length && coordSysRecord.dispatchAction(batch);
	    });
	  });
	  return coordSysRecord;
	}
	
	function dispatchAction(api, batch) {
	  api.dispatchAction({
	    type: 'dataZoom',
	    animation: {
	      easing: 'cubicOut',
	      duration: 100
	    },
	    batch: batch
	  });
	}
	
	function containsPoint(coordSysModel, e, x, y) {
	  return coordSysModel.coordinateSystem.containPoint([x, y]);
	}
	
	function mergeControllerParams(dataZoomInfoMap) {
	  var controlType;
	  var prefix = 'type_';
	  var typePriority = {
	    'type_true': 2,
	    'type_move': 1,
	    'type_false': 0,
	    'type_undefined': -1
	  };
	  var preventDefaultMouseMove = true;
	  dataZoomInfoMap.each(function (dataZoomInfo) {
	    var dataZoomModel = dataZoomInfo.model;
	    var oneType = dataZoomModel.get('disabled', true) ? false : dataZoomModel.get('zoomLock', true) ? 'move' : true;
	
	    if (typePriority[prefix + oneType] > typePriority[prefix + controlType]) {
	      controlType = oneType;
	    }
	
	    preventDefaultMouseMove = preventDefaultMouseMove && dataZoomModel.get('preventDefaultMouseMove', true);
	  });
	  return {
	    controlType: controlType,
	    opt: {
	      zoomOnMouseWheel: true,
	      moveOnMouseMove: true,
	      moveOnMouseWheel: true,
	      preventDefaultMouseMove: !!preventDefaultMouseMove
	    }
	  };
	}

/***/ },
/* 314 */
/***/ function(module, exports, __webpack_require__) {

	
	/*
	* Licensed to the Apache Software Foundation (ASF) under one
	* or more contributor license agreements.  See the NOTICE file
	* distributed with this work for additional information
	* regarding copyright ownership.  The ASF licenses this file
	* to you under the Apache License, Version 2.0 (the
	* "License"); you may not use this file except in compliance
	* with the License.  You may obtain a copy of the License at
	*
	*   http://www.apache.org/licenses/LICENSE-2.0
	*
	* Unless required by applicable law or agreed to in writing,
	* software distributed under the License is distributed on an
	* "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
	* KIND, either express or implied.  See the License for the
	* specific language governing permissions and limitations
	* under the License.
	*/
	
	
	
	/**
	 * AUTO-GENERATED FILE. DO NOT MODIFY.
	 */
	
	"use strict";
	
	exports.__esModule = true;
	
	__webpack_require__(140);
	
	__webpack_require__(65);
	
	__webpack_require__(66);
	
	__webpack_require__(309);
	
	__webpack_require__(310);
	
	__webpack_require__(139);
	
	__webpack_require__(138);

/***/ },
/* 315 */
/***/ function(module, exports, __webpack_require__) {

	
	/*
	* Licensed to the Apache Software Foundation (ASF) under one
	* or more contributor license agreements.  See the NOTICE file
	* distributed with this work for additional information
	* regarding copyright ownership.  The ASF licenses this file
	* to you under the Apache License, Version 2.0 (the
	* "License"); you may not use this file except in compliance
	* with the License.  You may obtain a copy of the License at
	*
	*   http://www.apache.org/licenses/LICENSE-2.0
	*
	* Unless required by applicable law or agreed to in writing,
	* software distributed under the License is distributed on an
	* "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
	* KIND, either express or implied.  See the License for the
	* specific language governing permissions and limitations
	* under the License.
	*/
	
	
	
	/**
	 * AUTO-GENERATED FILE. DO NOT MODIFY.
	 */
	
	"use strict";
	
	exports.__esModule = true;
	
	__webpack_require__(140);
	
	__webpack_require__(65);
	
	__webpack_require__(66);
	
	__webpack_require__(311);
	
	__webpack_require__(312);
	
	__webpack_require__(139);
	
	__webpack_require__(138);

/***/ },
/* 316 */
/***/ function(module, exports, __webpack_require__) {

	
	/*
	* Licensed to the Apache Software Foundation (ASF) under one
	* or more contributor license agreements.  See the NOTICE file
	* distributed with this work for additional information
	* regarding copyright ownership.  The ASF licenses this file
	* to you under the Apache License, Version 2.0 (the
	* "License"); you may not use this file except in compliance
	* with the License.  You may obtain a copy of the License at
	*
	*   http://www.apache.org/licenses/LICENSE-2.0
	*
	* Unless required by applicable law or agreed to in writing,
	* software distributed under the License is distributed on an
	* "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
	* KIND, either express or implied.  See the License for the
	* specific language governing permissions and limitations
	* under the License.
	*/
	
	
	
	/**
	 * AUTO-GENERATED FILE. DO NOT MODIFY.
	 */
	
	"use strict";
	
	exports.__esModule = true;
	
	var tslib_1 = __webpack_require__(3);
	
	var Component_1 = __webpack_require__(10);
	
	var Component_2 = __webpack_require__(18);
	
	var types_1 = __webpack_require__(25);
	
	var sourceManager_1 = __webpack_require__(147);
	
	var DatasetModel = function (_super) {
	  tslib_1.__extends(DatasetModel, _super);
	
	  function DatasetModel() {
	    var _this = _super !== null && _super.apply(this, arguments) || this;
	
	    _this.type = 'dataset';
	    return _this;
	  }
	
	  DatasetModel.prototype.init = function (option, parentModel, ecModel) {
	    _super.prototype.init.call(this, option, parentModel, ecModel);
	
	    this._sourceManager = new sourceManager_1.SourceManager(this);
	    sourceManager_1.disableTransformOptionMerge(this);
	  };
	
	  DatasetModel.prototype.mergeOption = function (newOption, ecModel) {
	    _super.prototype.mergeOption.call(this, newOption, ecModel);
	
	    sourceManager_1.disableTransformOptionMerge(this);
	  };
	
	  DatasetModel.prototype.optionUpdated = function () {
	    this._sourceManager.dirty();
	  };
	
	  DatasetModel.prototype.getSourceManager = function () {
	    return this._sourceManager;
	  };
	
	  DatasetModel.type = 'dataset';
	  DatasetModel.defaultOption = {
	    seriesLayoutBy: types_1.SERIES_LAYOUT_BY_COLUMN
	  };
	  return DatasetModel;
	}(Component_1["default"]);
	
	exports.DatasetModel = DatasetModel;
	Component_1["default"].registerClass(DatasetModel);
	
	var DatasetView = function (_super) {
	  tslib_1.__extends(DatasetView, _super);
	
	  function DatasetView() {
	    var _this = _super !== null && _super.apply(this, arguments) || this;
	
	    _this.type = 'dataset';
	    return _this;
	  }
	
	  DatasetView.type = 'dataset';
	  return DatasetView;
	}(Component_2["default"]);
	
	Component_2["default"].registerClass(DatasetView);

/***/ },
/* 317 */
/***/ function(module, exports, __webpack_require__) {

	
	/*
	* Licensed to the Apache Software Foundation (ASF) under one
	* or more contributor license agreements.  See the NOTICE file
	* distributed with this work for additional information
	* regarding copyright ownership.  The ASF licenses this file
	* to you under the Apache License, Version 2.0 (the
	* "License"); you may not use this file except in compliance
	* with the License.  You may obtain a copy of the License at
	*
	*   http://www.apache.org/licenses/LICENSE-2.0
	*
	* Unless required by applicable law or agreed to in writing,
	* software distributed under the License is distributed on an
	* "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
	* KIND, either express or implied.  See the License for the
	* specific language governing permissions and limitations
	* under the License.
	*/
	
	
	
	/**
	 * AUTO-GENERATED FILE. DO NOT MODIFY.
	 */
	
	"use strict";
	
	exports.__esModule = true;
	
	var tslib_1 = __webpack_require__(3);
	
	var Eventful_1 = __webpack_require__(37);
	
	var eventTool = __webpack_require__(42);
	
	var interactionMutex = __webpack_require__(318);
	
	var util_1 = __webpack_require__(1);
	
	var RoamController = function (_super) {
	  tslib_1.__extends(RoamController, _super);
	
	  function RoamController(zr) {
	    var _this = _super.call(this) || this;
	
	    _this._zr = zr;
	    var mousedownHandler = util_1.bind(_this._mousedownHandler, _this);
	    var mousemoveHandler = util_1.bind(_this._mousemoveHandler, _this);
	    var mouseupHandler = util_1.bind(_this._mouseupHandler, _this);
	    var mousewheelHandler = util_1.bind(_this._mousewheelHandler, _this);
	    var pinchHandler = util_1.bind(_this._pinchHandler, _this);
	
	    _this.enable = function (controlType, opt) {
	      this.disable();
	      this._opt = util_1.defaults(util_1.clone(opt) || {}, {
	        zoomOnMouseWheel: true,
	        moveOnMouseMove: true,
	        moveOnMouseWheel: false,
	        preventDefaultMouseMove: true
	      });
	
	      if (controlType == null) {
	        controlType = true;
	      }
	
	      if (controlType === true || controlType === 'move' || controlType === 'pan') {
	        zr.on('mousedown', mousedownHandler);
	        zr.on('mousemove', mousemoveHandler);
	        zr.on('mouseup', mouseupHandler);
	      }
	
	      if (controlType === true || controlType === 'scale' || controlType === 'zoom') {
	        zr.on('mousewheel', mousewheelHandler);
	        zr.on('pinch', pinchHandler);
	      }
	    };
	
	    _this.disable = function () {
	      zr.off('mousedown', mousedownHandler);
	      zr.off('mousemove', mousemoveHandler);
	      zr.off('mouseup', mouseupHandler);
	      zr.off('mousewheel', mousewheelHandler);
	      zr.off('pinch', pinchHandler);
	    };
	
	    return _this;
	  }
	
	  RoamController.prototype.isDragging = function () {
	    return this._dragging;
	  };
	
	  RoamController.prototype.isPinching = function () {
	    return this._pinching;
	  };
	
	  RoamController.prototype.setPointerChecker = function (pointerChecker) {
	    this.pointerChecker = pointerChecker;
	  };
	
	  RoamController.prototype.dispose = function () {
	    this.disable();
	  };
	
	  RoamController.prototype._mousedownHandler = function (e) {
	    if (eventTool.isMiddleOrRightButtonOnMouseUpDown(e) || e.target && e.target.draggable) {
	      return;
	    }
	
	    var x = e.offsetX;
	    var y = e.offsetY;
	
	    if (this.pointerChecker && this.pointerChecker(e, x, y)) {
	      this._x = x;
	      this._y = y;
	      this._dragging = true;
	    }
	  };
	
	  RoamController.prototype._mousemoveHandler = function (e) {
	    if (!this._dragging || !isAvailableBehavior('moveOnMouseMove', e, this._opt) || e.gestureEvent === 'pinch' || interactionMutex.isTaken(this._zr, 'globalPan')) {
	      return;
	    }
	
	    var x = e.offsetX;
	    var y = e.offsetY;
	    var oldX = this._x;
	    var oldY = this._y;
	    var dx = x - oldX;
	    var dy = y - oldY;
	    this._x = x;
	    this._y = y;
	    this._opt.preventDefaultMouseMove && eventTool.stop(e.event);
	    trigger(this, 'pan', 'moveOnMouseMove', e, {
	      dx: dx,
	      dy: dy,
	      oldX: oldX,
	      oldY: oldY,
	      newX: x,
	      newY: y,
	      isAvailableBehavior: null
	    });
	  };
	
	  RoamController.prototype._mouseupHandler = function (e) {
	    if (!eventTool.isMiddleOrRightButtonOnMouseUpDown(e)) {
	      this._dragging = false;
	    }
	  };
	
	  RoamController.prototype._mousewheelHandler = function (e) {
	    var shouldZoom = isAvailableBehavior('zoomOnMouseWheel', e, this._opt);
	    var shouldMove = isAvailableBehavior('moveOnMouseWheel', e, this._opt);
	    var wheelDelta = e.wheelDelta;
	    var absWheelDeltaDelta = Math.abs(wheelDelta);
	    var originX = e.offsetX;
	    var originY = e.offsetY;
	
	    if (wheelDelta === 0 || !shouldZoom && !shouldMove) {
	      return;
	    }
	
	    if (shouldZoom) {
	      var factor = absWheelDeltaDelta > 3 ? 1.4 : absWheelDeltaDelta > 1 ? 1.2 : 1.1;
	      var scale = wheelDelta > 0 ? factor : 1 / factor;
	      checkPointerAndTrigger(this, 'zoom', 'zoomOnMouseWheel', e, {
	        scale: scale,
	        originX: originX,
	        originY: originY,
	        isAvailableBehavior: null
	      });
	    }
	
	    if (shouldMove) {
	      var absDelta = Math.abs(wheelDelta);
	      var scrollDelta = (wheelDelta > 0 ? 1 : -1) * (absDelta > 3 ? 0.4 : absDelta > 1 ? 0.15 : 0.05);
	      checkPointerAndTrigger(this, 'scrollMove', 'moveOnMouseWheel', e, {
	        scrollDelta: scrollDelta,
	        originX: originX,
	        originY: originY,
	        isAvailableBehavior: null
	      });
	    }
	  };
	
	  RoamController.prototype._pinchHandler = function (e) {
	    if (interactionMutex.isTaken(this._zr, 'globalPan')) {
	      return;
	    }
	
	    var scale = e.pinchScale > 1 ? 1.1 : 1 / 1.1;
	    checkPointerAndTrigger(this, 'zoom', null, e, {
	      scale: scale,
	      originX: e.pinchX,
	      originY: e.pinchY,
	      isAvailableBehavior: null
	    });
	  };
	
	  return RoamController;
	}(Eventful_1["default"]);
	
	function checkPointerAndTrigger(controller, eventName, behaviorToCheck, e, contollerEvent) {
	  if (controller.pointerChecker && controller.pointerChecker(e, contollerEvent.originX, contollerEvent.originY)) {
	    eventTool.stop(e.event);
	    trigger(controller, eventName, behaviorToCheck, e, contollerEvent);
	  }
	}
	
	function trigger(controller, eventName, behaviorToCheck, e, contollerEvent) {
	  contollerEvent.isAvailableBehavior = util_1.bind(isAvailableBehavior, null, behaviorToCheck, e);
	  controller.trigger(eventName, contollerEvent);
	}
	
	function isAvailableBehavior(behaviorToCheck, e, settings) {
	  var setting = settings[behaviorToCheck];
	  return !behaviorToCheck || setting && (!util_1.isString(setting) || e.event[setting + 'Key']);
	}
	
	exports["default"] = RoamController;

/***/ },
/* 318 */
/***/ function(module, exports, __webpack_require__) {

	
	/*
	* Licensed to the Apache Software Foundation (ASF) under one
	* or more contributor license agreements.  See the NOTICE file
	* distributed with this work for additional information
	* regarding copyright ownership.  The ASF licenses this file
	* to you under the Apache License, Version 2.0 (the
	* "License"); you may not use this file except in compliance
	* with the License.  You may obtain a copy of the License at
	*
	*   http://www.apache.org/licenses/LICENSE-2.0
	*
	* Unless required by applicable law or agreed to in writing,
	* software distributed under the License is distributed on an
	* "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
	* KIND, either express or implied.  See the License for the
	* specific language governing permissions and limitations
	* under the License.
	*/
	
	
	
	/**
	 * AUTO-GENERATED FILE. DO NOT MODIFY.
	 */
	
	"use strict";
	
	exports.__esModule = true;
	
	var echarts = __webpack_require__(6);
	
	var ATTR = '\0_ec_interaction_mutex';
	
	function take(zr, resourceKey, userKey) {
	  var store = getStore(zr);
	  store[resourceKey] = userKey;
	}
	
	exports.take = take;
	
	function release(zr, resourceKey, userKey) {
	  var store = getStore(zr);
	  var uKey = store[resourceKey];
	
	  if (uKey === userKey) {
	    store[resourceKey] = null;
	  }
	}
	
	exports.release = release;
	
	function isTaken(zr, resourceKey) {
	  return !!getStore(zr)[resourceKey];
	}
	
	exports.isTaken = isTaken;
	
	function getStore(zr) {
	  return zr[ATTR] || (zr[ATTR] = {});
	}
	
	echarts.registerAction({
	  type: 'takeGlobalCursor',
	  event: 'globalCursorTaken',
	  update: 'update'
	}, function () {});

/***/ },
/* 319 */
/***/ function(module, exports, __webpack_require__) {

	
	/*
	* Licensed to the Apache Software Foundation (ASF) under one
	* or more contributor license agreements.  See the NOTICE file
	* distributed with this work for additional information
	* regarding copyright ownership.  The ASF licenses this file
	* to you under the Apache License, Version 2.0 (the
	* "License"); you may not use this file except in compliance
	* with the License.  You may obtain a copy of the License at
	*
	*   http://www.apache.org/licenses/LICENSE-2.0
	*
	* Unless required by applicable law or agreed to in writing,
	* software distributed under the License is distributed on an
	* "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
	* KIND, either express or implied.  See the License for the
	* specific language governing permissions and limitations
	* under the License.
	*/
	
	
	
	/**
	 * AUTO-GENERATED FILE. DO NOT MODIFY.
	 */
	
	"use strict";
	
	exports.__esModule = true;
	
	var layout_1 = __webpack_require__(30);
	
	var formatUtil = __webpack_require__(29);
	
	var graphic = __webpack_require__(7);
	
	function layout(group, componentModel, api) {
	  var boxLayoutParams = componentModel.getBoxLayoutParams();
	  var padding = componentModel.get('padding');
	  var viewportSize = {
	    width: api.getWidth(),
	    height: api.getHeight()
	  };
	  var rect = layout_1.getLayoutRect(boxLayoutParams, viewportSize, padding);
	  layout_1.box(componentModel.get('orient'), group, componentModel.get('itemGap'), rect.width, rect.height);
	  layout_1.positionElement(group, boxLayoutParams, viewportSize, padding);
	}
	
	exports.layout = layout;
	
	function makeBackground(rect, componentModel) {
	  var padding = formatUtil.normalizeCssArray(componentModel.get('padding'));
	  var style = componentModel.getItemStyle(['color', 'opacity']);
	  style.fill = componentModel.get('backgroundColor');
	  rect = new graphic.Rect({
	    shape: {
	      x: rect.x - padding[3],
	      y: rect.y - padding[0],
	      width: rect.width + padding[1] + padding[3],
	      height: rect.height + padding[0] + padding[2],
	      r: componentModel.get('borderRadius')
	    },
	    style: style,
	    silent: true,
	    z2: -1
	  });
	  return rect;
	}
	
	exports.makeBackground = makeBackground;

/***/ },
/* 320 */
/***/ function(module, exports, __webpack_require__) {

	
	/*
	* Licensed to the Apache Software Foundation (ASF) under one
	* or more contributor license agreements.  See the NOTICE file
	* distributed with this work for additional information
	* regarding copyright ownership.  The ASF licenses this file
	* to you under the Apache License, Version 2.0 (the
	* "License"); you may not use this file except in compliance
	* with the License.  You may obtain a copy of the License at
	*
	*   http://www.apache.org/licenses/LICENSE-2.0
	*
	* Unless required by applicable law or agreed to in writing,
	* software distributed under the License is distributed on an
	* "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
	* KIND, either express or implied.  See the License for the
	* specific language governing permissions and limitations
	* under the License.
	*/
	
	
	
	/**
	 * AUTO-GENERATED FILE. DO NOT MODIFY.
	 */
	
	"use strict";
	
	exports.__esModule = true;
	
	var tslib_1 = __webpack_require__(3);
	
	var zrUtil = __webpack_require__(1);
	
	var Model_1 = __webpack_require__(24);
	
	var model_1 = __webpack_require__(4);
	
	var Component_1 = __webpack_require__(10);
	
	var getDefaultSelectorOptions = function (ecModel, type) {
	  if (type === 'all') {
	    return {
	      type: 'all',
	      title: ecModel.getLocale(['legend', 'selector', 'all'])
	    };
	  } else if (type === 'inverse') {
	    return {
	      type: 'inverse',
	      title: ecModel.getLocale(['legend', 'selector', 'inverse'])
	    };
	  }
	};
	
	var LegendModel = function (_super) {
	  tslib_1.__extends(LegendModel, _super);
	
	  function LegendModel() {
	    var _this = _super !== null && _super.apply(this, arguments) || this;
	
	    _this.type = LegendModel.type;
	    _this.layoutMode = {
	      type: 'box',
	      ignoreSize: true
	    };
	    return _this;
	  }
	
	  LegendModel.prototype.init = function (option, parentModel, ecModel) {
	    this.mergeDefaultAndTheme(option, ecModel);
	    option.selected = option.selected || {};
	
	    this._updateSelector(option);
	  };
	
	  LegendModel.prototype.mergeOption = function (option, ecModel) {
	    _super.prototype.mergeOption.call(this, option, ecModel);
	
	    this._updateSelector(option);
	  };
	
	  LegendModel.prototype._updateSelector = function (option) {
	    var selector = option.selector;
	    var ecModel = this.ecModel;
	
	    if (selector === true) {
	      selector = option.selector = ['all', 'inverse'];
	    }
	
	    if (zrUtil.isArray(selector)) {
	      zrUtil.each(selector, function (item, index) {
	        zrUtil.isString(item) && (item = {
	          type: item
	        });
	        selector[index] = zrUtil.merge(item, getDefaultSelectorOptions(ecModel, item.type));
	      });
	    }
	  };
	
	  LegendModel.prototype.optionUpdated = function () {
	    this._updateData(this.ecModel);
	
	    var legendData = this._data;
	
	    if (legendData[0] && this.get('selectedMode') === 'single') {
	      var hasSelected = false;
	
	      for (var i = 0; i < legendData.length; i++) {
	        var name_1 = legendData[i].get('name');
	
	        if (this.isSelected(name_1)) {
	          this.select(name_1);
	          hasSelected = true;
	          break;
	        }
	      }
	
	      !hasSelected && this.select(legendData[0].get('name'));
	    }
	  };
	
	  LegendModel.prototype._updateData = function (ecModel) {
	    var potentialData = [];
	    var availableNames = [];
	    ecModel.eachRawSeries(function (seriesModel) {
	      var seriesName = seriesModel.name;
	      availableNames.push(seriesName);
	      var isPotential;
	
	      if (seriesModel.legendVisualProvider) {
	        var provider = seriesModel.legendVisualProvider;
	        var names = provider.getAllNames();
	
	        if (!ecModel.isSeriesFiltered(seriesModel)) {
	          availableNames = availableNames.concat(names);
	        }
	
	        if (names.length) {
	          potentialData = potentialData.concat(names);
	        } else {
	          isPotential = true;
	        }
	      } else {
	        isPotential = true;
	      }
	
	      if (isPotential && model_1.isNameSpecified(seriesModel)) {
	        potentialData.push(seriesModel.name);
	      }
	    });
	    this._availableNames = availableNames;
	    var rawData = this.get('data') || potentialData;
	    var legendData = zrUtil.map(rawData, function (dataItem) {
	      if (typeof dataItem === 'string' || typeof dataItem === 'number') {
	        dataItem = {
	          name: dataItem
	        };
	      }
	
	      return new Model_1["default"](dataItem, this, this.ecModel);
	    }, this);
	    this._data = legendData;
	  };
	
	  LegendModel.prototype.getData = function () {
	    return this._data;
	  };
	
	  LegendModel.prototype.select = function (name) {
	    var selected = this.option.selected;
	    var selectedMode = this.get('selectedMode');
	
	    if (selectedMode === 'single') {
	      var data = this._data;
	      zrUtil.each(data, function (dataItem) {
	        selected[dataItem.get('name')] = false;
	      });
	    }
	
	    selected[name] = true;
	  };
	
	  LegendModel.prototype.unSelect = function (name) {
	    if (this.get('selectedMode') !== 'single') {
	      this.option.selected[name] = false;
	    }
	  };
	
	  LegendModel.prototype.toggleSelected = function (name) {
	    var selected = this.option.selected;
	
	    if (!selected.hasOwnProperty(name)) {
	      selected[name] = true;
	    }
	
	    this[selected[name] ? 'unSelect' : 'select'](name);
	  };
	
	  LegendModel.prototype.allSelect = function () {
	    var data = this._data;
	    var selected = this.option.selected;
	    zrUtil.each(data, function (dataItem) {
	      selected[dataItem.get('name', true)] = true;
	    });
	  };
	
	  LegendModel.prototype.inverseSelect = function () {
	    var data = this._data;
	    var selected = this.option.selected;
	    zrUtil.each(data, function (dataItem) {
	      var name = dataItem.get('name', true);
	
	      if (!selected.hasOwnProperty(name)) {
	        selected[name] = true;
	      }
	
	      selected[name] = !selected[name];
	    });
	  };
	
	  LegendModel.prototype.isSelected = function (name) {
	    var selected = this.option.selected;
	    return !(selected.hasOwnProperty(name) && !selected[name]) && zrUtil.indexOf(this._availableNames, name) >= 0;
	  };
	
	  LegendModel.prototype.getOrient = function () {
	    return this.get('orient') === 'vertical' ? {
	      index: 1,
	      name: 'vertical'
	    } : {
	      index: 0,
	      name: 'horizontal'
	    };
	  };
	
	  LegendModel.type = 'legend.plain';
	  LegendModel.dependencies = ['series'];
	  LegendModel.defaultOption = {
	    zlevel: 0,
	    z: 4,
	    show: true,
	    orient: 'horizontal',
	    left: 'center',
	    top: 0,
	    align: 'auto',
	    backgroundColor: 'rgba(0,0,0,0)',
	    borderColor: '#ccc',
	    borderRadius: 0,
	    borderWidth: 0,
	    padding: 5,
	    itemGap: 10,
	    itemWidth: 25,
	    itemHeight: 14,
	    inactiveColor: '#ccc',
	    inactiveBorderColor: '#ccc',
	    itemStyle: {
	      borderWidth: 0
	    },
	    textStyle: {
	      color: '#333'
	    },
	    selectedMode: true,
	    selector: false,
	    selectorLabel: {
	      show: true,
	      borderRadius: 10,
	      padding: [3, 5, 3, 5],
	      fontSize: 12,
	      fontFamily: ' sans-serif',
	      color: '#666',
	      borderWidth: 1,
	      borderColor: '#666'
	    },
	    emphasis: {
	      selectorLabel: {
	        show: true,
	        color: '#eee',
	        backgroundColor: '#666'
	      }
	    },
	    selectorPosition: 'auto',
	    selectorItemGap: 7,
	    selectorButtonGap: 10,
	    tooltip: {
	      show: false
	    }
	  };
	  return LegendModel;
	}(Component_1["default"]);
	
	Component_1["default"].registerClass(LegendModel);
	exports["default"] = LegendModel;

/***/ },
/* 321 */
/***/ function(module, exports, __webpack_require__) {

	
	/*
	* Licensed to the Apache Software Foundation (ASF) under one
	* or more contributor license agreements.  See the NOTICE file
	* distributed with this work for additional information
	* regarding copyright ownership.  The ASF licenses this file
	* to you under the Apache License, Version 2.0 (the
	* "License"); you may not use this file except in compliance
	* with the License.  You may obtain a copy of the License at
	*
	*   http://www.apache.org/licenses/LICENSE-2.0
	*
	* Unless required by applicable law or agreed to in writing,
	* software distributed under the License is distributed on an
	* "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
	* KIND, either express or implied.  See the License for the
	* specific language governing permissions and limitations
	* under the License.
	*/
	
	
	
	/**
	 * AUTO-GENERATED FILE. DO NOT MODIFY.
	 */
	
	"use strict";
	
	exports.__esModule = true;
	
	var tslib_1 = __webpack_require__(3);
	
	var zrUtil = __webpack_require__(1);
	
	var symbol_1 = __webpack_require__(48);
	
	var graphic = __webpack_require__(7);
	
	var states_1 = __webpack_require__(22);
	
	var labelStyle_1 = __webpack_require__(20);
	
	var listComponent_1 = __webpack_require__(319);
	
	var layoutUtil = __webpack_require__(30);
	
	var Component_1 = __webpack_require__(18);
	
	var color_1 = __webpack_require__(34);
	
	var curry = zrUtil.curry;
	var each = zrUtil.each;
	var Group = graphic.Group;
	
	var LegendView = function (_super) {
	  tslib_1.__extends(LegendView, _super);
	
	  function LegendView() {
	    var _this = _super !== null && _super.apply(this, arguments) || this;
	
	    _this.type = LegendView.type;
	    _this.newlineDisabled = false;
	    return _this;
	  }
	
	  LegendView.prototype.init = function () {
	    this.group.add(this._contentGroup = new Group());
	    this.group.add(this._selectorGroup = new Group());
	    this._isFirstRender = true;
	  };
	
	  LegendView.prototype.getContentGroup = function () {
	    return this._contentGroup;
	  };
	
	  LegendView.prototype.getSelectorGroup = function () {
	    return this._selectorGroup;
	  };
	
	  LegendView.prototype.render = function (legendModel, ecModel, api) {
	    var isFirstRender = this._isFirstRender;
	    this._isFirstRender = false;
	    this.resetInner();
	
	    if (!legendModel.get('show', true)) {
	      return;
	    }
	
	    var itemAlign = legendModel.get('align');
	    var orient = legendModel.get('orient');
	
	    if (!itemAlign || itemAlign === 'auto') {
	      itemAlign = legendModel.get('left') === 'right' && orient === 'vertical' ? 'right' : 'left';
	    }
	
	    var selector = legendModel.get('selector', true);
	    var selectorPosition = legendModel.get('selectorPosition', true);
	
	    if (selector && (!selectorPosition || selectorPosition === 'auto')) {
	      selectorPosition = orient === 'horizontal' ? 'end' : 'start';
	    }
	
	    this.renderInner(itemAlign, legendModel, ecModel, api, selector, orient, selectorPosition);
	    var positionInfo = legendModel.getBoxLayoutParams();
	    var viewportSize = {
	      width: api.getWidth(),
	      height: api.getHeight()
	    };
	    var padding = legendModel.get('padding');
	    var maxSize = layoutUtil.getLayoutRect(positionInfo, viewportSize, padding);
	    var mainRect = this.layoutInner(legendModel, itemAlign, maxSize, isFirstRender, selector, selectorPosition);
	    var layoutRect = layoutUtil.getLayoutRect(zrUtil.defaults({
	      width: mainRect.width,
	      height: mainRect.height
	    }, positionInfo), viewportSize, padding);
	    this.group.x = layoutRect.x - mainRect.x;
	    this.group.y = layoutRect.y - mainRect.y;
	    this.group.markRedraw();
	    this.group.add(this._backgroundEl = listComponent_1.makeBackground(mainRect, legendModel));
	  };
	
	  LegendView.prototype.resetInner = function () {
	    this.getContentGroup().removeAll();
	    this._backgroundEl && this.group.remove(this._backgroundEl);
	    this.getSelectorGroup().removeAll();
	  };
	
	  LegendView.prototype.renderInner = function (itemAlign, legendModel, ecModel, api, selector, orient, selectorPosition) {
	    var contentGroup = this.getContentGroup();
	    var legendDrawnMap = zrUtil.createHashMap();
	    var selectMode = legendModel.get('selectedMode');
	    var excludeSeriesId = [];
	    ecModel.eachRawSeries(function (seriesModel) {
	      !seriesModel.get('legendHoverLink') && excludeSeriesId.push(seriesModel.id);
	    });
	    each(legendModel.getData(), function (itemModel, dataIndex) {
	      var name = itemModel.get('name');
	
	      if (!this.newlineDisabled && (name === '' || name === '\n')) {
	        var g = new Group();
	        g.newline = true;
	        contentGroup.add(g);
	        return;
	      }
	
	      var seriesModel = ecModel.getSeriesByName(name)[0];
	
	      if (legendDrawnMap.get(name)) {
	        return;
	      }
	
	      if (seriesModel) {
	        var data = seriesModel.getData();
	        var style = data.getVisual('style');
	        var color = style[data.getVisual('drawType')] || style.fill;
	        var borderColor = style.stroke;
	        var decal = style.decal;
	        var legendSymbolType = data.getVisual('legendSymbol') || 'roundRect';
	        var symbolType = data.getVisual('symbol');
	
	        var itemGroup = this._createItem(name, dataIndex, itemModel, legendModel, legendSymbolType, symbolType, itemAlign, color, borderColor, decal, selectMode);
	
	        itemGroup.on('click', curry(dispatchSelectAction, name, null, api, excludeSeriesId)).on('mouseover', curry(dispatchHighlightAction, seriesModel.name, null, api, excludeSeriesId)).on('mouseout', curry(dispatchDownplayAction, seriesModel.name, null, api, excludeSeriesId));
	        legendDrawnMap.set(name, true);
	      } else {
	        ecModel.eachRawSeries(function (seriesModel) {
	          if (legendDrawnMap.get(name)) {
	            return;
	          }
	
	          if (seriesModel.legendVisualProvider) {
	            var provider = seriesModel.legendVisualProvider;
	
	            if (!provider.containName(name)) {
	              return;
	            }
	
	            var idx = provider.indexOfName(name);
	            var style = provider.getItemVisual(idx, 'style');
	            var borderColor = style.stroke;
	            var decal = style.decal;
	            var color = style.fill;
	            var colorArr = color_1.parse(style.fill);
	
	            if (colorArr && colorArr[3] === 0) {
	              colorArr[3] = 0.2;
	              color = color_1.stringify(colorArr, 'rgba');
	            }
	
	            var legendSymbolType = 'roundRect';
	
	            var itemGroup = this._createItem(name, dataIndex, itemModel, legendModel, legendSymbolType, null, itemAlign, color, borderColor, decal, selectMode);
	
	            itemGroup.on('click', curry(dispatchSelectAction, null, name, api, excludeSeriesId)).on('mouseover', curry(dispatchHighlightAction, null, name, api, excludeSeriesId)).on('mouseout', curry(dispatchDownplayAction, null, name, api, excludeSeriesId));
	            legendDrawnMap.set(name, true);
	          }
	        }, this);
	      }
	
	      if (false) {
	        if (!legendDrawnMap.get(name)) {
	          console.warn(name + ' series not exists. Legend data should be same with series name or data name.');
	        }
	      }
	    }, this);
	
	    if (selector) {
	      this._createSelector(selector, legendModel, api, orient, selectorPosition);
	    }
	  };
	
	  LegendView.prototype._createSelector = function (selector, legendModel, api, orient, selectorPosition) {
	    var selectorGroup = this.getSelectorGroup();
	    each(selector, function createSelectorButton(selectorItem) {
	      var type = selectorItem.type;
	      var labelText = new graphic.Text({
	        style: {
	          x: 0,
	          y: 0,
	          align: 'center',
	          verticalAlign: 'middle'
	        },
	        onclick: function () {
	          api.dispatchAction({
	            type: type === 'all' ? 'legendAllSelect' : 'legendInverseSelect'
	          });
	        }
	      });
	      selectorGroup.add(labelText);
	      var labelModel = legendModel.getModel('selectorLabel');
	      var emphasisLabelModel = legendModel.getModel(['emphasis', 'selectorLabel']);
	      labelStyle_1.setLabelStyle(labelText, {
	        normal: labelModel,
	        emphasis: emphasisLabelModel
	      }, {
	        defaultText: selectorItem.title
	      });
	      states_1.enableHoverEmphasis(labelText);
	    });
	  };
	
	  LegendView.prototype._createItem = function (name, dataIndex, itemModel, legendModel, legendSymbolType, symbolType, itemAlign, color, borderColor, decal, selectMode) {
	    var itemWidth = legendModel.get('itemWidth');
	    var itemHeight = legendModel.get('itemHeight');
	    var inactiveColor = legendModel.get('inactiveColor');
	    var inactiveBorderColor = legendModel.get('inactiveBorderColor');
	    var symbolKeepAspect = legendModel.get('symbolKeepAspect');
	    var legendModelItemStyle = legendModel.getModel('itemStyle');
	    var isSelected = legendModel.isSelected(name);
	    var itemGroup = new Group();
	    var textStyleModel = itemModel.getModel('textStyle');
	    var itemIcon = itemModel.get('icon');
	    var tooltipModel = itemModel.getModel('tooltip');
	    var legendGlobalTooltipModel = tooltipModel.parentModel;
	    legendSymbolType = itemIcon || legendSymbolType;
	    var legendSymbol = symbol_1.createSymbol(legendSymbolType, 0, 0, itemWidth, itemHeight, isSelected ? color : inactiveColor, symbolKeepAspect == null ? true : symbolKeepAspect);
	    itemGroup.add(setSymbolStyle(legendSymbol, legendSymbolType, legendModelItemStyle, borderColor, inactiveBorderColor, decal, isSelected));
	
	    if (!itemIcon && symbolType && (symbolType !== legendSymbolType || symbolType === 'none')) {
	      var size = itemHeight * 0.8;
	
	      if (symbolType === 'none') {
	        symbolType = 'circle';
	      }
	
	      var legendSymbolCenter = symbol_1.createSymbol(symbolType, (itemWidth - size) / 2, (itemHeight - size) / 2, size, size, isSelected ? color : inactiveColor, symbolKeepAspect == null ? true : symbolKeepAspect);
	      itemGroup.add(setSymbolStyle(legendSymbolCenter, symbolType, legendModelItemStyle, borderColor, inactiveBorderColor, decal, isSelected));
	    }
	
	    var textX = itemAlign === 'left' ? itemWidth + 5 : -5;
	    var textAlign = itemAlign;
	    var formatter = legendModel.get('formatter');
	    var content = name;
	
	    if (typeof formatter === 'string' && formatter) {
	      content = formatter.replace('{name}', name != null ? name : '');
	    } else if (typeof formatter === 'function') {
	      content = formatter(name);
	    }
	
	    itemGroup.add(new graphic.Text({
	      style: labelStyle_1.createTextStyle(textStyleModel, {
	        text: content,
	        x: textX,
	        y: itemHeight / 2,
	        fill: isSelected ? textStyleModel.getTextColor() : inactiveColor,
	        align: textAlign,
	        verticalAlign: 'middle'
	      })
	    }));
	    var hitRect = new graphic.Rect({
	      shape: itemGroup.getBoundingRect(),
	      invisible: true
	    });
	
	    if (tooltipModel.get('show')) {
	      var formatterParams = {
	        componentType: 'legend',
	        legendIndex: legendModel.componentIndex,
	        name: name,
	        $vars: ['name']
	      };
	      hitRect.tooltip = zrUtil.extend({
	        content: name,
	        formatter: legendGlobalTooltipModel.get('formatter', true) || function (params) {
	          return params.name;
	        },
	        formatterParams: formatterParams
	      }, tooltipModel.option);
	    }
	
	    itemGroup.add(hitRect);
	    itemGroup.eachChild(function (child) {
	      child.silent = true;
	    });
	    hitRect.silent = !selectMode;
	    this.getContentGroup().add(itemGroup);
	    states_1.enableHoverEmphasis(itemGroup);
	    itemGroup.__legendDataIndex = dataIndex;
	    return itemGroup;
	  };
	
	  LegendView.prototype.layoutInner = function (legendModel, itemAlign, maxSize, isFirstRender, selector, selectorPosition) {
	    var contentGroup = this.getContentGroup();
	    var selectorGroup = this.getSelectorGroup();
	    layoutUtil.box(legendModel.get('orient'), contentGroup, legendModel.get('itemGap'), maxSize.width, maxSize.height);
	    var contentRect = contentGroup.getBoundingRect();
	    var contentPos = [-contentRect.x, -contentRect.y];
	    selectorGroup.markRedraw();
	    contentGroup.markRedraw();
	
	    if (selector) {
	      layoutUtil.box('horizontal', selectorGroup, legendModel.get('selectorItemGap', true));
	      var selectorRect = selectorGroup.getBoundingRect();
	      var selectorPos = [-selectorRect.x, -selectorRect.y];
	      var selectorButtonGap = legendModel.get('selectorButtonGap', true);
	      var orientIdx = legendModel.getOrient().index;
	      var wh = orientIdx === 0 ? 'width' : 'height';
	      var hw = orientIdx === 0 ? 'height' : 'width';
	      var yx = orientIdx === 0 ? 'y' : 'x';
	
	      if (selectorPosition === 'end') {
	        selectorPos[orientIdx] += contentRect[wh] + selectorButtonGap;
	      } else {
	        contentPos[orientIdx] += selectorRect[wh] + selectorButtonGap;
	      }
	
	      selectorPos[1 - orientIdx] += contentRect[hw] / 2 - selectorRect[hw] / 2;
	      selectorGroup.x = selectorPos[0];
	      selectorGroup.y = selectorPos[1];
	      contentGroup.x = contentPos[0];
	      contentGroup.y = contentPos[1];
	      var mainRect = {
	        x: 0,
	        y: 0
	      };
	      mainRect[wh] = contentRect[wh] + selectorButtonGap + selectorRect[wh];
	      mainRect[hw] = Math.max(contentRect[hw], selectorRect[hw]);
	      mainRect[yx] = Math.min(0, selectorRect[yx] + selectorPos[1 - orientIdx]);
	      return mainRect;
	    } else {
	      contentGroup.x = contentPos[0];
	      contentGroup.y = contentPos[1];
	      return this.group.getBoundingRect();
	    }
	  };
	
	  LegendView.prototype.remove = function () {
	    this.getContentGroup().removeAll();
	    this._isFirstRender = true;
	  };
	
	  LegendView.type = 'legend.plain';
	  return LegendView;
	}(Component_1["default"]);
	
	function setSymbolStyle(symbol, symbolType, legendModelItemStyle, borderColor, inactiveBorderColor, decal, isSelected) {
	  var itemStyle;
	
	  if (symbolType !== 'line' && symbolType.indexOf('empty') < 0) {
	    itemStyle = legendModelItemStyle.getItemStyle();
	    symbol.style.stroke = borderColor;
	    symbol.style.decal = decal;
	
	    if (!isSelected) {
	      itemStyle.stroke = inactiveBorderColor;
	    }
	  } else {
	    itemStyle = legendModelItemStyle.getItemStyle(['borderWidth', 'borderColor']);
	  }
	
	  symbol.setStyle(itemStyle);
	  return symbol;
	}
	
	function dispatchSelectAction(seriesName, dataName, api, excludeSeriesId) {
	  dispatchDownplayAction(seriesName, dataName, api, excludeSeriesId);
	  api.dispatchAction({
	    type: 'legendToggleSelect',
	    name: seriesName != null ? seriesName : dataName
	  });
	  dispatchHighlightAction(seriesName, dataName, api, excludeSeriesId);
	}
	
	function isUseHoverLayer(api) {
	  var list = api.getZr().storage.getDisplayList();
	  var emphasisState;
	  var i = 0;
	  var len = list.length;
	
	  while (i < len && !(emphasisState = list[i].states.emphasis)) {
	    i++;
	  }
	
	  return emphasisState && emphasisState.hoverLayer;
	}
	
	function dispatchHighlightAction(seriesName, dataName, api, excludeSeriesId) {
	  if (!isUseHoverLayer(api)) {
	    api.dispatchAction({
	      type: 'highlight',
	      seriesName: seriesName,
	      name: dataName,
	      excludeSeriesId: excludeSeriesId
	    });
	  }
	}
	
	function dispatchDownplayAction(seriesName, dataName, api, excludeSeriesId) {
	  if (!isUseHoverLayer(api)) {
	    api.dispatchAction({
	      type: 'downplay',
	      seriesName: seriesName,
	      name: dataName,
	      excludeSeriesId: excludeSeriesId
	    });
	  }
	}
	
	Component_1["default"].registerClass(LegendView);
	exports["default"] = LegendView;

/***/ },
/* 322 */
/***/ function(module, exports, __webpack_require__) {

	
	/*
	* Licensed to the Apache Software Foundation (ASF) under one
	* or more contributor license agreements.  See the NOTICE file
	* distributed with this work for additional information
	* regarding copyright ownership.  The ASF licenses this file
	* to you under the Apache License, Version 2.0 (the
	* "License"); you may not use this file except in compliance
	* with the License.  You may obtain a copy of the License at
	*
	*   http://www.apache.org/licenses/LICENSE-2.0
	*
	* Unless required by applicable law or agreed to in writing,
	* software distributed under the License is distributed on an
	* "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
	* KIND, either express or implied.  See the License for the
	* specific language governing permissions and limitations
	* under the License.
	*/
	
	
	
	/**
	 * AUTO-GENERATED FILE. DO NOT MODIFY.
	 */
	
	"use strict";
	
	exports.__esModule = true;
	
	var echarts = __webpack_require__(6);
	
	var zrUtil = __webpack_require__(1);
	
	function legendSelectActionHandler(methodName, payload, ecModel) {
	  var selectedMap = {};
	  var isToggleSelect = methodName === 'toggleSelected';
	  var isSelected;
	  ecModel.eachComponent('legend', function (legendModel) {
	    if (isToggleSelect && isSelected != null) {
	      legendModel[isSelected ? 'select' : 'unSelect'](payload.name);
	    } else if (methodName === 'allSelect' || methodName === 'inverseSelect') {
	      legendModel[methodName]();
	    } else {
	      legendModel[methodName](payload.name);
	      isSelected = legendModel.isSelected(payload.name);
	    }
	
	    var legendData = legendModel.getData();
	    zrUtil.each(legendData, function (model) {
	      var name = model.get('name');
	
	      if (name === '\n' || name === '') {
	        return;
	      }
	
	      var isItemSelected = legendModel.isSelected(name);
	
	      if (selectedMap.hasOwnProperty(name)) {
	        selectedMap[name] = selectedMap[name] && isItemSelected;
	      } else {
	        selectedMap[name] = isItemSelected;
	      }
	    });
	  });
	  return methodName === 'allSelect' || methodName === 'inverseSelect' ? {
	    selected: selectedMap
	  } : {
	    name: payload.name,
	    selected: selectedMap
	  };
	}
	
	echarts.registerAction('legendToggleSelect', 'legendselectchanged', zrUtil.curry(legendSelectActionHandler, 'toggleSelected'));
	echarts.registerAction('legendAllSelect', 'legendselectall', zrUtil.curry(legendSelectActionHandler, 'allSelect'));
	echarts.registerAction('legendInverseSelect', 'legendinverseselect', zrUtil.curry(legendSelectActionHandler, 'inverseSelect'));
	echarts.registerAction('legendSelect', 'legendselected', zrUtil.curry(legendSelectActionHandler, 'select'));
	echarts.registerAction('legendUnSelect', 'legendunselected', zrUtil.curry(legendSelectActionHandler, 'unSelect'));

/***/ },
/* 323 */
/***/ function(module, exports) {

	
	/*
	* Licensed to the Apache Software Foundation (ASF) under one
	* or more contributor license agreements.  See the NOTICE file
	* distributed with this work for additional information
	* regarding copyright ownership.  The ASF licenses this file
	* to you under the Apache License, Version 2.0 (the
	* "License"); you may not use this file except in compliance
	* with the License.  You may obtain a copy of the License at
	*
	*   http://www.apache.org/licenses/LICENSE-2.0
	*
	* Unless required by applicable law or agreed to in writing,
	* software distributed under the License is distributed on an
	* "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
	* KIND, either express or implied.  See the License for the
	* specific language governing permissions and limitations
	* under the License.
	*/
	
	
	
	/**
	 * AUTO-GENERATED FILE. DO NOT MODIFY.
	 */
	
	"use strict";
	
	exports.__esModule = true;
	
	function legendFilter(ecModel) {
	  var legendModels = ecModel.findComponents({
	    mainType: 'legend'
	  });
	
	  if (legendModels && legendModels.length) {
	    ecModel.filterSeries(function (series) {
	      for (var i = 0; i < legendModels.length; i++) {
	        if (!legendModels[i].isSelected(series.name)) {
	          return false;
	        }
	      }
	
	      return true;
	    });
	  }
	}
	
	exports["default"] = legendFilter;

/***/ },
/* 324 */
/***/ function(module, exports, __webpack_require__) {

	
	/*
	* Licensed to the Apache Software Foundation (ASF) under one
	* or more contributor license agreements.  See the NOTICE file
	* distributed with this work for additional information
	* regarding copyright ownership.  The ASF licenses this file
	* to you under the Apache License, Version 2.0 (the
	* "License"); you may not use this file except in compliance
	* with the License.  You may obtain a copy of the License at
	*
	*   http://www.apache.org/licenses/LICENSE-2.0
	*
	* Unless required by applicable law or agreed to in writing,
	* software distributed under the License is distributed on an
	* "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
	* KIND, either express or implied.  See the License for the
	* specific language governing permissions and limitations
	* under the License.
	*/
	
	
	
	/**
	 * AUTO-GENERATED FILE. DO NOT MODIFY.
	 */
	
	"use strict";
	
	exports.__esModule = true;
	
	var tslib_1 = __webpack_require__(3);
	
	var MarkerModel_1 = __webpack_require__(86);
	
	var Component_1 = __webpack_require__(10);
	
	var MarkLineModel = function (_super) {
	  tslib_1.__extends(MarkLineModel, _super);
	
	  function MarkLineModel() {
	    var _this = _super !== null && _super.apply(this, arguments) || this;
	
	    _this.type = MarkLineModel.type;
	    return _this;
	  }
	
	  MarkLineModel.prototype.createMarkerModelFromSeries = function (markerOpt, masterMarkerModel, ecModel) {
	    return new MarkLineModel(markerOpt, masterMarkerModel, ecModel);
	  };
	
	  MarkLineModel.type = 'markLine';
	  MarkLineModel.defaultOption = {
	    zlevel: 0,
	    z: 5,
	    symbol: ['circle', 'arrow'],
	    symbolSize: [8, 16],
	    precision: 2,
	    tooltip: {
	      trigger: 'item'
	    },
	    label: {
	      show: true,
	      position: 'end',
	      distance: 5
	    },
	    lineStyle: {
	      type: 'dashed'
	    },
	    emphasis: {
	      label: {
	        show: true
	      },
	      lineStyle: {
	        width: 3
	      }
	    },
	    animationEasing: 'linear'
	  };
	  return MarkLineModel;
	}(MarkerModel_1["default"]);
	
	Component_1["default"].registerClass(MarkLineModel);
	exports["default"] = MarkLineModel;

/***/ },
/* 325 */
/***/ function(module, exports, __webpack_require__) {

	
	/*
	* Licensed to the Apache Software Foundation (ASF) under one
	* or more contributor license agreements.  See the NOTICE file
	* distributed with this work for additional information
	* regarding copyright ownership.  The ASF licenses this file
	* to you under the Apache License, Version 2.0 (the
	* "License"); you may not use this file except in compliance
	* with the License.  You may obtain a copy of the License at
	*
	*   http://www.apache.org/licenses/LICENSE-2.0
	*
	* Unless required by applicable law or agreed to in writing,
	* software distributed under the License is distributed on an
	* "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
	* KIND, either express or implied.  See the License for the
	* specific language governing permissions and limitations
	* under the License.
	*/
	
	
	
	/**
	 * AUTO-GENERATED FILE. DO NOT MODIFY.
	 */
	
	"use strict";
	
	exports.__esModule = true;
	
	var tslib_1 = __webpack_require__(3);
	
	var List_1 = __webpack_require__(144);
	
	var numberUtil = __webpack_require__(9);
	
	var markerHelper = __webpack_require__(327);
	
	var LineDraw_1 = __webpack_require__(294);
	
	var MarkerView_1 = __webpack_require__(326);
	
	var dataStackHelper_1 = __webpack_require__(40);
	
	var CoordinateSystem_1 = __webpack_require__(87);
	
	var innerStore_1 = __webpack_require__(21);
	
	var MarkerModel_1 = __webpack_require__(86);
	
	var util_1 = __webpack_require__(1);
	
	var Component_1 = __webpack_require__(18);
	
	var model_1 = __webpack_require__(4);
	
	var helper_1 = __webpack_require__(156);
	
	var inner = model_1.makeInner();
	
	var markLineTransform = function (seriesModel, coordSys, mlModel, item) {
	  var data = seriesModel.getData();
	  var itemArray;
	
	  if (!util_1.isArray(item)) {
	    var mlType = item.type;
	
	    if (mlType === 'min' || mlType === 'max' || mlType === 'average' || mlType === 'median' || item.xAxis != null || item.yAxis != null) {
	      var valueAxis = void 0;
	      var value = void 0;
	
	      if (item.yAxis != null || item.xAxis != null) {
	        valueAxis = coordSys.getAxis(item.yAxis != null ? 'y' : 'x');
	        value = util_1.retrieve(item.yAxis, item.xAxis);
	      } else {
	        var axisInfo = markerHelper.getAxisInfo(item, data, coordSys, seriesModel);
	        valueAxis = axisInfo.valueAxis;
	        var valueDataDim = dataStackHelper_1.getStackedDimension(data, axisInfo.valueDataDim);
	        value = markerHelper.numCalculate(data, valueDataDim, mlType);
	      }
	
	      var valueIndex = valueAxis.dim === 'x' ? 0 : 1;
	      var baseIndex = 1 - valueIndex;
	      var mlFrom = util_1.clone(item);
	      var mlTo = {
	        coord: []
	      };
	      mlFrom.type = null;
	      mlFrom.coord = [];
	      mlFrom.coord[baseIndex] = -Infinity;
	      mlTo.coord[baseIndex] = Infinity;
	      var precision = mlModel.get('precision');
	
	      if (precision >= 0 && typeof value === 'number') {
	        value = +value.toFixed(Math.min(precision, 20));
	      }
	
	      mlFrom.coord[valueIndex] = mlTo.coord[valueIndex] = value;
	      itemArray = [mlFrom, mlTo, {
	        type: mlType,
	        valueIndex: item.valueIndex,
	        value: value
	      }];
	    } else {
	      if (false) {
	        util_1.logError('Invalid markLine data.');
	      }
	
	      itemArray = [];
	    }
	  } else {
	    itemArray = item;
	  }
	
	  var normalizedItem = [markerHelper.dataTransform(seriesModel, itemArray[0]), markerHelper.dataTransform(seriesModel, itemArray[1]), util_1.extend({}, itemArray[2])];
	  normalizedItem[2].type = normalizedItem[2].type || null;
	  util_1.merge(normalizedItem[2], normalizedItem[0]);
	  util_1.merge(normalizedItem[2], normalizedItem[1]);
	  return normalizedItem;
	};
	
	function isInifinity(val) {
	  return !isNaN(val) && !isFinite(val);
	}
	
	function ifMarkLineHasOnlyDim(dimIndex, fromCoord, toCoord, coordSys) {
	  var otherDimIndex = 1 - dimIndex;
	  var dimName = coordSys.dimensions[dimIndex];
	  return isInifinity(fromCoord[otherDimIndex]) && isInifinity(toCoord[otherDimIndex]) && fromCoord[dimIndex] === toCoord[dimIndex] && coordSys.getAxis(dimName).containData(fromCoord[dimIndex]);
	}
	
	function markLineFilter(coordSys, item) {
	  if (coordSys.type === 'cartesian2d') {
	    var fromCoord = item[0].coord;
	    var toCoord = item[1].coord;
	
	    if (fromCoord && toCoord && (ifMarkLineHasOnlyDim(1, fromCoord, toCoord, coordSys) || ifMarkLineHasOnlyDim(0, fromCoord, toCoord, coordSys))) {
	      return true;
	    }
	  }
	
	  return markerHelper.dataFilter(coordSys, item[0]) && markerHelper.dataFilter(coordSys, item[1]);
	}
	
	function updateSingleMarkerEndLayout(data, idx, isFrom, seriesModel, api) {
	  var coordSys = seriesModel.coordinateSystem;
	  var itemModel = data.getItemModel(idx);
	  var point;
	  var xPx = numberUtil.parsePercent(itemModel.get('x'), api.getWidth());
	  var yPx = numberUtil.parsePercent(itemModel.get('y'), api.getHeight());
	
	  if (!isNaN(xPx) && !isNaN(yPx)) {
	    point = [xPx, yPx];
	  } else {
	    if (seriesModel.getMarkerPosition) {
	      point = seriesModel.getMarkerPosition(data.getValues(data.dimensions, idx));
	    } else {
	      var dims = coordSys.dimensions;
	      var x = data.get(dims[0], idx);
	      var y = data.get(dims[1], idx);
	      point = coordSys.dataToPoint([x, y]);
	    }
	
	    if (CoordinateSystem_1.isCoordinateSystemType(coordSys, 'cartesian2d')) {
	      var xAxis = coordSys.getAxis('x');
	      var yAxis = coordSys.getAxis('y');
	      var dims = coordSys.dimensions;
	
	      if (isInifinity(data.get(dims[0], idx))) {
	        point[0] = xAxis.toGlobalCoord(xAxis.getExtent()[isFrom ? 0 : 1]);
	      } else if (isInifinity(data.get(dims[1], idx))) {
	        point[1] = yAxis.toGlobalCoord(yAxis.getExtent()[isFrom ? 0 : 1]);
	      }
	    }
	
	    if (!isNaN(xPx)) {
	      point[0] = xPx;
	    }
	
	    if (!isNaN(yPx)) {
	      point[1] = yPx;
	    }
	  }
	
	  data.setItemLayout(idx, point);
	}
	
	var MarkLineView = function (_super) {
	  tslib_1.__extends(MarkLineView, _super);
	
	  function MarkLineView() {
	    var _this = _super !== null && _super.apply(this, arguments) || this;
	
	    _this.type = MarkLineView.type;
	    return _this;
	  }
	
	  MarkLineView.prototype.updateTransform = function (markLineModel, ecModel, api) {
	    ecModel.eachSeries(function (seriesModel) {
	      var mlModel = MarkerModel_1["default"].getMarkerModelFromSeries(seriesModel, 'markLine');
	
	      if (mlModel) {
	        var mlData_1 = mlModel.getData();
	        var fromData_1 = inner(mlModel).from;
	        var toData_1 = inner(mlModel).to;
	        fromData_1.each(function (idx) {
	          updateSingleMarkerEndLayout(fromData_1, idx, true, seriesModel, api);
	          updateSingleMarkerEndLayout(toData_1, idx, false, seriesModel, api);
	        });
	        mlData_1.each(function (idx) {
	          mlData_1.setItemLayout(idx, [fromData_1.getItemLayout(idx), toData_1.getItemLayout(idx)]);
	        });
	        this.markerGroupMap.get(seriesModel.id).updateLayout();
	      }
	    }, this);
	  };
	
	  MarkLineView.prototype.renderSeries = function (seriesModel, mlModel, ecModel, api) {
	    var coordSys = seriesModel.coordinateSystem;
	    var seriesId = seriesModel.id;
	    var seriesData = seriesModel.getData();
	    var lineDrawMap = this.markerGroupMap;
	    var lineDraw = lineDrawMap.get(seriesId) || lineDrawMap.set(seriesId, new LineDraw_1["default"]());
	    this.group.add(lineDraw.group);
	    var mlData = createList(coordSys, seriesModel, mlModel);
	    var fromData = mlData.from;
	    var toData = mlData.to;
	    var lineData = mlData.line;
	    inner(mlModel).from = fromData;
	    inner(mlModel).to = toData;
	    mlModel.setData(lineData);
	    var symbolType = mlModel.get('symbol');
	    var symbolSize = mlModel.get('symbolSize');
	
	    if (!util_1.isArray(symbolType)) {
	      symbolType = [symbolType, symbolType];
	    }
	
	    if (!util_1.isArray(symbolSize)) {
	      symbolSize = [symbolSize, symbolSize];
	    }
	
	    mlData.from.each(function (idx) {
	      updateDataVisualAndLayout(fromData, idx, true);
	      updateDataVisualAndLayout(toData, idx, false);
	    });
	    lineData.each(function (idx) {
	      var lineStyle = lineData.getItemModel(idx).getModel('lineStyle').getLineStyle();
	      lineData.setItemLayout(idx, [fromData.getItemLayout(idx), toData.getItemLayout(idx)]);
	
	      if (lineStyle.stroke == null) {
	        lineStyle.stroke = fromData.getItemVisual(idx, 'style').fill;
	      }
	
	      lineData.setItemVisual(idx, {
	        fromSymbolRotate: fromData.getItemVisual(idx, 'symbolRotate'),
	        fromSymbolSize: fromData.getItemVisual(idx, 'symbolSize'),
	        fromSymbol: fromData.getItemVisual(idx, 'symbol'),
	        toSymbolRotate: toData.getItemVisual(idx, 'symbolRotate'),
	        toSymbolSize: toData.getItemVisual(idx, 'symbolSize'),
	        toSymbol: toData.getItemVisual(idx, 'symbol'),
	        style: lineStyle
	      });
	    });
	    lineDraw.updateData(lineData);
	    mlData.line.eachItemGraphicEl(function (el, idx) {
	      el.traverse(function (child) {
	        innerStore_1.getECData(child).dataModel = mlModel;
	      });
	    });
	
	    function updateDataVisualAndLayout(data, idx, isFrom) {
	      var itemModel = data.getItemModel(idx);
	      updateSingleMarkerEndLayout(data, idx, isFrom, seriesModel, api);
	      var style = itemModel.getModel('itemStyle').getItemStyle();
	
	      if (style.fill == null) {
	        style.fill = helper_1.getVisualFromData(seriesData, 'color');
	      }
	
	      data.setItemVisual(idx, {
	        symbolRotate: itemModel.get('symbolRotate'),
	        symbolSize: itemModel.get('symbolSize') || symbolSize[isFrom ? 0 : 1],
	        symbol: itemModel.get('symbol', true) || symbolType[isFrom ? 0 : 1],
	        style: style
	      });
	    }
	
	    this.markKeep(lineDraw);
	    lineDraw.group.silent = mlModel.get('silent') || seriesModel.get('silent');
	  };
	
	  MarkLineView.type = 'markLine';
	  return MarkLineView;
	}(MarkerView_1["default"]);
	
	function createList(coordSys, seriesModel, mlModel) {
	  var coordDimsInfos;
	
	  if (coordSys) {
	    coordDimsInfos = util_1.map(coordSys && coordSys.dimensions, function (coordDim) {
	      var info = seriesModel.getData().getDimensionInfo(seriesModel.getData().mapDimension(coordDim)) || {};
	      return util_1.defaults({
	        name: coordDim
	      }, info);
	    });
	  } else {
	    coordDimsInfos = [{
	      name: 'value',
	      type: 'float'
	    }];
	  }
	
	  var fromData = new List_1["default"](coordDimsInfos, mlModel);
	  var toData = new List_1["default"](coordDimsInfos, mlModel);
	  var lineData = new List_1["default"]([], mlModel);
	  var optData = util_1.map(mlModel.get('data'), util_1.curry(markLineTransform, seriesModel, coordSys, mlModel));
	
	  if (coordSys) {
	    optData = util_1.filter(optData, util_1.curry(markLineFilter, coordSys));
	  }
	
	  var dimValueGetter = coordSys ? markerHelper.dimValueGetter : function (item) {
	    return item.value;
	  };
	  fromData.initData(util_1.map(optData, function (item) {
	    return item[0];
	  }), null, dimValueGetter);
	  toData.initData(util_1.map(optData, function (item) {
	    return item[1];
	  }), null, dimValueGetter);
	  lineData.initData(util_1.map(optData, function (item) {
	    return item[2];
	  }));
	  lineData.hasItemOption = true;
	  return {
	    from: fromData,
	    to: toData,
	    line: lineData
	  };
	}
	
	Component_1["default"].registerClass(MarkLineView);

/***/ },
/* 326 */
/***/ function(module, exports, __webpack_require__) {

	
	/*
	* Licensed to the Apache Software Foundation (ASF) under one
	* or more contributor license agreements.  See the NOTICE file
	* distributed with this work for additional information
	* regarding copyright ownership.  The ASF licenses this file
	* to you under the Apache License, Version 2.0 (the
	* "License"); you may not use this file except in compliance
	* with the License.  You may obtain a copy of the License at
	*
	*   http://www.apache.org/licenses/LICENSE-2.0
	*
	* Unless required by applicable law or agreed to in writing,
	* software distributed under the License is distributed on an
	* "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
	* KIND, either express or implied.  See the License for the
	* specific language governing permissions and limitations
	* under the License.
	*/
	
	
	
	/**
	 * AUTO-GENERATED FILE. DO NOT MODIFY.
	 */
	
	"use strict";
	
	exports.__esModule = true;
	
	var tslib_1 = __webpack_require__(3);
	
	var Component_1 = __webpack_require__(18);
	
	var util_1 = __webpack_require__(1);
	
	var MarkerModel_1 = __webpack_require__(86);
	
	var model_1 = __webpack_require__(4);
	
	var states_1 = __webpack_require__(22);
	
	var inner = model_1.makeInner();
	
	var MarkerView = function (_super) {
	  tslib_1.__extends(MarkerView, _super);
	
	  function MarkerView() {
	    var _this = _super !== null && _super.apply(this, arguments) || this;
	
	    _this.type = MarkerView.type;
	    return _this;
	  }
	
	  MarkerView.prototype.init = function () {
	    this.markerGroupMap = util_1.createHashMap();
	  };
	
	  MarkerView.prototype.render = function (markerModel, ecModel, api) {
	    var _this = this;
	
	    var markerGroupMap = this.markerGroupMap;
	    markerGroupMap.each(function (item) {
	      inner(item).keep = false;
	    });
	    ecModel.eachSeries(function (seriesModel) {
	      var markerModel = MarkerModel_1["default"].getMarkerModelFromSeries(seriesModel, _this.type);
	      markerModel && _this.renderSeries(seriesModel, markerModel, ecModel, api);
	    });
	    markerGroupMap.each(function (item) {
	      !inner(item).keep && _this.group.remove(item.group);
	    });
	  };
	
	  MarkerView.prototype.markKeep = function (drawGroup) {
	    inner(drawGroup).keep = true;
	  };
	
	  MarkerView.prototype.blurSeries = function (seriesModelList) {
	    var _this = this;
	
	    util_1.each(seriesModelList, function (seriesModel) {
	      var markerModel = MarkerModel_1["default"].getMarkerModelFromSeries(seriesModel, _this.type);
	
	      if (markerModel) {
	        var data = markerModel.getData();
	        data.eachItemGraphicEl(function (el) {
	          if (el) {
	            states_1.enterBlur(el);
	          }
	        });
	      }
	    });
	  };
	
	  MarkerView.type = 'marker';
	  return MarkerView;
	}(Component_1["default"]);
	
	exports["default"] = MarkerView;

/***/ },
/* 327 */
/***/ function(module, exports, __webpack_require__) {

	
	/*
	* Licensed to the Apache Software Foundation (ASF) under one
	* or more contributor license agreements.  See the NOTICE file
	* distributed with this work for additional information
	* regarding copyright ownership.  The ASF licenses this file
	* to you under the Apache License, Version 2.0 (the
	* "License"); you may not use this file except in compliance
	* with the License.  You may obtain a copy of the License at
	*
	*   http://www.apache.org/licenses/LICENSE-2.0
	*
	* Unless required by applicable law or agreed to in writing,
	* software distributed under the License is distributed on an
	* "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
	* KIND, either express or implied.  See the License for the
	* specific language governing permissions and limitations
	* under the License.
	*/
	
	
	
	/**
	 * AUTO-GENERATED FILE. DO NOT MODIFY.
	 */
	
	"use strict";
	
	exports.__esModule = true;
	
	var numberUtil = __webpack_require__(9);
	
	var dataStackHelper_1 = __webpack_require__(40);
	
	var util_1 = __webpack_require__(1);
	
	function hasXOrY(item) {
	  return !(isNaN(parseFloat(item.x)) && isNaN(parseFloat(item.y)));
	}
	
	function hasXAndY(item) {
	  return !isNaN(parseFloat(item.x)) && !isNaN(parseFloat(item.y));
	}
	
	function markerTypeCalculatorWithExtent(markerType, data, otherDataDim, targetDataDim, otherCoordIndex, targetCoordIndex) {
	  var coordArr = [];
	  var stacked = dataStackHelper_1.isDimensionStacked(data, targetDataDim);
	  var calcDataDim = stacked ? data.getCalculationInfo('stackResultDimension') : targetDataDim;
	  var value = numCalculate(data, calcDataDim, markerType);
	  var dataIndex = data.indicesOfNearest(calcDataDim, value)[0];
	  coordArr[otherCoordIndex] = data.get(otherDataDim, dataIndex);
	  coordArr[targetCoordIndex] = data.get(calcDataDim, dataIndex);
	  var coordArrValue = data.get(targetDataDim, dataIndex);
	  var precision = numberUtil.getPrecision(data.get(targetDataDim, dataIndex));
	  precision = Math.min(precision, 20);
	
	  if (precision >= 0) {
	    coordArr[targetCoordIndex] = +coordArr[targetCoordIndex].toFixed(precision);
	  }
	
	  return [coordArr, coordArrValue];
	}
	
	var markerTypeCalculator = {
	  min: util_1.curry(markerTypeCalculatorWithExtent, 'min'),
	  max: util_1.curry(markerTypeCalculatorWithExtent, 'max'),
	  average: util_1.curry(markerTypeCalculatorWithExtent, 'average'),
	  median: util_1.curry(markerTypeCalculatorWithExtent, 'median')
	};
	
	function dataTransform(seriesModel, item) {
	  var data = seriesModel.getData();
	  var coordSys = seriesModel.coordinateSystem;
	
	  if (item && !hasXAndY(item) && !util_1.isArray(item.coord) && coordSys) {
	    var dims = coordSys.dimensions;
	    var axisInfo = getAxisInfo(item, data, coordSys, seriesModel);
	    item = util_1.clone(item);
	
	    if (item.type && markerTypeCalculator[item.type] && axisInfo.baseAxis && axisInfo.valueAxis) {
	      var otherCoordIndex = util_1.indexOf(dims, axisInfo.baseAxis.dim);
	      var targetCoordIndex = util_1.indexOf(dims, axisInfo.valueAxis.dim);
	      var coordInfo = markerTypeCalculator[item.type](data, axisInfo.baseDataDim, axisInfo.valueDataDim, otherCoordIndex, targetCoordIndex);
	      item.coord = coordInfo[0];
	      item.value = coordInfo[1];
	    } else {
	      var coord = [item.xAxis != null ? item.xAxis : item.radiusAxis, item.yAxis != null ? item.yAxis : item.angleAxis];
	
	      for (var i = 0; i < 2; i++) {
	        if (markerTypeCalculator[coord[i]]) {
	          coord[i] = numCalculate(data, data.mapDimension(dims[i]), coord[i]);
	        }
	      }
	
	      item.coord = coord;
	    }
	  }
	
	  return item;
	}
	
	exports.dataTransform = dataTransform;
	
	function getAxisInfo(item, data, coordSys, seriesModel) {
	  var ret = {};
	
	  if (item.valueIndex != null || item.valueDim != null) {
	    ret.valueDataDim = item.valueIndex != null ? data.getDimension(item.valueIndex) : item.valueDim;
	    ret.valueAxis = coordSys.getAxis(dataDimToCoordDim(seriesModel, ret.valueDataDim));
	    ret.baseAxis = coordSys.getOtherAxis(ret.valueAxis);
	    ret.baseDataDim = data.mapDimension(ret.baseAxis.dim);
	  } else {
	    ret.baseAxis = seriesModel.getBaseAxis();
	    ret.valueAxis = coordSys.getOtherAxis(ret.baseAxis);
	    ret.baseDataDim = data.mapDimension(ret.baseAxis.dim);
	    ret.valueDataDim = data.mapDimension(ret.valueAxis.dim);
	  }
	
	  return ret;
	}
	
	exports.getAxisInfo = getAxisInfo;
	
	function dataDimToCoordDim(seriesModel, dataDim) {
	  var data = seriesModel.getData();
	  var dimensions = data.dimensions;
	  dataDim = data.getDimension(dataDim);
	
	  for (var i = 0; i < dimensions.length; i++) {
	    var dimItem = data.getDimensionInfo(dimensions[i]);
	
	    if (dimItem.name === dataDim) {
	      return dimItem.coordDim;
	    }
	  }
	}
	
	function dataFilter(coordSys, item) {
	  return coordSys && coordSys.containData && item.coord && !hasXOrY(item) ? coordSys.containData(item.coord) : true;
	}
	
	exports.dataFilter = dataFilter;
	
	function dimValueGetter(item, dimName, dataIndex, dimIndex) {
	  if (dimIndex < 2) {
	    return item.coord && item.coord[dimIndex];
	  }
	
	  return item.value;
	}
	
	exports.dimValueGetter = dimValueGetter;
	
	function numCalculate(data, valueDataDim, type) {
	  if (type === 'average') {
	    var sum_1 = 0;
	    var count_1 = 0;
	    data.each(valueDataDim, function (val, idx) {
	      if (!isNaN(val)) {
	        sum_1 += val;
	        count_1++;
	      }
	    });
	    return sum_1 / count_1;
	  } else if (type === 'median') {
	    return data.getMedian(valueDataDim);
	  } else {
	    return data.getDataExtent(valueDataDim)[type === 'max' ? 1 : 0];
	  }
	}
	
	exports.numCalculate = numCalculate;

/***/ },
/* 328 */
/***/ function(module, exports, __webpack_require__) {

	
	/*
	* Licensed to the Apache Software Foundation (ASF) under one
	* or more contributor license agreements.  See the NOTICE file
	* distributed with this work for additional information
	* regarding copyright ownership.  The ASF licenses this file
	* to you under the Apache License, Version 2.0 (the
	* "License"); you may not use this file except in compliance
	* with the License.  You may obtain a copy of the License at
	*
	*   http://www.apache.org/licenses/LICENSE-2.0
	*
	* Unless required by applicable law or agreed to in writing,
	* software distributed under the License is distributed on an
	* "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
	* KIND, either express or implied.  See the License for the
	* specific language governing permissions and limitations
	* under the License.
	*/
	
	
	
	/**
	 * AUTO-GENERATED FILE. DO NOT MODIFY.
	 */
	
	"use strict";
	
	exports.__esModule = true;
	
	var util_1 = __webpack_require__(1);
	
	var color_1 = __webpack_require__(34);
	
	var event_1 = __webpack_require__(42);
	
	var dom_1 = __webpack_require__(181);
	
	var env_1 = __webpack_require__(13);
	
	var format_1 = __webpack_require__(29);
	
	var helper_1 = __webpack_require__(141);
	
	var tooltipMarkup_1 = __webpack_require__(52);
	
	var vendors = ['-ms-', '-moz-', '-o-', '-webkit-', ''];
	var gCssText = 'position:absolute;display:block;border-style:solid;white-space:nowrap;z-index:9999999;';
	
	function mirrorPos(pos) {
	  pos = pos === 'left' ? 'right' : pos === 'right' ? 'left' : pos === 'top' ? 'bottom' : 'top';
	  return pos;
	}
	
	function assembleArrow(backgroundColor, borderColor, arrowPosition) {
	  if (!util_1.isString(arrowPosition) || arrowPosition === 'inside') {
	    return '';
	  }
	
	  borderColor = format_1.convertToColorString(borderColor);
	  var arrowPos = mirrorPos(arrowPosition);
	  var positionStyle = '';
	  var transformStyle = '';
	
	  if (util_1.indexOf(['left', 'right'], arrowPos) > -1) {
	    positionStyle = arrowPos + ":-6px;top:50%;";
	    transformStyle = "translateY(-50%) rotate(" + (arrowPos === 'left' ? -225 : -45) + "deg)";
	  } else {
	    positionStyle = arrowPos + ":-6px;left:50%;";
	    transformStyle = "translateX(-50%) rotate(" + (arrowPos === 'top' ? 225 : 45) + "deg)";
	  }
	
	  transformStyle = util_1.map(vendors, function (vendorPrefix) {
	    return vendorPrefix + 'transform:' + transformStyle;
	  }).join(';');
	  var styleCss = ['position:absolute;width:10px;height:10px;', "" + positionStyle + transformStyle + ";", "border-bottom: " + borderColor + " solid 1px;", "border-right: " + borderColor + " solid 1px;", "background-color: " + backgroundColor + ";", 'box-shadow: 8px 8px 16px -3px #000;'];
	  return "<div style=\"" + styleCss.join('') + "\"></div>";
	}
	
	function assembleTransition(duration, onlyFade) {
	  var transitionCurve = 'cubic-bezier(0.23, 1, 0.32, 1)';
	  var transitionText = 'opacity ' + duration / 2 + 's ' + transitionCurve + ',' + 'visibility ' + duration / 2 + 's ' + transitionCurve;
	
	  if (!onlyFade) {
	    transitionText += ',left ' + duration + 's ' + transitionCurve + ',top ' + duration + 's ' + transitionCurve;
	  }
	
	  return util_1.map(vendors, function (vendorPrefix) {
	    return vendorPrefix + 'transition:' + transitionText;
	  }).join(';');
	}
	
	function assembleFont(textStyleModel) {
	  var cssText = [];
	  var fontSize = textStyleModel.get('fontSize');
	  var color = textStyleModel.getTextColor();
	  color && cssText.push('color:' + color);
	  cssText.push('font:' + textStyleModel.getFont());
	  fontSize && cssText.push('line-height:' + Math.round(fontSize * 3 / 2) + 'px');
	  var shadowColor = textStyleModel.get('textShadowColor');
	  var shadowBlur = textStyleModel.get('textShadowBlur') || 0;
	  var shadowOffsetX = textStyleModel.get('textShadowOffsetX') || 0;
	  var shadowOffsetY = textStyleModel.get('textShadowOffsetY') || 0;
	  shadowColor && shadowBlur && cssText.push('text-shadow:' + shadowOffsetX + 'px ' + shadowOffsetY + 'px ' + shadowBlur + 'px ' + shadowColor);
	  util_1.each(['decoration', 'align'], function (name) {
	    var val = textStyleModel.get(name);
	    val && cssText.push('text-' + name + ':' + val);
	  });
	  return cssText.join(';');
	}
	
	function assembleCssText(tooltipModel, enableTransition, onlyFade) {
	  var cssText = [];
	  var transitionDuration = tooltipModel.get('transitionDuration');
	  var backgroundColor = tooltipModel.get('backgroundColor');
	  var shadowBlur = tooltipModel.get('shadowBlur');
	  var shadowColor = tooltipModel.get('shadowColor');
	  var shadowOffsetX = tooltipModel.get('shadowOffsetX');
	  var shadowOffsetY = tooltipModel.get('shadowOffsetY');
	  var textStyleModel = tooltipModel.getModel('textStyle');
	  var padding = tooltipMarkup_1.getPaddingFromTooltipModel(tooltipModel, 'html');
	  var boxShadow = shadowOffsetX + "px " + shadowOffsetY + "px " + shadowBlur + "px " + shadowColor;
	  cssText.push('box-shadow:' + boxShadow);
	  enableTransition && transitionDuration && cssText.push(assembleTransition(transitionDuration, onlyFade));
	
	  if (backgroundColor) {
	    if (env_1["default"].canvasSupported) {
	      cssText.push('background-Color:' + backgroundColor);
	    } else {
	      cssText.push('background-Color:#' + color_1.toHex(backgroundColor));
	      cssText.push('filter:alpha(opacity=70)');
	    }
	  }
	
	  util_1.each(['width', 'color', 'radius'], function (name) {
	    var borderName = 'border-' + name;
	    var camelCase = format_1.toCamelCase(borderName);
	    var val = tooltipModel.get(camelCase);
	    val != null && cssText.push(borderName + ':' + val + (name === 'color' ? '' : 'px'));
	  });
	  cssText.push(assembleFont(textStyleModel));
	
	  if (padding != null) {
	    cssText.push('padding:' + format_1.normalizeCssArray(padding).join('px ') + 'px');
	  }
	
	  return cssText.join(';') + ';';
	}
	
	function makeStyleCoord(out, zr, appendToBody, zrX, zrY) {
	  var zrPainter = zr && zr.painter;
	
	  if (appendToBody) {
	    var zrViewportRoot = zrPainter && zrPainter.getViewportRoot();
	
	    if (zrViewportRoot) {
	      dom_1.transformLocalCoord(out, zrViewportRoot, document.body, zrX, zrY);
	    }
	  } else {
	    out[0] = zrX;
	    out[1] = zrY;
	    var viewportRootOffset = zrPainter && zrPainter.getViewportRootOffset();
	
	    if (viewportRootOffset) {
	      out[0] += viewportRootOffset.offsetLeft;
	      out[1] += viewportRootOffset.offsetTop;
	    }
	  }
	
	  out[2] = out[0] / zr.getWidth();
	  out[3] = out[1] / zr.getHeight();
	}
	
	var TooltipHTMLContent = function () {
	  function TooltipHTMLContent(container, api, opt) {
	    this._show = false;
	    this._styleCoord = [0, 0, 0, 0];
	    this._enterable = true;
	    this._firstShow = true;
	    this._longHide = true;
	
	    if (env_1["default"].wxa) {
	      return null;
	    }
	
	    var el = document.createElement('div');
	    el.domBelongToZr = true;
	    this.el = el;
	    var zr = this._zr = api.getZr();
	    var appendToBody = this._appendToBody = opt && opt.appendToBody;
	    makeStyleCoord(this._styleCoord, zr, appendToBody, api.getWidth() / 2, api.getHeight() / 2);
	
	    if (appendToBody) {
	      document.body.appendChild(el);
	    } else {
	      container.appendChild(el);
	    }
	
	    this._container = container;
	    var self = this;
	
	    el.onmouseenter = function () {
	      if (self._enterable) {
	        clearTimeout(self._hideTimeout);
	        self._show = true;
	      }
	
	      self._inContent = true;
	    };
	
	    el.onmousemove = function (e) {
	      e = e || window.event;
	
	      if (!self._enterable) {
	        var handler = zr.handler;
	        var zrViewportRoot = zr.painter.getViewportRoot();
	        event_1.normalizeEvent(zrViewportRoot, e, true);
	        handler.dispatch('mousemove', e);
	      }
	    };
	
	    el.onmouseleave = function () {
	      self._inContent = false;
	
	      if (self._enterable) {
	        if (self._show) {
	          self.hideLater(self._hideDelay);
	        }
	      }
	    };
	  }
	
	  TooltipHTMLContent.prototype.update = function (tooltipModel) {
	    var container = this._container;
	    var stl = container.currentStyle || document.defaultView.getComputedStyle(container);
	    var domStyle = container.style;
	
	    if (domStyle.position !== 'absolute' && stl.position !== 'absolute') {
	      domStyle.position = 'relative';
	    }
	
	    var alwaysShowContent = tooltipModel.get('alwaysShowContent');
	    alwaysShowContent && this._moveIfResized();
	    this.el.className = tooltipModel.get('className') || '';
	  };
	
	  TooltipHTMLContent.prototype.show = function (tooltipModel, nearPointColor) {
	    clearTimeout(this._hideTimeout);
	    clearTimeout(this._longHideTimeout);
	    var el = this.el;
	    var styleCoord = this._styleCoord;
	    var offset = el.offsetHeight / 2;
	    nearPointColor = format_1.convertToColorString(nearPointColor);
	    el.style.cssText = gCssText + assembleCssText(tooltipModel, !this._firstShow, this._longHide) + ';left:' + styleCoord[0] + 'px;top:' + (styleCoord[1] - offset) + 'px;' + ("border-color: " + nearPointColor + ";") + (tooltipModel.get('extraCssText') || '');
	    el.style.display = el.innerHTML ? 'block' : 'none';
	    el.style.pointerEvents = this._enterable ? 'auto' : 'none';
	    this._show = true;
	    this._firstShow = false;
	    this._longHide = false;
	  };
	
	  TooltipHTMLContent.prototype.setContent = function (content, markers, tooltipModel, borderColor, arrowPosition) {
	    if (content == null) {
	      return;
	    }
	
	    var el = this.el;
	
	    if (util_1.isString(arrowPosition) && tooltipModel.get('trigger') === 'item' && !helper_1.shouldTooltipConfine(tooltipModel)) {
	      content += assembleArrow(tooltipModel.get('backgroundColor'), borderColor, arrowPosition);
	    }
	
	    if (util_1.isString(content)) {
	      el.innerHTML = content;
	    } else if (content) {
	      el.innerHTML = '';
	
	      if (!util_1.isArray(content)) {
	        content = [content];
	      }
	
	      for (var i = 0; i < content.length; i++) {
	        if (util_1.isDom(content[i]) && content[i].parentNode !== el) {
	          el.appendChild(content[i]);
	        }
	      }
	    }
	  };
	
	  TooltipHTMLContent.prototype.setEnterable = function (enterable) {
	    this._enterable = enterable;
	  };
	
	  TooltipHTMLContent.prototype.getSize = function () {
	    var el = this.el;
	    return [el.clientWidth, el.clientHeight];
	  };
	
	  TooltipHTMLContent.prototype.moveTo = function (zrX, zrY) {
	    var styleCoord = this._styleCoord;
	    makeStyleCoord(styleCoord, this._zr, this._appendToBody, zrX, zrY);
	
	    if (styleCoord[0] != null && styleCoord[1] != null) {
	      var style = this.el.style;
	      style.left = styleCoord[0].toFixed(0) + 'px';
	      style.top = styleCoord[1].toFixed(0) + 'px';
	    }
	  };
	
	  TooltipHTMLContent.prototype._moveIfResized = function () {
	    var ratioX = this._styleCoord[2];
	    var ratioY = this._styleCoord[3];
	    this.moveTo(ratioX * this._zr.getWidth(), ratioY * this._zr.getHeight());
	  };
	
	  TooltipHTMLContent.prototype.hide = function () {
	    var _this = this;
	
	    this.el.style.visibility = 'hidden';
	    this.el.style.opacity = '0';
	    this._show = false;
	    this._longHideTimeout = setTimeout(function () {
	      return _this._longHide = true;
	    }, 500);
	  };
	
	  TooltipHTMLContent.prototype.hideLater = function (time) {
	    if (this._show && !(this._inContent && this._enterable)) {
	      if (time) {
	        this._hideDelay = time;
	        this._show = false;
	        this._hideTimeout = setTimeout(util_1.bind(this.hide, this), time);
	      } else {
	        this.hide();
	      }
	    }
	  };
	
	  TooltipHTMLContent.prototype.isShow = function () {
	    return this._show;
	  };
	
	  TooltipHTMLContent.prototype.dispose = function () {
	    this.el.parentNode.removeChild(this.el);
	  };
	
	  TooltipHTMLContent.prototype.getOuterSize = function () {
	    var width = this.el.clientWidth;
	    var height = this.el.clientHeight;
	
	    if (document.defaultView && document.defaultView.getComputedStyle) {
	      var stl = document.defaultView.getComputedStyle(this.el);
	
	      if (stl) {
	        width += parseInt(stl.borderLeftWidth, 10) + parseInt(stl.borderRightWidth, 10);
	        height += parseInt(stl.borderTopWidth, 10) + parseInt(stl.borderBottomWidth, 10);
	      }
	    }
	
	    return {
	      width: width,
	      height: height
	    };
	  };
	
	  return TooltipHTMLContent;
	}();
	
	exports["default"] = TooltipHTMLContent;

/***/ },
/* 329 */
/***/ function(module, exports, __webpack_require__) {

	
	/*
	* Licensed to the Apache Software Foundation (ASF) under one
	* or more contributor license agreements.  See the NOTICE file
	* distributed with this work for additional information
	* regarding copyright ownership.  The ASF licenses this file
	* to you under the Apache License, Version 2.0 (the
	* "License"); you may not use this file except in compliance
	* with the License.  You may obtain a copy of the License at
	*
	*   http://www.apache.org/licenses/LICENSE-2.0
	*
	* Unless required by applicable law or agreed to in writing,
	* software distributed under the License is distributed on an
	* "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
	* KIND, either express or implied.  See the License for the
	* specific language governing permissions and limitations
	* under the License.
	*/
	
	
	
	/**
	 * AUTO-GENERATED FILE. DO NOT MODIFY.
	 */
	
	"use strict";
	
	exports.__esModule = true;
	
	var tslib_1 = __webpack_require__(3);
	
	var Component_1 = __webpack_require__(10);
	
	var TooltipModel = function (_super) {
	  tslib_1.__extends(TooltipModel, _super);
	
	  function TooltipModel() {
	    var _this = _super !== null && _super.apply(this, arguments) || this;
	
	    _this.type = TooltipModel.type;
	    return _this;
	  }
	
	  TooltipModel.type = 'tooltip';
	  TooltipModel.dependencies = ['axisPointer'];
	  TooltipModel.defaultOption = {
	    zlevel: 0,
	    z: 60,
	    show: true,
	    showContent: true,
	    trigger: 'item',
	    triggerOn: 'mousemove|click',
	    alwaysShowContent: false,
	    displayMode: 'single',
	    renderMode: 'auto',
	    confine: null,
	    showDelay: 0,
	    hideDelay: 100,
	    transitionDuration: 0.4,
	    enterable: false,
	    backgroundColor: '#fff',
	    shadowBlur: 10,
	    shadowColor: 'rgba(0, 0, 0, .2)',
	    shadowOffsetX: 1,
	    shadowOffsetY: 2,
	    borderColor: '#333',
	    borderRadius: 4,
	    borderWidth: 1,
	    padding: null,
	    extraCssText: '',
	    axisPointer: {
	      type: 'line',
	      axis: 'auto',
	      animation: 'auto',
	      animationDurationUpdate: 200,
	      animationEasingUpdate: 'exponentialOut',
	      crossStyle: {
	        color: '#999',
	        width: 1,
	        type: 'dashed',
	        textStyle: {}
	      }
	    },
	    textStyle: {
	      color: '#666',
	      fontSize: 14
	    }
	  };
	  return TooltipModel;
	}(Component_1["default"]);
	
	Component_1["default"].registerClass(TooltipModel);
	exports["default"] = TooltipModel;

/***/ },
/* 330 */
/***/ function(module, exports, __webpack_require__) {

	
	/*
	* Licensed to the Apache Software Foundation (ASF) under one
	* or more contributor license agreements.  See the NOTICE file
	* distributed with this work for additional information
	* regarding copyright ownership.  The ASF licenses this file
	* to you under the Apache License, Version 2.0 (the
	* "License"); you may not use this file except in compliance
	* with the License.  You may obtain a copy of the License at
	*
	*   http://www.apache.org/licenses/LICENSE-2.0
	*
	* Unless required by applicable law or agreed to in writing,
	* software distributed under the License is distributed on an
	* "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
	* KIND, either express or implied.  See the License for the
	* specific language governing permissions and limitations
	* under the License.
	*/
	
	
	
	/**
	 * AUTO-GENERATED FILE. DO NOT MODIFY.
	 */
	
	"use strict";
	
	exports.__esModule = true;
	
	var zrUtil = __webpack_require__(1);
	
	var Text_1 = __webpack_require__(60);
	
	var tooltipMarkup_1 = __webpack_require__(52);
	
	var log_1 = __webpack_require__(12);
	
	var TooltipRichContent = function () {
	  function TooltipRichContent(api) {
	    this._show = false;
	    this._styleCoord = [0, 0, 0, 0];
	    this._enterable = true;
	    this._zr = api.getZr();
	    makeStyleCoord(this._styleCoord, this._zr, api.getWidth() / 2, api.getHeight() / 2);
	  }
	
	  TooltipRichContent.prototype.update = function (tooltipModel) {
	    var alwaysShowContent = tooltipModel.get('alwaysShowContent');
	    alwaysShowContent && this._moveIfResized();
	  };
	
	  TooltipRichContent.prototype.show = function () {
	    if (this._hideTimeout) {
	      clearTimeout(this._hideTimeout);
	    }
	
	    this.el.show();
	    this._show = true;
	  };
	
	  TooltipRichContent.prototype.setContent = function (content, markupStyleCreator, tooltipModel, borderColor, arrowPosition) {
	    if (zrUtil.isObject(content)) {
	      log_1.throwError( false ? 'Passing DOM nodes as content is not supported in richText tooltip!' : '');
	    }
	
	    if (this.el) {
	      this._zr.remove(this.el);
	    }
	
	    var textStyleModel = tooltipModel.getModel('textStyle');
	    this.el = new Text_1["default"]({
	      style: {
	        rich: markupStyleCreator.richTextStyles,
	        text: content,
	        lineHeight: 22,
	        backgroundColor: tooltipModel.get('backgroundColor'),
	        borderRadius: tooltipModel.get('borderRadius'),
	        borderWidth: 1,
	        borderColor: borderColor,
	        shadowColor: tooltipModel.get('shadowColor'),
	        shadowBlur: tooltipModel.get('shadowBlur'),
	        shadowOffsetX: tooltipModel.get('shadowOffsetX'),
	        shadowOffsetY: tooltipModel.get('shadowOffsetY'),
	        textShadowColor: textStyleModel.get('textShadowColor'),
	        textShadowBlur: textStyleModel.get('textShadowBlur') || 0,
	        textShadowOffsetX: textStyleModel.get('textShadowOffsetX') || 0,
	        textShadowOffsetY: textStyleModel.get('textShadowOffsetY') || 0,
	        fill: tooltipModel.get(['textStyle', 'color']),
	        padding: tooltipMarkup_1.getPaddingFromTooltipModel(tooltipModel, 'richText'),
	        verticalAlign: 'top',
	        align: 'left'
	      },
	      z: tooltipModel.get('z')
	    });
	
	    this._zr.add(this.el);
	
	    var self = this;
	    this.el.on('mouseover', function () {
	      if (self._enterable) {
	        clearTimeout(self._hideTimeout);
	        self._show = true;
	      }
	
	      self._inContent = true;
	    });
	    this.el.on('mouseout', function () {
	      if (self._enterable) {
	        if (self._show) {
	          self.hideLater(self._hideDelay);
	        }
	      }
	
	      self._inContent = false;
	    });
	  };
	
	  TooltipRichContent.prototype.setEnterable = function (enterable) {
	    this._enterable = enterable;
	  };
	
	  TooltipRichContent.prototype.getSize = function () {
	    var el = this.el;
	    var bounding = this.el.getBoundingRect();
	    var shadowOuterSize = calcShadowOuterSize(el.style);
	    return [bounding.width + shadowOuterSize.left + shadowOuterSize.right, bounding.height + shadowOuterSize.top + shadowOuterSize.bottom];
	  };
	
	  TooltipRichContent.prototype.moveTo = function (x, y) {
	    var el = this.el;
	
	    if (el) {
	      var styleCoord = this._styleCoord;
	      makeStyleCoord(styleCoord, this._zr, x, y);
	      x = styleCoord[0];
	      y = styleCoord[1];
	      var style = el.style;
	      var borderWidth = mathMaxWith0(style.borderWidth || 0);
	      var shadowOuterSize = calcShadowOuterSize(style);
	      el.x = x + borderWidth + shadowOuterSize.left;
	      el.y = y + borderWidth + shadowOuterSize.top;
	      el.markRedraw();
	    }
	  };
	
	  TooltipRichContent.prototype._moveIfResized = function () {
	    var ratioX = this._styleCoord[2];
	    var ratioY = this._styleCoord[3];
	    this.moveTo(ratioX * this._zr.getWidth(), ratioY * this._zr.getHeight());
	  };
	
	  TooltipRichContent.prototype.hide = function () {
	    if (this.el) {
	      this.el.hide();
	    }
	
	    this._show = false;
	  };
	
	  TooltipRichContent.prototype.hideLater = function (time) {
	    if (this._show && !(this._inContent && this._enterable)) {
	      if (time) {
	        this._hideDelay = time;
	        this._show = false;
	        this._hideTimeout = setTimeout(zrUtil.bind(this.hide, this), time);
	      } else {
	        this.hide();
	      }
	    }
	  };
	
	  TooltipRichContent.prototype.isShow = function () {
	    return this._show;
	  };
	
	  TooltipRichContent.prototype.getOuterSize = function () {
	    var size = this.getSize();
	    return {
	      width: size[0],
	      height: size[1]
	    };
	  };
	
	  TooltipRichContent.prototype.dispose = function () {
	    this._zr.remove(this.el);
	  };
	
	  return TooltipRichContent;
	}();
	
	function mathMaxWith0(val) {
	  return Math.max(0, val);
	}
	
	function calcShadowOuterSize(style) {
	  var shadowBlur = mathMaxWith0(style.shadowBlur || 0);
	  var shadowOffsetX = mathMaxWith0(style.shadowOffsetX || 0);
	  var shadowOffsetY = mathMaxWith0(style.shadowOffsetY || 0);
	  return {
	    left: mathMaxWith0(shadowBlur - shadowOffsetX),
	    right: mathMaxWith0(shadowBlur + shadowOffsetX),
	    top: mathMaxWith0(shadowBlur - shadowOffsetY),
	    bottom: mathMaxWith0(shadowBlur + shadowOffsetY)
	  };
	}
	
	function makeStyleCoord(out, zr, zrX, zrY) {
	  out[0] = zrX;
	  out[1] = zrY;
	  out[2] = out[0] / zr.getWidth();
	  out[3] = out[1] / zr.getHeight();
	}
	
	exports["default"] = TooltipRichContent;

/***/ },
/* 331 */
/***/ function(module, exports, __webpack_require__) {

	
	/*
	* Licensed to the Apache Software Foundation (ASF) under one
	* or more contributor license agreements.  See the NOTICE file
	* distributed with this work for additional information
	* regarding copyright ownership.  The ASF licenses this file
	* to you under the Apache License, Version 2.0 (the
	* "License"); you may not use this file except in compliance
	* with the License.  You may obtain a copy of the License at
	*
	*   http://www.apache.org/licenses/LICENSE-2.0
	*
	* Unless required by applicable law or agreed to in writing,
	* software distributed under the License is distributed on an
	* "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
	* KIND, either express or implied.  See the License for the
	* specific language governing permissions and limitations
	* under the License.
	*/
	
	
	
	/**
	 * AUTO-GENERATED FILE. DO NOT MODIFY.
	 */
	
	"use strict";
	
	exports.__esModule = true;
	
	var tslib_1 = __webpack_require__(3);
	
	var zrUtil = __webpack_require__(1);
	
	var env_1 = __webpack_require__(13);
	
	var TooltipHTMLContent_1 = __webpack_require__(328);
	
	var TooltipRichContent_1 = __webpack_require__(330);
	
	var formatUtil = __webpack_require__(29);
	
	var numberUtil = __webpack_require__(9);
	
	var graphic = __webpack_require__(7);
	
	var findPointFromSeries_1 = __webpack_require__(135);
	
	var layoutUtil = __webpack_require__(30);
	
	var Model_1 = __webpack_require__(24);
	
	var globalListener = __webpack_require__(136);
	
	var axisHelper = __webpack_require__(39);
	
	var axisPointerViewHelper = __webpack_require__(137);
	
	var model_1 = __webpack_require__(4);
	
	var Component_1 = __webpack_require__(18);
	
	var time_1 = __webpack_require__(94);
	
	var innerStore_1 = __webpack_require__(21);
	
	var helper_1 = __webpack_require__(141);
	
	var dataFormat_1 = __webpack_require__(91);
	
	var tooltipMarkup_1 = __webpack_require__(52);
	
	var event_1 = __webpack_require__(155);
	
	var bind = zrUtil.bind;
	var each = zrUtil.each;
	var parsePercent = numberUtil.parsePercent;
	var proxyRect = new graphic.Rect({
	  shape: {
	    x: -1,
	    y: -1,
	    width: 2,
	    height: 2
	  }
	});
	
	var TooltipView = function (_super) {
	  tslib_1.__extends(TooltipView, _super);
	
	  function TooltipView() {
	    var _this = _super !== null && _super.apply(this, arguments) || this;
	
	    _this.type = TooltipView.type;
	    return _this;
	  }
	
	  TooltipView.prototype.init = function (ecModel, api) {
	    if (env_1["default"].node) {
	      return;
	    }
	
	    var tooltipModel = ecModel.getComponent('tooltip');
	    var renderMode = tooltipModel.get('renderMode');
	    this._renderMode = model_1.getTooltipRenderMode(renderMode);
	    this._tooltipContent = this._renderMode === 'richText' ? new TooltipRichContent_1["default"](api) : new TooltipHTMLContent_1["default"](api.getDom(), api, {
	      appendToBody: tooltipModel.get('appendToBody', true)
	    });
	  };
	
	  TooltipView.prototype.render = function (tooltipModel, ecModel, api) {
	    if (env_1["default"].node) {
	      return;
	    }
	
	    this.group.removeAll();
	    this._tooltipModel = tooltipModel;
	    this._ecModel = ecModel;
	    this._api = api;
	    this._alwaysShowContent = tooltipModel.get('alwaysShowContent');
	    var tooltipContent = this._tooltipContent;
	    tooltipContent.update(tooltipModel);
	    tooltipContent.setEnterable(tooltipModel.get('enterable'));
	
	    this._initGlobalListener();
	
	    this._keepShow();
	  };
	
	  TooltipView.prototype._initGlobalListener = function () {
	    var tooltipModel = this._tooltipModel;
	    var triggerOn = tooltipModel.get('triggerOn');
	    globalListener.register('itemTooltip', this._api, bind(function (currTrigger, e, dispatchAction) {
	      if (triggerOn !== 'none') {
	        if (triggerOn.indexOf(currTrigger) >= 0) {
	          this._tryShow(e, dispatchAction);
	        } else if (currTrigger === 'leave') {
	          this._hide(dispatchAction);
	        }
	      }
	    }, this));
	  };
	
	  TooltipView.prototype._keepShow = function () {
	    var tooltipModel = this._tooltipModel;
	    var ecModel = this._ecModel;
	    var api = this._api;
	
	    if (this._lastX != null && this._lastY != null && tooltipModel.get('triggerOn') !== 'none') {
	      var self_1 = this;
	      clearTimeout(this._refreshUpdateTimeout);
	      this._refreshUpdateTimeout = setTimeout(function () {
	        !api.isDisposed() && self_1.manuallyShowTip(tooltipModel, ecModel, api, {
	          x: self_1._lastX,
	          y: self_1._lastY,
	          dataByCoordSys: self_1._lastDataByCoordSys
	        });
	      });
	    }
	  };
	
	  TooltipView.prototype.manuallyShowTip = function (tooltipModel, ecModel, api, payload) {
	    if (payload.from === this.uid || env_1["default"].node) {
	      return;
	    }
	
	    var dispatchAction = makeDispatchAction(payload, api);
	    this._ticket = '';
	    var dataByCoordSys = payload.dataByCoordSys;
	
	    if (payload.tooltip && payload.x != null && payload.y != null) {
	      var el = proxyRect;
	      el.x = payload.x;
	      el.y = payload.y;
	      el.update();
	      el.tooltip = payload.tooltip;
	
	      this._tryShow({
	        offsetX: payload.x,
	        offsetY: payload.y,
	        target: el
	      }, dispatchAction);
	    } else if (dataByCoordSys) {
	      this._tryShow({
	        offsetX: payload.x,
	        offsetY: payload.y,
	        position: payload.position,
	        dataByCoordSys: dataByCoordSys,
	        tooltipOption: payload.tooltipOption
	      }, dispatchAction);
	    } else if (payload.seriesIndex != null) {
	      if (this._manuallyAxisShowTip(tooltipModel, ecModel, api, payload)) {
	        return;
	      }
	
	      var pointInfo = findPointFromSeries_1["default"](payload, ecModel);
	      var cx = pointInfo.point[0];
	      var cy = pointInfo.point[1];
	
	      if (cx != null && cy != null) {
	        this._tryShow({
	          offsetX: cx,
	          offsetY: cy,
	          position: payload.position,
	          target: pointInfo.el
	        }, dispatchAction);
	      }
	    } else if (payload.x != null && payload.y != null) {
	      api.dispatchAction({
	        type: 'updateAxisPointer',
	        x: payload.x,
	        y: payload.y
	      });
	
	      this._tryShow({
	        offsetX: payload.x,
	        offsetY: payload.y,
	        position: payload.position,
	        target: api.getZr().findHover(payload.x, payload.y).target
	      }, dispatchAction);
	    }
	  };
	
	  TooltipView.prototype.manuallyHideTip = function (tooltipModel, ecModel, api, payload) {
	    var tooltipContent = this._tooltipContent;
	
	    if (!this._alwaysShowContent && this._tooltipModel) {
	      tooltipContent.hideLater(this._tooltipModel.get('hideDelay'));
	    }
	
	    this._lastX = this._lastY = this._lastDataByCoordSys = null;
	
	    if (payload.from !== this.uid) {
	      this._hide(makeDispatchAction(payload, api));
	    }
	  };
	
	  TooltipView.prototype._manuallyAxisShowTip = function (tooltipModel, ecModel, api, payload) {
	    var seriesIndex = payload.seriesIndex;
	    var dataIndex = payload.dataIndex;
	    var coordSysAxesInfo = ecModel.getComponent('axisPointer').coordSysAxesInfo;
	
	    if (seriesIndex == null || dataIndex == null || coordSysAxesInfo == null) {
	      return;
	    }
	
	    var seriesModel = ecModel.getSeriesByIndex(seriesIndex);
	
	    if (!seriesModel) {
	      return;
	    }
	
	    var data = seriesModel.getData();
	    var tooltipCascadedModel = buildTooltipModel([data.getItemModel(dataIndex), seriesModel, (seriesModel.coordinateSystem || {}).model, tooltipModel]);
	
	    if (tooltipCascadedModel.get('trigger') !== 'axis') {
	      return;
	    }
	
	    api.dispatchAction({
	      type: 'updateAxisPointer',
	      seriesIndex: seriesIndex,
	      dataIndex: dataIndex,
	      position: payload.position
	    });
	    return true;
	  };
	
	  TooltipView.prototype._tryShow = function (e, dispatchAction) {
	    var el = e.target;
	    var tooltipModel = this._tooltipModel;
	
	    if (!tooltipModel) {
	      return;
	    }
	
	    this._lastX = e.offsetX;
	    this._lastY = e.offsetY;
	    var dataByCoordSys = e.dataByCoordSys;
	
	    if (dataByCoordSys && dataByCoordSys.length) {
	      this._showAxisTooltip(dataByCoordSys, e);
	    } else if (el && event_1.findEventDispatcher(el, function (target) {
	      return innerStore_1.getECData(target).dataIndex != null;
	    })) {
	      this._lastDataByCoordSys = null;
	
	      this._showSeriesItemTooltip(e, el, dispatchAction);
	    } else if (el && el.tooltip) {
	      this._lastDataByCoordSys = null;
	
	      this._showComponentItemTooltip(e, el, dispatchAction);
	    } else {
	      this._lastDataByCoordSys = null;
	
	      this._hide(dispatchAction);
	    }
	  };
	
	  TooltipView.prototype._showOrMove = function (tooltipModel, cb) {
	    var delay = tooltipModel.get('showDelay');
	    cb = zrUtil.bind(cb, this);
	    clearTimeout(this._showTimout);
	    delay > 0 ? this._showTimout = setTimeout(cb, delay) : cb();
	  };
	
	  TooltipView.prototype._showAxisTooltip = function (dataByCoordSys, e) {
	    var ecModel = this._ecModel;
	    var globalTooltipModel = this._tooltipModel;
	    var point = [e.offsetX, e.offsetY];
	    var singleTooltipModel = buildTooltipModel([e.tooltipOption, globalTooltipModel]);
	    var renderMode = this._renderMode;
	    var cbParamsList = [];
	    var articleMarkup = tooltipMarkup_1.createTooltipMarkup('section', {
	      blocks: [],
	      noHeader: true
	    });
	    var markupTextArrLegacy = [];
	    var markupStyleCreator = new tooltipMarkup_1.TooltipMarkupStyleCreator();
	    each(dataByCoordSys, function (itemCoordSys) {
	      each(itemCoordSys.dataByAxis, function (axisItem) {
	        var axisModel = ecModel.getComponent(axisItem.axisDim + 'Axis', axisItem.axisIndex);
	        var axisValue = axisItem.value;
	
	        if (!axisModel || axisValue == null) {
	          return;
	        }
	
	        var axisValueLabel = axisPointerViewHelper.getValueLabel(axisValue, axisModel.axis, ecModel, axisItem.seriesDataIndices, axisItem.valueLabelOpt);
	        var axisSectionMarkup = tooltipMarkup_1.createTooltipMarkup('section', {
	          header: axisValueLabel,
	          noHeader: !zrUtil.trim(axisValueLabel),
	          sortBlocks: true,
	          blocks: []
	        });
	        articleMarkup.blocks.push(axisSectionMarkup);
	        zrUtil.each(axisItem.seriesDataIndices, function (idxItem) {
	          var series = ecModel.getSeriesByIndex(idxItem.seriesIndex);
	          var dataIndex = idxItem.dataIndexInside;
	          var cbParams = series.getDataParams(dataIndex);
	          cbParams.axisDim = axisItem.axisDim;
	          cbParams.axisIndex = axisItem.axisIndex;
	          cbParams.axisType = axisItem.axisType;
	          cbParams.axisId = axisItem.axisId;
	          cbParams.axisValue = axisHelper.getAxisRawValue(axisModel.axis, {
	            value: axisValue
	          });
	          cbParams.axisValueLabel = axisValueLabel;
	          cbParams.marker = markupStyleCreator.makeTooltipMarker('item', formatUtil.convertToColorString(cbParams.color), renderMode);
	          var seriesTooltipResult = dataFormat_1.normalizeTooltipFormatResult(series.formatTooltip(dataIndex, true, null));
	
	          if (seriesTooltipResult.markupFragment) {
	            axisSectionMarkup.blocks.push(seriesTooltipResult.markupFragment);
	          }
	
	          if (seriesTooltipResult.markupText) {
	            markupTextArrLegacy.push(seriesTooltipResult.markupText);
	          }
	
	          cbParamsList.push(cbParams);
	        });
	      });
	    });
	    articleMarkup.blocks.reverse();
	    markupTextArrLegacy.reverse();
	    var positionExpr = e.position;
	    var orderMode = singleTooltipModel.get('order');
	    var builtMarkupText = tooltipMarkup_1.buildTooltipMarkup(articleMarkup, markupStyleCreator, renderMode, orderMode, ecModel.get('useUTC'));
	    builtMarkupText && markupTextArrLegacy.unshift(builtMarkupText);
	    var blockBreak = renderMode === 'richText' ? '\n\n' : '<br/>';
	    var allMarkupText = markupTextArrLegacy.join(blockBreak);
	
	    this._showOrMove(singleTooltipModel, function () {
	      if (this._updateContentNotChangedOnAxis(dataByCoordSys)) {
	        this._updatePosition(singleTooltipModel, positionExpr, point[0], point[1], this._tooltipContent, cbParamsList);
	      } else {
	        this._showTooltipContent(singleTooltipModel, allMarkupText, cbParamsList, Math.random() + '', point[0], point[1], positionExpr, null, markupStyleCreator);
	      }
	    });
	  };
	
	  TooltipView.prototype._showSeriesItemTooltip = function (e, el, dispatchAction) {
	    var dispatcher = event_1.findEventDispatcher(el, function (target) {
	      return innerStore_1.getECData(target).dataIndex != null;
	    });
	    var ecModel = this._ecModel;
	    var ecData = innerStore_1.getECData(dispatcher);
	    var seriesIndex = ecData.seriesIndex;
	    var seriesModel = ecModel.getSeriesByIndex(seriesIndex);
	    var dataModel = ecData.dataModel || seriesModel;
	    var dataIndex = ecData.dataIndex;
	    var dataType = ecData.dataType;
	    var data = dataModel.getData(dataType);
	    var renderMode = this._renderMode;
	    var tooltipModel = buildTooltipModel([data.getItemModel(dataIndex), dataModel, seriesModel && (seriesModel.coordinateSystem || {}).model, this._tooltipModel]);
	    var tooltipTrigger = tooltipModel.get('trigger');
	
	    if (tooltipTrigger != null && tooltipTrigger !== 'item') {
	      return;
	    }
	
	    var params = dataModel.getDataParams(dataIndex, dataType);
	    var markupStyleCreator = new tooltipMarkup_1.TooltipMarkupStyleCreator();
	    params.marker = markupStyleCreator.makeTooltipMarker('item', formatUtil.convertToColorString(params.color), renderMode);
	    var seriesTooltipResult = dataFormat_1.normalizeTooltipFormatResult(dataModel.formatTooltip(dataIndex, false, dataType));
	    var orderMode = tooltipModel.get('order');
	    var markupText = seriesTooltipResult.markupFragment ? tooltipMarkup_1.buildTooltipMarkup(seriesTooltipResult.markupFragment, markupStyleCreator, renderMode, orderMode, ecModel.get('useUTC')) : seriesTooltipResult.markupText;
	    var asyncTicket = 'item_' + dataModel.name + '_' + dataIndex;
	
	    this._showOrMove(tooltipModel, function () {
	      this._showTooltipContent(tooltipModel, markupText, params, asyncTicket, e.offsetX, e.offsetY, e.position, e.target, markupStyleCreator);
	    });
	
	    dispatchAction({
	      type: 'showTip',
	      dataIndexInside: dataIndex,
	      dataIndex: data.getRawIndex(dataIndex),
	      seriesIndex: seriesIndex,
	      from: this.uid
	    });
	  };
	
	  TooltipView.prototype._showComponentItemTooltip = function (e, el, dispatchAction) {
	    var tooltipOpt = el.tooltip;
	
	    if (zrUtil.isString(tooltipOpt)) {
	      var content = tooltipOpt;
	      tooltipOpt = {
	        content: content,
	        formatter: content
	      };
	    }
	
	    var subTooltipModel = new Model_1["default"](tooltipOpt, this._tooltipModel, this._ecModel);
	    var defaultHtml = subTooltipModel.get('content');
	    var asyncTicket = Math.random() + '';
	    var markupStyleCreator = new tooltipMarkup_1.TooltipMarkupStyleCreator();
	
	    this._showOrMove(subTooltipModel, function () {
	      this._showTooltipContent(subTooltipModel, defaultHtml, subTooltipModel.get('formatterParams') || {}, asyncTicket, e.offsetX, e.offsetY, e.position, el, markupStyleCreator);
	    });
	
	    dispatchAction({
	      type: 'showTip',
	      from: this.uid
	    });
	  };
	
	  TooltipView.prototype._showTooltipContent = function (tooltipModel, defaultHtml, params, asyncTicket, x, y, positionExpr, el, markupStyleCreator) {
	    this._ticket = '';
	
	    if (!tooltipModel.get('showContent') || !tooltipModel.get('show')) {
	      return;
	    }
	
	    var tooltipContent = this._tooltipContent;
	    var formatter = tooltipModel.get('formatter');
	    positionExpr = positionExpr || tooltipModel.get('position');
	    var html = defaultHtml;
	
	    var nearPoint = this._getNearestPoint([x, y], params, tooltipModel.get('trigger'));
	
	    if (formatter && zrUtil.isString(formatter)) {
	      var useUTC = tooltipModel.ecModel.get('useUTC');
	      var params0 = zrUtil.isArray(params) ? params[0] : params;
	      var isTimeAxis = params0 && params0.axisType && params0.axisType.indexOf('time') >= 0;
	      html = formatter;
	
	      if (isTimeAxis) {
	        html = time_1.format(params0.axisValue, html, useUTC);
	      }
	
	      html = formatUtil.formatTpl(html, params, true);
	    } else if (zrUtil.isFunction(formatter)) {
	      var callback = bind(function (cbTicket, html) {
	        if (cbTicket === this._ticket) {
	          tooltipContent.setContent(html, markupStyleCreator, tooltipModel, nearPoint.color, positionExpr);
	
	          this._updatePosition(tooltipModel, positionExpr, x, y, tooltipContent, params, el);
	        }
	      }, this);
	      this._ticket = asyncTicket;
	      html = formatter(params, asyncTicket, callback);
	    }
	
	    tooltipContent.setContent(html, markupStyleCreator, tooltipModel, nearPoint.color, positionExpr);
	    tooltipContent.show(tooltipModel, nearPoint.color);
	
	    this._updatePosition(tooltipModel, positionExpr, x, y, tooltipContent, params, el);
	  };
	
	  TooltipView.prototype._getNearestPoint = function (point, tooltipDataParams, trigger) {
	    if (trigger === 'axis' || zrUtil.isArray(tooltipDataParams)) {
	      return {
	        color: this._renderMode === 'html' ? '#fff' : 'none'
	      };
	    }
	
	    if (!zrUtil.isArray(tooltipDataParams)) {
	      return {
	        color: tooltipDataParams.color || tooltipDataParams.borderColor
	      };
	    }
	  };
	
	  TooltipView.prototype._updatePosition = function (tooltipModel, positionExpr, x, y, content, params, el) {
	    var viewWidth = this._api.getWidth();
	
	    var viewHeight = this._api.getHeight();
	
	    positionExpr = positionExpr || tooltipModel.get('position');
	    var contentSize = content.getSize();
	    var align = tooltipModel.get('align');
	    var vAlign = tooltipModel.get('verticalAlign');
	    var rect = el && el.getBoundingRect().clone();
	    el && rect.applyTransform(el.transform);
	
	    if (zrUtil.isFunction(positionExpr)) {
	      positionExpr = positionExpr([x, y], params, content.el, rect, {
	        viewSize: [viewWidth, viewHeight],
	        contentSize: contentSize.slice()
	      });
	    }
	
	    if (zrUtil.isArray(positionExpr)) {
	      x = parsePercent(positionExpr[0], viewWidth);
	      y = parsePercent(positionExpr[1], viewHeight);
	    } else if (zrUtil.isObject(positionExpr)) {
	      var boxLayoutPosition = positionExpr;
	      boxLayoutPosition.width = contentSize[0];
	      boxLayoutPosition.height = contentSize[1];
	      var layoutRect = layoutUtil.getLayoutRect(boxLayoutPosition, {
	        width: viewWidth,
	        height: viewHeight
	      });
	      x = layoutRect.x;
	      y = layoutRect.y;
	      align = null;
	      vAlign = null;
	    } else if (zrUtil.isString(positionExpr) && el) {
	      var pos = calcTooltipPosition(positionExpr, rect, contentSize);
	      x = pos[0];
	      y = pos[1];
	    } else {
	      var pos = refixTooltipPosition(x, y, content, viewWidth, viewHeight, align ? null : 20, vAlign ? null : 20);
	      x = pos[0];
	      y = pos[1];
	    }
	
	    align && (x -= isCenterAlign(align) ? contentSize[0] / 2 : align === 'right' ? contentSize[0] : 0);
	    vAlign && (y -= isCenterAlign(vAlign) ? contentSize[1] / 2 : vAlign === 'bottom' ? contentSize[1] : 0);
	
	    if (helper_1.shouldTooltipConfine(tooltipModel)) {
	      var pos = confineTooltipPosition(x, y, content, viewWidth, viewHeight);
	      x = pos[0];
	      y = pos[1];
	    }
	
	    content.moveTo(x, y);
	  };
	
	  TooltipView.prototype._updateContentNotChangedOnAxis = function (dataByCoordSys) {
	    var lastCoordSys = this._lastDataByCoordSys;
	    var contentNotChanged = !!lastCoordSys && lastCoordSys.length === dataByCoordSys.length;
	    contentNotChanged && each(lastCoordSys, function (lastItemCoordSys, indexCoordSys) {
	      var lastDataByAxis = lastItemCoordSys.dataByAxis || [];
	      var thisItemCoordSys = dataByCoordSys[indexCoordSys] || {};
	      var thisDataByAxis = thisItemCoordSys.dataByAxis || [];
	      contentNotChanged = contentNotChanged && lastDataByAxis.length === thisDataByAxis.length;
	      contentNotChanged && each(lastDataByAxis, function (lastItem, indexAxis) {
	        var thisItem = thisDataByAxis[indexAxis] || {};
	        var lastIndices = lastItem.seriesDataIndices || [];
	        var newIndices = thisItem.seriesDataIndices || [];
	        contentNotChanged = contentNotChanged && lastItem.value === thisItem.value && lastItem.axisType === thisItem.axisType && lastItem.axisId === thisItem.axisId && lastIndices.length === newIndices.length;
	        contentNotChanged && each(lastIndices, function (lastIdxItem, j) {
	          var newIdxItem = newIndices[j];
	          contentNotChanged = contentNotChanged && lastIdxItem.seriesIndex === newIdxItem.seriesIndex && lastIdxItem.dataIndex === newIdxItem.dataIndex;
	        });
	      });
	    });
	    this._lastDataByCoordSys = dataByCoordSys;
	    return !!contentNotChanged;
	  };
	
	  TooltipView.prototype._hide = function (dispatchAction) {
	    this._lastDataByCoordSys = null;
	    dispatchAction({
	      type: 'hideTip',
	      from: this.uid
	    });
	  };
	
	  TooltipView.prototype.dispose = function (ecModel, api) {
	    if (env_1["default"].node) {
	      return;
	    }
	
	    this._tooltipContent.dispose();
	
	    globalListener.unregister('itemTooltip', api);
	  };
	
	  TooltipView.type = 'tooltip';
	  return TooltipView;
	}(Component_1["default"]);
	
	function buildTooltipModel(modelCascade) {
	  var resultModel = modelCascade.pop();
	
	  while (modelCascade.length) {
	    var tooltipOpt = modelCascade.pop();
	
	    if (tooltipOpt) {
	      if (tooltipOpt instanceof Model_1["default"]) {
	        tooltipOpt = tooltipOpt.get('tooltip', true);
	      }
	
	      if (zrUtil.isString(tooltipOpt)) {
	        tooltipOpt = {
	          formatter: tooltipOpt
	        };
	      }
	
	      resultModel = new Model_1["default"](tooltipOpt, resultModel, resultModel.ecModel);
	    }
	  }
	
	  return resultModel;
	}
	
	function makeDispatchAction(payload, api) {
	  return payload.dispatchAction || zrUtil.bind(api.dispatchAction, api);
	}
	
	function refixTooltipPosition(x, y, content, viewWidth, viewHeight, gapH, gapV) {
	  var size = content.getOuterSize();
	  var width = size.width;
	  var height = size.height;
	
	  if (gapH != null) {
	    if (x + width + gapH + 2 > viewWidth) {
	      x -= width + gapH;
	    } else {
	      x += gapH;
	    }
	  }
	
	  if (gapV != null) {
	    if (y + height + gapV > viewHeight) {
	      y -= height + gapV;
	    } else {
	      y += gapV;
	    }
	  }
	
	  return [x, y];
	}
	
	function confineTooltipPosition(x, y, content, viewWidth, viewHeight) {
	  var size = content.getOuterSize();
	  var width = size.width;
	  var height = size.height;
	  x = Math.min(x + width, viewWidth) - width;
	  y = Math.min(y + height, viewHeight) - height;
	  x = Math.max(x, 0);
	  y = Math.max(y, 0);
	  return [x, y];
	}
	
	function calcTooltipPosition(position, rect, contentSize) {
	  var domWidth = contentSize[0];
	  var domHeight = contentSize[1];
	  var gap = 10;
	  var offset = 5;
	  var x = 0;
	  var y = 0;
	  var rectWidth = rect.width;
	  var rectHeight = rect.height;
	
	  switch (position) {
	    case 'inside':
	      x = rect.x + rectWidth / 2 - domWidth / 2;
	      y = rect.y + rectHeight / 2 - domHeight / 2;
	      break;
	
	    case 'top':
	      x = rect.x + rectWidth / 2 - domWidth / 2;
	      y = rect.y - domHeight - gap;
	      break;
	
	    case 'bottom':
	      x = rect.x + rectWidth / 2 - domWidth / 2;
	      y = rect.y + rectHeight + gap;
	      break;
	
	    case 'left':
	      x = rect.x - domWidth - gap - offset;
	      y = rect.y + rectHeight / 2 - domHeight / 2;
	      break;
	
	    case 'right':
	      x = rect.x + rectWidth + gap + offset;
	      y = rect.y + rectHeight / 2 - domHeight / 2;
	  }
	
	  return [x, y];
	}
	
	function isCenterAlign(align) {
	  return align === 'center' || align === 'middle';
	}
	
	Component_1["default"].registerClass(TooltipView);

/***/ },
/* 332 */
/***/ function(module, exports, __webpack_require__) {

	
	/*
	* Licensed to the Apache Software Foundation (ASF) under one
	* or more contributor license agreements.  See the NOTICE file
	* distributed with this work for additional information
	* regarding copyright ownership.  The ASF licenses this file
	* to you under the Apache License, Version 2.0 (the
	* "License"); you may not use this file except in compliance
	* with the License.  You may obtain a copy of the License at
	*
	*   http://www.apache.org/licenses/LICENSE-2.0
	*
	* Unless required by applicable law or agreed to in writing,
	* software distributed under the License is distributed on an
	* "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
	* KIND, either express or implied.  See the License for the
	* specific language governing permissions and limitations
	* under the License.
	*/
	
	
	
	/**
	 * AUTO-GENERATED FILE. DO NOT MODIFY.
	 */
	
	"use strict";
	
	exports.__esModule = true;
	
	var util_1 = __webpack_require__(1);
	
	var tooltipMarkup_1 = __webpack_require__(52);
	
	var dataProvider_1 = __webpack_require__(53);
	
	var model_1 = __webpack_require__(4);
	
	function defaultSeriesFormatTooltip(opt) {
	  var series = opt.series;
	  var dataIndex = opt.dataIndex;
	  var multipleSeries = opt.multipleSeries;
	  var data = series.getData();
	  var tooltipDims = data.mapDimensionsAll('defaultedTooltip');
	  var tooltipDimLen = tooltipDims.length;
	  var value = series.getRawValue(dataIndex);
	  var isValueArr = util_1.isArray(value);
	  var markerColor = tooltipMarkup_1.retrieveVisualColorForTooltipMarker(series, dataIndex);
	  var inlineValue;
	  var inlineValueType;
	  var subBlocks;
	  var sortParam;
	
	  if (tooltipDimLen > 1 || isValueArr && !tooltipDimLen) {
	    var formatArrResult = formatTooltipArrayValue(value, series, dataIndex, tooltipDims, markerColor);
	    inlineValue = formatArrResult.inlineValues;
	    inlineValueType = formatArrResult.inlineValueTypes;
	    subBlocks = formatArrResult.blocks;
	    sortParam = formatArrResult.inlineValues[0];
	  } else if (tooltipDimLen) {
	    var dimInfo = data.getDimensionInfo(tooltipDims[0]);
	    sortParam = inlineValue = dataProvider_1.retrieveRawValue(data, dataIndex, tooltipDims[0]);
	    inlineValueType = dimInfo.type;
	  } else {
	    sortParam = inlineValue = isValueArr ? value[0] : value;
	  }
	
	  var seriesNameSpecified = model_1.isNameSpecified(series);
	  var seriesName = seriesNameSpecified && series.name || '';
	  var itemName = data.getName(dataIndex);
	  var inlineName = multipleSeries ? seriesName : itemName;
	  return tooltipMarkup_1.createTooltipMarkup('section', {
	    header: seriesName,
	    noHeader: multipleSeries || !seriesNameSpecified,
	    sortParam: sortParam,
	    blocks: [tooltipMarkup_1.createTooltipMarkup('nameValue', {
	      markerType: 'item',
	      markerColor: markerColor,
	      name: inlineName,
	      noName: !util_1.trim(inlineName),
	      value: inlineValue,
	      valueType: inlineValueType
	    })].concat(subBlocks || [])
	  });
	}
	
	exports.defaultSeriesFormatTooltip = defaultSeriesFormatTooltip;
	
	function formatTooltipArrayValue(value, series, dataIndex, tooltipDims, colorStr) {
	  var data = series.getData();
	  var isValueMultipleLine = util_1.reduce(value, function (isValueMultipleLine, val, idx) {
	    var dimItem = data.getDimensionInfo(idx);
	    return isValueMultipleLine = isValueMultipleLine || dimItem && dimItem.tooltip !== false && dimItem.displayName != null;
	  }, false);
	  var inlineValues = [];
	  var inlineValueTypes = [];
	  var blocks = [];
	  tooltipDims.length ? util_1.each(tooltipDims, function (dim) {
	    setEachItem(dataProvider_1.retrieveRawValue(data, dataIndex, dim), dim);
	  }) : util_1.each(value, setEachItem);
	
	  function setEachItem(val, dim) {
	    var dimInfo = data.getDimensionInfo(dim);
	
	    if (!dimInfo || dimInfo.otherDims.tooltip === false) {
	      return;
	    }
	
	    if (isValueMultipleLine) {
	      blocks.push(tooltipMarkup_1.createTooltipMarkup('nameValue', {
	        markerType: 'subItem',
	        markerColor: colorStr,
	        name: dimInfo.displayName,
	        value: val,
	        valueType: dimInfo.type
	      }));
	    } else {
	      inlineValues.push(val);
	      inlineValueTypes.push(dimInfo.type);
	    }
	  }
	
	  return {
	    inlineValues: inlineValues,
	    inlineValueTypes: inlineValueTypes,
	    blocks: blocks
	  };
	}

/***/ },
/* 333 */
/***/ function(module, exports, __webpack_require__) {

	
	/*
	* Licensed to the Apache Software Foundation (ASF) under one
	* or more contributor license agreements.  See the NOTICE file
	* distributed with this work for additional information
	* regarding copyright ownership.  The ASF licenses this file
	* to you under the Apache License, Version 2.0 (the
	* "License"); you may not use this file except in compliance
	* with the License.  You may obtain a copy of the License at
	*
	*   http://www.apache.org/licenses/LICENSE-2.0
	*
	* Unless required by applicable law or agreed to in writing,
	* software distributed under the License is distributed on an
	* "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
	* KIND, either express or implied.  See the License for the
	* specific language governing permissions and limitations
	* under the License.
	*/
	
	
	
	/**
	 * AUTO-GENERATED FILE. DO NOT MODIFY.
	 */
	
	"use strict";
	
	exports.__esModule = true;
	
	var util_1 = __webpack_require__(1);
	
	var number_1 = __webpack_require__(9);
	
	var axisTickLabelBuilder_1 = __webpack_require__(338);
	
	var NORMALIZED_EXTENT = [0, 1];
	
	var Axis = function () {
	  function Axis(dim, scale, extent) {
	    this.onBand = false;
	    this.inverse = false;
	    this.dim = dim;
	    this.scale = scale;
	    this._extent = extent || [0, 0];
	  }
	
	  Axis.prototype.contain = function (coord) {
	    var extent = this._extent;
	    var min = Math.min(extent[0], extent[1]);
	    var max = Math.max(extent[0], extent[1]);
	    return coord >= min && coord <= max;
	  };
	
	  Axis.prototype.containData = function (data) {
	    return this.scale.contain(data);
	  };
	
	  Axis.prototype.getExtent = function () {
	    return this._extent.slice();
	  };
	
	  Axis.prototype.getPixelPrecision = function (dataExtent) {
	    return number_1.getPixelPrecision(dataExtent || this.scale.getExtent(), this._extent);
	  };
	
	  Axis.prototype.setExtent = function (start, end) {
	    var extent = this._extent;
	    extent[0] = start;
	    extent[1] = end;
	  };
	
	  Axis.prototype.dataToCoord = function (data, clamp) {
	    var extent = this._extent;
	    var scale = this.scale;
	    data = scale.normalize(data);
	
	    if (this.onBand && scale.type === 'ordinal') {
	      extent = extent.slice();
	      fixExtentWithBands(extent, scale.count());
	    }
	
	    return number_1.linearMap(data, NORMALIZED_EXTENT, extent, clamp);
	  };
	
	  Axis.prototype.coordToData = function (coord, clamp) {
	    var extent = this._extent;
	    var scale = this.scale;
	
	    if (this.onBand && scale.type === 'ordinal') {
	      extent = extent.slice();
	      fixExtentWithBands(extent, scale.count());
	    }
	
	    var t = number_1.linearMap(coord, extent, NORMALIZED_EXTENT, clamp);
	    return this.scale.scale(t);
	  };
	
	  Axis.prototype.pointToData = function (point, clamp) {
	    return;
	  };
	
	  Axis.prototype.getTicksCoords = function (opt) {
	    opt = opt || {};
	    var tickModel = opt.tickModel || this.getTickModel();
	    var result = axisTickLabelBuilder_1.createAxisTicks(this, tickModel);
	    var ticks = result.ticks;
	    var ticksCoords = util_1.map(ticks, function (tickVal) {
	      return {
	        coord: this.dataToCoord(this.scale.type === 'ordinal' ? this.scale.getRawIndex(tickVal) : tickVal),
	        tickValue: tickVal
	      };
	    }, this);
	    var alignWithLabel = tickModel.get('alignWithLabel');
	    fixOnBandTicksCoords(this, ticksCoords, alignWithLabel, opt.clamp);
	    return ticksCoords;
	  };
	
	  Axis.prototype.getMinorTicksCoords = function () {
	    if (this.scale.type === 'ordinal') {
	      return [];
	    }
	
	    var minorTickModel = this.model.getModel('minorTick');
	    var splitNumber = minorTickModel.get('splitNumber');
	
	    if (!(splitNumber > 0 && splitNumber < 100)) {
	      splitNumber = 5;
	    }
	
	    var minorTicks = this.scale.getMinorTicks(splitNumber);
	    var minorTicksCoords = util_1.map(minorTicks, function (minorTicksGroup) {
	      return util_1.map(minorTicksGroup, function (minorTick) {
	        return {
	          coord: this.dataToCoord(minorTick),
	          tickValue: minorTick
	        };
	      }, this);
	    }, this);
	    return minorTicksCoords;
	  };
	
	  Axis.prototype.getViewLabels = function () {
	    return axisTickLabelBuilder_1.createAxisLabels(this).labels;
	  };
	
	  Axis.prototype.getLabelModel = function () {
	    return this.model.getModel('axisLabel');
	  };
	
	  Axis.prototype.getTickModel = function () {
	    return this.model.getModel('axisTick');
	  };
	
	  Axis.prototype.getBandWidth = function () {
	    var axisExtent = this._extent;
	    var dataExtent = this.scale.getExtent();
	    var len = dataExtent[1] - dataExtent[0] + (this.onBand ? 1 : 0);
	    len === 0 && (len = 1);
	    var size = Math.abs(axisExtent[1] - axisExtent[0]);
	    return Math.abs(size) / len;
	  };
	
	  Axis.prototype.calculateCategoryInterval = function () {
	    return axisTickLabelBuilder_1.calculateCategoryInterval(this);
	  };
	
	  return Axis;
	}();
	
	function fixExtentWithBands(extent, nTick) {
	  var size = extent[1] - extent[0];
	  var len = nTick;
	  var margin = size / len / 2;
	  extent[0] += margin;
	  extent[1] -= margin;
	}
	
	function fixOnBandTicksCoords(axis, ticksCoords, alignWithLabel, clamp) {
	  var ticksLen = ticksCoords.length;
	
	  if (!axis.onBand || alignWithLabel || !ticksLen) {
	    return;
	  }
	
	  var axisExtent = axis.getExtent();
	  var last;
	  var diffSize;
	
	  if (ticksLen === 1) {
	    ticksCoords[0].coord = axisExtent[0];
	    last = ticksCoords[1] = {
	      coord: axisExtent[0]
	    };
	  } else {
	    var crossLen = ticksCoords[ticksLen - 1].tickValue - ticksCoords[0].tickValue;
	    var shift_1 = (ticksCoords[ticksLen - 1].coord - ticksCoords[0].coord) / crossLen;
	    util_1.each(ticksCoords, function (ticksItem) {
	      ticksItem.coord -= shift_1 / 2;
	    });
	    var dataExtent = axis.scale.getExtent();
	    diffSize = 1 + dataExtent[1] - ticksCoords[ticksLen - 1].tickValue;
	    last = {
	      coord: ticksCoords[ticksLen - 1].coord + shift_1 * diffSize
	    };
	    ticksCoords.push(last);
	  }
	
	  var inverse = axisExtent[0] > axisExtent[1];
	
	  if (littleThan(ticksCoords[0].coord, axisExtent[0])) {
	    clamp ? ticksCoords[0].coord = axisExtent[0] : ticksCoords.shift();
	  }
	
	  if (clamp && littleThan(axisExtent[0], ticksCoords[0].coord)) {
	    ticksCoords.unshift({
	      coord: axisExtent[0]
	    });
	  }
	
	  if (littleThan(axisExtent[1], last.coord)) {
	    clamp ? last.coord = axisExtent[1] : ticksCoords.pop();
	  }
	
	  if (clamp && littleThan(last.coord, axisExtent[1])) {
	    ticksCoords.push({
	      coord: axisExtent[1]
	    });
	  }
	
	  function littleThan(a, b) {
	    a = number_1.round(a);
	    b = number_1.round(b);
	    return inverse ? a > b : a < b;
	  }
	}
	
	exports["default"] = Axis;

/***/ },
/* 334 */
/***/ function(module, exports) {

	
	/*
	* Licensed to the Apache Software Foundation (ASF) under one
	* or more contributor license agreements.  See the NOTICE file
	* distributed with this work for additional information
	* regarding copyright ownership.  The ASF licenses this file
	* to you under the Apache License, Version 2.0 (the
	* "License"); you may not use this file except in compliance
	* with the License.  You may obtain a copy of the License at
	*
	*   http://www.apache.org/licenses/LICENSE-2.0
	*
	* Unless required by applicable law or agreed to in writing,
	* software distributed under the License is distributed on an
	* "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
	* KIND, either express or implied.  See the License for the
	* specific language governing permissions and limitations
	* under the License.
	*/
	
	
	
	/**
	 * AUTO-GENERATED FILE. DO NOT MODIFY.
	 */
	
	"use strict";
	
	exports.__esModule = true;
	exports.AXIS_TYPES = {
	  value: 1,
	  category: 1,
	  time: 1,
	  log: 1
	};

/***/ },
/* 335 */
/***/ function(module, exports, __webpack_require__) {

	
	/*
	* Licensed to the Apache Software Foundation (ASF) under one
	* or more contributor license agreements.  See the NOTICE file
	* distributed with this work for additional information
	* regarding copyright ownership.  The ASF licenses this file
	* to you under the Apache License, Version 2.0 (the
	* "License"); you may not use this file except in compliance
	* with the License.  You may obtain a copy of the License at
	*
	*   http://www.apache.org/licenses/LICENSE-2.0
	*
	* Unless required by applicable law or agreed to in writing,
	* software distributed under the License is distributed on an
	* "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
	* KIND, either express or implied.  See the License for the
	* specific language governing permissions and limitations
	* under the License.
	*/
	
	
	
	/**
	 * AUTO-GENERATED FILE. DO NOT MODIFY.
	 */
	
	"use strict";
	
	exports.__esModule = true;
	
	var zrUtil = __webpack_require__(1);
	
	var defaultOption = {
	  show: true,
	  zlevel: 0,
	  z: 0,
	  inverse: false,
	  name: '',
	  nameLocation: 'end',
	  nameRotate: null,
	  nameTruncate: {
	    maxWidth: null,
	    ellipsis: '...',
	    placeholder: '.'
	  },
	  nameTextStyle: {},
	  nameGap: 15,
	  silent: false,
	  triggerEvent: false,
	  tooltip: {
	    show: false
	  },
	  axisPointer: {},
	  axisLine: {
	    show: true,
	    onZero: true,
	    onZeroAxisIndex: null,
	    lineStyle: {
	      color: '#6E7079',
	      width: 1,
	      type: 'solid'
	    },
	    symbol: ['none', 'none'],
	    symbolSize: [10, 15]
	  },
	  axisTick: {
	    show: true,
	    inside: false,
	    length: 5,
	    lineStyle: {
	      width: 1
	    }
	  },
	  axisLabel: {
	    show: true,
	    inside: false,
	    rotate: 0,
	    showMinLabel: null,
	    showMaxLabel: null,
	    margin: 8,
	    fontSize: 12
	  },
	  splitLine: {
	    show: true,
	    lineStyle: {
	      color: ['#E0E6F1'],
	      width: 1,
	      type: 'solid'
	    }
	  },
	  splitArea: {
	    show: false,
	    areaStyle: {
	      color: ['rgba(250,250,250,0.2)', 'rgba(210,219,238,0.2)']
	    }
	  }
	};
	var categoryAxis = zrUtil.merge({
	  boundaryGap: true,
	  deduplication: null,
	  splitLine: {
	    show: false
	  },
	  axisTick: {
	    alignWithLabel: false,
	    interval: 'auto'
	  },
	  axisLabel: {
	    interval: 'auto'
	  }
	}, defaultOption);
	var valueAxis = zrUtil.merge({
	  boundaryGap: [0, 0],
	  axisLine: {
	    show: 'auto'
	  },
	  axisTick: {
	    show: 'auto'
	  },
	  splitNumber: 5,
	  minorTick: {
	    show: false,
	    splitNumber: 5,
	    length: 3,
	    lineStyle: {}
	  },
	  minorSplitLine: {
	    show: false,
	    lineStyle: {
	      color: '#F4F7FD',
	      width: 1
	    }
	  }
	}, defaultOption);
	var timeAxis = zrUtil.merge({
	  scale: true,
	  splitNumber: 6,
	  axisLabel: {
	    showMinLabel: false,
	    showMaxLabel: false,
	    rich: {
	      primary: {
	        fontWeight: 'bold'
	      }
	    }
	  },
	  splitLine: {
	    show: false
	  }
	}, valueAxis);
	var logAxis = zrUtil.defaults({
	  scale: true,
	  logBase: 10
	}, valueAxis);
	exports["default"] = {
	  category: categoryAxis,
	  value: valueAxis,
	  time: timeAxis,
	  log: logAxis
	};

/***/ },
/* 336 */
/***/ function(module, exports) {

	
	/*
	* Licensed to the Apache Software Foundation (ASF) under one
	* or more contributor license agreements.  See the NOTICE file
	* distributed with this work for additional information
	* regarding copyright ownership.  The ASF licenses this file
	* to you under the Apache License, Version 2.0 (the
	* "License"); you may not use this file except in compliance
	* with the License.  You may obtain a copy of the License at
	*
	*   http://www.apache.org/licenses/LICENSE-2.0
	*
	* Unless required by applicable law or agreed to in writing,
	* software distributed under the License is distributed on an
	* "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
	* KIND, either express or implied.  See the License for the
	* specific language governing permissions and limitations
	* under the License.
	*/
	
	
	
	/**
	 * AUTO-GENERATED FILE. DO NOT MODIFY.
	 */
	
	"use strict";
	
	exports.__esModule = true;
	
	var AxisModelCommonMixin = function () {
	  function AxisModelCommonMixin() {}
	
	  AxisModelCommonMixin.prototype.getNeedCrossZero = function () {
	    var option = this.option;
	    return !option.scale;
	  };
	
	  AxisModelCommonMixin.prototype.getCoordSysModel = function () {
	    return;
	  };
	
	  return AxisModelCommonMixin;
	}();
	
	exports.AxisModelCommonMixin = AxisModelCommonMixin;

/***/ },
/* 337 */
/***/ function(module, exports, __webpack_require__) {

	
	/*
	* Licensed to the Apache Software Foundation (ASF) under one
	* or more contributor license agreements.  See the NOTICE file
	* distributed with this work for additional information
	* regarding copyright ownership.  The ASF licenses this file
	* to you under the Apache License, Version 2.0 (the
	* "License"); you may not use this file except in compliance
	* with the License.  You may obtain a copy of the License at
	*
	*   http://www.apache.org/licenses/LICENSE-2.0
	*
	* Unless required by applicable law or agreed to in writing,
	* software distributed under the License is distributed on an
	* "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
	* KIND, either express or implied.  See the License for the
	* specific language governing permissions and limitations
	* under the License.
	*/
	
	
	
	/**
	 * AUTO-GENERATED FILE. DO NOT MODIFY.
	 */
	
	"use strict";
	
	exports.__esModule = true;
	
	var tslib_1 = __webpack_require__(3);
	
	var zrUtil = __webpack_require__(1);
	
	var axisDefault_1 = __webpack_require__(335);
	
	var Component_1 = __webpack_require__(10);
	
	var layout_1 = __webpack_require__(30);
	
	var OrdinalMeta_1 = __webpack_require__(145);
	
	var axisCommonTypes_1 = __webpack_require__(334);
	
	function axisModelCreator(axisName, BaseAxisModelClass, extraDefaultOption) {
	  zrUtil.each(axisCommonTypes_1.AXIS_TYPES, function (v, axisType) {
	    var defaultOption = zrUtil.merge(zrUtil.merge({}, axisDefault_1["default"][axisType], true), extraDefaultOption, true);
	
	    var AxisModel = function (_super) {
	      tslib_1.__extends(AxisModel, _super);
	
	      function AxisModel() {
	        var args = [];
	
	        for (var _i = 0; _i < arguments.length; _i++) {
	          args[_i] = arguments[_i];
	        }
	
	        var _this = _super.apply(this, args) || this;
	
	        _this.type = axisName + 'Axis.' + axisType;
	        return _this;
	      }
	
	      AxisModel.prototype.mergeDefaultAndTheme = function (option, ecModel) {
	        var layoutMode = layout_1.fetchLayoutMode(this);
	        var inputPositionParams = layoutMode ? layout_1.getLayoutParams(option) : {};
	        var themeModel = ecModel.getTheme();
	        zrUtil.merge(option, themeModel.get(axisType + 'Axis'));
	        zrUtil.merge(option, this.getDefaultOption());
	        option.type = getAxisType(option);
	
	        if (layoutMode) {
	          layout_1.mergeLayoutParam(option, inputPositionParams, layoutMode);
	        }
	      };
	
	      AxisModel.prototype.optionUpdated = function () {
	        var thisOption = this.option;
	
	        if (thisOption.type === 'category') {
	          this.__ordinalMeta = OrdinalMeta_1["default"].createByAxisModel(this);
	        }
	      };
	
	      AxisModel.prototype.getCategories = function (rawData) {
	        var option = this.option;
	
	        if (option.type === 'category') {
	          if (rawData) {
	            return option.data;
	          }
	
	          return this.__ordinalMeta.categories;
	        }
	      };
	
	      AxisModel.prototype.getOrdinalMeta = function () {
	        return this.__ordinalMeta;
	      };
	
	      AxisModel.type = axisName + 'Axis.' + axisType;
	      AxisModel.defaultOption = defaultOption;
	      return AxisModel;
	    }(BaseAxisModelClass);
	
	    Component_1["default"].registerClass(AxisModel);
	  });
	  Component_1["default"].registerSubTypeDefaulter(axisName + 'Axis', getAxisType);
	}
	
	exports["default"] = axisModelCreator;
	
	function getAxisType(option) {
	  return option.type || (option.data ? 'category' : 'value');
	}

/***/ },
/* 338 */
/***/ function(module, exports, __webpack_require__) {

	
	/*
	* Licensed to the Apache Software Foundation (ASF) under one
	* or more contributor license agreements.  See the NOTICE file
	* distributed with this work for additional information
	* regarding copyright ownership.  The ASF licenses this file
	* to you under the Apache License, Version 2.0 (the
	* "License"); you may not use this file except in compliance
	* with the License.  You may obtain a copy of the License at
	*
	*   http://www.apache.org/licenses/LICENSE-2.0
	*
	* Unless required by applicable law or agreed to in writing,
	* software distributed under the License is distributed on an
	* "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
	* KIND, either express or implied.  See the License for the
	* specific language governing permissions and limitations
	* under the License.
	*/
	
	
	
	/**
	 * AUTO-GENERATED FILE. DO NOT MODIFY.
	 */
	
	"use strict";
	
	exports.__esModule = true;
	
	var zrUtil = __webpack_require__(1);
	
	var textContain = __webpack_require__(26);
	
	var model_1 = __webpack_require__(4);
	
	var axisHelper_1 = __webpack_require__(39);
	
	var inner = model_1.makeInner();
	
	function createAxisLabels(axis) {
	  return axis.type === 'category' ? makeCategoryLabels(axis) : makeRealNumberLabels(axis);
	}
	
	exports.createAxisLabels = createAxisLabels;
	
	function createAxisTicks(axis, tickModel) {
	  return axis.type === 'category' ? makeCategoryTicks(axis, tickModel) : {
	    ticks: zrUtil.map(axis.scale.getTicks(), function (tick) {
	      return tick.value;
	    })
	  };
	}
	
	exports.createAxisTicks = createAxisTicks;
	
	function makeCategoryLabels(axis) {
	  var labelModel = axis.getLabelModel();
	  var result = makeCategoryLabelsActually(axis, labelModel);
	  return !labelModel.get('show') || axis.scale.isBlank() ? {
	    labels: [],
	    labelCategoryInterval: result.labelCategoryInterval
	  } : result;
	}
	
	function makeCategoryLabelsActually(axis, labelModel) {
	  var labelsCache = getListCache(axis, 'labels');
	  var optionLabelInterval = axisHelper_1.getOptionCategoryInterval(labelModel);
	  var result = listCacheGet(labelsCache, optionLabelInterval);
	
	  if (result) {
	    return result;
	  }
	
	  var labels;
	  var numericLabelInterval;
	
	  if (zrUtil.isFunction(optionLabelInterval)) {
	    labels = makeLabelsByCustomizedCategoryInterval(axis, optionLabelInterval);
	  } else {
	    numericLabelInterval = optionLabelInterval === 'auto' ? makeAutoCategoryInterval(axis) : optionLabelInterval;
	    labels = makeLabelsByNumericCategoryInterval(axis, numericLabelInterval);
	  }
	
	  return listCacheSet(labelsCache, optionLabelInterval, {
	    labels: labels,
	    labelCategoryInterval: numericLabelInterval
	  });
	}
	
	function makeCategoryTicks(axis, tickModel) {
	  var ticksCache = getListCache(axis, 'ticks');
	  var optionTickInterval = axisHelper_1.getOptionCategoryInterval(tickModel);
	  var result = listCacheGet(ticksCache, optionTickInterval);
	
	  if (result) {
	    return result;
	  }
	
	  var ticks;
	  var tickCategoryInterval;
	
	  if (!tickModel.get('show') || axis.scale.isBlank()) {
	    ticks = [];
	  }
	
	  if (zrUtil.isFunction(optionTickInterval)) {
	    ticks = makeLabelsByCustomizedCategoryInterval(axis, optionTickInterval, true);
	  } else if (optionTickInterval === 'auto') {
	    var labelsResult = makeCategoryLabelsActually(axis, axis.getLabelModel());
	    tickCategoryInterval = labelsResult.labelCategoryInterval;
	    ticks = zrUtil.map(labelsResult.labels, function (labelItem) {
	      return labelItem.tickValue;
	    });
	  } else {
	    tickCategoryInterval = optionTickInterval;
	    ticks = makeLabelsByNumericCategoryInterval(axis, tickCategoryInterval, true);
	  }
	
	  return listCacheSet(ticksCache, optionTickInterval, {
	    ticks: ticks,
	    tickCategoryInterval: tickCategoryInterval
	  });
	}
	
	function makeRealNumberLabels(axis) {
	  var ticks = axis.scale.getTicks();
	  var labelFormatter = axisHelper_1.makeLabelFormatter(axis);
	  return {
	    labels: zrUtil.map(ticks, function (tick, idx) {
	      return {
	        formattedLabel: labelFormatter(tick, idx),
	        rawLabel: axis.scale.getLabel(tick),
	        tickValue: tick.value
	      };
	    })
	  };
	}
	
	function getListCache(axis, prop) {
	  return inner(axis)[prop] || (inner(axis)[prop] = []);
	}
	
	function listCacheGet(cache, key) {
	  for (var i = 0; i < cache.length; i++) {
	    if (cache[i].key === key) {
	      return cache[i].value;
	    }
	  }
	}
	
	function listCacheSet(cache, key, value) {
	  cache.push({
	    key: key,
	    value: value
	  });
	  return value;
	}
	
	function makeAutoCategoryInterval(axis) {
	  var result = inner(axis).autoInterval;
	  return result != null ? result : inner(axis).autoInterval = axis.calculateCategoryInterval();
	}
	
	function calculateCategoryInterval(axis) {
	  var params = fetchAutoCategoryIntervalCalculationParams(axis);
	  var labelFormatter = axisHelper_1.makeLabelFormatter(axis);
	  var rotation = (params.axisRotate - params.labelRotate) / 180 * Math.PI;
	  var ordinalScale = axis.scale;
	  var ordinalExtent = ordinalScale.getExtent();
	  var tickCount = ordinalScale.count();
	
	  if (ordinalExtent[1] - ordinalExtent[0] < 1) {
	    return 0;
	  }
	
	  var step = 1;
	
	  if (tickCount > 40) {
	    step = Math.max(1, Math.floor(tickCount / 40));
	  }
	
	  var tickValue = ordinalExtent[0];
	  var unitSpan = axis.dataToCoord(tickValue + 1) - axis.dataToCoord(tickValue);
	  var unitW = Math.abs(unitSpan * Math.cos(rotation));
	  var unitH = Math.abs(unitSpan * Math.sin(rotation));
	  var maxW = 0;
	  var maxH = 0;
	
	  for (; tickValue <= ordinalExtent[1]; tickValue += step) {
	    var width = 0;
	    var height = 0;
	    var rect = textContain.getBoundingRect(labelFormatter({
	      value: tickValue
	    }), params.font, 'center', 'top');
	    width = rect.width * 1.3;
	    height = rect.height * 1.3;
	    maxW = Math.max(maxW, width, 7);
	    maxH = Math.max(maxH, height, 7);
	  }
	
	  var dw = maxW / unitW;
	  var dh = maxH / unitH;
	  isNaN(dw) && (dw = Infinity);
	  isNaN(dh) && (dh = Infinity);
	  var interval = Math.max(0, Math.floor(Math.min(dw, dh)));
	  var cache = inner(axis.model);
	  var axisExtent = axis.getExtent();
	  var lastAutoInterval = cache.lastAutoInterval;
	  var lastTickCount = cache.lastTickCount;
	
	  if (lastAutoInterval != null && lastTickCount != null && Math.abs(lastAutoInterval - interval) <= 1 && Math.abs(lastTickCount - tickCount) <= 1 && lastAutoInterval > interval && cache.axisExtent0 === axisExtent[0] && cache.axisExtent1 === axisExtent[1]) {
	    interval = lastAutoInterval;
	  } else {
	    cache.lastTickCount = tickCount;
	    cache.lastAutoInterval = interval;
	    cache.axisExtent0 = axisExtent[0];
	    cache.axisExtent1 = axisExtent[1];
	  }
	
	  return interval;
	}
	
	exports.calculateCategoryInterval = calculateCategoryInterval;
	
	function fetchAutoCategoryIntervalCalculationParams(axis) {
	  var labelModel = axis.getLabelModel();
	  return {
	    axisRotate: axis.getRotate ? axis.getRotate() : axis.isHorizontal && !axis.isHorizontal() ? 90 : 0,
	    labelRotate: labelModel.get('rotate') || 0,
	    font: labelModel.getFont()
	  };
	}
	
	function makeLabelsByNumericCategoryInterval(axis, categoryInterval, onlyTick) {
	  var labelFormatter = axisHelper_1.makeLabelFormatter(axis);
	  var ordinalScale = axis.scale;
	  var ordinalExtent = ordinalScale.getExtent();
	  var labelModel = axis.getLabelModel();
	  var result = [];
	  var step = Math.max((categoryInterval || 0) + 1, 1);
	  var startTick = ordinalExtent[0];
	  var tickCount = ordinalScale.count();
	
	  if (startTick !== 0 && step > 1 && tickCount / step > 2) {
	    startTick = Math.round(Math.ceil(startTick / step) * step);
	  }
	
	  var showAllLabel = axisHelper_1.shouldShowAllLabels(axis);
	  var includeMinLabel = labelModel.get('showMinLabel') || showAllLabel;
	  var includeMaxLabel = labelModel.get('showMaxLabel') || showAllLabel;
	
	  if (includeMinLabel && startTick !== ordinalExtent[0]) {
	    addItem(ordinalExtent[0]);
	  }
	
	  var tickValue = startTick;
	
	  for (; tickValue <= ordinalExtent[1]; tickValue += step) {
	    addItem(tickValue);
	  }
	
	  if (includeMaxLabel && tickValue - step !== ordinalExtent[1]) {
	    addItem(ordinalExtent[1]);
	  }
	
	  function addItem(tickValue) {
	    var tickObj = {
	      value: tickValue
	    };
	    result.push(onlyTick ? tickValue : {
	      formattedLabel: labelFormatter(tickObj),
	      rawLabel: ordinalScale.getLabel(tickObj),
	      tickValue: tickValue
	    });
	  }
	
	  return result;
	}
	
	function makeLabelsByCustomizedCategoryInterval(axis, categoryInterval, onlyTick) {
	  var ordinalScale = axis.scale;
	  var labelFormatter = axisHelper_1.makeLabelFormatter(axis);
	  var result = [];
	  zrUtil.each(ordinalScale.getTicks(), function (tick) {
	    var rawLabel = ordinalScale.getLabel(tick);
	    var tickValue = tick.value;
	
	    if (categoryInterval(tick.value, rawLabel)) {
	      result.push(onlyTick ? tickValue : {
	        formattedLabel: labelFormatter(tick),
	        rawLabel: rawLabel,
	        tickValue: tickValue
	      });
	    }
	  });
	  return result;
	}

/***/ },
/* 339 */
/***/ function(module, exports, __webpack_require__) {

	
	/*
	* Licensed to the Apache Software Foundation (ASF) under one
	* or more contributor license agreements.  See the NOTICE file
	* distributed with this work for additional information
	* regarding copyright ownership.  The ASF licenses this file
	* to you under the Apache License, Version 2.0 (the
	* "License"); you may not use this file except in compliance
	* with the License.  You may obtain a copy of the License at
	*
	*   http://www.apache.org/licenses/LICENSE-2.0
	*
	* Unless required by applicable law or agreed to in writing,
	* software distributed under the License is distributed on an
	* "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
	* KIND, either express or implied.  See the License for the
	* specific language governing permissions and limitations
	* under the License.
	*/
	
	
	
	/**
	 * AUTO-GENERATED FILE. DO NOT MODIFY.
	 */
	
	"use strict";
	
	exports.__esModule = true;
	
	var tslib_1 = __webpack_require__(3);
	
	var Axis_1 = __webpack_require__(333);
	
	var Axis2D = function (_super) {
	  tslib_1.__extends(Axis2D, _super);
	
	  function Axis2D(dim, scale, coordExtent, axisType, position) {
	    var _this = _super.call(this, dim, scale, coordExtent) || this;
	
	    _this.index = 0;
	    _this.type = axisType || 'value';
	    _this.position = position || 'bottom';
	    return _this;
	  }
	
	  Axis2D.prototype.isHorizontal = function () {
	    var position = this.position;
	    return position === 'top' || position === 'bottom';
	  };
	
	  Axis2D.prototype.getGlobalExtent = function (asc) {
	    var ret = this.getExtent();
	    ret[0] = this.toGlobalCoord(ret[0]);
	    ret[1] = this.toGlobalCoord(ret[1]);
	    asc && ret[0] > ret[1] && ret.reverse();
	    return ret;
	  };
	
	  Axis2D.prototype.pointToData = function (point, clamp) {
	    return this.coordToData(this.toLocalCoord(point[this.dim === 'x' ? 0 : 1]), clamp);
	  };
	
	  Axis2D.prototype.setCategorySortInfo = function (info) {
	    if (this.type !== 'category') {
	      return false;
	    }
	
	    this.model.option.categorySortInfo = info;
	    this.scale.setCategorySortInfo(info);
	  };
	
	  return Axis2D;
	}(Axis_1["default"]);
	
	exports["default"] = Axis2D;

/***/ },
/* 340 */
/***/ function(module, exports, __webpack_require__) {

	
	/*
	* Licensed to the Apache Software Foundation (ASF) under one
	* or more contributor license agreements.  See the NOTICE file
	* distributed with this work for additional information
	* regarding copyright ownership.  The ASF licenses this file
	* to you under the Apache License, Version 2.0 (the
	* "License"); you may not use this file except in compliance
	* with the License.  You may obtain a copy of the License at
	*
	*   http://www.apache.org/licenses/LICENSE-2.0
	*
	* Unless required by applicable law or agreed to in writing,
	* software distributed under the License is distributed on an
	* "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
	* KIND, either express or implied.  See the License for the
	* specific language governing permissions and limitations
	* under the License.
	*/
	
	
	
	/**
	 * AUTO-GENERATED FILE. DO NOT MODIFY.
	 */
	
	"use strict";
	
	exports.__esModule = true;
	
	var zrUtil = __webpack_require__(1);
	
	var Cartesian = function () {
	  function Cartesian(name) {
	    this.type = 'cartesian';
	    this._dimList = [];
	    this._axes = {};
	    this.name = name || '';
	  }
	
	  Cartesian.prototype.getAxis = function (dim) {
	    return this._axes[dim];
	  };
	
	  Cartesian.prototype.getAxes = function () {
	    return zrUtil.map(this._dimList, function (dim) {
	      return this._axes[dim];
	    }, this);
	  };
	
	  Cartesian.prototype.getAxesByScale = function (scaleType) {
	    scaleType = scaleType.toLowerCase();
	    return zrUtil.filter(this.getAxes(), function (axis) {
	      return axis.scale.type === scaleType;
	    });
	  };
	
	  Cartesian.prototype.addAxis = function (axis) {
	    var dim = axis.dim;
	    this._axes[dim] = axis;
	
	    this._dimList.push(dim);
	  };
	
	  return Cartesian;
	}();
	
	;
	exports["default"] = Cartesian;

/***/ },
/* 341 */
/***/ function(module, exports, __webpack_require__) {

	
	/*
	* Licensed to the Apache Software Foundation (ASF) under one
	* or more contributor license agreements.  See the NOTICE file
	* distributed with this work for additional information
	* regarding copyright ownership.  The ASF licenses this file
	* to you under the Apache License, Version 2.0 (the
	* "License"); you may not use this file except in compliance
	* with the License.  You may obtain a copy of the License at
	*
	*   http://www.apache.org/licenses/LICENSE-2.0
	*
	* Unless required by applicable law or agreed to in writing,
	* software distributed under the License is distributed on an
	* "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
	* KIND, either express or implied.  See the License for the
	* specific language governing permissions and limitations
	* under the License.
	*/
	
	
	
	/**
	 * AUTO-GENERATED FILE. DO NOT MODIFY.
	 */
	
	"use strict";
	
	exports.__esModule = true;
	
	var tslib_1 = __webpack_require__(3);
	
	var BoundingRect_1 = __webpack_require__(17);
	
	var Cartesian_1 = __webpack_require__(340);
	
	var matrix_1 = __webpack_require__(27);
	
	var vector_1 = __webpack_require__(11);
	
	exports.cartesian2DDimensions = ['x', 'y'];
	
	function canCalculateAffineTransform(scale) {
	  return scale.type === 'interval' || scale.type === 'time';
	}
	
	var Cartesian2D = function (_super) {
	  tslib_1.__extends(Cartesian2D, _super);
	
	  function Cartesian2D() {
	    var _this = _super !== null && _super.apply(this, arguments) || this;
	
	    _this.type = 'cartesian2d';
	    _this.dimensions = exports.cartesian2DDimensions;
	    return _this;
	  }
	
	  Cartesian2D.prototype.calcAffineTransform = function () {
	    this._transform = this._invTransform = null;
	    var xAxisScale = this.getAxis('x').scale;
	    var yAxisScale = this.getAxis('y').scale;
	
	    if (!canCalculateAffineTransform(xAxisScale) || !canCalculateAffineTransform(yAxisScale)) {
	      return;
	    }
	
	    var xScaleExtent = xAxisScale.getExtent();
	    var yScaleExtent = yAxisScale.getExtent();
	    var start = this.dataToPoint([xScaleExtent[0], yScaleExtent[0]]);
	    var end = this.dataToPoint([xScaleExtent[1], yScaleExtent[1]]);
	    var xScaleSpan = xScaleExtent[1] - xScaleExtent[0];
	    var yScaleSpan = yScaleExtent[1] - yScaleExtent[0];
	
	    if (!xScaleSpan || !yScaleSpan) {
	      return;
	    }
	
	    var scaleX = (end[0] - start[0]) / xScaleSpan;
	    var scaleY = (end[1] - start[1]) / yScaleSpan;
	    var translateX = start[0] - xScaleExtent[0] * scaleX;
	    var translateY = start[1] - yScaleExtent[0] * scaleY;
	    var m = this._transform = [scaleX, 0, 0, scaleY, translateX, translateY];
	    this._invTransform = matrix_1.invert([], m);
	  };
	
	  Cartesian2D.prototype.getBaseAxis = function () {
	    return this.getAxesByScale('ordinal')[0] || this.getAxesByScale('time')[0] || this.getAxis('x');
	  };
	
	  Cartesian2D.prototype.containPoint = function (point) {
	    var axisX = this.getAxis('x');
	    var axisY = this.getAxis('y');
	    return axisX.contain(axisX.toLocalCoord(point[0])) && axisY.contain(axisY.toLocalCoord(point[1]));
	  };
	
	  Cartesian2D.prototype.containData = function (data) {
	    return this.getAxis('x').containData(data[0]) && this.getAxis('y').containData(data[1]);
	  };
	
	  Cartesian2D.prototype.dataToPoint = function (data, reserved, out) {
	    out = out || [];
	    var xVal = data[0];
	    var yVal = data[1];
	
	    if (this._transform && xVal != null && isFinite(xVal) && yVal != null && isFinite(yVal)) {
	      return vector_1.applyTransform(out, data, this._transform);
	    }
	
	    var xAxis = this.getAxis('x');
	    var yAxis = this.getAxis('y');
	    out[0] = xAxis.toGlobalCoord(xAxis.dataToCoord(xVal));
	    out[1] = yAxis.toGlobalCoord(yAxis.dataToCoord(yVal));
	    return out;
	  };
	
	  Cartesian2D.prototype.clampData = function (data, out) {
	    var xScale = this.getAxis('x').scale;
	    var yScale = this.getAxis('y').scale;
	    var xAxisExtent = xScale.getExtent();
	    var yAxisExtent = yScale.getExtent();
	    var x = xScale.parse(data[0]);
	    var y = yScale.parse(data[1]);
	    out = out || [];
	    out[0] = Math.min(Math.max(Math.min(xAxisExtent[0], xAxisExtent[1]), x), Math.max(xAxisExtent[0], xAxisExtent[1]));
	    out[1] = Math.min(Math.max(Math.min(yAxisExtent[0], yAxisExtent[1]), y), Math.max(yAxisExtent[0], yAxisExtent[1]));
	    return out;
	  };
	
	  Cartesian2D.prototype.pointToData = function (point, out) {
	    out = out || [];
	
	    if (this._invTransform) {
	      return vector_1.applyTransform(out, point, this._invTransform);
	    }
	
	    var xAxis = this.getAxis('x');
	    var yAxis = this.getAxis('y');
	    out[0] = xAxis.coordToData(xAxis.toLocalCoord(point[0]));
	    out[1] = yAxis.coordToData(yAxis.toLocalCoord(point[1]));
	    return out;
	  };
	
	  Cartesian2D.prototype.getOtherAxis = function (axis) {
	    return this.getAxis(axis.dim === 'x' ? 'y' : 'x');
	  };
	
	  Cartesian2D.prototype.getArea = function () {
	    var xExtent = this.getAxis('x').getGlobalExtent();
	    var yExtent = this.getAxis('y').getGlobalExtent();
	    var x = Math.min(xExtent[0], xExtent[1]);
	    var y = Math.min(yExtent[0], yExtent[1]);
	    var width = Math.max(xExtent[0], xExtent[1]) - x;
	    var height = Math.max(yExtent[0], yExtent[1]) - y;
	    return new BoundingRect_1["default"](x, y, width, height);
	  };
	
	  return Cartesian2D;
	}(Cartesian_1["default"]);
	
	;
	exports["default"] = Cartesian2D;

/***/ },
/* 342 */
/***/ function(module, exports, __webpack_require__) {

	
	/*
	* Licensed to the Apache Software Foundation (ASF) under one
	* or more contributor license agreements.  See the NOTICE file
	* distributed with this work for additional information
	* regarding copyright ownership.  The ASF licenses this file
	* to you under the Apache License, Version 2.0 (the
	* "License"); you may not use this file except in compliance
	* with the License.  You may obtain a copy of the License at
	*
	*   http://www.apache.org/licenses/LICENSE-2.0
	*
	* Unless required by applicable law or agreed to in writing,
	* software distributed under the License is distributed on an
	* "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
	* KIND, either express or implied.  See the License for the
	* specific language governing permissions and limitations
	* under the License.
	*/
	
	
	
	/**
	 * AUTO-GENERATED FILE. DO NOT MODIFY.
	 */
	
	"use strict";
	
	exports.__esModule = true;
	
	var util_1 = __webpack_require__(1);
	
	var layout_1 = __webpack_require__(30);
	
	var axisHelper_1 = __webpack_require__(39);
	
	var Cartesian2D_1 = __webpack_require__(341);
	
	var Axis2D_1 = __webpack_require__(339);
	
	var CoordinateSystem_1 = __webpack_require__(81);
	
	var model_1 = __webpack_require__(4);
	
	var cartesianAxisHelper_1 = __webpack_require__(67);
	
	var Grid = function () {
	  function Grid(gridModel, ecModel, api) {
	    this.type = 'grid';
	    this._coordsMap = {};
	    this._coordsList = [];
	    this._axesMap = {};
	    this._axesList = [];
	    this.axisPointerEnabled = true;
	    this.dimensions = Cartesian2D_1.cartesian2DDimensions;
	
	    this._initCartesian(gridModel, ecModel, api);
	
	    this.model = gridModel;
	  }
	
	  Grid.prototype.getRect = function () {
	    return this._rect;
	  };
	
	  Grid.prototype.update = function (ecModel, api) {
	    var axesMap = this._axesMap;
	
	    this._updateScale(ecModel, this.model);
	
	    util_1.each(axesMap.x, function (xAxis) {
	      axisHelper_1.niceScaleExtent(xAxis.scale, xAxis.model);
	    });
	    util_1.each(axesMap.y, function (yAxis) {
	      axisHelper_1.niceScaleExtent(yAxis.scale, yAxis.model);
	    });
	    var onZeroRecords = {};
	    util_1.each(axesMap.x, function (xAxis) {
	      fixAxisOnZero(axesMap, 'y', xAxis, onZeroRecords);
	    });
	    util_1.each(axesMap.y, function (yAxis) {
	      fixAxisOnZero(axesMap, 'x', yAxis, onZeroRecords);
	    });
	    this.resize(this.model, api);
	  };
	
	  Grid.prototype.resize = function (gridModel, api, ignoreContainLabel) {
	    var boxLayoutParams = gridModel.getBoxLayoutParams();
	    var isContainLabel = !ignoreContainLabel && gridModel.get('containLabel');
	    var gridRect = layout_1.getLayoutRect(boxLayoutParams, {
	      width: api.getWidth(),
	      height: api.getHeight()
	    });
	    this._rect = gridRect;
	    var axesList = this._axesList;
	    adjustAxes();
	
	    if (isContainLabel) {
	      util_1.each(axesList, function (axis) {
	        if (!axis.model.get(['axisLabel', 'inside'])) {
	          var labelUnionRect = axisHelper_1.estimateLabelUnionRect(axis);
	
	          if (labelUnionRect) {
	            var dim = axis.isHorizontal() ? 'height' : 'width';
	            var margin = axis.model.get(['axisLabel', 'margin']);
	            gridRect[dim] -= labelUnionRect[dim] + margin;
	
	            if (axis.position === 'top') {
	              gridRect.y += labelUnionRect.height + margin;
	            } else if (axis.position === 'left') {
	              gridRect.x += labelUnionRect.width + margin;
	            }
	          }
	        }
	      });
	      adjustAxes();
	    }
	
	    util_1.each(this._coordsList, function (coord) {
	      coord.calcAffineTransform();
	    });
	
	    function adjustAxes() {
	      util_1.each(axesList, function (axis) {
	        var isHorizontal = axis.isHorizontal();
	        var extent = isHorizontal ? [0, gridRect.width] : [0, gridRect.height];
	        var idx = axis.inverse ? 1 : 0;
	        axis.setExtent(extent[idx], extent[1 - idx]);
	        updateAxisTransform(axis, isHorizontal ? gridRect.x : gridRect.y);
	      });
	    }
	  };
	
	  Grid.prototype.getAxis = function (dim, axisIndex) {
	    var axesMapOnDim = this._axesMap[dim];
	
	    if (axesMapOnDim != null) {
	      return axesMapOnDim[axisIndex || 0];
	    }
	  };
	
	  Grid.prototype.getAxes = function () {
	    return this._axesList.slice();
	  };
	
	  Grid.prototype.getCartesian = function (xAxisIndex, yAxisIndex) {
	    if (xAxisIndex != null && yAxisIndex != null) {
	      var key = 'x' + xAxisIndex + 'y' + yAxisIndex;
	      return this._coordsMap[key];
	    }
	
	    if (util_1.isObject(xAxisIndex)) {
	      yAxisIndex = xAxisIndex.yAxisIndex;
	      xAxisIndex = xAxisIndex.xAxisIndex;
	    }
	
	    for (var i = 0, coordList = this._coordsList; i < coordList.length; i++) {
	      if (coordList[i].getAxis('x').index === xAxisIndex || coordList[i].getAxis('y').index === yAxisIndex) {
	        return coordList[i];
	      }
	    }
	  };
	
	  Grid.prototype.getCartesians = function () {
	    return this._coordsList.slice();
	  };
	
	  Grid.prototype.convertToPixel = function (ecModel, finder, value) {
	    var target = this._findConvertTarget(finder);
	
	    return target.cartesian ? target.cartesian.dataToPoint(value) : target.axis ? target.axis.toGlobalCoord(target.axis.dataToCoord(value)) : null;
	  };
	
	  Grid.prototype.convertFromPixel = function (ecModel, finder, value) {
	    var target = this._findConvertTarget(finder);
	
	    return target.cartesian ? target.cartesian.pointToData(value) : target.axis ? target.axis.coordToData(target.axis.toLocalCoord(value)) : null;
	  };
	
	  Grid.prototype._findConvertTarget = function (finder) {
	    var seriesModel = finder.seriesModel;
	    var xAxisModel = finder.xAxisModel || seriesModel && seriesModel.getReferringComponents('xAxis', model_1.SINGLE_REFERRING).models[0];
	    var yAxisModel = finder.yAxisModel || seriesModel && seriesModel.getReferringComponents('yAxis', model_1.SINGLE_REFERRING).models[0];
	    var gridModel = finder.gridModel;
	    var coordsList = this._coordsList;
	    var cartesian;
	    var axis;
	
	    if (seriesModel) {
	      cartesian = seriesModel.coordinateSystem;
	      util_1.indexOf(coordsList, cartesian) < 0 && (cartesian = null);
	    } else if (xAxisModel && yAxisModel) {
	      cartesian = this.getCartesian(xAxisModel.componentIndex, yAxisModel.componentIndex);
	    } else if (xAxisModel) {
	      axis = this.getAxis('x', xAxisModel.componentIndex);
	    } else if (yAxisModel) {
	      axis = this.getAxis('y', yAxisModel.componentIndex);
	    } else if (gridModel) {
	      var grid = gridModel.coordinateSystem;
	
	      if (grid === this) {
	        cartesian = this._coordsList[0];
	      }
	    }
	
	    return {
	      cartesian: cartesian,
	      axis: axis
	    };
	  };
	
	  Grid.prototype.containPoint = function (point) {
	    var coord = this._coordsList[0];
	
	    if (coord) {
	      return coord.containPoint(point);
	    }
	  };
	
	  Grid.prototype._initCartesian = function (gridModel, ecModel, api) {
	    var _this = this;
	
	    var grid = this;
	    var axisPositionUsed = {
	      left: false,
	      right: false,
	      top: false,
	      bottom: false
	    };
	    var axesMap = {
	      x: {},
	      y: {}
	    };
	    var axesCount = {
	      x: 0,
	      y: 0
	    };
	    ecModel.eachComponent('xAxis', createAxisCreator('x'), this);
	    ecModel.eachComponent('yAxis', createAxisCreator('y'), this);
	
	    if (!axesCount.x || !axesCount.y) {
	      this._axesMap = {};
	      this._axesList = [];
	      return;
	    }
	
	    this._axesMap = axesMap;
	    util_1.each(axesMap.x, function (xAxis, xAxisIndex) {
	      util_1.each(axesMap.y, function (yAxis, yAxisIndex) {
	        var key = 'x' + xAxisIndex + 'y' + yAxisIndex;
	        var cartesian = new Cartesian2D_1["default"](key);
	        cartesian.master = _this;
	        cartesian.model = gridModel;
	        _this._coordsMap[key] = cartesian;
	
	        _this._coordsList.push(cartesian);
	
	        cartesian.addAxis(xAxis);
	        cartesian.addAxis(yAxis);
	      });
	    });
	
	    function createAxisCreator(dimName) {
	      return function (axisModel, idx) {
	        if (!isAxisUsedInTheGrid(axisModel, gridModel)) {
	          return;
	        }
	
	        var axisPosition = axisModel.get('position');
	
	        if (dimName === 'x') {
	          if (axisPosition !== 'top' && axisPosition !== 'bottom') {
	            axisPosition = axisPositionUsed.bottom ? 'top' : 'bottom';
	          }
	        } else {
	          if (axisPosition !== 'left' && axisPosition !== 'right') {
	            axisPosition = axisPositionUsed.left ? 'right' : 'left';
	          }
	        }
	
	        axisPositionUsed[axisPosition] = true;
	        var axis = new Axis2D_1["default"](dimName, axisHelper_1.createScaleByModel(axisModel), [0, 0], axisModel.get('type'), axisPosition);
	        var isCategory = axis.type === 'category';
	        axis.onBand = isCategory && axisModel.get('boundaryGap');
	        axis.inverse = axisModel.get('inverse');
	        axisModel.axis = axis;
	        axis.model = axisModel;
	        axis.grid = grid;
	        axis.index = idx;
	
	        grid._axesList.push(axis);
	
	        axesMap[dimName][idx] = axis;
	        axesCount[dimName]++;
	      };
	    }
	  };
	
	  Grid.prototype._updateScale = function (ecModel, gridModel) {
	    util_1.each(this._axesList, function (axis) {
	      axis.scale.setExtent(Infinity, -Infinity);
	
	      if (axis.type === 'category') {
	        var categorySortInfo = axis.model.get('categorySortInfo');
	        axis.scale.setCategorySortInfo(categorySortInfo);
	      }
	    });
	    ecModel.eachSeries(function (seriesModel) {
	      if (cartesianAxisHelper_1.isCartesian2DSeries(seriesModel)) {
	        var axesModelMap = cartesianAxisHelper_1.findAxisModels(seriesModel);
	        var xAxisModel = axesModelMap.xAxisModel;
	        var yAxisModel = axesModelMap.yAxisModel;
	
	        if (!isAxisUsedInTheGrid(xAxisModel, gridModel) || !isAxisUsedInTheGrid(yAxisModel, gridModel)) {
	          return;
	        }
	
	        var cartesian = this.getCartesian(xAxisModel.componentIndex, yAxisModel.componentIndex);
	        var data = seriesModel.getData();
	        var xAxis = cartesian.getAxis('x');
	        var yAxis = cartesian.getAxis('y');
	
	        if (data.type === 'list') {
	          unionExtent(data, xAxis);
	          unionExtent(data, yAxis);
	        }
	      }
	    }, this);
	
	    function unionExtent(data, axis) {
	      util_1.each(axisHelper_1.getDataDimensionsOnAxis(data, axis.dim), function (dim) {
	        axis.scale.unionExtentFromData(data, dim);
	      });
	    }
	  };
	
	  Grid.prototype.getTooltipAxes = function (dim) {
	    var baseAxes = [];
	    var otherAxes = [];
	    util_1.each(this.getCartesians(), function (cartesian) {
	      var baseAxis = dim != null && dim !== 'auto' ? cartesian.getAxis(dim) : cartesian.getBaseAxis();
	      var otherAxis = cartesian.getOtherAxis(baseAxis);
	      util_1.indexOf(baseAxes, baseAxis) < 0 && baseAxes.push(baseAxis);
	      util_1.indexOf(otherAxes, otherAxis) < 0 && otherAxes.push(otherAxis);
	    });
	    return {
	      baseAxes: baseAxes,
	      otherAxes: otherAxes
	    };
	  };
	
	  Grid.create = function (ecModel, api) {
	    var grids = [];
	    ecModel.eachComponent('grid', function (gridModel, idx) {
	      var grid = new Grid(gridModel, ecModel, api);
	      grid.name = 'grid_' + idx;
	      grid.resize(gridModel, api, true);
	      gridModel.coordinateSystem = grid;
	      grids.push(grid);
	    });
	    ecModel.eachSeries(function (seriesModel) {
	      if (!cartesianAxisHelper_1.isCartesian2DSeries(seriesModel)) {
	        return;
	      }
	
	      var axesModelMap = cartesianAxisHelper_1.findAxisModels(seriesModel);
	      var xAxisModel = axesModelMap.xAxisModel;
	      var yAxisModel = axesModelMap.yAxisModel;
	      var gridModel = xAxisModel.getCoordSysModel();
	
	      if (false) {
	        if (!gridModel) {
	          throw new Error('Grid "' + util_1.retrieve3(xAxisModel.get('gridIndex'), xAxisModel.get('gridId'), 0) + '" not found');
	        }
	
	        if (xAxisModel.getCoordSysModel() !== yAxisModel.getCoordSysModel()) {
	          throw new Error('xAxis and yAxis must use the same grid');
	        }
	      }
	
	      var grid = gridModel.coordinateSystem;
	      seriesModel.coordinateSystem = grid.getCartesian(xAxisModel.componentIndex, yAxisModel.componentIndex);
	    });
	    return grids;
	  };
	
	  Grid.dimensions = Cartesian2D_1.cartesian2DDimensions;
	  return Grid;
	}();
	
	function isAxisUsedInTheGrid(axisModel, gridModel) {
	  return axisModel.getCoordSysModel() === gridModel;
	}
	
	function fixAxisOnZero(axesMap, otherAxisDim, axis, onZeroRecords) {
	  axis.getAxesOnZeroOf = function () {
	    return otherAxisOnZeroOf ? [otherAxisOnZeroOf] : [];
	  };
	
	  var otherAxes = axesMap[otherAxisDim];
	  var otherAxisOnZeroOf;
	  var axisModel = axis.model;
	  var onZero = axisModel.get(['axisLine', 'onZero']);
	  var onZeroAxisIndex = axisModel.get(['axisLine', 'onZeroAxisIndex']);
	
	  if (!onZero) {
	    return;
	  }
	
	  if (onZeroAxisIndex != null) {
	    if (canOnZeroToAxis(otherAxes[onZeroAxisIndex])) {
	      otherAxisOnZeroOf = otherAxes[onZeroAxisIndex];
	    }
	  } else {
	    for (var idx in otherAxes) {
	      if (otherAxes.hasOwnProperty(idx) && canOnZeroToAxis(otherAxes[idx]) && !onZeroRecords[getOnZeroRecordKey(otherAxes[idx])]) {
	        otherAxisOnZeroOf = otherAxes[idx];
	        break;
	      }
	    }
	  }
	
	  if (otherAxisOnZeroOf) {
	    onZeroRecords[getOnZeroRecordKey(otherAxisOnZeroOf)] = true;
	  }
	
	  function getOnZeroRecordKey(axis) {
	    return axis.dim + '_' + axis.index;
	  }
	}
	
	function canOnZeroToAxis(axis) {
	  return axis && axis.type !== 'category' && axis.type !== 'time' && axisHelper_1.ifAxisCrossZero(axis);
	}
	
	function updateAxisTransform(axis, coordBase) {
	  var axisExtent = axis.getExtent();
	  var axisExtentSum = axisExtent[0] + axisExtent[1];
	  axis.toGlobalCoord = axis.dim === 'x' ? function (coord) {
	    return coord + coordBase;
	  } : function (coord) {
	    return axisExtentSum - coord + coordBase;
	  };
	  axis.toLocalCoord = axis.dim === 'x' ? function (coord) {
	    return coord - coordBase;
	  } : function (coord) {
	    return axisExtentSum - coord + coordBase;
	  };
	}
	
	CoordinateSystem_1["default"].register('cartesian2d', Grid);
	exports["default"] = Grid;

/***/ },
/* 343 */
/***/ function(module, exports, __webpack_require__) {

	
	/*
	* Licensed to the Apache Software Foundation (ASF) under one
	* or more contributor license agreements.  See the NOTICE file
	* distributed with this work for additional information
	* regarding copyright ownership.  The ASF licenses this file
	* to you under the Apache License, Version 2.0 (the
	* "License"); you may not use this file except in compliance
	* with the License.  You may obtain a copy of the License at
	*
	*   http://www.apache.org/licenses/LICENSE-2.0
	*
	* Unless required by applicable law or agreed to in writing,
	* software distributed under the License is distributed on an
	* "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
	* KIND, either express or implied.  See the License for the
	* specific language governing permissions and limitations
	* under the License.
	*/
	
	
	
	/**
	 * AUTO-GENERATED FILE. DO NOT MODIFY.
	 */
	
	"use strict";
	
	exports.__esModule = true;
	
	var tslib_1 = __webpack_require__(3);
	
	__webpack_require__(142);
	
	var Component_1 = __webpack_require__(10);
	
	var GridModel = function (_super) {
	  tslib_1.__extends(GridModel, _super);
	
	  function GridModel() {
	    return _super !== null && _super.apply(this, arguments) || this;
	  }
	
	  GridModel.type = 'grid';
	  GridModel.dependencies = ['xAxis', 'yAxis'];
	  GridModel.layoutMode = 'box';
	  GridModel.defaultOption = {
	    show: false,
	    zlevel: 0,
	    z: 0,
	    left: '10%',
	    top: 60,
	    right: '10%',
	    bottom: 70,
	    containLabel: false,
	    backgroundColor: 'rgba(0,0,0,0)',
	    borderWidth: 1,
	    borderColor: '#ccc'
	  };
	  return GridModel;
	}(Component_1["default"]);
	
	exports["default"] = GridModel;

/***/ },
/* 344 */
/***/ function(module, exports, __webpack_require__) {

	
	/*
	* Licensed to the Apache Software Foundation (ASF) under one
	* or more contributor license agreements.  See the NOTICE file
	* distributed with this work for additional information
	* regarding copyright ownership.  The ASF licenses this file
	* to you under the Apache License, Version 2.0 (the
	* "License"); you may not use this file except in compliance
	* with the License.  You may obtain a copy of the License at
	*
	*   http://www.apache.org/licenses/LICENSE-2.0
	*
	* Unless required by applicable law or agreed to in writing,
	* software distributed under the License is distributed on an
	* "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
	* KIND, either express or implied.  See the License for the
	* specific language governing permissions and limitations
	* under the License.
	*/
	
	
	
	/**
	 * AUTO-GENERATED FILE. DO NOT MODIFY.
	 */
	
	"use strict";
	
	exports.__esModule = true;
	
	var echarts = __webpack_require__(6);
	
	var util_1 = __webpack_require__(1);
	
	var cartesianAxisHelper_1 = __webpack_require__(67);
	
	var axisHelper_1 = __webpack_require__(39);
	
	var scaleRawExtentInfo_1 = __webpack_require__(88);
	
	echarts.registerProcessor(echarts.PRIORITY.PROCESSOR.FILTER + 10, {
	  getTargetSeries: function (ecModel) {
	    var seriesModelMap = util_1.createHashMap();
	    ecModel.eachSeries(function (seriesModel) {
	      cartesianAxisHelper_1.isCartesian2DSeries(seriesModel) && seriesModelMap.set(seriesModel.uid, seriesModel);
	    });
	    return seriesModelMap;
	  },
	  overallReset: function (ecModel, api) {
	    var seriesRecords = [];
	    var axisRecordMap = util_1.createHashMap();
	    prepareDataExtentOnAxis(ecModel, axisRecordMap, seriesRecords);
	    calculateFilteredExtent(axisRecordMap, seriesRecords);
	    shrinkAxisExtent(axisRecordMap);
	  }
	});
	
	function prepareDataExtentOnAxis(ecModel, axisRecordMap, seriesRecords) {
	  ecModel.eachSeries(function (seriesModel) {
	    if (!cartesianAxisHelper_1.isCartesian2DSeries(seriesModel)) {
	      return;
	    }
	
	    var axesModelMap = cartesianAxisHelper_1.findAxisModels(seriesModel);
	    var xAxisModel = axesModelMap.xAxisModel;
	    var yAxisModel = axesModelMap.yAxisModel;
	    var xAxis = xAxisModel.axis;
	    var yAxis = yAxisModel.axis;
	    var xRawExtentInfo = xAxis.scale.rawExtentInfo;
	    var yRawExtentInfo = yAxis.scale.rawExtentInfo;
	    var data = seriesModel.getData();
	
	    if (xRawExtentInfo && xRawExtentInfo.frozen || yRawExtentInfo && yRawExtentInfo.frozen) {
	      return;
	    }
	
	    seriesRecords.push({
	      seriesModel: seriesModel,
	      xAxisModel: xAxisModel,
	      yAxisModel: yAxisModel
	    });
	    axisHelper_1.unionAxisExtentFromData(prepareAxisRecord(axisRecordMap, xAxisModel).condExtent, data, xAxis.dim);
	    axisHelper_1.unionAxisExtentFromData(prepareAxisRecord(axisRecordMap, yAxisModel).condExtent, data, yAxis.dim);
	  });
	}
	
	function calculateFilteredExtent(axisRecordMap, seriesRecords) {
	  util_1.each(seriesRecords, function (seriesRecord) {
	    var xAxisModel = seriesRecord.xAxisModel;
	    var yAxisModel = seriesRecord.yAxisModel;
	    var xAxis = xAxisModel.axis;
	    var yAxis = yAxisModel.axis;
	    var xAxisRecord = prepareAxisRecord(axisRecordMap, xAxisModel);
	    var yAxisRecord = prepareAxisRecord(axisRecordMap, yAxisModel);
	    xAxisRecord.rawExtentInfo = scaleRawExtentInfo_1.ensureScaleRawExtentInfo(xAxis.scale, xAxisModel, xAxisRecord.condExtent);
	    yAxisRecord.rawExtentInfo = scaleRawExtentInfo_1.ensureScaleRawExtentInfo(yAxis.scale, yAxisModel, yAxisRecord.condExtent);
	    xAxisRecord.rawExtentResult = xAxisRecord.rawExtentInfo.calculate();
	    yAxisRecord.rawExtentResult = yAxisRecord.rawExtentInfo.calculate();
	    var data = seriesRecord.seriesModel.getData();
	    var condDimMap = {};
	    var tarDimMap = {};
	    var condAxis;
	    var tarAxisRecord;
	
	    function addCondition(axis, axisRecord) {
	      var condExtent = axisRecord.condExtent;
	      var rawExtentResult = axisRecord.rawExtentResult;
	
	      if (axis.type === 'category' && (condExtent[0] < rawExtentResult.min || rawExtentResult.max < condExtent[1])) {
	        util_1.each(axisHelper_1.getDataDimensionsOnAxis(data, axis.dim), function (dataDim) {
	          if (!util_1.hasOwn(condDimMap, dataDim)) {
	            condDimMap[dataDim] = true;
	            condAxis = axis;
	          }
	        });
	      }
	    }
	
	    function addTarget(axis, axisRecord) {
	      var rawExtentResult = axisRecord.rawExtentResult;
	
	      if (axis.type !== 'category' && (!rawExtentResult.minFixed || !rawExtentResult.maxFixed)) {
	        util_1.each(axisHelper_1.getDataDimensionsOnAxis(data, axis.dim), function (dataDim) {
	          if (!util_1.hasOwn(condDimMap, dataDim) && !util_1.hasOwn(tarDimMap, dataDim)) {
	            tarDimMap[dataDim] = true;
	            tarAxisRecord = axisRecord;
	          }
	        });
	      }
	    }
	
	    addCondition(xAxis, xAxisRecord);
	    addCondition(yAxis, yAxisRecord);
	    addTarget(xAxis, xAxisRecord);
	    addTarget(yAxis, yAxisRecord);
	    var condDims = util_1.keys(condDimMap);
	    var tarDims = util_1.keys(tarDimMap);
	    var tarDimExtents = util_1.map(tarDims, function () {
	      return initExtent();
	    });
	    var condDimsLen = condDims.length;
	    var tarDimsLen = tarDims.length;
	
	    if (!condDimsLen || !tarDimsLen) {
	      return;
	    }
	
	    var singleCondDim = condDimsLen === 1 ? condDims[0] : null;
	    var singleTarDim = tarDimsLen === 1 ? tarDims[0] : null;
	    var dataLen = data.count();
	
	    if (singleCondDim && singleTarDim) {
	      for (var dataIdx = 0; dataIdx < dataLen; dataIdx++) {
	        var condVal = data.get(singleCondDim, dataIdx);
	
	        if (condAxis.scale.isInExtentRange(condVal)) {
	          unionExtent(tarDimExtents[0], data.get(singleTarDim, dataIdx));
	        }
	      }
	    } else {
	      for (var dataIdx = 0; dataIdx < dataLen; dataIdx++) {
	        for (var j = 0; j < condDimsLen; j++) {
	          var condVal = data.get(condDims[j], dataIdx);
	
	          if (condAxis.scale.isInExtentRange(condVal)) {
	            for (var k = 0; k < tarDimsLen; k++) {
	              unionExtent(tarDimExtents[k], data.get(tarDims[k], dataIdx));
	            }
	
	            break;
	          }
	        }
	      }
	    }
	
	    util_1.each(tarDimExtents, function (tarDimExtent, i) {
	      var dim = tarDims[i];
	      data.setApproximateExtent(tarDimExtent, dim);
	      var tarAxisExtent = tarAxisRecord.tarExtent = tarAxisRecord.tarExtent || initExtent();
	      unionExtent(tarAxisExtent, tarDimExtent[0]);
	      unionExtent(tarAxisExtent, tarDimExtent[1]);
	    });
	  });
	}
	
	function shrinkAxisExtent(axisRecordMap) {
	  axisRecordMap.each(function (axisRecord) {
	    var tarAxisExtent = axisRecord.tarExtent;
	
	    if (tarAxisExtent) {
	      var rawExtentResult = axisRecord.rawExtentResult;
	      var rawExtentInfo = axisRecord.rawExtentInfo;
	
	      if (!rawExtentResult.minFixed && tarAxisExtent[0] > rawExtentResult.min) {
	        rawExtentInfo.modifyDataMinMax('min', tarAxisExtent[0]);
	      }
	
	      if (!rawExtentResult.maxFixed && tarAxisExtent[1] < rawExtentResult.max) {
	        rawExtentInfo.modifyDataMinMax('max', tarAxisExtent[1]);
	      }
	    }
	  });
	}
	
	function prepareAxisRecord(axisRecordMap, axisModel) {
	  return axisRecordMap.get(axisModel.uid) || axisRecordMap.set(axisModel.uid, {
	    condExtent: initExtent()
	  });
	}
	
	function initExtent() {
	  return [Infinity, -Infinity];
	}
	
	function unionExtent(extent, val) {
	  val < extent[0] && (extent[0] = val);
	  val > extent[1] && (extent[1] = val);
	}

/***/ },
/* 345 */
/***/ function(module, exports, __webpack_require__) {

	
	/*
	* Licensed to the Apache Software Foundation (ASF) under one
	* or more contributor license agreements.  See the NOTICE file
	* distributed with this work for additional information
	* regarding copyright ownership.  The ASF licenses this file
	* to you under the Apache License, Version 2.0 (the
	* "License"); you may not use this file except in compliance
	* with the License.  You may obtain a copy of the License at
	*
	*   http://www.apache.org/licenses/LICENSE-2.0
	*
	* Unless required by applicable law or agreed to in writing,
	* software distributed under the License is distributed on an
	* "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
	* KIND, either express or implied.  See the License for the
	* specific language governing permissions and limitations
	* under the License.
	*/
	
	
	
	/**
	 * AUTO-GENERATED FILE. DO NOT MODIFY.
	 */
	
	"use strict";
	
	exports.__esModule = true;
	
	var util_1 = __webpack_require__(1);
	
	var parseSVG_1 = __webpack_require__(194);
	
	var storage = util_1.createHashMap();
	exports["default"] = {
	  registerMap: function (mapName, rawDef, rawSpecialAreas) {
	    var records;
	
	    if (util_1.isArray(rawDef)) {
	      records = rawDef;
	    } else if (rawDef.svg) {
	      records = [{
	        type: 'svg',
	        source: rawDef.svg,
	        specialAreas: rawDef.specialAreas
	      }];
	    } else {
	      var geoSource = rawDef.geoJson || rawDef.geoJSON;
	
	      if (geoSource && !rawDef.features) {
	        rawSpecialAreas = rawDef.specialAreas;
	        rawDef = geoSource;
	      }
	
	      records = [{
	        type: 'geoJSON',
	        source: rawDef,
	        specialAreas: rawSpecialAreas
	      }];
	    }
	
	    util_1.each(records, function (record) {
	      var type = record.type;
	      type === 'geoJson' && (type = record.type = 'geoJSON');
	      var parse = parsers[type];
	
	      if (false) {
	        util_1.assert(parse, 'Illegal map type: ' + type);
	      }
	
	      parse(record);
	    });
	    return storage.set(mapName, records);
	  },
	  retrieveMap: function (mapName) {
	    return storage.get(mapName);
	  }
	};
	var parsers = {
	  geoJSON: function (record) {
	    var source = record.source;
	    record.geoJSON = !util_1.isString(source) ? source : typeof JSON !== 'undefined' && JSON.parse ? JSON.parse(source) : new Function('return (' + source + ');')();
	  },
	  svg: function (record) {
	    record.svgXML = parseSVG_1.parseXML(record.source);
	  }
	};

/***/ },
/* 346 */
/***/ function(module, exports) {

	
	/*
	* Licensed to the Apache Software Foundation (ASF) under one
	* or more contributor license agreements.  See the NOTICE file
	* distributed with this work for additional information
	* regarding copyright ownership.  The ASF licenses this file
	* to you under the Apache License, Version 2.0 (the
	* "License"); you may not use this file except in compliance
	* with the License.  You may obtain a copy of the License at
	*
	*   http://www.apache.org/licenses/LICENSE-2.0
	*
	* Unless required by applicable law or agreed to in writing,
	* software distributed under the License is distributed on an
	* "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
	* KIND, either express or implied.  See the License for the
	* specific language governing permissions and limitations
	* under the License.
	*/
	
	
	
	/**
	 * AUTO-GENERATED FILE. DO NOT MODIFY.
	 */
	
	"use strict";
	
	exports.__esModule = true;
	
	function dataIndexMapValueLength(valNumOrArrLengthMoreThan2) {
	  return valNumOrArrLengthMoreThan2 == null ? 0 : valNumOrArrLengthMoreThan2.length || 1;
	}
	
	function defaultKeyGetter(item) {
	  return item;
	}
	
	var DataDiffer = function () {
	  function DataDiffer(oldArr, newArr, oldKeyGetter, newKeyGetter, context, diffMode) {
	    this._old = oldArr;
	    this._new = newArr;
	    this._oldKeyGetter = oldKeyGetter || defaultKeyGetter;
	    this._newKeyGetter = newKeyGetter || defaultKeyGetter;
	    this.context = context;
	    this._diffModeMultiple = diffMode === 'multiple';
	  }
	
	  DataDiffer.prototype.add = function (func) {
	    this._add = func;
	    return this;
	  };
	
	  DataDiffer.prototype.update = function (func) {
	    this._update = func;
	    return this;
	  };
	
	  DataDiffer.prototype.updateManyToOne = function (func) {
	    this._updateManyToOne = func;
	    return this;
	  };
	
	  DataDiffer.prototype.updateOneToMany = function (func) {
	    this._updateOneToMany = func;
	    return this;
	  };
	
	  DataDiffer.prototype.remove = function (func) {
	    this._remove = func;
	    return this;
	  };
	
	  DataDiffer.prototype.execute = function () {
	    this[this._diffModeMultiple ? '_executeMultiple' : '_executeOneToOne']();
	  };
	
	  DataDiffer.prototype._executeOneToOne = function () {
	    var oldArr = this._old;
	    var newArr = this._new;
	    var newDataIndexMap = {};
	    var oldDataKeyArr = new Array(oldArr.length);
	    var newDataKeyArr = new Array(newArr.length);
	
	    this._initIndexMap(oldArr, null, oldDataKeyArr, '_oldKeyGetter');
	
	    this._initIndexMap(newArr, newDataIndexMap, newDataKeyArr, '_newKeyGetter');
	
	    for (var i = 0; i < oldArr.length; i++) {
	      var oldKey = oldDataKeyArr[i];
	      var newIdxMapVal = newDataIndexMap[oldKey];
	      var newIdxMapValLen = dataIndexMapValueLength(newIdxMapVal);
	
	      if (newIdxMapValLen > 1) {
	        var newIdx = newIdxMapVal.shift();
	
	        if (newIdxMapVal.length === 1) {
	          newDataIndexMap[oldKey] = newIdxMapVal[0];
	        }
	
	        this._update && this._update(newIdx, i);
	      } else if (newIdxMapValLen === 1) {
	        newDataIndexMap[oldKey] = null;
	        this._update && this._update(newIdxMapVal, i);
	      } else {
	        this._remove && this._remove(i);
	      }
	    }
	
	    this._performRestAdd(newDataKeyArr, newDataIndexMap);
	  };
	
	  DataDiffer.prototype._executeMultiple = function () {
	    var oldArr = this._old;
	    var newArr = this._new;
	    var oldDataIndexMap = {};
	    var newDataIndexMap = {};
	    var oldDataKeyArr = [];
	    var newDataKeyArr = [];
	
	    this._initIndexMap(oldArr, oldDataIndexMap, oldDataKeyArr, '_oldKeyGetter');
	
	    this._initIndexMap(newArr, newDataIndexMap, newDataKeyArr, '_newKeyGetter');
	
	    for (var i = 0; i < oldDataKeyArr.length; i++) {
	      var oldKey = oldDataKeyArr[i];
	      var oldIdxMapVal = oldDataIndexMap[oldKey];
	      var newIdxMapVal = newDataIndexMap[oldKey];
	      var oldIdxMapValLen = dataIndexMapValueLength(oldIdxMapVal);
	      var newIdxMapValLen = dataIndexMapValueLength(newIdxMapVal);
	
	      if (oldIdxMapValLen > 1 && newIdxMapValLen === 1) {
	        this._updateManyToOne && this._updateManyToOne(newIdxMapVal, oldIdxMapVal);
	        newDataIndexMap[oldKey] = null;
	      } else if (oldIdxMapValLen === 1 && newIdxMapValLen > 1) {
	        this._updateOneToMany && this._updateOneToMany(newIdxMapVal, oldIdxMapVal);
	        newDataIndexMap[oldKey] = null;
	      } else if (oldIdxMapValLen === 1 && newIdxMapValLen === 1) {
	        this._update && this._update(newIdxMapVal, oldIdxMapVal);
	        newDataIndexMap[oldKey] = null;
	      } else if (oldIdxMapValLen > 1) {
	        for (var i_1 = 0; i_1 < oldIdxMapValLen; i_1++) {
	          this._remove && this._remove(oldIdxMapVal[i_1]);
	        }
	      } else {
	        this._remove && this._remove(oldIdxMapVal);
	      }
	    }
	
	    this._performRestAdd(newDataKeyArr, newDataIndexMap);
	  };
	
	  DataDiffer.prototype._performRestAdd = function (newDataKeyArr, newDataIndexMap) {
	    for (var i = 0; i < newDataKeyArr.length; i++) {
	      var newKey = newDataKeyArr[i];
	      var newIdxMapVal = newDataIndexMap[newKey];
	      var idxMapValLen = dataIndexMapValueLength(newIdxMapVal);
	
	      if (idxMapValLen > 1) {
	        for (var j = 0; j < idxMapValLen; j++) {
	          this._add && this._add(newIdxMapVal[j]);
	        }
	      } else if (idxMapValLen === 1) {
	        this._add && this._add(newIdxMapVal);
	      }
	
	      newDataIndexMap[newKey] = null;
	    }
	  };
	
	  DataDiffer.prototype._initIndexMap = function (arr, map, keyArr, keyGetterName) {
	    var cbModeMultiple = this._diffModeMultiple;
	
	    for (var i = 0; i < arr.length; i++) {
	      var key = '_ec_' + this[keyGetterName](arr[i], i);
	
	      if (!cbModeMultiple) {
	        keyArr[i] = key;
	      }
	
	      if (!map) {
	        continue;
	      }
	
	      var idxMapVal = map[key];
	      var idxMapValLen = dataIndexMapValueLength(idxMapVal);
	
	      if (idxMapValLen === 0) {
	        map[key] = i;
	
	        if (cbModeMultiple) {
	          keyArr.push(key);
	        }
	      } else if (idxMapValLen === 1) {
	        map[key] = [idxMapVal, i];
	      } else {
	        idxMapVal.push(i);
	      }
	    }
	  };
	
	  return DataDiffer;
	}();
	
	exports["default"] = DataDiffer;

/***/ },
/* 347 */
/***/ function(module, exports, __webpack_require__) {

	
	/*
	* Licensed to the Apache Software Foundation (ASF) under one
	* or more contributor license agreements.  See the NOTICE file
	* distributed with this work for additional information
	* regarding copyright ownership.  The ASF licenses this file
	* to you under the Apache License, Version 2.0 (the
	* "License"); you may not use this file except in compliance
	* with the License.  You may obtain a copy of the License at
	*
	*   http://www.apache.org/licenses/LICENSE-2.0
	*
	* Unless required by applicable law or agreed to in writing,
	* software distributed under the License is distributed on an
	* "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
	* KIND, either express or implied.  See the License for the
	* specific language governing permissions and limitations
	* under the License.
	*/
	
	
	
	/**
	 * AUTO-GENERATED FILE. DO NOT MODIFY.
	 */
	
	"use strict";
	
	exports.__esModule = true;
	
	var util_1 = __webpack_require__(1);
	
	var model_1 = __webpack_require__(4);
	
	var sourceHelper_1 = __webpack_require__(54);
	
	var Source_1 = __webpack_require__(47);
	
	var types_1 = __webpack_require__(25);
	
	var DataDimensionInfo_1 = __webpack_require__(143);
	
	function completeDimensions(sysDims, source, opt) {
	  if (!Source_1.isSourceInstance(source)) {
	    source = Source_1.createSourceFromSeriesDataOption(source);
	  }
	
	  opt = opt || {};
	  sysDims = (sysDims || []).slice();
	  var dimsDef = (opt.dimsDef || []).slice();
	  var dataDimNameMap = util_1.createHashMap();
	  var coordDimNameMap = util_1.createHashMap();
	  var result = [];
	  var dimCount = getDimCount(source, sysDims, dimsDef, opt.dimCount);
	
	  for (var i = 0; i < dimCount; i++) {
	    var dimDefItemRaw = dimsDef[i];
	    var dimDefItem = dimsDef[i] = util_1.extend({}, util_1.isObject(dimDefItemRaw) ? dimDefItemRaw : {
	      name: dimDefItemRaw
	    });
	    var userDimName = dimDefItem.name;
	    var resultItem = result[i] = new DataDimensionInfo_1["default"]();
	
	    if (userDimName != null && dataDimNameMap.get(userDimName) == null) {
	      resultItem.name = resultItem.displayName = userDimName;
	      dataDimNameMap.set(userDimName, i);
	    }
	
	    dimDefItem.type != null && (resultItem.type = dimDefItem.type);
	    dimDefItem.displayName != null && (resultItem.displayName = dimDefItem.displayName);
	  }
	
	  var encodeDef = opt.encodeDef;
	
	  if (!encodeDef && opt.encodeDefaulter) {
	    encodeDef = opt.encodeDefaulter(source, dimCount);
	  }
	
	  var encodeDefMap = util_1.createHashMap(encodeDef);
	  encodeDefMap.each(function (dataDimsRaw, coordDim) {
	    var dataDims = model_1.normalizeToArray(dataDimsRaw).slice();
	
	    if (dataDims.length === 1 && !util_1.isString(dataDims[0]) && dataDims[0] < 0) {
	      encodeDefMap.set(coordDim, false);
	      return;
	    }
	
	    var validDataDims = encodeDefMap.set(coordDim, []);
	    util_1.each(dataDims, function (resultDimIdxOrName, idx) {
	      var resultDimIdx = util_1.isString(resultDimIdxOrName) ? dataDimNameMap.get(resultDimIdxOrName) : resultDimIdxOrName;
	
	      if (resultDimIdx != null && resultDimIdx < dimCount) {
	        validDataDims[idx] = resultDimIdx;
	        applyDim(result[resultDimIdx], coordDim, idx);
	      }
	    });
	  });
	  var availDimIdx = 0;
	  util_1.each(sysDims, function (sysDimItemRaw) {
	    var coordDim;
	    var sysDimItemDimsDef;
	    var sysDimItemOtherDims;
	    var sysDimItem;
	
	    if (util_1.isString(sysDimItemRaw)) {
	      coordDim = sysDimItemRaw;
	      sysDimItem = {};
	    } else {
	      sysDimItem = sysDimItemRaw;
	      coordDim = sysDimItem.name;
	      var ordinalMeta = sysDimItem.ordinalMeta;
	      sysDimItem.ordinalMeta = null;
	      sysDimItem = util_1.clone(sysDimItem);
	      sysDimItem.ordinalMeta = ordinalMeta;
	      sysDimItemDimsDef = sysDimItem.dimsDef;
	      sysDimItemOtherDims = sysDimItem.otherDims;
	      sysDimItem.name = sysDimItem.coordDim = sysDimItem.coordDimIndex = sysDimItem.dimsDef = sysDimItem.otherDims = null;
	    }
	
	    var dataDims = encodeDefMap.get(coordDim);
	
	    if (dataDims === false) {
	      return;
	    }
	
	    dataDims = model_1.normalizeToArray(dataDims);
	
	    if (!dataDims.length) {
	      for (var i = 0; i < (sysDimItemDimsDef && sysDimItemDimsDef.length || 1); i++) {
	        while (availDimIdx < result.length && result[availDimIdx].coordDim != null) {
	          availDimIdx++;
	        }
	
	        availDimIdx < result.length && dataDims.push(availDimIdx++);
	      }
	    }
	
	    util_1.each(dataDims, function (resultDimIdx, coordDimIndex) {
	      var resultItem = result[resultDimIdx];
	      applyDim(util_1.defaults(resultItem, sysDimItem), coordDim, coordDimIndex);
	
	      if (resultItem.name == null && sysDimItemDimsDef) {
	        var sysDimItemDimsDefItem = sysDimItemDimsDef[coordDimIndex];
	        !util_1.isObject(sysDimItemDimsDefItem) && (sysDimItemDimsDefItem = {
	          name: sysDimItemDimsDefItem
	        });
	        resultItem.name = resultItem.displayName = sysDimItemDimsDefItem.name;
	        resultItem.defaultTooltip = sysDimItemDimsDefItem.defaultTooltip;
	      }
	
	      sysDimItemOtherDims && util_1.defaults(resultItem.otherDims, sysDimItemOtherDims);
	    });
	  });
	
	  function applyDim(resultItem, coordDim, coordDimIndex) {
	    if (types_1.VISUAL_DIMENSIONS.get(coordDim) != null) {
	      resultItem.otherDims[coordDim] = coordDimIndex;
	    } else {
	      resultItem.coordDim = coordDim;
	      resultItem.coordDimIndex = coordDimIndex;
	      coordDimNameMap.set(coordDim, true);
	    }
	  }
	
	  var generateCoord = opt.generateCoord;
	  var generateCoordCount = opt.generateCoordCount;
	  var fromZero = generateCoordCount != null;
	  generateCoordCount = generateCoord ? generateCoordCount || 1 : 0;
	  var extra = generateCoord || 'value';
	
	  for (var resultDimIdx = 0; resultDimIdx < dimCount; resultDimIdx++) {
	    var resultItem = result[resultDimIdx] = result[resultDimIdx] || new DataDimensionInfo_1["default"]();
	    var coordDim = resultItem.coordDim;
	
	    if (coordDim == null) {
	      resultItem.coordDim = genName(extra, coordDimNameMap, fromZero);
	      resultItem.coordDimIndex = 0;
	
	      if (!generateCoord || generateCoordCount <= 0) {
	        resultItem.isExtraCoord = true;
	      }
	
	      generateCoordCount--;
	    }
	
	    resultItem.name == null && (resultItem.name = genName(resultItem.coordDim, dataDimNameMap, false));
	
	    if (resultItem.type == null && (sourceHelper_1.guessOrdinal(source, resultDimIdx) === sourceHelper_1.BE_ORDINAL.Must || resultItem.isExtraCoord && (resultItem.otherDims.itemName != null || resultItem.otherDims.seriesName != null))) {
	      resultItem.type = 'ordinal';
	    }
	  }
	
	  return result;
	}
	
	function getDimCount(source, sysDims, dimsDef, optDimCount) {
	  var dimCount = Math.max(source.dimensionsDetectedCount || 1, sysDims.length, dimsDef.length, optDimCount || 0);
	  util_1.each(sysDims, function (sysDimItem) {
	    var sysDimItemDimsDef;
	
	    if (util_1.isObject(sysDimItem) && (sysDimItemDimsDef = sysDimItem.dimsDef)) {
	      dimCount = Math.max(dimCount, sysDimItemDimsDef.length);
	    }
	  });
	  return dimCount;
	}
	
	function genName(name, map, fromZero) {
	  if (fromZero || map.get(name) != null) {
	    var i = 0;
	
	    while (map.get(name + i) != null) {
	      i++;
	    }
	
	    name += i;
	  }
	
	  map.set(name, true);
	  return name;
	}
	
	exports["default"] = completeDimensions;

/***/ },
/* 348 */
/***/ function(module, exports, __webpack_require__) {

	
	/*
	* Licensed to the Apache Software Foundation (ASF) under one
	* or more contributor license agreements.  See the NOTICE file
	* distributed with this work for additional information
	* regarding copyright ownership.  The ASF licenses this file
	* to you under the Apache License, Version 2.0 (the
	* "License"); you may not use this file except in compliance
	* with the License.  You may obtain a copy of the License at
	*
	*   http://www.apache.org/licenses/LICENSE-2.0
	*
	* Unless required by applicable law or agreed to in writing,
	* software distributed under the License is distributed on an
	* "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
	* KIND, either express or implied.  See the License for the
	* specific language governing permissions and limitations
	* under the License.
	*/
	
	
	
	/**
	 * AUTO-GENERATED FILE. DO NOT MODIFY.
	 */
	
	"use strict";
	
	exports.__esModule = true;
	
	var completeDimensions_1 = __webpack_require__(347);
	
	function createDimensions(source, opt) {
	  opt = opt || {};
	  return completeDimensions_1["default"](opt.coordDimensions || [], source, {
	    dimsDef: opt.dimensionsDefine || source.dimensionsDefine,
	    encodeDef: opt.encodeDefine || source.encodeDefine,
	    dimCount: opt.dimensionsCount,
	    encodeDefaulter: opt.encodeDefaulter,
	    generateCoord: opt.generateCoord,
	    generateCoordCount: opt.generateCoordCount
	  });
	}
	
	exports["default"] = createDimensions;

/***/ },
/* 349 */
/***/ function(module, exports) {

	
	/*
	* Licensed to the Apache Software Foundation (ASF) under one
	* or more contributor license agreements.  See the NOTICE file
	* distributed with this work for additional information
	* regarding copyright ownership.  The ASF licenses this file
	* to you under the Apache License, Version 2.0 (the
	* "License"); you may not use this file except in compliance
	* with the License.  You may obtain a copy of the License at
	*
	*   http://www.apache.org/licenses/LICENSE-2.0
	*
	* Unless required by applicable law or agreed to in writing,
	* software distributed under the License is distributed on an
	* "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
	* KIND, either express or implied.  See the License for the
	* specific language governing permissions and limitations
	* under the License.
	*/
	
	
	
	/**
	 * AUTO-GENERATED FILE. DO NOT MODIFY.
	 */
	
	"use strict";
	
	exports.__esModule = true;
	exports["default"] = {
	  time: {
	    month: ['January', 'February', 'March', 'April', 'May', 'June', 'July', 'August', 'September', 'October', 'November', 'December'],
	    monthAbbr: ['Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun', 'Jul', 'Aug', 'Sep', 'Oct', 'Nov', 'Dec'],
	    dayOfWeek: ['Sunday', 'Monday', 'Tuesday', 'Wednesday', 'Thursday', 'Friday', 'Saturday'],
	    dayOfWeekAbbr: ['Sun', 'Mon', 'Tue', 'Wed', 'Thu', 'Fri', 'Sat']
	  },
	  legend: {
	    selector: {
	      all: 'All',
	      inverse: 'Inv'
	    }
	  },
	  toolbox: {
	    brush: {
	      title: {
	        rect: 'Box Select',
	        polygon: 'Lasso Select',
	        lineX: 'Horizontally Select',
	        lineY: 'Vertically Select',
	        keep: 'Keep Selections',
	        clear: 'Clear Selections'
	      }
	    },
	    dataView: {
	      title: 'Data View',
	      lang: ['Data View', 'Close', 'Refresh']
	    },
	    dataZoom: {
	      title: {
	        zoom: 'Zoom',
	        back: 'Zoom Reset'
	      }
	    },
	    magicType: {
	      title: {
	        line: 'Switch to Line Chart',
	        bar: 'Switch to Bar Chart',
	        stack: 'Stack',
	        tiled: 'Tile'
	      }
	    },
	    restore: {
	      title: 'Restore'
	    },
	    saveAsImage: {
	      title: 'Save as Image',
	      lang: ['Right Click to Save Image']
	    }
	  },
	  series: {
	    typeNames: {
	      pie: 'Pie chart',
	      bar: 'Bar chart',
	      line: 'Line chart',
	      scatter: 'Scatter plot',
	      effectScatter: 'Ripple scatter plot',
	      radar: 'Radar chart',
	      tree: 'Tree',
	      treemap: 'Treemap',
	      boxplot: 'Boxplot',
	      candlestick: 'Candlestick',
	      k: 'K line chart',
	      heatmap: 'Heat map',
	      map: 'Map',
	      parallel: 'Parallel coordinate map',
	      lines: 'Line graph',
	      graph: 'Relationship graph',
	      sankey: 'Sankey diagram',
	      funnel: 'Funnel chart',
	      gauge: 'Guage',
	      pictorialBar: 'Pictorial bar',
	      themeRiver: 'Theme River Map',
	      sunburst: 'Sunburst'
	    }
	  },
	  aria: {
	    general: {
	      withTitle: 'This is a chart about "{title}"',
	      withoutTitle: 'This is a chart'
	    },
	    series: {
	      single: {
	        prefix: '',
	        withName: ' with type {seriesType} named {seriesName}.',
	        withoutName: ' with type {seriesType}.'
	      },
	      multiple: {
	        prefix: '. It consists of {seriesCount} series count.',
	        withName: ' The {seriesId} series is a {seriesType} representing {seriesName}.',
	        withoutName: ' The {seriesId} series is a {seriesType}.',
	        separator: {
	          middle: '',
	          end: ''
	        }
	      }
	    },
	    data: {
	      allData: 'The data is as follows: ',
	      partialData: 'The first {displayCnt} items are: ',
	      withName: 'the data for {name} is {value}',
	      withoutName: '{value}',
	      separator: {
	        middle: ', ',
	        end: '. '
	      }
	    }
	  }
	};

/***/ },
/* 350 */
/***/ function(module, exports) {

	
	/*
	* Licensed to the Apache Software Foundation (ASF) under one
	* or more contributor license agreements.  See the NOTICE file
	* distributed with this work for additional information
	* regarding copyright ownership.  The ASF licenses this file
	* to you under the Apache License, Version 2.0 (the
	* "License"); you may not use this file except in compliance
	* with the License.  You may obtain a copy of the License at
	*
	*   http://www.apache.org/licenses/LICENSE-2.0
	*
	* Unless required by applicable law or agreed to in writing,
	* software distributed under the License is distributed on an
	* "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
	* KIND, either express or implied.  See the License for the
	* specific language governing permissions and limitations
	* under the License.
	*/
	
	
	
	/**
	 * AUTO-GENERATED FILE. DO NOT MODIFY.
	 */
	
	"use strict";
	
	exports.__esModule = true;
	exports["default"] = {
	  time: {
	    month: ['一月', '二月', '三月', '四月', '五月', '六月', '七月', '八月', '九月', '十月', '十一月', '十二月'],
	    monthAbbr: ['1月', '2月', '3月', '4月', '5月', '6月', '7月', '8月', '9月', '10月', '11月', '12月'],
	    dayOfWeek: ['星期日', '星期一', '星期二', '星期三', '星期四', '星期五', '星期六'],
	    dayOfWeekAbbr: ['日', '一', '二', '三', '四', '五', '六']
	  },
	  legend: {
	    selector: {
	      all: '全选',
	      inverse: '反选'
	    }
	  },
	  toolbox: {
	    brush: {
	      title: {
	        rect: '矩形选择',
	        polygon: '圈选',
	        lineX: '横向选择',
	        lineY: '纵向选择',
	        keep: '保持选择',
	        clear: '清除选择'
	      }
	    },
	    dataView: {
	      title: '数据视图',
	      lang: ['数据视图', '关闭', '刷新']
	    },
	    dataZoom: {
	      title: {
	        zoom: '区域缩放',
	        back: '区域缩放还原'
	      }
	    },
	    magicType: {
	      title: {
	        line: '切换为折线图',
	        bar: '切换为柱状图',
	        stack: '切换为堆叠',
	        tiled: '切换为平铺'
	      }
	    },
	    restore: {
	      title: '还原'
	    },
	    saveAsImage: {
	      title: '保存为图片',
	      lang: ['右键另存为图片']
	    }
	  },
	  series: {
	    typeNames: {
	      pie: '饼图',
	      bar: '柱状图',
	      line: '折线图',
	      scatter: '散点图',
	      effectScatter: '涟漪散点图',
	      radar: '雷达图',
	      tree: '树图',
	      treemap: '矩形树图',
	      boxplot: '箱型图',
	      candlestick: 'K线图',
	      k: 'K线图',
	      heatmap: '热力图',
	      map: '地图',
	      parallel: '平行坐标图',
	      lines: '线图',
	      graph: '关系图',
	      sankey: '桑基图',
	      funnel: '漏斗图',
	      gauge: '仪表盘图',
	      pictorialBar: '象形柱图',
	      themeRiver: '主题河流图',
	      sunburst: '旭日图'
	    }
	  },
	  aria: {
	    general: {
	      withTitle: '这是一个关于“{title}”的图表。',
	      withoutTitle: '这是一个图表，'
	    },
	    series: {
	      single: {
	        prefix: '',
	        withName: '图表类型是{seriesType}，表示{seriesName}。',
	        withoutName: '图表类型是{seriesType}。'
	      },
	      multiple: {
	        prefix: '它由{seriesCount}个图表系列组成。',
	        withName: '第{seriesId}个系列是一个表示{seriesName}的{seriesType}，',
	        withoutName: '第{seriesId}个系列是一个{seriesType}，',
	        separator: {
	          middle: '；',
	          end: '。'
	        }
	      }
	    },
	    data: {
	      allData: '其数据是——',
	      partialData: '其中，前{displayCnt}项是——',
	      withName: '{name}的数据是{value}',
	      withoutName: '{value}',
	      separator: {
	        middle: '，',
	        end: ''
	      }
	    }
	  }
	};

/***/ },
/* 351 */
/***/ function(module, exports, __webpack_require__) {

	
	/*
	* Licensed to the Apache Software Foundation (ASF) under one
	* or more contributor license agreements.  See the NOTICE file
	* distributed with this work for additional information
	* regarding copyright ownership.  The ASF licenses this file
	* to you under the Apache License, Version 2.0 (the
	* "License"); you may not use this file except in compliance
	* with the License.  You may obtain a copy of the License at
	*
	*   http://www.apache.org/licenses/LICENSE-2.0
	*
	* Unless required by applicable law or agreed to in writing,
	* software distributed under the License is distributed on an
	* "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
	* KIND, either express or implied.  See the License for the
	* specific language governing permissions and limitations
	* under the License.
	*/
	
	
	
	/**
	 * AUTO-GENERATED FILE. DO NOT MODIFY.
	 */
	
	"use strict";
	
	exports.__esModule = true;
	
	var graphic_1 = __webpack_require__(7);
	
	var innerStore_1 = __webpack_require__(21);
	
	var number_1 = __webpack_require__(9);
	
	var Transformable_1 = __webpack_require__(108);
	
	var labelGuideHelper_1 = __webpack_require__(352);
	
	var model_1 = __webpack_require__(4);
	
	var util_1 = __webpack_require__(1);
	
	var labelLayoutHelper_1 = __webpack_require__(353);
	
	var labelStyle_1 = __webpack_require__(20);
	
	function cloneArr(points) {
	  if (points) {
	    var newPoints = [];
	
	    for (var i = 0; i < points.length; i++) {
	      newPoints.push(points[i].slice());
	    }
	
	    return newPoints;
	  }
	}
	
	function prepareLayoutCallbackParams(labelItem, hostEl) {
	  var label = labelItem.label;
	  var labelLine = hostEl && hostEl.getTextGuideLine();
	  return {
	    dataIndex: labelItem.dataIndex,
	    dataType: labelItem.dataType,
	    seriesIndex: labelItem.seriesModel.seriesIndex,
	    text: labelItem.label.style.text,
	    rect: labelItem.hostRect,
	    labelRect: labelItem.rect,
	    align: label.style.align,
	    verticalAlign: label.style.verticalAlign,
	    labelLinePoints: cloneArr(labelLine && labelLine.shape.points)
	  };
	}
	
	var LABEL_OPTION_TO_STYLE_KEYS = ['align', 'verticalAlign', 'width', 'height', 'fontSize'];
	var dummyTransformable = new Transformable_1["default"]();
	var labelLayoutInnerStore = model_1.makeInner();
	var labelLineAnimationStore = model_1.makeInner();
	
	function extendWithKeys(target, source, keys) {
	  for (var i = 0; i < keys.length; i++) {
	    var key = keys[i];
	
	    if (source[key] != null) {
	      target[key] = source[key];
	    }
	  }
	}
	
	var LABEL_LAYOUT_PROPS = ['x', 'y', 'rotation'];
	
	var LabelManager = function () {
	  function LabelManager() {
	    this._labelList = [];
	    this._chartViewList = [];
	  }
	
	  LabelManager.prototype.clearLabels = function () {
	    this._labelList = [];
	    this._chartViewList = [];
	  };
	
	  LabelManager.prototype._addLabel = function (dataIndex, dataType, seriesModel, label, layoutOption) {
	    var labelStyle = label.style;
	    var hostEl = label.__hostTarget;
	    var textConfig = hostEl.textConfig || {};
	    var labelTransform = label.getComputedTransform();
	    var labelRect = label.getBoundingRect().plain();
	    graphic_1.BoundingRect.applyTransform(labelRect, labelRect, labelTransform);
	
	    if (labelTransform) {
	      dummyTransformable.setLocalTransform(labelTransform);
	    } else {
	      dummyTransformable.x = dummyTransformable.y = dummyTransformable.rotation = dummyTransformable.originX = dummyTransformable.originY = 0;
	      dummyTransformable.scaleX = dummyTransformable.scaleY = 1;
	    }
	
	    var host = label.__hostTarget;
	    var hostRect;
	
	    if (host) {
	      hostRect = host.getBoundingRect().plain();
	      var transform = host.getComputedTransform();
	      graphic_1.BoundingRect.applyTransform(hostRect, hostRect, transform);
	    }
	
	    var labelGuide = hostRect && host.getTextGuideLine();
	
	    this._labelList.push({
	      label: label,
	      labelLine: labelGuide,
	      seriesModel: seriesModel,
	      dataIndex: dataIndex,
	      dataType: dataType,
	      layoutOption: layoutOption,
	      computedLayoutOption: null,
	      rect: labelRect,
	      hostRect: hostRect,
	      priority: hostRect ? hostRect.width * hostRect.height : 0,
	      defaultAttr: {
	        ignore: label.ignore,
	        labelGuideIgnore: labelGuide && labelGuide.ignore,
	        x: dummyTransformable.x,
	        y: dummyTransformable.y,
	        rotation: dummyTransformable.rotation,
	        style: {
	          x: labelStyle.x,
	          y: labelStyle.y,
	          align: labelStyle.align,
	          verticalAlign: labelStyle.verticalAlign,
	          width: labelStyle.width,
	          height: labelStyle.height,
	          fontSize: labelStyle.fontSize
	        },
	        cursor: label.cursor,
	        attachedPos: textConfig.position,
	        attachedRot: textConfig.rotation
	      }
	    });
	  };
	
	  LabelManager.prototype.addLabelsOfSeries = function (chartView) {
	    var _this = this;
	
	    this._chartViewList.push(chartView);
	
	    var seriesModel = chartView.__model;
	    var layoutOption = seriesModel.get('labelLayout');
	
	    if (!(util_1.isFunction(layoutOption) || util_1.keys(layoutOption).length)) {
	      return;
	    }
	
	    chartView.group.traverse(function (child) {
	      if (child.ignore) {
	        return true;
	      }
	
	      var textEl = child.getTextContent();
	      var ecData = innerStore_1.getECData(child);
	
	      if (textEl && !textEl.disableLabelLayout) {
	        _this._addLabel(ecData.dataIndex, ecData.dataType, seriesModel, textEl, layoutOption);
	      }
	    });
	  };
	
	  LabelManager.prototype.updateLayoutConfig = function (api) {
	    var width = api.getWidth();
	    var height = api.getHeight();
	
	    function createDragHandler(el, labelLineModel) {
	      return function () {
	        labelGuideHelper_1.updateLabelLinePoints(el, labelLineModel);
	      };
	    }
	
	    for (var i = 0; i < this._labelList.length; i++) {
	      var labelItem = this._labelList[i];
	      var label = labelItem.label;
	      var hostEl = label.__hostTarget;
	      var defaultLabelAttr = labelItem.defaultAttr;
	      var layoutOption = void 0;
	
	      if (typeof labelItem.layoutOption === 'function') {
	        layoutOption = labelItem.layoutOption(prepareLayoutCallbackParams(labelItem, hostEl));
	      } else {
	        layoutOption = labelItem.layoutOption;
	      }
	
	      layoutOption = layoutOption || {};
	      labelItem.computedLayoutOption = layoutOption;
	      var degreeToRadian = Math.PI / 180;
	
	      if (hostEl) {
	        hostEl.setTextConfig({
	          local: false,
	          position: layoutOption.x != null || layoutOption.y != null ? null : defaultLabelAttr.attachedPos,
	          rotation: layoutOption.rotate != null ? layoutOption.rotate * degreeToRadian : defaultLabelAttr.attachedRot,
	          offset: [layoutOption.dx || 0, layoutOption.dy || 0]
	        });
	      }
	
	      var needsUpdateLabelLine = false;
	
	      if (layoutOption.x != null) {
	        label.x = number_1.parsePercent(layoutOption.x, width);
	        label.setStyle('x', 0);
	        needsUpdateLabelLine = true;
	      } else {
	        label.x = defaultLabelAttr.x;
	        label.setStyle('x', defaultLabelAttr.style.x);
	      }
	
	      if (layoutOption.y != null) {
	        label.y = number_1.parsePercent(layoutOption.y, height);
	        label.setStyle('y', 0);
	        needsUpdateLabelLine = true;
	      } else {
	        label.y = defaultLabelAttr.y;
	        label.setStyle('y', defaultLabelAttr.style.y);
	      }
	
	      if (layoutOption.labelLinePoints) {
	        var guideLine = hostEl.getTextGuideLine();
	
	        if (guideLine) {
	          guideLine.setShape({
	            points: layoutOption.labelLinePoints
	          });
	          needsUpdateLabelLine = false;
	        }
	      }
	
	      var labelLayoutStore = labelLayoutInnerStore(label);
	      labelLayoutStore.needsUpdateLabelLine = needsUpdateLabelLine;
	      label.rotation = layoutOption.rotate != null ? layoutOption.rotate * degreeToRadian : defaultLabelAttr.rotation;
	
	      for (var k = 0; k < LABEL_OPTION_TO_STYLE_KEYS.length; k++) {
	        var key = LABEL_OPTION_TO_STYLE_KEYS[k];
	        label.setStyle(key, layoutOption[key] != null ? layoutOption[key] : defaultLabelAttr.style[key]);
	      }
	
	      if (layoutOption.draggable) {
	        label.draggable = true;
	        label.cursor = 'move';
	
	        if (hostEl) {
	          var hostModel = labelItem.seriesModel;
	
	          if (labelItem.dataIndex != null) {
	            var data = labelItem.seriesModel.getData(labelItem.dataType);
	            hostModel = data.getItemModel(labelItem.dataIndex);
	          }
	
	          label.on('drag', createDragHandler(hostEl, hostModel.getModel('labelLine')));
	        }
	      } else {
	        label.off('drag');
	        label.cursor = defaultLabelAttr.cursor;
	      }
	    }
	  };
	
	  LabelManager.prototype.layout = function (api) {
	    var width = api.getWidth();
	    var height = api.getHeight();
	    var labelList = labelLayoutHelper_1.prepareLayoutList(this._labelList);
	    var labelsNeedsAdjustOnX = util_1.filter(labelList, function (item) {
	      return item.layoutOption.moveOverlap === 'shiftX';
	    });
	    var labelsNeedsAdjustOnY = util_1.filter(labelList, function (item) {
	      return item.layoutOption.moveOverlap === 'shiftY';
	    });
	    labelLayoutHelper_1.shiftLayoutOnX(labelsNeedsAdjustOnX, 0, width);
	    labelLayoutHelper_1.shiftLayoutOnY(labelsNeedsAdjustOnY, 0, height);
	    var labelsNeedsHideOverlap = util_1.filter(labelList, function (item) {
	      return item.layoutOption.hideOverlap;
	    });
	    labelLayoutHelper_1.hideOverlap(labelsNeedsHideOverlap);
	  };
	
	  LabelManager.prototype.processLabelsOverall = function () {
	    var _this = this;
	
	    util_1.each(this._chartViewList, function (chartView) {
	      var seriesModel = chartView.__model;
	      var ignoreLabelLineUpdate = chartView.ignoreLabelLineUpdate;
	      var animationEnabled = seriesModel.isAnimationEnabled();
	      chartView.group.traverse(function (child) {
	        if (child.ignore) {
	          return true;
	        }
	
	        var needsUpdateLabelLine = !ignoreLabelLineUpdate;
	        var label = child.getTextContent();
	
	        if (!needsUpdateLabelLine && label) {
	          needsUpdateLabelLine = labelLayoutInnerStore(label).needsUpdateLabelLine;
	        }
	
	        if (needsUpdateLabelLine) {
	          _this._updateLabelLine(child, seriesModel);
	        }
	
	        if (animationEnabled) {
	          _this._animateLabels(child, seriesModel);
	        }
	      });
	    });
	  };
	
	  LabelManager.prototype._updateLabelLine = function (el, seriesModel) {
	    var textEl = el.getTextContent();
	    var ecData = innerStore_1.getECData(el);
	    var dataIndex = ecData.dataIndex;
	
	    if (textEl && dataIndex != null) {
	      var data = seriesModel.getData(ecData.dataType);
	      var itemModel = data.getItemModel(dataIndex);
	      var defaultStyle = {};
	      var visualStyle = data.getItemVisual(dataIndex, 'style');
	      var visualType = data.getVisual('drawType');
	      defaultStyle.stroke = visualStyle[visualType];
	      var labelLineModel = itemModel.getModel('labelLine');
	      labelGuideHelper_1.setLabelLineStyle(el, labelGuideHelper_1.getLabelLineStatesModels(itemModel), defaultStyle);
	      labelGuideHelper_1.updateLabelLinePoints(el, labelLineModel);
	    }
	  };
	
	  LabelManager.prototype._animateLabels = function (el, seriesModel) {
	    var textEl = el.getTextContent();
	    var guideLine = el.getTextGuideLine();
	
	    if (textEl && !textEl.ignore && !textEl.invisible && !el.disableLabelAnimation && !graphic_1.isElementRemoved(el)) {
	      var layoutStore = labelLayoutInnerStore(textEl);
	      var oldLayout = layoutStore.oldLayout;
	      var ecData = innerStore_1.getECData(el);
	      var dataIndex = ecData.dataIndex;
	      var newProps = {
	        x: textEl.x,
	        y: textEl.y,
	        rotation: textEl.rotation
	      };
	      var data = seriesModel.getData(ecData.dataType);
	
	      if (!oldLayout) {
	        textEl.attr(newProps);
	
	        if (!labelStyle_1.labelInner(textEl).valueAnimation) {
	          var oldOpacity = util_1.retrieve2(textEl.style.opacity, 1);
	          textEl.style.opacity = 0;
	          graphic_1.initProps(textEl, {
	            style: {
	              opacity: oldOpacity
	            }
	          }, seriesModel, dataIndex);
	        }
	      } else {
	        textEl.attr(oldLayout);
	        var prevStates = el.prevStates;
	
	        if (prevStates) {
	          if (util_1.indexOf(prevStates, 'select') >= 0) {
	            textEl.attr(layoutStore.oldLayoutSelect);
	          }
	
	          if (util_1.indexOf(prevStates, 'emphasis') >= 0) {
	            textEl.attr(layoutStore.oldLayoutEmphasis);
	          }
	        }
	
	        graphic_1.updateProps(textEl, newProps, seriesModel, dataIndex);
	      }
	
	      layoutStore.oldLayout = newProps;
	
	      if (textEl.states.select) {
	        var layoutSelect = layoutStore.oldLayoutSelect = {};
	        extendWithKeys(layoutSelect, newProps, LABEL_LAYOUT_PROPS);
	        extendWithKeys(layoutSelect, textEl.states.select, LABEL_LAYOUT_PROPS);
	      }
	
	      if (textEl.states.emphasis) {
	        var layoutEmphasis = layoutStore.oldLayoutEmphasis = {};
	        extendWithKeys(layoutEmphasis, newProps, LABEL_LAYOUT_PROPS);
	        extendWithKeys(layoutEmphasis, textEl.states.emphasis, LABEL_LAYOUT_PROPS);
	      }
	
	      labelStyle_1.animateLabelValue(textEl, dataIndex, data, seriesModel);
	    }
	
	    if (guideLine && !guideLine.ignore && !guideLine.invisible) {
	      var layoutStore = labelLineAnimationStore(guideLine);
	      var oldLayout = layoutStore.oldLayout;
	      var newLayout = {
	        points: guideLine.shape.points
	      };
	
	      if (!oldLayout) {
	        guideLine.setShape(newLayout);
	        guideLine.style.strokePercent = 0;
	        graphic_1.initProps(guideLine, {
	          style: {
	            strokePercent: 1
	          }
	        }, seriesModel);
	      } else {
	        guideLine.attr({
	          shape: oldLayout
	        });
	        graphic_1.updateProps(guideLine, {
	          shape: newLayout
	        }, seriesModel);
	      }
	
	      layoutStore.oldLayout = newLayout;
	    }
	  };
	
	  return LabelManager;
	}();
	
	exports["default"] = LabelManager;

/***/ },
/* 352 */
/***/ function(module, exports, __webpack_require__) {

	
	/*
	* Licensed to the Apache Software Foundation (ASF) under one
	* or more contributor license agreements.  See the NOTICE file
	* distributed with this work for additional information
	* regarding copyright ownership.  The ASF licenses this file
	* to you under the Apache License, Version 2.0 (the
	* "License"); you may not use this file except in compliance
	* with the License.  You may obtain a copy of the License at
	*
	*   http://www.apache.org/licenses/LICENSE-2.0
	*
	* Unless required by applicable law or agreed to in writing,
	* software distributed under the License is distributed on an
	* "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
	* KIND, either express or implied.  See the License for the
	* specific language governing permissions and limitations
	* under the License.
	*/
	
	
	
	/**
	 * AUTO-GENERATED FILE. DO NOT MODIFY.
	 */
	
	"use strict";
	
	exports.__esModule = true;
	
	var graphic_1 = __webpack_require__(7);
	
	var PathProxy_1 = __webpack_require__(32);
	
	var util_1 = __webpack_require__(179);
	
	var curve_1 = __webpack_require__(33);
	
	var util_2 = __webpack_require__(1);
	
	var matrix_1 = __webpack_require__(27);
	
	var vector = __webpack_require__(11);
	
	var states_1 = __webpack_require__(22);
	
	var PI2 = Math.PI * 2;
	var CMD = PathProxy_1["default"].CMD;
	var DEFAULT_SEARCH_SPACE = ['top', 'right', 'bottom', 'left'];
	
	function getCandidateAnchor(pos, distance, rect, outPt, outDir) {
	  var width = rect.width;
	  var height = rect.height;
	
	  switch (pos) {
	    case 'top':
	      outPt.set(rect.x + width / 2, rect.y - distance);
	      outDir.set(0, -1);
	      break;
	
	    case 'bottom':
	      outPt.set(rect.x + width / 2, rect.y + height + distance);
	      outDir.set(0, 1);
	      break;
	
	    case 'left':
	      outPt.set(rect.x - distance, rect.y + height / 2);
	      outDir.set(-1, 0);
	      break;
	
	    case 'right':
	      outPt.set(rect.x + width + distance, rect.y + height / 2);
	      outDir.set(1, 0);
	      break;
	  }
	}
	
	function projectPointToArc(cx, cy, r, startAngle, endAngle, anticlockwise, x, y, out) {
	  x -= cx;
	  y -= cy;
	  var d = Math.sqrt(x * x + y * y);
	  x /= d;
	  y /= d;
	  var ox = x * r + cx;
	  var oy = y * r + cy;
	
	  if (Math.abs(startAngle - endAngle) % PI2 < 1e-4) {
	    out[0] = ox;
	    out[1] = oy;
	    return d - r;
	  }
	
	  if (anticlockwise) {
	    var tmp = startAngle;
	    startAngle = util_1.normalizeRadian(endAngle);
	    endAngle = util_1.normalizeRadian(tmp);
	  } else {
	    startAngle = util_1.normalizeRadian(startAngle);
	    endAngle = util_1.normalizeRadian(endAngle);
	  }
	
	  if (startAngle > endAngle) {
	    endAngle += PI2;
	  }
	
	  var angle = Math.atan2(y, x);
	
	  if (angle < 0) {
	    angle += PI2;
	  }
	
	  if (angle >= startAngle && angle <= endAngle || angle + PI2 >= startAngle && angle + PI2 <= endAngle) {
	    out[0] = ox;
	    out[1] = oy;
	    return d - r;
	  }
	
	  var x1 = r * Math.cos(startAngle) + cx;
	  var y1 = r * Math.sin(startAngle) + cy;
	  var x2 = r * Math.cos(endAngle) + cx;
	  var y2 = r * Math.sin(endAngle) + cy;
	  var d1 = (x1 - x) * (x1 - x) + (y1 - y) * (y1 - y);
	  var d2 = (x2 - x) * (x2 - x) + (y2 - y) * (y2 - y);
	
	  if (d1 < d2) {
	    out[0] = x1;
	    out[1] = y1;
	    return Math.sqrt(d1);
	  } else {
	    out[0] = x2;
	    out[1] = y2;
	    return Math.sqrt(d2);
	  }
	}
	
	function projectPointToLine(x1, y1, x2, y2, x, y, out, limitToEnds) {
	  var dx = x - x1;
	  var dy = y - y1;
	  var dx1 = x2 - x1;
	  var dy1 = y2 - y1;
	  var lineLen = Math.sqrt(dx1 * dx1 + dy1 * dy1);
	  dx1 /= lineLen;
	  dy1 /= lineLen;
	  var projectedLen = dx * dx1 + dy * dy1;
	  var t = projectedLen / lineLen;
	
	  if (limitToEnds) {
	    t = Math.min(Math.max(t, 0), 1);
	  }
	
	  t *= lineLen;
	  var ox = out[0] = x1 + t * dx1;
	  var oy = out[1] = y1 + t * dy1;
	  return Math.sqrt((ox - x) * (ox - x) + (oy - y) * (oy - y));
	}
	
	function projectPointToRect(x1, y1, width, height, x, y, out) {
	  if (width < 0) {
	    x1 = x1 + width;
	    width = -width;
	  }
	
	  if (height < 0) {
	    y1 = y1 + height;
	    height = -height;
	  }
	
	  var x2 = x1 + width;
	  var y2 = y1 + height;
	  var ox = out[0] = Math.min(Math.max(x, x1), x2);
	  var oy = out[1] = Math.min(Math.max(y, y1), y2);
	  return Math.sqrt((ox - x) * (ox - x) + (oy - y) * (oy - y));
	}
	
	var tmpPt = [];
	
	function nearestPointOnRect(pt, rect, out) {
	  var dist = projectPointToRect(rect.x, rect.y, rect.width, rect.height, pt.x, pt.y, tmpPt);
	  out.set(tmpPt[0], tmpPt[1]);
	  return dist;
	}
	
	function nearestPointOnPath(pt, path, out) {
	  var xi = 0;
	  var yi = 0;
	  var x0 = 0;
	  var y0 = 0;
	  var x1;
	  var y1;
	  var minDist = Infinity;
	  var data = path.data;
	  var x = pt.x;
	  var y = pt.y;
	
	  for (var i = 0; i < data.length;) {
	    var cmd = data[i++];
	
	    if (i === 1) {
	      xi = data[i];
	      yi = data[i + 1];
	      x0 = xi;
	      y0 = yi;
	    }
	
	    var d = minDist;
	
	    switch (cmd) {
	      case CMD.M:
	        x0 = data[i++];
	        y0 = data[i++];
	        xi = x0;
	        yi = y0;
	        break;
	
	      case CMD.L:
	        d = projectPointToLine(xi, yi, data[i], data[i + 1], x, y, tmpPt, true);
	        xi = data[i++];
	        yi = data[i++];
	        break;
	
	      case CMD.C:
	        d = curve_1.cubicProjectPoint(xi, yi, data[i++], data[i++], data[i++], data[i++], data[i], data[i + 1], x, y, tmpPt);
	        xi = data[i++];
	        yi = data[i++];
	        break;
	
	      case CMD.Q:
	        d = curve_1.quadraticProjectPoint(xi, yi, data[i++], data[i++], data[i], data[i + 1], x, y, tmpPt);
	        xi = data[i++];
	        yi = data[i++];
	        break;
	
	      case CMD.A:
	        var cx = data[i++];
	        var cy = data[i++];
	        var rx = data[i++];
	        var ry = data[i++];
	        var theta = data[i++];
	        var dTheta = data[i++];
	        i += 1;
	        var anticlockwise = !!(1 - data[i++]);
	        x1 = Math.cos(theta) * rx + cx;
	        y1 = Math.sin(theta) * ry + cy;
	
	        if (i <= 1) {
	          x0 = x1;
	          y0 = y1;
	        }
	
	        var _x = (x - cx) * ry / rx + cx;
	
	        d = projectPointToArc(cx, cy, ry, theta, theta + dTheta, anticlockwise, _x, y, tmpPt);
	        xi = Math.cos(theta + dTheta) * rx + cx;
	        yi = Math.sin(theta + dTheta) * ry + cy;
	        break;
	
	      case CMD.R:
	        x0 = xi = data[i++];
	        y0 = yi = data[i++];
	        var width = data[i++];
	        var height = data[i++];
	        d = projectPointToRect(x0, y0, width, height, x, y, tmpPt);
	        break;
	
	      case CMD.Z:
	        d = projectPointToLine(xi, yi, x0, y0, x, y, tmpPt, true);
	        xi = x0;
	        yi = y0;
	        break;
	    }
	
	    if (d < minDist) {
	      minDist = d;
	      out.set(tmpPt[0], tmpPt[1]);
	    }
	  }
	
	  return minDist;
	}
	
	var pt0 = new graphic_1.Point();
	var pt1 = new graphic_1.Point();
	var pt2 = new graphic_1.Point();
	var dir = new graphic_1.Point();
	var dir2 = new graphic_1.Point();
	
	function updateLabelLinePoints(target, labelLineModel) {
	  if (!target) {
	    return;
	  }
	
	  var labelLine = target.getTextGuideLine();
	  var label = target.getTextContent();
	
	  if (!(label && labelLine)) {
	    return;
	  }
	
	  var labelGuideConfig = target.textGuideLineConfig || {};
	  var points = [[0, 0], [0, 0], [0, 0]];
	  var searchSpace = labelGuideConfig.candidates || DEFAULT_SEARCH_SPACE;
	  var labelRect = label.getBoundingRect().clone();
	  labelRect.applyTransform(label.getComputedTransform());
	  var minDist = Infinity;
	  var anchorPoint = labelGuideConfig.anchor;
	  var targetTransform = target.getComputedTransform();
	  var targetInversedTransform = targetTransform && matrix_1.invert([], targetTransform);
	  var len = labelLineModel.get('length2') || 0;
	
	  if (anchorPoint) {
	    pt2.copy(anchorPoint);
	  }
	
	  for (var i = 0; i < searchSpace.length; i++) {
	    var candidate = searchSpace[i];
	    getCandidateAnchor(candidate, 0, labelRect, pt0, dir);
	    graphic_1.Point.scaleAndAdd(pt1, pt0, dir, len);
	    pt1.transform(targetInversedTransform);
	    var boundingRect = target.getBoundingRect();
	    var dist = anchorPoint ? anchorPoint.distance(pt1) : target instanceof graphic_1.Path ? nearestPointOnPath(pt1, target.path, pt2) : nearestPointOnRect(pt1, boundingRect, pt2);
	
	    if (dist < minDist) {
	      minDist = dist;
	      pt1.transform(targetTransform);
	      pt2.transform(targetTransform);
	      pt2.toArray(points[0]);
	      pt1.toArray(points[1]);
	      pt0.toArray(points[2]);
	    }
	  }
	
	  limitTurnAngle(points, labelLineModel.get('minTurnAngle'));
	  labelLine.setShape({
	    points: points
	  });
	}
	
	exports.updateLabelLinePoints = updateLabelLinePoints;
	var tmpArr = [];
	var tmpProjPoint = new graphic_1.Point();
	
	function limitTurnAngle(linePoints, minTurnAngle) {
	  if (!(minTurnAngle <= 180 && minTurnAngle > 0)) {
	    return;
	  }
	
	  minTurnAngle = minTurnAngle / 180 * Math.PI;
	  pt0.fromArray(linePoints[0]);
	  pt1.fromArray(linePoints[1]);
	  pt2.fromArray(linePoints[2]);
	  graphic_1.Point.sub(dir, pt0, pt1);
	  graphic_1.Point.sub(dir2, pt2, pt1);
	  var len1 = dir.len();
	  var len2 = dir2.len();
	
	  if (len1 < 1e-3 || len2 < 1e-3) {
	    return;
	  }
	
	  dir.scale(1 / len1);
	  dir2.scale(1 / len2);
	  var angleCos = dir.dot(dir2);
	  var minTurnAngleCos = Math.cos(minTurnAngle);
	
	  if (minTurnAngleCos < angleCos) {
	    var d = projectPointToLine(pt1.x, pt1.y, pt2.x, pt2.y, pt0.x, pt0.y, tmpArr, false);
	    tmpProjPoint.fromArray(tmpArr);
	    tmpProjPoint.scaleAndAdd(dir2, d / Math.tan(Math.PI - minTurnAngle));
	    var t = pt2.x !== pt1.x ? (tmpProjPoint.x - pt1.x) / (pt2.x - pt1.x) : (tmpProjPoint.y - pt1.y) / (pt2.y - pt1.y);
	
	    if (isNaN(t)) {
	      return;
	    }
	
	    if (t < 0) {
	      graphic_1.Point.copy(tmpProjPoint, pt1);
	    } else if (t > 1) {
	      graphic_1.Point.copy(tmpProjPoint, pt2);
	    }
	
	    tmpProjPoint.toArray(linePoints[1]);
	  }
	}
	
	exports.limitTurnAngle = limitTurnAngle;
	
	function limitSurfaceAngle(linePoints, surfaceNormal, maxSurfaceAngle) {
	  if (!(maxSurfaceAngle <= 180 && maxSurfaceAngle > 0)) {
	    return;
	  }
	
	  maxSurfaceAngle = maxSurfaceAngle / 180 * Math.PI;
	  pt0.fromArray(linePoints[0]);
	  pt1.fromArray(linePoints[1]);
	  pt2.fromArray(linePoints[2]);
	  graphic_1.Point.sub(dir, pt1, pt0);
	  graphic_1.Point.sub(dir2, pt2, pt1);
	  var len1 = dir.len();
	  var len2 = dir2.len();
	
	  if (len1 < 1e-3 || len2 < 1e-3) {
	    return;
	  }
	
	  dir.scale(1 / len1);
	  dir2.scale(1 / len2);
	  var angleCos = dir.dot(surfaceNormal);
	  var maxSurfaceAngleCos = Math.cos(maxSurfaceAngle);
	
	  if (angleCos < maxSurfaceAngleCos) {
	    var d = projectPointToLine(pt1.x, pt1.y, pt2.x, pt2.y, pt0.x, pt0.y, tmpArr, false);
	    tmpProjPoint.fromArray(tmpArr);
	    var HALF_PI = Math.PI / 2;
	    var angle2 = Math.acos(dir2.dot(surfaceNormal));
	    var newAngle = HALF_PI + angle2 - maxSurfaceAngle;
	
	    if (newAngle >= HALF_PI) {
	      graphic_1.Point.copy(tmpProjPoint, pt2);
	    } else {
	      tmpProjPoint.scaleAndAdd(dir2, d / Math.tan(Math.PI / 2 - newAngle));
	      var t = pt2.x !== pt1.x ? (tmpProjPoint.x - pt1.x) / (pt2.x - pt1.x) : (tmpProjPoint.y - pt1.y) / (pt2.y - pt1.y);
	
	      if (isNaN(t)) {
	        return;
	      }
	
	      if (t < 0) {
	        graphic_1.Point.copy(tmpProjPoint, pt1);
	      } else if (t > 1) {
	        graphic_1.Point.copy(tmpProjPoint, pt2);
	      }
	    }
	
	    tmpProjPoint.toArray(linePoints[1]);
	  }
	}
	
	exports.limitSurfaceAngle = limitSurfaceAngle;
	
	function setLabelLineState(labelLine, ignore, stateName, stateModel) {
	  var isNormal = stateName === 'normal';
	  var stateObj = isNormal ? labelLine : labelLine.ensureState(stateName);
	  stateObj.ignore = ignore;
	  var smooth = stateModel.get('smooth');
	
	  if (smooth && smooth === true) {
	    smooth = 0.3;
	  }
	
	  stateObj.shape = stateObj.shape || {};
	
	  if (smooth > 0) {
	    stateObj.shape.smooth = smooth;
	  }
	
	  var styleObj = stateModel.getModel('lineStyle').getLineStyle();
	  isNormal ? labelLine.useStyle(styleObj) : stateObj.style = styleObj;
	}
	
	function buildLabelLinePath(path, shape) {
	  var smooth = shape.smooth;
	  var points = shape.points;
	
	  if (!points) {
	    return;
	  }
	
	  path.moveTo(points[0][0], points[0][1]);
	
	  if (smooth > 0 && points.length >= 3) {
	    var len1 = vector.dist(points[0], points[1]);
	    var len2 = vector.dist(points[1], points[2]);
	
	    if (!len1 || !len2) {
	      path.lineTo(points[1][0], points[1][1]);
	      path.lineTo(points[2][0], points[2][1]);
	      return;
	    }
	
	    var moveLen = Math.min(len1, len2) * smooth;
	    var midPoint0 = vector.lerp([], points[1], points[0], moveLen / len1);
	    var midPoint2 = vector.lerp([], points[1], points[2], moveLen / len2);
	    var midPoint1 = vector.lerp([], midPoint0, midPoint2, 0.5);
	    path.bezierCurveTo(midPoint0[0], midPoint0[1], midPoint0[0], midPoint0[1], midPoint1[0], midPoint1[1]);
	    path.bezierCurveTo(midPoint2[0], midPoint2[1], midPoint2[0], midPoint2[1], points[2][0], points[2][1]);
	  } else {
	    for (var i = 1; i < points.length; i++) {
	      path.lineTo(points[i][0], points[i][1]);
	    }
	  }
	}
	
	function setLabelLineStyle(targetEl, statesModels, defaultStyle) {
	  var labelLine = targetEl.getTextGuideLine();
	  var label = targetEl.getTextContent();
	
	  if (!label) {
	    if (labelLine) {
	      targetEl.removeTextGuideLine();
	    }
	
	    return;
	  }
	
	  var normalModel = statesModels.normal;
	  var showNormal = normalModel.get('show');
	  var labelIgnoreNormal = label.ignore;
	
	  for (var i = 0; i < states_1.DISPLAY_STATES.length; i++) {
	    var stateName = states_1.DISPLAY_STATES[i];
	    var stateModel = statesModels[stateName];
	    var isNormal = stateName === 'normal';
	
	    if (stateModel) {
	      var stateShow = stateModel.get('show');
	      var isLabelIgnored = isNormal ? labelIgnoreNormal : util_2.retrieve2(label.states[stateName] && label.states[stateName].ignore, labelIgnoreNormal);
	
	      if (isLabelIgnored || !util_2.retrieve2(stateShow, showNormal)) {
	        var stateObj = isNormal ? labelLine : labelLine && labelLine.states.normal;
	
	        if (stateObj) {
	          stateObj.ignore = true;
	        }
	
	        continue;
	      }
	
	      if (!labelLine) {
	        labelLine = new graphic_1.Polyline();
	        targetEl.setTextGuideLine(labelLine);
	
	        if (!isNormal && (labelIgnoreNormal || !showNormal)) {
	          setLabelLineState(labelLine, true, 'normal', statesModels.normal);
	        }
	
	        if (targetEl.stateProxy) {
	          labelLine.stateProxy = targetEl.stateProxy;
	        }
	      }
	
	      setLabelLineState(labelLine, false, stateName, stateModel);
	    }
	  }
	
	  if (labelLine) {
	    util_2.defaults(labelLine.style, defaultStyle);
	    labelLine.style.fill = null;
	    var showAbove = normalModel.get('showAbove');
	    var labelLineConfig = targetEl.textGuideLineConfig = targetEl.textGuideLineConfig || {};
	    labelLineConfig.showAbove = showAbove || false;
	    labelLine.buildPath = buildLabelLinePath;
	  }
	}
	
	exports.setLabelLineStyle = setLabelLineStyle;
	
	function getLabelLineStatesModels(itemModel, labelLineName) {
	  labelLineName = labelLineName || 'labelLine';
	  var statesModels = {
	    normal: itemModel.getModel(labelLineName)
	  };
	
	  for (var i = 0; i < states_1.SPECIAL_STATES.length; i++) {
	    var stateName = states_1.SPECIAL_STATES[i];
	    statesModels[stateName] = itemModel.getModel([stateName, labelLineName]);
	  }
	
	  return statesModels;
	}
	
	exports.getLabelLineStatesModels = getLabelLineStatesModels;

/***/ },
/* 353 */
/***/ function(module, exports, __webpack_require__) {

	
	/*
	* Licensed to the Apache Software Foundation (ASF) under one
	* or more contributor license agreements.  See the NOTICE file
	* distributed with this work for additional information
	* regarding copyright ownership.  The ASF licenses this file
	* to you under the Apache License, Version 2.0 (the
	* "License"); you may not use this file except in compliance
	* with the License.  You may obtain a copy of the License at
	*
	*   http://www.apache.org/licenses/LICENSE-2.0
	*
	* Unless required by applicable law or agreed to in writing,
	* software distributed under the License is distributed on an
	* "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
	* KIND, either express or implied.  See the License for the
	* specific language governing permissions and limitations
	* under the License.
	*/
	
	
	
	/**
	 * AUTO-GENERATED FILE. DO NOT MODIFY.
	 */
	
	"use strict";
	
	exports.__esModule = true;
	
	var graphic_1 = __webpack_require__(7);
	
	function prepareLayoutList(input) {
	  var list = [];
	
	  for (var i = 0; i < input.length; i++) {
	    var rawItem = input[i];
	
	    if (rawItem.defaultAttr.ignore) {
	      continue;
	    }
	
	    var label = rawItem.label;
	    var transform = label.getComputedTransform();
	    var localRect = label.getBoundingRect();
	    var isAxisAligned = !transform || transform[1] < 1e-5 && transform[2] < 1e-5;
	    var minMargin = label.style.margin || 0;
	    var globalRect = localRect.clone();
	    globalRect.applyTransform(transform);
	    globalRect.x -= minMargin / 2;
	    globalRect.y -= minMargin / 2;
	    globalRect.width += minMargin;
	    globalRect.height += minMargin;
	    var obb = isAxisAligned ? new graphic_1.OrientedBoundingRect(localRect, transform) : null;
	    list.push({
	      label: label,
	      labelLine: rawItem.labelLine,
	      rect: globalRect,
	      localRect: localRect,
	      obb: obb,
	      priority: rawItem.priority,
	      defaultAttr: rawItem.defaultAttr,
	      layoutOption: rawItem.computedLayoutOption,
	      axisAligned: isAxisAligned,
	      transform: transform
	    });
	  }
	
	  return list;
	}
	
	exports.prepareLayoutList = prepareLayoutList;
	
	function shiftLayout(list, xyDim, sizeDim, minBound, maxBound, balanceShift) {
	  var len = list.length;
	
	  if (len < 2) {
	    return;
	  }
	
	  list.sort(function (a, b) {
	    return a.rect[xyDim] - b.rect[xyDim];
	  });
	  var lastPos = 0;
	  var delta;
	  var adjusted = false;
	  var shifts = [];
	  var totalShifts = 0;
	
	  for (var i = 0; i < len; i++) {
	    var item = list[i];
	    var rect = item.rect;
	    delta = rect[xyDim] - lastPos;
	
	    if (delta < 0) {
	      rect[xyDim] -= delta;
	      item.label[xyDim] -= delta;
	      adjusted = true;
	    }
	
	    var shift = Math.max(-delta, 0);
	    shifts.push(shift);
	    totalShifts += shift;
	    lastPos = rect[xyDim] + rect[sizeDim];
	  }
	
	  if (totalShifts > 0 && balanceShift) {
	    shiftList(-totalShifts / len, 0, len);
	  }
	
	  var first = list[0];
	  var last = list[len - 1];
	  var minGap;
	  var maxGap;
	  updateMinMaxGap();
	  minGap < 0 && squeezeGaps(-minGap, 0.8);
	  maxGap < 0 && squeezeGaps(maxGap, 0.8);
	  updateMinMaxGap();
	  takeBoundsGap(minGap, maxGap, 1);
	  takeBoundsGap(maxGap, minGap, -1);
	  updateMinMaxGap();
	
	  if (minGap < 0) {
	    squeezeWhenBailout(-minGap);
	  }
	
	  if (maxGap < 0) {
	    squeezeWhenBailout(maxGap);
	  }
	
	  function updateMinMaxGap() {
	    minGap = first.rect[xyDim] - minBound;
	    maxGap = maxBound - last.rect[xyDim] - last.rect[sizeDim];
	  }
	
	  function takeBoundsGap(gapThisBound, gapOtherBound, moveDir) {
	    if (gapThisBound < 0) {
	      var moveFromMaxGap = Math.min(gapOtherBound, -gapThisBound);
	
	      if (moveFromMaxGap > 0) {
	        shiftList(moveFromMaxGap * moveDir, 0, len);
	        var remained = moveFromMaxGap + gapThisBound;
	
	        if (remained < 0) {
	          squeezeGaps(-remained * moveDir, 1);
	        }
	      } else {
	        squeezeGaps(-gapThisBound * moveDir, 1);
	      }
	    }
	  }
	
	  function shiftList(delta, start, end) {
	    if (delta !== 0) {
	      adjusted = true;
	    }
	
	    for (var i = start; i < end; i++) {
	      var item = list[i];
	      var rect = item.rect;
	      rect[xyDim] += delta;
	      item.label[xyDim] += delta;
	    }
	  }
	
	  function squeezeGaps(delta, maxSqeezePercent) {
	    var gaps = [];
	    var totalGaps = 0;
	
	    for (var i = 1; i < len; i++) {
	      var prevItemRect = list[i - 1].rect;
	      var gap = Math.max(list[i].rect[xyDim] - prevItemRect[xyDim] - prevItemRect[sizeDim], 0);
	      gaps.push(gap);
	      totalGaps += gap;
	    }
	
	    if (!totalGaps) {
	      return;
	    }
	
	    var squeezePercent = Math.min(Math.abs(delta) / totalGaps, maxSqeezePercent);
	
	    if (delta > 0) {
	      for (var i = 0; i < len - 1; i++) {
	        var movement = gaps[i] * squeezePercent;
	        shiftList(movement, 0, i + 1);
	      }
	    } else {
	      for (var i = len - 1; i > 0; i--) {
	        var movement = gaps[i - 1] * squeezePercent;
	        shiftList(-movement, i, len);
	      }
	    }
	  }
	
	  function squeezeWhenBailout(delta) {
	    var dir = delta < 0 ? -1 : 1;
	    delta = Math.abs(delta);
	    var moveForEachLabel = Math.ceil(delta / (len - 1));
	
	    for (var i = 0; i < len - 1; i++) {
	      if (dir > 0) {
	        shiftList(moveForEachLabel, 0, i + 1);
	      } else {
	        shiftList(-moveForEachLabel, len - i - 1, len);
	      }
	
	      delta -= moveForEachLabel;
	
	      if (delta <= 0) {
	        return;
	      }
	    }
	  }
	
	  return adjusted;
	}
	
	function shiftLayoutOnX(list, leftBound, rightBound, balanceShift) {
	  return shiftLayout(list, 'x', 'width', leftBound, rightBound, balanceShift);
	}
	
	exports.shiftLayoutOnX = shiftLayoutOnX;
	
	function shiftLayoutOnY(list, topBound, bottomBound, balanceShift) {
	  return shiftLayout(list, 'y', 'height', topBound, bottomBound, balanceShift);
	}
	
	exports.shiftLayoutOnY = shiftLayoutOnY;
	
	function hideOverlap(labelList) {
	  var displayedLabels = [];
	  labelList.sort(function (a, b) {
	    return b.priority - a.priority;
	  });
	  var globalRect = new graphic_1.BoundingRect(0, 0, 0, 0);
	
	  function hideEl(el) {
	    if (!el.ignore) {
	      var emphasisState = el.ensureState('emphasis');
	
	      if (emphasisState.ignore == null) {
	        emphasisState.ignore = false;
	      }
	    }
	
	    el.ignore = true;
	  }
	
	  for (var i = 0; i < labelList.length; i++) {
	    var labelItem = labelList[i];
	    var isAxisAligned = labelItem.axisAligned;
	    var localRect = labelItem.localRect;
	    var transform = labelItem.transform;
	    var label = labelItem.label;
	    var labelLine = labelItem.labelLine;
	    globalRect.copy(labelItem.rect);
	    globalRect.width -= 0.1;
	    globalRect.height -= 0.1;
	    globalRect.x += 0.05;
	    globalRect.y += 0.05;
	    var obb = labelItem.obb;
	    var overlapped = false;
	
	    for (var j = 0; j < displayedLabels.length; j++) {
	      var existsTextCfg = displayedLabels[j];
	
	      if (!globalRect.intersect(existsTextCfg.rect)) {
	        continue;
	      }
	
	      if (isAxisAligned && existsTextCfg.axisAligned) {
	        overlapped = true;
	        break;
	      }
	
	      if (!existsTextCfg.obb) {
	        existsTextCfg.obb = new graphic_1.OrientedBoundingRect(existsTextCfg.localRect, existsTextCfg.transform);
	      }
	
	      if (!obb) {
	        obb = new graphic_1.OrientedBoundingRect(localRect, transform);
	      }
	
	      if (obb.intersect(existsTextCfg.obb)) {
	        overlapped = true;
	        break;
	      }
	    }
	
	    if (overlapped) {
	      hideEl(label);
	      labelLine && hideEl(labelLine);
	    } else {
	      label.attr('ignore', labelItem.defaultAttr.ignore);
	      labelLine && labelLine.attr('ignore', labelItem.defaultAttr.labelGuideIgnore);
	      displayedLabels.push(labelItem);
	    }
	  }
	}
	
	exports.hideOverlap = hideOverlap;

/***/ },
/* 354 */
/***/ function(module, exports, __webpack_require__) {

	
	/*
	* Licensed to the Apache Software Foundation (ASF) under one
	* or more contributor license agreements.  See the NOTICE file
	* distributed with this work for additional information
	* regarding copyright ownership.  The ASF licenses this file
	* to you under the Apache License, Version 2.0 (the
	* "License"); you may not use this file except in compliance
	* with the License.  You may obtain a copy of the License at
	*
	*   http://www.apache.org/licenses/LICENSE-2.0
	*
	* Unless required by applicable law or agreed to in writing,
	* software distributed under the License is distributed on an
	* "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
	* KIND, either express or implied.  See the License for the
	* specific language governing permissions and limitations
	* under the License.
	*/
	
	
	
	/**
	 * AUTO-GENERATED FILE. DO NOT MODIFY.
	 */
	
	"use strict";
	
	exports.__esModule = true;
	
	var util_1 = __webpack_require__(1);
	
	var createRenderPlanner_1 = __webpack_require__(82);
	
	var dataStackHelper_1 = __webpack_require__(40);
	
	var vendor_1 = __webpack_require__(95);
	
	function pointsLayout(seriesType, forceStoreInTypedArray) {
	  return {
	    seriesType: seriesType,
	    plan: createRenderPlanner_1["default"](),
	    reset: function (seriesModel) {
	      var data = seriesModel.getData();
	      var coordSys = seriesModel.coordinateSystem;
	      var pipelineContext = seriesModel.pipelineContext;
	      var useTypedArray = forceStoreInTypedArray || pipelineContext.large;
	
	      if (!coordSys) {
	        return;
	      }
	
	      var dims = util_1.map(coordSys.dimensions, function (dim) {
	        return data.mapDimension(dim);
	      }).slice(0, 2);
	      var dimLen = dims.length;
	      var stackResultDim = data.getCalculationInfo('stackResultDimension');
	
	      if (dataStackHelper_1.isDimensionStacked(data, dims[0])) {
	        dims[0] = stackResultDim;
	      }
	
	      if (dataStackHelper_1.isDimensionStacked(data, dims[1])) {
	        dims[1] = stackResultDim;
	      }
	
	      var dimInfo0 = data.getDimensionInfo(dims[0]);
	      var dimInfo1 = data.getDimensionInfo(dims[1]);
	      var dimIdx0 = dimInfo0 && dimInfo0.index;
	      var dimIdx1 = dimInfo1 && dimInfo1.index;
	      return dimLen && {
	        progress: function (params, data) {
	          var segCount = params.end - params.start;
	          var points = useTypedArray && vendor_1.createFloat32Array(segCount * dimLen);
	          var tmpIn = [];
	          var tmpOut = [];
	
	          for (var i = params.start, offset = 0; i < params.end; i++) {
	            var point = void 0;
	
	            if (dimLen === 1) {
	              var x = data.getByDimIdx(dimIdx0, i);
	              point = coordSys.dataToPoint(x, null, tmpOut);
	            } else {
	              tmpIn[0] = data.getByDimIdx(dimIdx0, i);
	              tmpIn[1] = data.getByDimIdx(dimIdx1, i);
	              point = coordSys.dataToPoint(tmpIn, null, tmpOut);
	            }
	
	            if (useTypedArray) {
	              points[offset++] = point[0];
	              points[offset++] = point[1];
	            } else {
	              data.setItemLayout(i, point.slice());
	            }
	          }
	
	          useTypedArray && data.setLayout('points', points);
	        }
	      };
	    }
	  };
	}
	
	exports["default"] = pointsLayout;
	;

/***/ },
/* 355 */
/***/ function(module, exports, __webpack_require__) {

	
	/*
	* Licensed to the Apache Software Foundation (ASF) under one
	* or more contributor license agreements.  See the NOTICE file
	* distributed with this work for additional information
	* regarding copyright ownership.  The ASF licenses this file
	* to you under the Apache License, Version 2.0 (the
	* "License"); you may not use this file except in compliance
	* with the License.  You may obtain a copy of the License at
	*
	*   http://www.apache.org/licenses/LICENSE-2.0
	*
	* Unless required by applicable law or agreed to in writing,
	* software distributed under the License is distributed on an
	* "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
	* KIND, either express or implied.  See the License for the
	* specific language governing permissions and limitations
	* under the License.
	*/
	
	
	
	/**
	 * AUTO-GENERATED FILE. DO NOT MODIFY.
	 */
	
	"use strict";
	
	exports.__esModule = true;
	
	var util_1 = __webpack_require__(1);
	
	var log_1 = __webpack_require__(12);
	
	var model_1 = __webpack_require__(4);
	
	function createLegacyDataSelectAction(seriesType, ecRegisterAction) {
	  function getSeriesIndices(ecModel, payload) {
	    var seriesIndices = [];
	    ecModel.eachComponent({
	      mainType: 'series',
	      subType: seriesType,
	      query: payload
	    }, function (seriesModel) {
	      seriesIndices.push(seriesModel.seriesIndex);
	    });
	    return seriesIndices;
	  }
	
	  util_1.each([[seriesType + 'ToggleSelect', 'toggleSelect'], [seriesType + 'Select', 'select'], [seriesType + 'UnSelect', 'unselect']], function (eventsMap) {
	    ecRegisterAction(eventsMap[0], function (payload, ecModel, api) {
	      payload = util_1.extend({}, payload);
	
	      if (false) {
	        log_1.deprecateReplaceLog(payload.type, eventsMap[1]);
	      }
	
	      api.dispatchAction(util_1.extend(payload, {
	        type: eventsMap[1],
	        seriesIndex: getSeriesIndices(ecModel, payload)
	      }));
	    });
	  });
	}
	
	exports.createLegacyDataSelectAction = createLegacyDataSelectAction;
	
	function handleSeriesLegacySelectEvents(type, eventPostfix, ecIns, ecModel, payload) {
	  var legacyEventName = type + eventPostfix;
	
	  if (!ecIns.isSilent(legacyEventName)) {
	    if (false) {
	      log_1.deprecateLog("event " + legacyEventName + " is deprecated.");
	    }
	
	    ecModel.eachComponent({
	      mainType: 'series',
	      subType: 'pie'
	    }, function (seriesModel) {
	      var seriesIndex = seriesModel.seriesIndex;
	      var selected = payload.selected;
	
	      for (var i = 0; i < selected.length; i++) {
	        if (selected[i].seriesIndex === seriesIndex) {
	          var data = seriesModel.getData();
	          var dataIndex = model_1.queryDataIndex(data, payload.fromActionPayload);
	          ecIns.trigger(legacyEventName, {
	            type: legacyEventName,
	            seriesId: seriesModel.id,
	            name: util_1.isArray(dataIndex) ? data.getName(dataIndex[0]) : data.getName(dataIndex),
	            selected: util_1.extend({}, seriesModel.option.selectedMap)
	          });
	        }
	      }
	    });
	  }
	}
	
	function handleLegacySelectEvents(messageCenter, ecIns, ecModel) {
	  messageCenter.on('selectchanged', function (params) {
	    if (params.isFromClick) {
	      handleSeriesLegacySelectEvents('map', 'selectchanged', ecIns, ecModel, params);
	      handleSeriesLegacySelectEvents('pie', 'selectchanged', ecIns, ecModel, params);
	    } else if (params.fromAction === 'select') {
	      handleSeriesLegacySelectEvents('map', 'selected', ecIns, ecModel, params);
	      handleSeriesLegacySelectEvents('pie', 'selected', ecIns, ecModel, params);
	    } else if (params.fromAction === 'unselect') {
	      handleSeriesLegacySelectEvents('map', 'unselected', ecIns, ecModel, params);
	      handleSeriesLegacySelectEvents('pie', 'unselected', ecIns, ecModel, params);
	    }
	  });
	}
	
	exports.handleLegacySelectEvents = handleLegacySelectEvents;

/***/ },
/* 356 */
/***/ function(module, exports, __webpack_require__) {

	
	/*
	* Licensed to the Apache Software Foundation (ASF) under one
	* or more contributor license agreements.  See the NOTICE file
	* distributed with this work for additional information
	* regarding copyright ownership.  The ASF licenses this file
	* to you under the Apache License, Version 2.0 (the
	* "License"); you may not use this file except in compliance
	* with the License.  You may obtain a copy of the License at
	*
	*   http://www.apache.org/licenses/LICENSE-2.0
	*
	* Unless required by applicable law or agreed to in writing,
	* software distributed under the License is distributed on an
	* "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
	* KIND, either express or implied.  See the License for the
	* specific language governing permissions and limitations
	* under the License.
	*/
	
	
	
	/**
	 * AUTO-GENERATED FILE. DO NOT MODIFY.
	 */
	
	"use strict";
	
	exports.__esModule = true;
	
	var graphic_1 = __webpack_require__(7);
	
	var log_1 = __webpack_require__(12);
	
	function getTextRect(text, font, align, verticalAlign, padding, rich, truncate, lineHeight) {
	  log_1.deprecateLog('getTextRect is deprecated.');
	  var textEl = new graphic_1.Text({
	    style: {
	      text: text,
	      font: font,
	      align: align,
	      verticalAlign: verticalAlign,
	      padding: padding,
	      rich: rich,
	      overflow: truncate ? 'truncate' : null,
	      lineHeight: lineHeight
	    }
	  });
	  return textEl.getBoundingRect();
	}
	
	exports.getTextRect = getTextRect;

/***/ },
/* 357 */
/***/ function(module, exports, __webpack_require__) {

	
	/*
	* Licensed to the Apache Software Foundation (ASF) under one
	* or more contributor license agreements.  See the NOTICE file
	* distributed with this work for additional information
	* regarding copyright ownership.  The ASF licenses this file
	* to you under the Apache License, Version 2.0 (the
	* "License"); you may not use this file except in compliance
	* with the License.  You may obtain a copy of the License at
	*
	*   http://www.apache.org/licenses/LICENSE-2.0
	*
	* Unless required by applicable law or agreed to in writing,
	* software distributed under the License is distributed on an
	* "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
	* KIND, either express or implied.  See the License for the
	* specific language governing permissions and limitations
	* under the License.
	*/
	
	
	
	/**
	 * AUTO-GENERATED FILE. DO NOT MODIFY.
	 */
	
	"use strict";
	
	exports.__esModule = true;
	
	var zrUtil = __webpack_require__(1);
	
	var graphic = __webpack_require__(7);
	
	var textContain = __webpack_require__(26);
	
	var PI = Math.PI;
	
	function defaultLoading(api, opts) {
	  opts = opts || {};
	  zrUtil.defaults(opts, {
	    text: 'loading',
	    textColor: '#000',
	    fontSize: '12px',
	    maskColor: 'rgba(255, 255, 255, 0.8)',
	    showSpinner: true,
	    color: '#5470c6',
	    spinnerRadius: 10,
	    lineWidth: 5,
	    zlevel: 0
	  });
	  var group = new graphic.Group();
	  var mask = new graphic.Rect({
	    style: {
	      fill: opts.maskColor
	    },
	    zlevel: opts.zlevel,
	    z: 10000
	  });
	  group.add(mask);
	  var font = opts.fontSize + ' sans-serif';
	  var labelRect = new graphic.Rect({
	    style: {
	      fill: 'none'
	    },
	    textContent: new graphic.Text({
	      style: {
	        text: opts.text,
	        fill: opts.textColor,
	        font: font
	      }
	    }),
	    textConfig: {
	      position: 'right',
	      distance: 10
	    },
	    zlevel: opts.zlevel,
	    z: 10001
	  });
	  group.add(labelRect);
	  var arc;
	
	  if (opts.showSpinner) {
	    arc = new graphic.Arc({
	      shape: {
	        startAngle: -PI / 2,
	        endAngle: -PI / 2 + 0.1,
	        r: opts.spinnerRadius
	      },
	      style: {
	        stroke: opts.color,
	        lineCap: 'round',
	        lineWidth: opts.lineWidth
	      },
	      zlevel: opts.zlevel,
	      z: 10001
	    });
	    arc.animateShape(true).when(1000, {
	      endAngle: PI * 3 / 2
	    }).start('circularInOut');
	    arc.animateShape(true).when(1000, {
	      startAngle: PI * 3 / 2
	    }).delay(300).start('circularInOut');
	    group.add(arc);
	  }
	
	  group.resize = function () {
	    var textWidth = textContain.getWidth(opts.text, font);
	    var r = opts.showSpinner ? opts.spinnerRadius : 0;
	    var cx = (api.getWidth() - r * 2 - (opts.showSpinner && textWidth ? 10 : 0) - textWidth) / 2 - (opts.showSpinner ? 0 : textWidth / 2);
	    var cy = api.getHeight() / 2;
	    opts.showSpinner && arc.setShape({
	      cx: cx,
	      cy: cy
	    });
	    labelRect.setShape({
	      x: cx - r,
	      y: cy - r,
	      width: r * 2,
	      height: r * 2
	    });
	    mask.setShape({
	      x: 0,
	      y: 0,
	      width: api.getWidth(),
	      height: api.getHeight()
	    });
	  };
	
	  group.resize();
	  return group;
	}
	
	exports["default"] = defaultLoading;

/***/ },
/* 358 */
/***/ function(module, exports, __webpack_require__) {

	
	/*
	* Licensed to the Apache Software Foundation (ASF) under one
	* or more contributor license agreements.  See the NOTICE file
	* distributed with this work for additional information
	* regarding copyright ownership.  The ASF licenses this file
	* to you under the Apache License, Version 2.0 (the
	* "License"); you may not use this file except in compliance
	* with the License.  You may obtain a copy of the License at
	*
	*   http://www.apache.org/licenses/LICENSE-2.0
	*
	* Unless required by applicable law or agreed to in writing,
	* software distributed under the License is distributed on an
	* "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
	* KIND, either express or implied.  See the License for the
	* specific language governing permissions and limitations
	* under the License.
	*/
	
	
	
	/**
	 * AUTO-GENERATED FILE. DO NOT MODIFY.
	 */
	
	"use strict";
	
	exports.__esModule = true;
	
	var model_1 = __webpack_require__(4);
	
	var util_1 = __webpack_require__(1);
	
	var log_1 = __webpack_require__(12);
	
	var QUERY_REG = /^(min|max)?(.+)$/;
	
	var OptionManager = function () {
	  function OptionManager(api) {
	    this._timelineOptions = [];
	    this._mediaList = [];
	    this._currentMediaIndices = [];
	    this._api = api;
	  }
	
	  OptionManager.prototype.setOption = function (rawOption, optionPreprocessorFuncs, opt) {
	    if (rawOption) {
	      util_1.each(model_1.normalizeToArray(rawOption.series), function (series) {
	        series && series.data && util_1.isTypedArray(series.data) && util_1.setAsPrimitive(series.data);
	      });
	      util_1.each(model_1.normalizeToArray(rawOption.dataset), function (dataset) {
	        dataset && dataset.source && util_1.isTypedArray(dataset.source) && util_1.setAsPrimitive(dataset.source);
	      });
	    }
	
	    rawOption = util_1.clone(rawOption);
	    var optionBackup = this._optionBackup;
	    var newParsedOption = parseRawOption(rawOption, optionPreprocessorFuncs, !optionBackup);
	    this._newBaseOption = newParsedOption.baseOption;
	
	    if (optionBackup) {
	      if (newParsedOption.timelineOptions.length) {
	        optionBackup.timelineOptions = newParsedOption.timelineOptions;
	      }
	
	      if (newParsedOption.mediaList.length) {
	        optionBackup.mediaList = newParsedOption.mediaList;
	      }
	
	      if (newParsedOption.mediaDefault) {
	        optionBackup.mediaDefault = newParsedOption.mediaDefault;
	      }
	    } else {
	      this._optionBackup = newParsedOption;
	    }
	  };
	
	  OptionManager.prototype.mountOption = function (isRecreate) {
	    var optionBackup = this._optionBackup;
	    this._timelineOptions = optionBackup.timelineOptions;
	    this._mediaList = optionBackup.mediaList;
	    this._mediaDefault = optionBackup.mediaDefault;
	    this._currentMediaIndices = [];
	    return util_1.clone(isRecreate ? optionBackup.baseOption : this._newBaseOption);
	  };
	
	  OptionManager.prototype.getTimelineOption = function (ecModel) {
	    var option;
	    var timelineOptions = this._timelineOptions;
	
	    if (timelineOptions.length) {
	      var timelineModel = ecModel.getComponent('timeline');
	
	      if (timelineModel) {
	        option = util_1.clone(timelineOptions[timelineModel.getCurrentIndex()]);
	      }
	    }
	
	    return option;
	  };
	
	  OptionManager.prototype.getMediaOption = function (ecModel) {
	    var ecWidth = this._api.getWidth();
	
	    var ecHeight = this._api.getHeight();
	
	    var mediaList = this._mediaList;
	    var mediaDefault = this._mediaDefault;
	    var indices = [];
	    var result = [];
	
	    if (!mediaList.length && !mediaDefault) {
	      return result;
	    }
	
	    for (var i = 0, len = mediaList.length; i < len; i++) {
	      if (applyMediaQuery(mediaList[i].query, ecWidth, ecHeight)) {
	        indices.push(i);
	      }
	    }
	
	    if (!indices.length && mediaDefault) {
	      indices = [-1];
	    }
	
	    if (indices.length && !indicesEquals(indices, this._currentMediaIndices)) {
	      result = util_1.map(indices, function (index) {
	        return util_1.clone(index === -1 ? mediaDefault.option : mediaList[index].option);
	      });
	    }
	
	    this._currentMediaIndices = indices;
	    return result;
	  };
	
	  return OptionManager;
	}();
	
	function parseRawOption(rawOption, optionPreprocessorFuncs, isNew) {
	  var mediaList = [];
	  var mediaDefault;
	  var baseOption;
	  var declaredBaseOption = rawOption.baseOption;
	  var timelineOnRoot = rawOption.timeline;
	  var timelineOptionsOnRoot = rawOption.options;
	  var mediaOnRoot = rawOption.media;
	  var hasMedia = !!rawOption.media;
	  var hasTimeline = !!(timelineOptionsOnRoot || timelineOnRoot || declaredBaseOption && declaredBaseOption.timeline);
	
	  if (declaredBaseOption) {
	    baseOption = declaredBaseOption;
	
	    if (!baseOption.timeline) {
	      baseOption.timeline = timelineOnRoot;
	    }
	  } else {
	    if (hasTimeline || hasMedia) {
	      rawOption.options = rawOption.media = null;
	    }
	
	    baseOption = rawOption;
	  }
	
	  if (hasMedia) {
	    if (util_1.isArray(mediaOnRoot)) {
	      util_1.each(mediaOnRoot, function (singleMedia) {
	        if (false) {
	          if (singleMedia && !singleMedia.option && util_1.isObject(singleMedia.query) && util_1.isObject(singleMedia.query.option)) {
	            log_1.error('Illegal media option. Must be like { media: [ { query: {}, option: {} } ] }');
	          }
	        }
	
	        if (singleMedia && singleMedia.option) {
	          if (singleMedia.query) {
	            mediaList.push(singleMedia);
	          } else if (!mediaDefault) {
	            mediaDefault = singleMedia;
	          }
	        }
	      });
	    } else {
	      if (false) {
	        log_1.error('Illegal media option. Must be an array. Like { media: [ {...}, {...} ] }');
	      }
	    }
	  }
	
	  doPreprocess(baseOption);
	  util_1.each(timelineOptionsOnRoot, function (option) {
	    return doPreprocess(option);
	  });
	  util_1.each(mediaList, function (media) {
	    return doPreprocess(media.option);
	  });
	
	  function doPreprocess(option) {
	    util_1.each(optionPreprocessorFuncs, function (preProcess) {
	      preProcess(option, isNew);
	    });
	  }
	
	  return {
	    baseOption: baseOption,
	    timelineOptions: timelineOptionsOnRoot || [],
	    mediaDefault: mediaDefault,
	    mediaList: mediaList
	  };
	}
	
	function applyMediaQuery(query, ecWidth, ecHeight) {
	  var realMap = {
	    width: ecWidth,
	    height: ecHeight,
	    aspectratio: ecWidth / ecHeight
	  };
	  var applicatable = true;
	  util_1.each(query, function (value, attr) {
	    var matched = attr.match(QUERY_REG);
	
	    if (!matched || !matched[1] || !matched[2]) {
	      return;
	    }
	
	    var operator = matched[1];
	    var realAttr = matched[2].toLowerCase();
	
	    if (!compare(realMap[realAttr], value, operator)) {
	      applicatable = false;
	    }
	  });
	  return applicatable;
	}
	
	function compare(real, expect, operator) {
	  if (operator === 'min') {
	    return real >= expect;
	  } else if (operator === 'max') {
	    return real <= expect;
	  } else {
	    return real === expect;
	  }
	}
	
	function indicesEquals(indices1, indices2) {
	  return indices1.join(',') === indices2.join(',');
	}
	
	exports["default"] = OptionManager;

/***/ },
/* 359 */
/***/ function(module, exports) {

	
	/*
	* Licensed to the Apache Software Foundation (ASF) under one
	* or more contributor license agreements.  See the NOTICE file
	* distributed with this work for additional information
	* regarding copyright ownership.  The ASF licenses this file
	* to you under the Apache License, Version 2.0 (the
	* "License"); you may not use this file except in compliance
	* with the License.  You may obtain a copy of the License at
	*
	*   http://www.apache.org/licenses/LICENSE-2.0
	*
	* Unless required by applicable law or agreed to in writing,
	* software distributed under the License is distributed on an
	* "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
	* KIND, either express or implied.  See the License for the
	* specific language governing permissions and limitations
	* under the License.
	*/
	
	
	
	/**
	 * AUTO-GENERATED FILE. DO NOT MODIFY.
	 */
	
	"use strict";
	
	exports.__esModule = true;
	var platform = '';
	
	if (typeof navigator !== 'undefined') {
	  platform = navigator.platform || '';
	}
	
	var decalColor = 'rgba(0, 0, 0, 0.2)';
	exports["default"] = {
	  darkMode: 'auto',
	  color: ['#5470c6', '#91cc75', '#fac858', '#ee6666', '#73c0de', '#3ba272', '#fc8452', '#9a60b4', '#ea7ccc'],
	  gradientColor: ['#f6efa6', '#d88273', '#bf444c'],
	  aria: {
	    decal: {
	      decals: [{
	        color: decalColor,
	        dashArrayX: [1, 0],
	        dashArrayY: [2, 5],
	        symbolSize: 1,
	        rotation: Math.PI / 6
	      }, {
	        color: decalColor,
	        symbol: 'circle',
	        dashArrayX: [[8, 8], [0, 8, 8, 0]],
	        dashArrayY: [6, 0],
	        symbolSize: 0.8
	      }, {
	        color: decalColor,
	        dashArrayX: [1, 0],
	        dashArrayY: [4, 3],
	        dashLineOffset: 0,
	        rotation: -Math.PI / 4
	      }, {
	        color: decalColor,
	        dashArrayX: [[6, 6], [0, 6, 6, 0]],
	        dashArrayY: [6, 0]
	      }, {
	        color: decalColor,
	        dashArrayX: [[1, 0], [1, 6]],
	        dashArrayY: [1, 0, 6, 0],
	        rotation: Math.PI / 4
	      }, {
	        color: decalColor,
	        symbol: 'triangle',
	        dashArrayX: [[9, 9], [0, 9, 9, 0]],
	        dashArrayY: [7, 2],
	        symbolSize: 0.75
	      }]
	    }
	  },
	  textStyle: {
	    fontFamily: platform.match(/^Win/) ? 'Microsoft YaHei' : 'sans-serif',
	    fontSize: 12,
	    fontStyle: 'normal',
	    fontWeight: 'normal'
	  },
	  blendMode: null,
	  stateAnimation: {
	    duration: 300,
	    easing: 'cubicOut'
	  },
	  animation: 'auto',
	  animationDuration: 1000,
	  animationDurationUpdate: 500,
	  animationEasing: 'cubicInOut',
	  animationEasingUpdate: 'cubicInOut',
	  animationThreshold: 2000,
	  progressiveThreshold: 3000,
	  progressive: 400,
	  hoverLayerThreshold: 3000,
	  useUTC: false
	};

/***/ },
/* 360 */
/***/ function(module, exports, __webpack_require__) {

	
	/*
	* Licensed to the Apache Software Foundation (ASF) under one
	* or more contributor license agreements.  See the NOTICE file
	* distributed with this work for additional information
	* regarding copyright ownership.  The ASF licenses this file
	* to you under the Apache License, Version 2.0 (the
	* "License"); you may not use this file except in compliance
	* with the License.  You may obtain a copy of the License at
	*
	*   http://www.apache.org/licenses/LICENSE-2.0
	*
	* Unless required by applicable law or agreed to in writing,
	* software distributed under the License is distributed on an
	* "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
	* KIND, either express or implied.  See the License for the
	* specific language governing permissions and limitations
	* under the License.
	*/
	
	
	
	/**
	 * AUTO-GENERATED FILE. DO NOT MODIFY.
	 */
	
	"use strict";
	
	exports.__esModule = true;
	
	var util_1 = __webpack_require__(1);
	
	var model_1 = __webpack_require__(4);
	
	var internalOptionCreatorMap = util_1.createHashMap();
	
	function registerInternalOptionCreator(mainType, creator) {
	  util_1.assert(internalOptionCreatorMap.get(mainType) == null && creator);
	  internalOptionCreatorMap.set(mainType, creator);
	}
	
	exports.registerInternalOptionCreator = registerInternalOptionCreator;
	
	function concatInternalOptions(ecModel, mainType, newCmptOptionList) {
	  var internalOptionCreator = internalOptionCreatorMap.get(mainType);
	
	  if (!internalOptionCreator) {
	    return newCmptOptionList;
	  }
	
	  var internalOptions = internalOptionCreator(ecModel);
	
	  if (!internalOptions) {
	    return newCmptOptionList;
	  }
	
	  if (false) {
	    for (var i = 0; i < internalOptions.length; i++) {
	      util_1.assert(model_1.isComponentIdInternal(internalOptions[i]));
	    }
	  }
	
	  return newCmptOptionList.concat(internalOptions);
	}
	
	exports.concatInternalOptions = concatInternalOptions;

/***/ },
/* 361 */
/***/ function(module, exports, __webpack_require__) {

	
	/*
	* Licensed to the Apache Software Foundation (ASF) under one
	* or more contributor license agreements.  See the NOTICE file
	* distributed with this work for additional information
	* regarding copyright ownership.  The ASF licenses this file
	* to you under the Apache License, Version 2.0 (the
	* "License"); you may not use this file except in compliance
	* with the License.  You may obtain a copy of the License at
	*
	*   http://www.apache.org/licenses/LICENSE-2.0
	*
	* Unless required by applicable law or agreed to in writing,
	* software distributed under the License is distributed on an
	* "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
	* KIND, either express or implied.  See the License for the
	* specific language governing permissions and limitations
	* under the License.
	*/
	
	
	
	/**
	 * AUTO-GENERATED FILE. DO NOT MODIFY.
	 */
	
	"use strict";
	
	exports.__esModule = true;
	
	var makeStyleMapper_1 = __webpack_require__(69);
	
	exports.AREA_STYLE_KEY_MAP = [['fill', 'color'], ['shadowBlur'], ['shadowOffsetX'], ['shadowOffsetY'], ['opacity'], ['shadowColor']];
	var getAreaStyle = makeStyleMapper_1["default"](exports.AREA_STYLE_KEY_MAP);
	
	var AreaStyleMixin = function () {
	  function AreaStyleMixin() {}
	
	  AreaStyleMixin.prototype.getAreaStyle = function (excludes, includes) {
	    return getAreaStyle(this, excludes, includes);
	  };
	
	  return AreaStyleMixin;
	}();
	
	exports.AreaStyleMixin = AreaStyleMixin;
	;

/***/ },
/* 362 */
/***/ function(module, exports, __webpack_require__) {

	
	/*
	* Licensed to the Apache Software Foundation (ASF) under one
	* or more contributor license agreements.  See the NOTICE file
	* distributed with this work for additional information
	* regarding copyright ownership.  The ASF licenses this file
	* to you under the Apache License, Version 2.0 (the
	* "License"); you may not use this file except in compliance
	* with the License.  You may obtain a copy of the License at
	*
	*   http://www.apache.org/licenses/LICENSE-2.0
	*
	* Unless required by applicable law or agreed to in writing,
	* software distributed under the License is distributed on an
	* "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
	* KIND, either express or implied.  See the License for the
	* specific language governing permissions and limitations
	* under the License.
	*/
	
	
	
	/**
	 * AUTO-GENERATED FILE. DO NOT MODIFY.
	 */
	
	"use strict";
	
	exports.__esModule = true;
	
	var labelStyle_1 = __webpack_require__(20);
	
	var Text_1 = __webpack_require__(60);
	
	var PATH_COLOR = ['textStyle', 'color'];
	var tmpRichText = new Text_1["default"]();
	
	var TextStyleMixin = function () {
	  function TextStyleMixin() {}
	
	  TextStyleMixin.prototype.getTextColor = function (isEmphasis) {
	    var ecModel = this.ecModel;
	    return this.getShallow('color') || (!isEmphasis && ecModel ? ecModel.get(PATH_COLOR) : null);
	  };
	
	  TextStyleMixin.prototype.getFont = function () {
	    return labelStyle_1.getFont({
	      fontStyle: this.getShallow('fontStyle'),
	      fontWeight: this.getShallow('fontWeight'),
	      fontSize: this.getShallow('fontSize'),
	      fontFamily: this.getShallow('fontFamily')
	    }, this.ecModel);
	  };
	
	  TextStyleMixin.prototype.getTextRect = function (text) {
	    tmpRichText.useStyle({
	      text: text,
	      fontStyle: this.getShallow('fontStyle'),
	      fontWeight: this.getShallow('fontWeight'),
	      fontSize: this.getShallow('fontSize'),
	      fontFamily: this.getShallow('fontFamily'),
	      verticalAlign: this.getShallow('verticalAlign') || this.getShallow('baseline'),
	      padding: this.getShallow('padding'),
	      lineHeight: this.getShallow('lineHeight'),
	      rich: this.getShallow('rich')
	    });
	    tmpRichText.update();
	    return tmpRichText.getBoundingRect();
	  };
	
	  return TextStyleMixin;
	}();
	
	;
	exports["default"] = TextStyleMixin;

/***/ },
/* 363 */
/***/ function(module, exports, __webpack_require__) {

	
	/*
	* Licensed to the Apache Software Foundation (ASF) under one
	* or more contributor license agreements.  See the NOTICE file
	* distributed with this work for additional information
	* regarding copyright ownership.  The ASF licenses this file
	* to you under the Apache License, Version 2.0 (the
	* "License"); you may not use this file except in compliance
	* with the License.  You may obtain a copy of the License at
	*
	*   http://www.apache.org/licenses/LICENSE-2.0
	*
	* Unless required by applicable law or agreed to in writing,
	* software distributed under the License is distributed on an
	* "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
	* KIND, either express or implied.  See the License for the
	* specific language governing permissions and limitations
	* under the License.
	*/
	
	
	
	/**
	 * AUTO-GENERATED FILE. DO NOT MODIFY.
	 */
	
	"use strict";
	
	exports.__esModule = true;
	
	var util_1 = __webpack_require__(1);
	
	var model_1 = __webpack_require__(4);
	
	var CoordSysInfo = function () {
	  function CoordSysInfo(coordSysName) {
	    this.coordSysDims = [];
	    this.axisMap = util_1.createHashMap();
	    this.categoryAxisMap = util_1.createHashMap();
	    this.coordSysName = coordSysName;
	  }
	
	  return CoordSysInfo;
	}();
	
	function getCoordSysInfoBySeries(seriesModel) {
	  var coordSysName = seriesModel.get('coordinateSystem');
	  var result = new CoordSysInfo(coordSysName);
	  var fetch = fetchers[coordSysName];
	
	  if (fetch) {
	    fetch(seriesModel, result, result.axisMap, result.categoryAxisMap);
	    return result;
	  }
	}
	
	exports.getCoordSysInfoBySeries = getCoordSysInfoBySeries;
	var fetchers = {
	  cartesian2d: function (seriesModel, result, axisMap, categoryAxisMap) {
	    var xAxisModel = seriesModel.getReferringComponents('xAxis', model_1.SINGLE_REFERRING).models[0];
	    var yAxisModel = seriesModel.getReferringComponents('yAxis', model_1.SINGLE_REFERRING).models[0];
	
	    if (false) {
	      if (!xAxisModel) {
	        throw new Error('xAxis "' + util_1.retrieve(seriesModel.get('xAxisIndex'), seriesModel.get('xAxisId'), 0) + '" not found');
	      }
	
	      if (!yAxisModel) {
	        throw new Error('yAxis "' + util_1.retrieve(seriesModel.get('xAxisIndex'), seriesModel.get('yAxisId'), 0) + '" not found');
	      }
	    }
	
	    result.coordSysDims = ['x', 'y'];
	    axisMap.set('x', xAxisModel);
	    axisMap.set('y', yAxisModel);
	
	    if (isCategory(xAxisModel)) {
	      categoryAxisMap.set('x', xAxisModel);
	      result.firstCategoryDimIndex = 0;
	    }
	
	    if (isCategory(yAxisModel)) {
	      categoryAxisMap.set('y', yAxisModel);
	      result.firstCategoryDimIndex == null && (result.firstCategoryDimIndex = 1);
	    }
	  },
	  singleAxis: function (seriesModel, result, axisMap, categoryAxisMap) {
	    var singleAxisModel = seriesModel.getReferringComponents('singleAxis', model_1.SINGLE_REFERRING).models[0];
	
	    if (false) {
	      if (!singleAxisModel) {
	        throw new Error('singleAxis should be specified.');
	      }
	    }
	
	    result.coordSysDims = ['single'];
	    axisMap.set('single', singleAxisModel);
	
	    if (isCategory(singleAxisModel)) {
	      categoryAxisMap.set('single', singleAxisModel);
	      result.firstCategoryDimIndex = 0;
	    }
	  },
	  polar: function (seriesModel, result, axisMap, categoryAxisMap) {
	    var polarModel = seriesModel.getReferringComponents('polar', model_1.SINGLE_REFERRING).models[0];
	    var radiusAxisModel = polarModel.findAxisModel('radiusAxis');
	    var angleAxisModel = polarModel.findAxisModel('angleAxis');
	
	    if (false) {
	      if (!angleAxisModel) {
	        throw new Error('angleAxis option not found');
	      }
	
	      if (!radiusAxisModel) {
	        throw new Error('radiusAxis option not found');
	      }
	    }
	
	    result.coordSysDims = ['radius', 'angle'];
	    axisMap.set('radius', radiusAxisModel);
	    axisMap.set('angle', angleAxisModel);
	
	    if (isCategory(radiusAxisModel)) {
	      categoryAxisMap.set('radius', radiusAxisModel);
	      result.firstCategoryDimIndex = 0;
	    }
	
	    if (isCategory(angleAxisModel)) {
	      categoryAxisMap.set('angle', angleAxisModel);
	      result.firstCategoryDimIndex == null && (result.firstCategoryDimIndex = 1);
	    }
	  },
	  geo: function (seriesModel, result, axisMap, categoryAxisMap) {
	    result.coordSysDims = ['lng', 'lat'];
	  },
	  parallel: function (seriesModel, result, axisMap, categoryAxisMap) {
	    var ecModel = seriesModel.ecModel;
	    var parallelModel = ecModel.getComponent('parallel', seriesModel.get('parallelIndex'));
	    var coordSysDims = result.coordSysDims = parallelModel.dimensions.slice();
	    util_1.each(parallelModel.parallelAxisIndex, function (axisIndex, index) {
	      var axisModel = ecModel.getComponent('parallelAxis', axisIndex);
	      var axisDim = coordSysDims[index];
	      axisMap.set(axisDim, axisModel);
	
	      if (isCategory(axisModel)) {
	        categoryAxisMap.set(axisDim, axisModel);
	
	        if (result.firstCategoryDimIndex == null) {
	          result.firstCategoryDimIndex = index;
	        }
	      }
	    });
	  }
	};
	
	function isCategory(axisModel) {
	  return axisModel.get('type') === 'category';
	}

/***/ },
/* 364 */
/***/ function(module, exports, __webpack_require__) {

	
	/*
	* Licensed to the Apache Software Foundation (ASF) under one
	* or more contributor license agreements.  See the NOTICE file
	* distributed with this work for additional information
	* regarding copyright ownership.  The ASF licenses this file
	* to you under the Apache License, Version 2.0 (the
	* "License"); you may not use this file except in compliance
	* with the License.  You may obtain a copy of the License at
	*
	*   http://www.apache.org/licenses/LICENSE-2.0
	*
	* Unless required by applicable law or agreed to in writing,
	* software distributed under the License is distributed on an
	* "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
	* KIND, either express or implied.  See the License for the
	* specific language governing permissions and limitations
	* under the License.
	*/
	
	
	
	/**
	 * AUTO-GENERATED FILE. DO NOT MODIFY.
	 */
	
	"use strict";
	
	exports.__esModule = true;
	
	var util_1 = __webpack_require__(1);
	
	var compatStyle_1 = __webpack_require__(365);
	
	var model_1 = __webpack_require__(4);
	
	var log_1 = __webpack_require__(12);
	
	function get(opt, path) {
	  var pathArr = path.split(',');
	  var obj = opt;
	
	  for (var i = 0; i < pathArr.length; i++) {
	    obj = obj && obj[pathArr[i]];
	
	    if (obj == null) {
	      break;
	    }
	  }
	
	  return obj;
	}
	
	function set(opt, path, val, overwrite) {
	  var pathArr = path.split(',');
	  var obj = opt;
	  var key;
	  var i = 0;
	
	  for (; i < pathArr.length - 1; i++) {
	    key = pathArr[i];
	
	    if (obj[key] == null) {
	      obj[key] = {};
	    }
	
	    obj = obj[key];
	  }
	
	  if (overwrite || obj[pathArr[i]] == null) {
	    obj[pathArr[i]] = val;
	  }
	}
	
	function compatLayoutProperties(option) {
	  option && util_1.each(LAYOUT_PROPERTIES, function (prop) {
	    if (prop[0] in option && !(prop[1] in option)) {
	      option[prop[1]] = option[prop[0]];
	    }
	  });
	}
	
	var LAYOUT_PROPERTIES = [['x', 'left'], ['y', 'top'], ['x2', 'right'], ['y2', 'bottom']];
	var COMPATITABLE_COMPONENTS = ['grid', 'geo', 'parallel', 'legend', 'toolbox', 'title', 'visualMap', 'dataZoom', 'timeline'];
	var BAR_ITEM_STYLE_MAP = [['borderRadius', 'barBorderRadius'], ['borderColor', 'barBorderColor'], ['borderWidth', 'barBorderWidth']];
	
	function compatBarItemStyle(option) {
	  var itemStyle = option && option.itemStyle;
	
	  if (itemStyle) {
	    for (var i = 0; i < BAR_ITEM_STYLE_MAP.length; i++) {
	      var oldName = BAR_ITEM_STYLE_MAP[i][1];
	      var newName = BAR_ITEM_STYLE_MAP[i][0];
	
	      if (itemStyle[oldName] != null) {
	        itemStyle[newName] = itemStyle[oldName];
	
	        if (false) {
	          log_1.deprecateReplaceLog(oldName, newName);
	        }
	      }
	    }
	  }
	}
	
	function compatPieLabel(option) {
	  if (!option) {
	    return;
	  }
	
	  if (option.alignTo === 'edge' && option.margin != null && option.edgeDistance == null) {
	    if (false) {
	      log_1.deprecateReplaceLog('label.margin', 'label.edgeDistance', 'pie');
	    }
	
	    option.edgeDistance = option.margin;
	  }
	}
	
	function compatSunburstState(option) {
	  if (!option) {
	    return;
	  }
	
	  if (option.downplay && !option.blur) {
	    option.blur = option.downplay;
	
	    if (false) {
	      log_1.deprecateReplaceLog('downplay', 'blur', 'sunburst');
	    }
	  }
	}
	
	function compatGraphFocus(option) {
	  if (!option) {
	    return;
	  }
	
	  if (option.focusNodeAdjacency != null) {
	    option.emphasis = option.emphasis || {};
	
	    if (option.emphasis.focus == null) {
	      if (false) {
	        log_1.deprecateReplaceLog('focusNodeAdjacency', 'emphasis: { focus: \'adjacency\'}', 'graph/sankey');
	      }
	
	      option.emphasis.focus = 'adjacency';
	    }
	  }
	}
	
	function traverseTree(data, cb) {
	  if (data) {
	    for (var i = 0; i < data.length; i++) {
	      cb(data[i]);
	      data[i] && traverseTree(data[i].children, cb);
	    }
	  }
	}
	
	function globalBackwardCompat(option, isTheme) {
	  compatStyle_1["default"](option, isTheme);
	  option.series = model_1.normalizeToArray(option.series);
	  util_1.each(option.series, function (seriesOpt) {
	    if (!util_1.isObject(seriesOpt)) {
	      return;
	    }
	
	    var seriesType = seriesOpt.type;
	
	    if (seriesType === 'line') {
	      if (seriesOpt.clipOverflow != null) {
	        seriesOpt.clip = seriesOpt.clipOverflow;
	
	        if (false) {
	          log_1.deprecateReplaceLog('clipOverflow', 'clip', 'line');
	        }
	      }
	    } else if (seriesType === 'pie' || seriesType === 'gauge') {
	      if (seriesOpt.clockWise != null) {
	        seriesOpt.clockwise = seriesOpt.clockWise;
	
	        if (false) {
	          log_1.deprecateReplaceLog('clockWise', 'clockwise');
	        }
	      }
	
	      compatPieLabel(seriesOpt.label);
	      var data = seriesOpt.data;
	
	      if (data && !util_1.isTypedArray(data)) {
	        for (var i = 0; i < data.length; i++) {
	          compatPieLabel(data[i]);
	        }
	      }
	
	      if (seriesOpt.hoverOffset != null) {
	        seriesOpt.emphasis = seriesOpt.emphasis || {};
	
	        if (seriesOpt.emphasis.scaleSize = null) {
	          if (false) {
	            log_1.deprecateReplaceLog('hoverOffset', 'emphasis.scaleSize');
	          }
	
	          seriesOpt.emphasis.scaleSize = seriesOpt.hoverOffset;
	        }
	      }
	    } else if (seriesType === 'gauge') {
	      var pointerColor = get(seriesOpt, 'pointer.color');
	      pointerColor != null && set(seriesOpt, 'itemStyle.color', pointerColor);
	    } else if (seriesType === 'bar') {
	      compatBarItemStyle(seriesOpt);
	      compatBarItemStyle(seriesOpt.backgroundStyle);
	      compatBarItemStyle(seriesOpt.emphasis);
	      var data = seriesOpt.data;
	
	      if (data && !util_1.isTypedArray(data)) {
	        for (var i = 0; i < data.length; i++) {
	          if (typeof data[i] === 'object') {
	            compatBarItemStyle(data[i]);
	            compatBarItemStyle(data[i] && data[i].emphasis);
	          }
	        }
	      }
	    } else if (seriesType === 'sunburst') {
	      var highlightPolicy = seriesOpt.highlightPolicy;
	
	      if (highlightPolicy) {
	        seriesOpt.emphasis = seriesOpt.emphasis || {};
	
	        if (!seriesOpt.emphasis.focus) {
	          seriesOpt.emphasis.focus = highlightPolicy;
	
	          if (false) {
	            log_1.deprecateReplaceLog('highlightPolicy', 'emphasis.focus', 'sunburst');
	          }
	        }
	      }
	
	      compatSunburstState(seriesOpt);
	      traverseTree(seriesOpt.data, compatSunburstState);
	    } else if (seriesType === 'graph' || seriesType === 'sankey') {
	      compatGraphFocus(seriesOpt);
	    } else if (seriesType === 'map') {
	      if (seriesOpt.mapType && !seriesOpt.map) {
	        if (false) {
	          log_1.deprecateReplaceLog('mapType', 'map', 'map');
	        }
	
	        seriesOpt.map = seriesOpt.mapType;
	      }
	
	      if (seriesOpt.mapLocation) {
	        if (false) {
	          log_1.deprecateLog('`mapLocation` is not used anymore.');
	        }
	
	        util_1.defaults(seriesOpt, seriesOpt.mapLocation);
	      }
	    }
	
	    if (seriesOpt.hoverAnimation != null) {
	      seriesOpt.emphasis = seriesOpt.emphasis || {};
	
	      if (seriesOpt.emphasis && seriesOpt.emphasis.scale == null) {
	        if (false) {
	          log_1.deprecateReplaceLog('hoverAnimation', 'emphasis.scale');
	        }
	
	        seriesOpt.emphasis.scale = seriesOpt.hoverAnimation;
	      }
	    }
	
	    compatLayoutProperties(seriesOpt);
	  });
	
	  if (option.dataRange) {
	    option.visualMap = option.dataRange;
	  }
	
	  util_1.each(COMPATITABLE_COMPONENTS, function (componentName) {
	    var options = option[componentName];
	
	    if (options) {
	      if (!util_1.isArray(options)) {
	        options = [options];
	      }
	
	      util_1.each(options, function (option) {
	        compatLayoutProperties(option);
	      });
	    }
	  });
	}
	
	exports["default"] = globalBackwardCompat;

/***/ },
/* 365 */
/***/ function(module, exports, __webpack_require__) {

	
	/*
	* Licensed to the Apache Software Foundation (ASF) under one
	* or more contributor license agreements.  See the NOTICE file
	* distributed with this work for additional information
	* regarding copyright ownership.  The ASF licenses this file
	* to you under the Apache License, Version 2.0 (the
	* "License"); you may not use this file except in compliance
	* with the License.  You may obtain a copy of the License at
	*
	*   http://www.apache.org/licenses/LICENSE-2.0
	*
	* Unless required by applicable law or agreed to in writing,
	* software distributed under the License is distributed on an
	* "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
	* KIND, either express or implied.  See the License for the
	* specific language governing permissions and limitations
	* under the License.
	*/
	
	
	
	/**
	 * AUTO-GENERATED FILE. DO NOT MODIFY.
	 */
	
	"use strict";
	
	exports.__esModule = true;
	
	var zrUtil = __webpack_require__(1);
	
	var modelUtil = __webpack_require__(4);
	
	var log_1 = __webpack_require__(12);
	
	var each = zrUtil.each;
	var isObject = zrUtil.isObject;
	var POSSIBLE_STYLES = ['areaStyle', 'lineStyle', 'nodeStyle', 'linkStyle', 'chordStyle', 'label', 'labelLine'];
	
	function compatEC2ItemStyle(opt) {
	  var itemStyleOpt = opt && opt.itemStyle;
	
	  if (!itemStyleOpt) {
	    return;
	  }
	
	  for (var i = 0, len = POSSIBLE_STYLES.length; i < len; i++) {
	    var styleName = POSSIBLE_STYLES[i];
	    var normalItemStyleOpt = itemStyleOpt.normal;
	    var emphasisItemStyleOpt = itemStyleOpt.emphasis;
	
	    if (normalItemStyleOpt && normalItemStyleOpt[styleName]) {
	      if (false) {
	        log_1.deprecateReplaceLog("itemStyle.normal." + styleName, styleName);
	      }
	
	      opt[styleName] = opt[styleName] || {};
	
	      if (!opt[styleName].normal) {
	        opt[styleName].normal = normalItemStyleOpt[styleName];
	      } else {
	        zrUtil.merge(opt[styleName].normal, normalItemStyleOpt[styleName]);
	      }
	
	      normalItemStyleOpt[styleName] = null;
	    }
	
	    if (emphasisItemStyleOpt && emphasisItemStyleOpt[styleName]) {
	      if (false) {
	        log_1.deprecateReplaceLog("itemStyle.emphasis." + styleName, "emphasis." + styleName);
	      }
	
	      opt[styleName] = opt[styleName] || {};
	
	      if (!opt[styleName].emphasis) {
	        opt[styleName].emphasis = emphasisItemStyleOpt[styleName];
	      } else {
	        zrUtil.merge(opt[styleName].emphasis, emphasisItemStyleOpt[styleName]);
	      }
	
	      emphasisItemStyleOpt[styleName] = null;
	    }
	  }
	}
	
	function convertNormalEmphasis(opt, optType, useExtend) {
	  if (opt && opt[optType] && (opt[optType].normal || opt[optType].emphasis)) {
	    var normalOpt = opt[optType].normal;
	    var emphasisOpt = opt[optType].emphasis;
	
	    if (normalOpt) {
	      if (false) {
	        log_1.deprecateLog("'normal' hierarchy in " + optType + " has been removed since 4.0. All style properties are configured in " + optType + " directly now.");
	      }
	
	      if (useExtend) {
	        opt[optType].normal = opt[optType].emphasis = null;
	        zrUtil.defaults(opt[optType], normalOpt);
	      } else {
	        opt[optType] = normalOpt;
	      }
	    }
	
	    if (emphasisOpt) {
	      if (false) {
	        log_1.deprecateLog(optType + ".emphasis has been changed to emphasis." + optType + " since 4.0");
	      }
	
	      opt.emphasis = opt.emphasis || {};
	      opt.emphasis[optType] = emphasisOpt;
	
	      if (emphasisOpt.focus) {
	        opt.emphasis.focus = emphasisOpt.focus;
	      }
	
	      if (emphasisOpt.blurScope) {
	        opt.emphasis.blurScope = emphasisOpt.blurScope;
	      }
	    }
	  }
	}
	
	function removeEC3NormalStatus(opt) {
	  convertNormalEmphasis(opt, 'itemStyle');
	  convertNormalEmphasis(opt, 'lineStyle');
	  convertNormalEmphasis(opt, 'areaStyle');
	  convertNormalEmphasis(opt, 'label');
	  convertNormalEmphasis(opt, 'labelLine');
	  convertNormalEmphasis(opt, 'upperLabel');
	  convertNormalEmphasis(opt, 'edgeLabel');
	}
	
	function compatTextStyle(opt, propName) {
	  var labelOptSingle = isObject(opt) && opt[propName];
	  var textStyle = isObject(labelOptSingle) && labelOptSingle.textStyle;
	
	  if (textStyle) {
	    if (false) {
	      log_1.deprecateLog("textStyle hierarchy in " + propName + " has been removed since 4.0. All textStyle properties are configured in " + propName + " directly now.");
	    }
	
	    for (var i = 0, len = modelUtil.TEXT_STYLE_OPTIONS.length; i < len; i++) {
	      var textPropName = modelUtil.TEXT_STYLE_OPTIONS[i];
	
	      if (textStyle.hasOwnProperty(textPropName)) {
	        labelOptSingle[textPropName] = textStyle[textPropName];
	      }
	    }
	  }
	}
	
	function compatEC3CommonStyles(opt) {
	  if (opt) {
	    removeEC3NormalStatus(opt);
	    compatTextStyle(opt, 'label');
	    opt.emphasis && compatTextStyle(opt.emphasis, 'label');
	  }
	}
	
	function processSeries(seriesOpt) {
	  if (!isObject(seriesOpt)) {
	    return;
	  }
	
	  compatEC2ItemStyle(seriesOpt);
	  removeEC3NormalStatus(seriesOpt);
	  compatTextStyle(seriesOpt, 'label');
	  compatTextStyle(seriesOpt, 'upperLabel');
	  compatTextStyle(seriesOpt, 'edgeLabel');
	
	  if (seriesOpt.emphasis) {
	    compatTextStyle(seriesOpt.emphasis, 'label');
	    compatTextStyle(seriesOpt.emphasis, 'upperLabel');
	    compatTextStyle(seriesOpt.emphasis, 'edgeLabel');
	  }
	
	  var markPoint = seriesOpt.markPoint;
	
	  if (markPoint) {
	    compatEC2ItemStyle(markPoint);
	    compatEC3CommonStyles(markPoint);
	  }
	
	  var markLine = seriesOpt.markLine;
	
	  if (markLine) {
	    compatEC2ItemStyle(markLine);
	    compatEC3CommonStyles(markLine);
	  }
	
	  var markArea = seriesOpt.markArea;
	
	  if (markArea) {
	    compatEC3CommonStyles(markArea);
	  }
	
	  var data = seriesOpt.data;
	
	  if (seriesOpt.type === 'graph') {
	    data = data || seriesOpt.nodes;
	    var edgeData = seriesOpt.links || seriesOpt.edges;
	
	    if (edgeData && !zrUtil.isTypedArray(edgeData)) {
	      for (var i = 0; i < edgeData.length; i++) {
	        compatEC3CommonStyles(edgeData[i]);
	      }
	    }
	
	    zrUtil.each(seriesOpt.categories, function (opt) {
	      removeEC3NormalStatus(opt);
	    });
	  }
	
	  if (data && !zrUtil.isTypedArray(data)) {
	    for (var i = 0; i < data.length; i++) {
	      compatEC3CommonStyles(data[i]);
	    }
	  }
	
	  markPoint = seriesOpt.markPoint;
	
	  if (markPoint && markPoint.data) {
	    var mpData = markPoint.data;
	
	    for (var i = 0; i < mpData.length; i++) {
	      compatEC3CommonStyles(mpData[i]);
	    }
	  }
	
	  markLine = seriesOpt.markLine;
	
	  if (markLine && markLine.data) {
	    var mlData = markLine.data;
	
	    for (var i = 0; i < mlData.length; i++) {
	      if (zrUtil.isArray(mlData[i])) {
	        compatEC3CommonStyles(mlData[i][0]);
	        compatEC3CommonStyles(mlData[i][1]);
	      } else {
	        compatEC3CommonStyles(mlData[i]);
	      }
	    }
	  }
	
	  if (seriesOpt.type === 'gauge') {
	    compatTextStyle(seriesOpt, 'axisLabel');
	    compatTextStyle(seriesOpt, 'title');
	    compatTextStyle(seriesOpt, 'detail');
	  } else if (seriesOpt.type === 'treemap') {
	    convertNormalEmphasis(seriesOpt.breadcrumb, 'itemStyle');
	    zrUtil.each(seriesOpt.levels, function (opt) {
	      removeEC3NormalStatus(opt);
	    });
	  } else if (seriesOpt.type === 'tree') {
	    removeEC3NormalStatus(seriesOpt.leaves);
	  }
	}
	
	function toArr(o) {
	  return zrUtil.isArray(o) ? o : o ? [o] : [];
	}
	
	function toObj(o) {
	  return (zrUtil.isArray(o) ? o[0] : o) || {};
	}
	
	function globalCompatStyle(option, isTheme) {
	  each(toArr(option.series), function (seriesOpt) {
	    isObject(seriesOpt) && processSeries(seriesOpt);
	  });
	  var axes = ['xAxis', 'yAxis', 'radiusAxis', 'angleAxis', 'singleAxis', 'parallelAxis', 'radar'];
	  isTheme && axes.push('valueAxis', 'categoryAxis', 'logAxis', 'timeAxis');
	  each(axes, function (axisName) {
	    each(toArr(option[axisName]), function (axisOpt) {
	      if (axisOpt) {
	        compatTextStyle(axisOpt, 'axisLabel');
	        compatTextStyle(axisOpt.axisPointer, 'label');
	      }
	    });
	  });
	  each(toArr(option.parallel), function (parallelOpt) {
	    var parallelAxisDefault = parallelOpt && parallelOpt.parallelAxisDefault;
	    compatTextStyle(parallelAxisDefault, 'axisLabel');
	    compatTextStyle(parallelAxisDefault && parallelAxisDefault.axisPointer, 'label');
	  });
	  each(toArr(option.calendar), function (calendarOpt) {
	    convertNormalEmphasis(calendarOpt, 'itemStyle');
	    compatTextStyle(calendarOpt, 'dayLabel');
	    compatTextStyle(calendarOpt, 'monthLabel');
	    compatTextStyle(calendarOpt, 'yearLabel');
	  });
	  each(toArr(option.radar), function (radarOpt) {
	    compatTextStyle(radarOpt, 'name');
	
	    if (radarOpt.name && radarOpt.axisName == null) {
	      radarOpt.axisName = radarOpt.name;
	      delete radarOpt.name;
	
	      if (false) {
	        log_1.deprecateLog('name property in radar component has been changed to axisName');
	      }
	    }
	
	    if (radarOpt.nameGap != null && radarOpt.axisNameGap == null) {
	      radarOpt.axisNameGap = radarOpt.nameGap;
	      delete radarOpt.nameGap;
	
	      if (false) {
	        log_1.deprecateLog('nameGap property in radar component has been changed to axisNameGap');
	      }
	    }
	  });
	  each(toArr(option.geo), function (geoOpt) {
	    if (isObject(geoOpt)) {
	      compatEC3CommonStyles(geoOpt);
	      each(toArr(geoOpt.regions), function (regionObj) {
	        compatEC3CommonStyles(regionObj);
	      });
	    }
	  });
	  each(toArr(option.timeline), function (timelineOpt) {
	    compatEC3CommonStyles(timelineOpt);
	    convertNormalEmphasis(timelineOpt, 'label');
	    convertNormalEmphasis(timelineOpt, 'itemStyle');
	    convertNormalEmphasis(timelineOpt, 'controlStyle', true);
	    var data = timelineOpt.data;
	    zrUtil.isArray(data) && zrUtil.each(data, function (item) {
	      if (zrUtil.isObject(item)) {
	        convertNormalEmphasis(item, 'label');
	        convertNormalEmphasis(item, 'itemStyle');
	      }
	    });
	  });
	  each(toArr(option.toolbox), function (toolboxOpt) {
	    convertNormalEmphasis(toolboxOpt, 'iconStyle');
	    each(toolboxOpt.feature, function (featureOpt) {
	      convertNormalEmphasis(featureOpt, 'iconStyle');
	    });
	  });
	  compatTextStyle(toObj(option.axisPointer), 'label');
	  compatTextStyle(toObj(option.tooltip).axisPointer, 'label');
	}
	
	exports["default"] = globalCompatStyle;

/***/ },
/* 366 */
/***/ function(module, exports, __webpack_require__) {

	
	/*
	* Licensed to the Apache Software Foundation (ASF) under one
	* or more contributor license agreements.  See the NOTICE file
	* distributed with this work for additional information
	* regarding copyright ownership.  The ASF licenses this file
	* to you under the Apache License, Version 2.0 (the
	* "License"); you may not use this file except in compliance
	* with the License.  You may obtain a copy of the License at
	*
	*   http://www.apache.org/licenses/LICENSE-2.0
	*
	* Unless required by applicable law or agreed to in writing,
	* software distributed under the License is distributed on an
	* "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
	* KIND, either express or implied.  See the License for the
	* specific language governing permissions and limitations
	* under the License.
	*/
	
	
	
	/**
	 * AUTO-GENERATED FILE. DO NOT MODIFY.
	 */
	
	"use strict";
	
	exports.__esModule = true;
	
	var util_1 = __webpack_require__(1);
	
	function dataStack(ecModel) {
	  var stackInfoMap = util_1.createHashMap();
	  ecModel.eachSeries(function (seriesModel) {
	    var stack = seriesModel.get('stack');
	
	    if (stack) {
	      var stackInfoList = stackInfoMap.get(stack) || stackInfoMap.set(stack, []);
	      var data = seriesModel.getData();
	      var stackInfo = {
	        stackResultDimension: data.getCalculationInfo('stackResultDimension'),
	        stackedOverDimension: data.getCalculationInfo('stackedOverDimension'),
	        stackedDimension: data.getCalculationInfo('stackedDimension'),
	        stackedByDimension: data.getCalculationInfo('stackedByDimension'),
	        isStackedByIndex: data.getCalculationInfo('isStackedByIndex'),
	        data: data,
	        seriesModel: seriesModel
	      };
	
	      if (!stackInfo.stackedDimension || !(stackInfo.isStackedByIndex || stackInfo.stackedByDimension)) {
	        return;
	      }
	
	      stackInfoList.length && data.setCalculationInfo('stackedOnSeries', stackInfoList[stackInfoList.length - 1].seriesModel);
	      stackInfoList.push(stackInfo);
	    }
	  });
	  stackInfoMap.each(calculateStack);
	}
	
	exports["default"] = dataStack;
	
	function calculateStack(stackInfoList) {
	  util_1.each(stackInfoList, function (targetStackInfo, idxInStack) {
	    var resultVal = [];
	    var resultNaN = [NaN, NaN];
	    var dims = [targetStackInfo.stackResultDimension, targetStackInfo.stackedOverDimension];
	    var targetData = targetStackInfo.data;
	    var isStackedByIndex = targetStackInfo.isStackedByIndex;
	    var newData = targetData.map(dims, function (v0, v1, dataIndex) {
	      var sum = targetData.get(targetStackInfo.stackedDimension, dataIndex);
	
	      if (isNaN(sum)) {
	        return resultNaN;
	      }
	
	      var byValue;
	      var stackedDataRawIndex;
	
	      if (isStackedByIndex) {
	        stackedDataRawIndex = targetData.getRawIndex(dataIndex);
	      } else {
	        byValue = targetData.get(targetStackInfo.stackedByDimension, dataIndex);
	      }
	
	      var stackedOver = NaN;
	
	      for (var j = idxInStack - 1; j >= 0; j--) {
	        var stackInfo = stackInfoList[j];
	
	        if (!isStackedByIndex) {
	          stackedDataRawIndex = stackInfo.data.rawIndexOf(stackInfo.stackedByDimension, byValue);
	        }
	
	        if (stackedDataRawIndex >= 0) {
	          var val = stackInfo.data.getByRawIndex(stackInfo.stackResultDimension, stackedDataRawIndex);
	
	          if (sum >= 0 && val > 0 || sum <= 0 && val < 0) {
	            sum += val;
	            stackedOver = val;
	            break;
	          }
	        }
	      }
	
	      resultVal[0] = sum;
	      resultVal[1] = stackedOver;
	      return resultVal;
	    });
	    targetData.hostModel.setData(newData);
	    targetStackInfo.data = newData;
	  });
	}

/***/ },
/* 367 */
/***/ function(module, exports, __webpack_require__) {

	
	/*
	* Licensed to the Apache Software Foundation (ASF) under one
	* or more contributor license agreements.  See the NOTICE file
	* distributed with this work for additional information
	* regarding copyright ownership.  The ASF licenses this file
	* to you under the Apache License, Version 2.0 (the
	* "License"); you may not use this file except in compliance
	* with the License.  You may obtain a copy of the License at
	*
	*   http://www.apache.org/licenses/LICENSE-2.0
	*
	* Unless required by applicable law or agreed to in writing,
	* software distributed under the License is distributed on an
	* "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
	* KIND, either express or implied.  See the License for the
	* specific language governing permissions and limitations
	* under the License.
	*/
	
	
	
	/**
	 * AUTO-GENERATED FILE. DO NOT MODIFY.
	 */
	
	"use strict";
	
	exports.__esModule = true;
	
	var tslib_1 = __webpack_require__(3);
	
	var zrUtil = __webpack_require__(1);
	
	var Scale_1 = __webpack_require__(55);
	
	var numberUtil = __webpack_require__(9);
	
	var scaleHelper = __webpack_require__(70);
	
	var Interval_1 = __webpack_require__(92);
	
	var scaleProto = Scale_1["default"].prototype;
	var intervalScaleProto = Interval_1["default"].prototype;
	var getPrecisionSafe = numberUtil.getPrecisionSafe;
	var roundingErrorFix = numberUtil.round;
	var mathFloor = Math.floor;
	var mathCeil = Math.ceil;
	var mathPow = Math.pow;
	var mathLog = Math.log;
	
	var LogScale = function (_super) {
	  tslib_1.__extends(LogScale, _super);
	
	  function LogScale() {
	    var _this = _super !== null && _super.apply(this, arguments) || this;
	
	    _this.type = 'log';
	    _this.base = 10;
	    _this._originalScale = new Interval_1["default"]();
	    _this._interval = 0;
	    return _this;
	  }
	
	  LogScale.prototype.getTicks = function (expandToNicedExtent) {
	    var originalScale = this._originalScale;
	    var extent = this._extent;
	    var originalExtent = originalScale.getExtent();
	    var ticks = intervalScaleProto.getTicks.call(this, expandToNicedExtent);
	    return zrUtil.map(ticks, function (tick) {
	      var val = tick.value;
	      var powVal = numberUtil.round(mathPow(this.base, val));
	      powVal = val === extent[0] && this._fixMin ? fixRoundingError(powVal, originalExtent[0]) : powVal;
	      powVal = val === extent[1] && this._fixMax ? fixRoundingError(powVal, originalExtent[1]) : powVal;
	      return {
	        value: powVal
	      };
	    }, this);
	  };
	
	  LogScale.prototype.setExtent = function (start, end) {
	    var base = this.base;
	    start = mathLog(start) / mathLog(base);
	    end = mathLog(end) / mathLog(base);
	    intervalScaleProto.setExtent.call(this, start, end);
	  };
	
	  LogScale.prototype.getExtent = function () {
	    var base = this.base;
	    var extent = scaleProto.getExtent.call(this);
	    extent[0] = mathPow(base, extent[0]);
	    extent[1] = mathPow(base, extent[1]);
	    var originalScale = this._originalScale;
	    var originalExtent = originalScale.getExtent();
	    this._fixMin && (extent[0] = fixRoundingError(extent[0], originalExtent[0]));
	    this._fixMax && (extent[1] = fixRoundingError(extent[1], originalExtent[1]));
	    return extent;
	  };
	
	  LogScale.prototype.unionExtent = function (extent) {
	    this._originalScale.unionExtent(extent);
	
	    var base = this.base;
	    extent[0] = mathLog(extent[0]) / mathLog(base);
	    extent[1] = mathLog(extent[1]) / mathLog(base);
	    scaleProto.unionExtent.call(this, extent);
	  };
	
	  LogScale.prototype.unionExtentFromData = function (data, dim) {
	    this.unionExtent(data.getApproximateExtent(dim));
	  };
	
	  LogScale.prototype.niceTicks = function (approxTickNum) {
	    approxTickNum = approxTickNum || 10;
	    var extent = this._extent;
	    var span = extent[1] - extent[0];
	
	    if (span === Infinity || span <= 0) {
	      return;
	    }
	
	    var interval = numberUtil.quantity(span);
	    var err = approxTickNum / span * interval;
	
	    if (err <= 0.5) {
	      interval *= 10;
	    }
	
	    while (!isNaN(interval) && Math.abs(interval) < 1 && Math.abs(interval) > 0) {
	      interval *= 10;
	    }
	
	    var niceExtent = [numberUtil.round(mathCeil(extent[0] / interval) * interval), numberUtil.round(mathFloor(extent[1] / interval) * interval)];
	    this._interval = interval;
	    this._niceExtent = niceExtent;
	  };
	
	  LogScale.prototype.niceExtent = function (opt) {
	    intervalScaleProto.niceExtent.call(this, opt);
	    this._fixMin = opt.fixMin;
	    this._fixMax = opt.fixMax;
	  };
	
	  LogScale.prototype.parse = function (val) {
	    return val;
	  };
	
	  LogScale.prototype.contain = function (val) {
	    val = mathLog(val) / mathLog(this.base);
	    return scaleHelper.contain(val, this._extent);
	  };
	
	  LogScale.prototype.normalize = function (val) {
	    val = mathLog(val) / mathLog(this.base);
	    return scaleHelper.normalize(val, this._extent);
	  };
	
	  LogScale.prototype.scale = function (val) {
	    val = scaleHelper.scale(val, this._extent);
	    return mathPow(this.base, val);
	  };
	
	  LogScale.type = 'log';
	  return LogScale;
	}(Scale_1["default"]);
	
	var proto = LogScale.prototype;
	proto.getMinorTicks = intervalScaleProto.getMinorTicks;
	proto.getLabel = intervalScaleProto.getLabel;
	
	function fixRoundingError(val, originalVal) {
	  return roundingErrorFix(val, getPrecisionSafe(originalVal));
	}
	
	Scale_1["default"].registerClass(LogScale);
	exports["default"] = LogScale;

/***/ },
/* 368 */
/***/ function(module, exports, __webpack_require__) {

	
	/*
	* Licensed to the Apache Software Foundation (ASF) under one
	* or more contributor license agreements.  See the NOTICE file
	* distributed with this work for additional information
	* regarding copyright ownership.  The ASF licenses this file
	* to you under the Apache License, Version 2.0 (the
	* "License"); you may not use this file except in compliance
	* with the License.  You may obtain a copy of the License at
	*
	*   http://www.apache.org/licenses/LICENSE-2.0
	*
	* Unless required by applicable law or agreed to in writing,
	* software distributed under the License is distributed on an
	* "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
	* KIND, either express or implied.  See the License for the
	* specific language governing permissions and limitations
	* under the License.
	*/
	
	
	
	/**
	 * AUTO-GENERATED FILE. DO NOT MODIFY.
	 */
	
	"use strict";
	
	exports.__esModule = true;
	
	var tslib_1 = __webpack_require__(3);
	
	var Scale_1 = __webpack_require__(55);
	
	var OrdinalMeta_1 = __webpack_require__(145);
	
	var scaleHelper = __webpack_require__(70);
	
	var util_1 = __webpack_require__(1);
	
	var OrdinalScale = function (_super) {
	  tslib_1.__extends(OrdinalScale, _super);
	
	  function OrdinalScale(setting) {
	    var _this = _super.call(this, setting) || this;
	
	    _this.type = 'ordinal';
	
	    var ordinalMeta = _this.getSetting('ordinalMeta');
	
	    if (!ordinalMeta) {
	      ordinalMeta = new OrdinalMeta_1["default"]({});
	    }
	
	    if (util_1.isArray(ordinalMeta)) {
	      ordinalMeta = new OrdinalMeta_1["default"]({
	        categories: util_1.map(ordinalMeta, function (item) {
	          return util_1.isObject(item) ? item.value : item;
	        })
	      });
	    }
	
	    _this._ordinalMeta = ordinalMeta;
	    _this._categorySortInfo = [];
	    _this._extent = _this.getSetting('extent') || [0, ordinalMeta.categories.length - 1];
	    return _this;
	  }
	
	  OrdinalScale.prototype.parse = function (val) {
	    return typeof val === 'string' ? this._ordinalMeta.getOrdinal(val) : Math.round(val);
	  };
	
	  OrdinalScale.prototype.contain = function (rank) {
	    rank = this.parse(rank);
	    return scaleHelper.contain(rank, this._extent) && this._ordinalMeta.categories[rank] != null;
	  };
	
	  OrdinalScale.prototype.normalize = function (val) {
	    val = this.getCategoryIndex(this.parse(val));
	    return scaleHelper.normalize(val, this._extent);
	  };
	
	  OrdinalScale.prototype.scale = function (val) {
	    val = this.getCategoryIndex(val);
	    return Math.round(scaleHelper.scale(val, this._extent));
	  };
	
	  OrdinalScale.prototype.getTicks = function () {
	    var ticks = [];
	    var extent = this._extent;
	    var rank = extent[0];
	
	    while (rank <= extent[1]) {
	      ticks.push({
	        value: this.getCategoryIndex(rank)
	      });
	      rank++;
	    }
	
	    return ticks;
	  };
	
	  OrdinalScale.prototype.getMinorTicks = function (splitNumber) {
	    return;
	  };
	
	  OrdinalScale.prototype.setCategorySortInfo = function (info) {
	    this._categorySortInfo = info;
	  };
	
	  OrdinalScale.prototype.getCategorySortInfo = function () {
	    return this._categorySortInfo;
	  };
	
	  OrdinalScale.prototype.getCategoryIndex = function (n) {
	    if (this._categorySortInfo.length) {
	      return this._categorySortInfo[n].beforeSortIndex;
	    } else {
	      return n;
	    }
	  };
	
	  OrdinalScale.prototype.getRawIndex = function (displayIndex) {
	    if (this._categorySortInfo.length) {
	      return this._categorySortInfo[displayIndex].ordinalNumber;
	    } else {
	      return displayIndex;
	    }
	  };
	
	  OrdinalScale.prototype.getLabel = function (tick) {
	    if (!this.isBlank()) {
	      var rawIndex = this.getRawIndex(tick.value);
	      var cateogry = this._ordinalMeta.categories[rawIndex];
	      return cateogry == null ? '' : cateogry + '';
	    }
	  };
	
	  OrdinalScale.prototype.count = function () {
	    return this._extent[1] - this._extent[0] + 1;
	  };
	
	  OrdinalScale.prototype.unionExtentFromData = function (data, dim) {
	    this.unionExtent(data.getApproximateExtent(dim));
	  };
	
	  OrdinalScale.prototype.isInExtentRange = function (value) {
	    value = this.getCategoryIndex(value);
	    return this._extent[0] <= value && this._extent[1] >= value;
	  };
	
	  OrdinalScale.prototype.getOrdinalMeta = function () {
	    return this._ordinalMeta;
	  };
	
	  OrdinalScale.prototype.niceTicks = function () {};
	
	  OrdinalScale.prototype.niceExtent = function () {};
	
	  OrdinalScale.type = 'ordinal';
	  return OrdinalScale;
	}(Scale_1["default"]);
	
	Scale_1["default"].registerClass(OrdinalScale);
	exports["default"] = OrdinalScale;

/***/ },
/* 369 */
/***/ function(module, exports, __webpack_require__) {

	
	/*
	* Licensed to the Apache Software Foundation (ASF) under one
	* or more contributor license agreements.  See the NOTICE file
	* distributed with this work for additional information
	* regarding copyright ownership.  The ASF licenses this file
	* to you under the Apache License, Version 2.0 (the
	* "License"); you may not use this file except in compliance
	* with the License.  You may obtain a copy of the License at
	*
	*   http://www.apache.org/licenses/LICENSE-2.0
	*
	* Unless required by applicable law or agreed to in writing,
	* software distributed under the License is distributed on an
	* "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
	* KIND, either express or implied.  See the License for the
	* specific language governing permissions and limitations
	* under the License.
	*/
	
	
	
	/**
	 * AUTO-GENERATED FILE. DO NOT MODIFY.
	 */
	
	"use strict";
	
	exports.__esModule = true;
	
	var tslib_1 = __webpack_require__(3);
	
	var numberUtil = __webpack_require__(9);
	
	var time_1 = __webpack_require__(94);
	
	var scaleHelper = __webpack_require__(70);
	
	var Interval_1 = __webpack_require__(92);
	
	var Scale_1 = __webpack_require__(55);
	
	var log_1 = __webpack_require__(12);
	
	var util_1 = __webpack_require__(1);
	
	var bisect = function (a, x, lo, hi) {
	  while (lo < hi) {
	    var mid = lo + hi >>> 1;
	
	    if (a[mid][1] < x) {
	      lo = mid + 1;
	    } else {
	      hi = mid;
	    }
	  }
	
	  return lo;
	};
	
	var TimeScale = function (_super) {
	  tslib_1.__extends(TimeScale, _super);
	
	  function TimeScale(settings) {
	    var _this = _super.call(this, settings) || this;
	
	    _this.type = 'time';
	    return _this;
	  }
	
	  TimeScale.prototype.getLabel = function (tick) {
	    var useUTC = this.getSetting('useUTC');
	    return time_1.format(tick.value, time_1.fullLeveledFormatter[time_1.getDefaultFormatPrecisionOfInterval(time_1.getPrimaryTimeUnit(this._minLevelUnit))] || time_1.fullLeveledFormatter.second, useUTC, this.getSetting('locale'));
	  };
	
	  TimeScale.prototype.getFormattedLabel = function (tick, idx, labelFormatter) {
	    var isUTC = this.getSetting('useUTC');
	    var lang = this.getSetting('locale');
	    return time_1.leveledFormat(tick, idx, labelFormatter, lang, isUTC);
	  };
	
	  TimeScale.prototype.getTicks = function (expandToNicedExtent) {
	    var interval = this._interval;
	    var extent = this._extent;
	    var ticks = [];
	
	    if (!interval) {
	      return ticks;
	    }
	
	    ticks.push({
	      value: extent[0],
	      level: 0
	    });
	    var useUTC = this.getSetting('useUTC');
	    var innerTicks = getIntervalTicks(this._minLevelUnit, this._approxInterval, useUTC, extent);
	    ticks = ticks.concat(innerTicks);
	    ticks.push({
	      value: extent[1],
	      level: 0
	    });
	    return ticks;
	  };
	
	  TimeScale.prototype.niceExtent = function (opt) {
	    var extent = this._extent;
	
	    if (extent[0] === extent[1]) {
	      extent[0] -= time_1.ONE_DAY;
	      extent[1] += time_1.ONE_DAY;
	    }
	
	    if (extent[1] === -Infinity && extent[0] === Infinity) {
	      var d = new Date();
	      extent[1] = +new Date(d.getFullYear(), d.getMonth(), d.getDate());
	      extent[0] = extent[1] - time_1.ONE_DAY;
	    }
	
	    this.niceTicks(opt.splitNumber, opt.minInterval, opt.maxInterval);
	  };
	
	  TimeScale.prototype.niceTicks = function (approxTickNum, minInterval, maxInterval) {
	    approxTickNum = approxTickNum || 10;
	    var extent = this._extent;
	    var span = extent[1] - extent[0];
	    this._approxInterval = span / approxTickNum;
	
	    if (minInterval != null && this._approxInterval < minInterval) {
	      this._approxInterval = minInterval;
	    }
	
	    if (maxInterval != null && this._approxInterval > maxInterval) {
	      this._approxInterval = maxInterval;
	    }
	
	    var scaleIntervalsLen = scaleIntervals.length;
	    var idx = Math.min(bisect(scaleIntervals, this._approxInterval, 0, scaleIntervalsLen), scaleIntervalsLen - 1);
	    this._interval = scaleIntervals[idx][1];
	    this._minLevelUnit = scaleIntervals[Math.max(idx - 1, 0)][0];
	  };
	
	  TimeScale.prototype.parse = function (val) {
	    return typeof val === 'number' ? val : +numberUtil.parseDate(val);
	  };
	
	  TimeScale.prototype.contain = function (val) {
	    return scaleHelper.contain(this.parse(val), this._extent);
	  };
	
	  TimeScale.prototype.normalize = function (val) {
	    return scaleHelper.normalize(this.parse(val), this._extent);
	  };
	
	  TimeScale.prototype.scale = function (val) {
	    return scaleHelper.scale(val, this._extent);
	  };
	
	  TimeScale.type = 'time';
	  return TimeScale;
	}(Interval_1["default"]);
	
	var scaleIntervals = [['second', time_1.ONE_SECOND], ['minute', time_1.ONE_MINUTE], ['hour', time_1.ONE_HOUR], ['quarter-day', time_1.ONE_HOUR * 6], ['half-day', time_1.ONE_HOUR * 12], ['day', time_1.ONE_DAY * 1.2], ['half-week', time_1.ONE_DAY * 3.5], ['week', time_1.ONE_DAY * 7], ['month', time_1.ONE_DAY * 31], ['quarter', time_1.ONE_DAY * 95], ['half-year', time_1.ONE_YEAR / 2], ['year', time_1.ONE_YEAR]];
	
	function isUnitValueSame(unit, valueA, valueB, isUTC) {
	  var dateA = numberUtil.parseDate(valueA);
	  var dateB = numberUtil.parseDate(valueB);
	
	  var isSame = function (unit) {
	    return time_1.getUnitValue(dateA, unit, isUTC) === time_1.getUnitValue(dateB, unit, isUTC);
	  };
	
	  var isSameYear = function () {
	    return isSame('year');
	  };
	
	  var isSameMonth = function () {
	    return isSameYear() && isSame('month');
	  };
	
	  var isSameDay = function () {
	    return isSameMonth() && isSame('day');
	  };
	
	  var isSameHour = function () {
	    return isSameDay() && isSame('hour');
	  };
	
	  var isSameMinute = function () {
	    return isSameHour() && isSame('minute');
	  };
	
	  var isSameSecond = function () {
	    return isSameMinute() && isSame('second');
	  };
	
	  var isSameMilliSecond = function () {
	    return isSameSecond() && isSame('millisecond');
	  };
	
	  switch (unit) {
	    case 'year':
	      return isSameYear();
	
	    case 'month':
	      return isSameMonth();
	
	    case 'day':
	      return isSameDay();
	
	    case 'hour':
	      return isSameHour();
	
	    case 'minute':
	      return isSameMinute();
	
	    case 'second':
	      return isSameSecond();
	
	    case 'millisecond':
	      return isSameMilliSecond();
	  }
	}
	
	function getDateInterval(approxInterval, daysInMonth) {
	  approxInterval /= time_1.ONE_DAY;
	  return approxInterval > 16 ? 16 : approxInterval > 7.5 ? 7 : approxInterval > 3.5 ? 4 : approxInterval > 1.5 ? 2 : 1;
	}
	
	function getMonthInterval(approxInterval) {
	  var APPROX_ONE_MONTH = 30 * time_1.ONE_DAY;
	  approxInterval /= APPROX_ONE_MONTH;
	  return approxInterval > 6 ? 6 : approxInterval > 3 ? 3 : approxInterval > 2 ? 2 : 1;
	}
	
	function getHourInterval(approxInterval) {
	  approxInterval /= time_1.ONE_HOUR;
	  return approxInterval > 12 ? 12 : approxInterval > 6 ? 6 : approxInterval > 3.5 ? 4 : approxInterval > 2 ? 2 : 1;
	}
	
	function getMinutesAndSecondsInterval(approxInterval, isMinutes) {
	  approxInterval /= isMinutes ? time_1.ONE_MINUTE : time_1.ONE_SECOND;
	  return approxInterval > 30 ? 30 : approxInterval > 20 ? 20 : approxInterval > 15 ? 15 : approxInterval > 10 ? 10 : approxInterval > 5 ? 5 : approxInterval > 2 ? 2 : 1;
	}
	
	function getMillisecondsInterval(approxInterval) {
	  return numberUtil.nice(approxInterval, true);
	}
	
	function getFirstTimestampOfUnit(date, unitName, isUTC) {
	  var outDate = new Date(date);
	
	  switch (time_1.getPrimaryTimeUnit(unitName)) {
	    case 'year':
	    case 'month':
	      outDate[time_1.monthSetterName(isUTC)](0);
	
	    case 'day':
	      outDate[time_1.dateSetterName(isUTC)](1);
	
	    case 'hour':
	      outDate[time_1.hoursSetterName(isUTC)](0);
	
	    case 'minute':
	      outDate[time_1.minutesSetterName(isUTC)](0);
	
	    case 'second':
	      outDate[time_1.secondsSetterName(isUTC)](0);
	      outDate[time_1.millisecondsSetterName(isUTC)](0);
	  }
	
	  return outDate.getTime();
	}
	
	function getIntervalTicks(bottomUnitName, approxInterval, isUTC, extent) {
	  var safeLimit = 10000;
	  var unitNames = time_1.timeUnits;
	  var iter = 0;
	
	  function addTicksInSpan(interval, minTimestamp, maxTimestamp, getMethodName, setMethodName, isDate, out) {
	    var date = new Date(minTimestamp);
	    var dateTime = minTimestamp;
	    var d = date[getMethodName]();
	
	    while (dateTime < maxTimestamp && dateTime <= extent[1]) {
	      out.push({
	        value: dateTime
	      });
	      d += interval;
	      date[setMethodName](d);
	      dateTime = date.getTime();
	    }
	
	    out.push({
	      value: dateTime,
	      notAdd: true
	    });
	  }
	
	  function addLevelTicks(unitName, lastLevelTicks, levelTicks) {
	    var newAddedTicks = [];
	    var isFirstLevel = !lastLevelTicks.length;
	
	    if (isUnitValueSame(time_1.getPrimaryTimeUnit(unitName), extent[0], extent[1], isUTC)) {
	      return;
	    }
	
	    if (isFirstLevel) {
	      lastLevelTicks = [{
	        value: getFirstTimestampOfUnit(new Date(extent[0]), unitName, isUTC)
	      }, {
	        value: extent[1]
	      }];
	    }
	
	    for (var i = 0; i < lastLevelTicks.length - 1; i++) {
	      var startTick = lastLevelTicks[i].value;
	      var endTick = lastLevelTicks[i + 1].value;
	
	      if (startTick === endTick) {
	        continue;
	      }
	
	      var interval = void 0;
	      var getterName = void 0;
	      var setterName = void 0;
	      var isDate = false;
	
	      switch (unitName) {
	        case 'year':
	          interval = Math.max(1, Math.round(approxInterval / time_1.ONE_DAY / 365));
	          getterName = time_1.fullYearGetterName(isUTC);
	          setterName = time_1.fullYearSetterName(isUTC);
	          break;
	
	        case 'half-year':
	        case 'quarter':
	        case 'month':
	          interval = getMonthInterval(approxInterval);
	          getterName = time_1.monthGetterName(isUTC);
	          setterName = time_1.monthSetterName(isUTC);
	          break;
	
	        case 'week':
	        case 'half-week':
	        case 'day':
	          interval = getDateInterval(approxInterval, 31);
	          getterName = time_1.dateGetterName(isUTC);
	          setterName = time_1.dateSetterName(isUTC);
	          isDate = true;
	          break;
	
	        case 'half-day':
	        case 'quarter-day':
	        case 'hour':
	          interval = getHourInterval(approxInterval);
	          getterName = time_1.hoursGetterName(isUTC);
	          setterName = time_1.hoursSetterName(isUTC);
	          break;
	
	        case 'minute':
	          interval = getMinutesAndSecondsInterval(approxInterval, true);
	          getterName = time_1.minutesGetterName(isUTC);
	          setterName = time_1.minutesSetterName(isUTC);
	          break;
	
	        case 'second':
	          interval = getMinutesAndSecondsInterval(approxInterval, false);
	          getterName = time_1.secondsGetterName(isUTC);
	          setterName = time_1.secondsSetterName(isUTC);
	          break;
	
	        case 'millisecond':
	          interval = getMillisecondsInterval(approxInterval);
	          getterName = time_1.millisecondsGetterName(isUTC);
	          setterName = time_1.millisecondsSetterName(isUTC);
	          break;
	      }
	
	      addTicksInSpan(interval, startTick, endTick, getterName, setterName, isDate, newAddedTicks);
	
	      if (unitName === 'year' && levelTicks.length > 1 && i === 0) {
	        levelTicks.unshift({
	          value: levelTicks[0].value - interval
	        });
	      }
	    }
	
	    for (var i = 0; i < newAddedTicks.length; i++) {
	      levelTicks.push(newAddedTicks[i]);
	    }
	
	    return newAddedTicks;
	  }
	
	  var levelsTicks = [];
	  var currentLevelTicks = [];
	  var tickCount = 0;
	  var lastLevelTickCount = 0;
	
	  for (var i = 0; i < unitNames.length && iter++ < safeLimit; ++i) {
	    var primaryTimeUnit = time_1.getPrimaryTimeUnit(unitNames[i]);
	
	    if (!time_1.isPrimaryTimeUnit(unitNames[i])) {
	      continue;
	    }
	
	    addLevelTicks(unitNames[i], levelsTicks[levelsTicks.length - 1] || [], currentLevelTicks);
	    var nextPrimaryTimeUnit = unitNames[i + 1] ? time_1.getPrimaryTimeUnit(unitNames[i + 1]) : null;
	
	    if (primaryTimeUnit !== nextPrimaryTimeUnit) {
	      if (currentLevelTicks.length) {
	        lastLevelTickCount = tickCount;
	        currentLevelTicks.sort(function (a, b) {
	          return a.value - b.value;
	        });
	        var levelTicksRemoveDuplicated = [];
	
	        for (var i_1 = 0; i_1 < currentLevelTicks.length; ++i_1) {
	          var tickValue = currentLevelTicks[i_1].value;
	
	          if (i_1 === 0 || currentLevelTicks[i_1 - 1].value !== tickValue) {
	            levelTicksRemoveDuplicated.push(currentLevelTicks[i_1]);
	
	            if (tickValue >= extent[0] && tickValue <= extent[1]) {
	              tickCount++;
	            }
	          }
	        }
	
	        var targetTickNum = (extent[1] - extent[0]) / approxInterval;
	
	        if (tickCount > targetTickNum * 1.5 && lastLevelTickCount > targetTickNum / 1.5) {
	          break;
	        }
	
	        levelsTicks.push(levelTicksRemoveDuplicated);
	
	        if (tickCount > targetTickNum || bottomUnitName === unitNames[i]) {
	          break;
	        }
	      }
	
	      currentLevelTicks = [];
	    }
	  }
	
	  if (false) {
	    if (iter >= safeLimit) {
	      log_1.warn('Exceed safe limit.');
	    }
	  }
	
	  var levelsTicksInExtent = util_1.filter(util_1.map(levelsTicks, function (levelTicks) {
	    return util_1.filter(levelTicks, function (tick) {
	      return tick.value >= extent[0] && tick.value <= extent[1] && !tick.notAdd;
	    });
	  }), function (levelTicks) {
	    return levelTicks.length > 0;
	  });
	  var ticks = [];
	  var maxLevel = levelsTicksInExtent.length - 1;
	
	  for (var i = 0; i < levelsTicksInExtent.length; ++i) {
	    var levelTicks = levelsTicksInExtent[i];
	
	    for (var k = 0; k < levelTicks.length; ++k) {
	      ticks.push({
	        value: levelTicks[k].value,
	        level: maxLevel - i
	      });
	    }
	  }
	
	  ticks.sort(function (a, b) {
	    return a.value - b.value;
	  });
	  var result = [];
	
	  for (var i = 0; i < ticks.length; ++i) {
	    if (i === 0 || ticks[i].value !== ticks[i - 1].value) {
	      result.push(ticks[i]);
	    }
	  }
	
	  return result;
	}
	
	Scale_1["default"].registerClass(TimeScale);
	exports["default"] = TimeScale;

/***/ },
/* 370 */
/***/ function(module, exports, __webpack_require__) {

	
	/*
	* Licensed to the Apache Software Foundation (ASF) under one
	* or more contributor license agreements.  See the NOTICE file
	* distributed with this work for additional information
	* regarding copyright ownership.  The ASF licenses this file
	* to you under the Apache License, Version 2.0 (the
	* "License"); you may not use this file except in compliance
	* with the License.  You may obtain a copy of the License at
	*
	*   http://www.apache.org/licenses/LICENSE-2.0
	*
	* Unless required by applicable law or agreed to in writing,
	* software distributed under the License is distributed on an
	* "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
	* KIND, either express or implied.  See the License for the
	* specific language governing permissions and limitations
	* under the License.
	*/
	
	
	
	/**
	 * AUTO-GENERATED FILE. DO NOT MODIFY.
	 */
	
	"use strict";
	
	exports.__esModule = true;
	
	var util_1 = __webpack_require__(1);
	
	var task_1 = __webpack_require__(93);
	
	var component_1 = __webpack_require__(41);
	
	var Global_1 = __webpack_require__(150);
	
	var ExtensionAPI_1 = __webpack_require__(126);
	
	var model_1 = __webpack_require__(4);
	
	;
	
	var Scheduler = function () {
	  function Scheduler(ecInstance, api, dataProcessorHandlers, visualHandlers) {
	    this._stageTaskMap = util_1.createHashMap();
	    this.ecInstance = ecInstance;
	    this.api = api;
	    dataProcessorHandlers = this._dataProcessorHandlers = dataProcessorHandlers.slice();
	    visualHandlers = this._visualHandlers = visualHandlers.slice();
	    this._allHandlers = dataProcessorHandlers.concat(visualHandlers);
	  }
	
	  Scheduler.prototype.restoreData = function (ecModel, payload) {
	    ecModel.restoreData(payload);
	
	    this._stageTaskMap.each(function (taskRecord) {
	      var overallTask = taskRecord.overallTask;
	      overallTask && overallTask.dirty();
	    });
	  };
	
	  Scheduler.prototype.getPerformArgs = function (task, isBlock) {
	    if (!task.__pipeline) {
	      return;
	    }
	
	    var pipeline = this._pipelineMap.get(task.__pipeline.id);
	
	    var pCtx = pipeline.context;
	    var incremental = !isBlock && pipeline.progressiveEnabled && (!pCtx || pCtx.progressiveRender) && task.__idxInPipeline > pipeline.blockIndex;
	    var step = incremental ? pipeline.step : null;
	    var modDataCount = pCtx && pCtx.modDataCount;
	    var modBy = modDataCount != null ? Math.ceil(modDataCount / step) : null;
	    return {
	      step: step,
	      modBy: modBy,
	      modDataCount: modDataCount
	    };
	  };
	
	  Scheduler.prototype.getPipeline = function (pipelineId) {
	    return this._pipelineMap.get(pipelineId);
	  };
	
	  Scheduler.prototype.updateStreamModes = function (seriesModel, view) {
	    var pipeline = this._pipelineMap.get(seriesModel.uid);
	
	    var data = seriesModel.getData();
	    var dataLen = data.count();
	    var progressiveRender = pipeline.progressiveEnabled && view.incrementalPrepareRender && dataLen >= pipeline.threshold;
	    var large = seriesModel.get('large') && dataLen >= seriesModel.get('largeThreshold');
	    var modDataCount = seriesModel.get('progressiveChunkMode') === 'mod' ? dataLen : null;
	    seriesModel.pipelineContext = pipeline.context = {
	      progressiveRender: progressiveRender,
	      modDataCount: modDataCount,
	      large: large
	    };
	  };
	
	  Scheduler.prototype.restorePipelines = function (ecModel) {
	    var scheduler = this;
	    var pipelineMap = scheduler._pipelineMap = util_1.createHashMap();
	    ecModel.eachSeries(function (seriesModel) {
	      var progressive = seriesModel.getProgressive();
	      var pipelineId = seriesModel.uid;
	      pipelineMap.set(pipelineId, {
	        id: pipelineId,
	        head: null,
	        tail: null,
	        threshold: seriesModel.getProgressiveThreshold(),
	        progressiveEnabled: progressive && !(seriesModel.preventIncremental && seriesModel.preventIncremental()),
	        blockIndex: -1,
	        step: Math.round(progressive || 700),
	        count: 0
	      });
	
	      scheduler._pipe(seriesModel, seriesModel.dataTask);
	    });
	  };
	
	  Scheduler.prototype.prepareStageTasks = function () {
	    var stageTaskMap = this._stageTaskMap;
	    var ecModel = this.api.getModel();
	    var api = this.api;
	    util_1.each(this._allHandlers, function (handler) {
	      var record = stageTaskMap.get(handler.uid) || stageTaskMap.set(handler.uid, {});
	      var errMsg = '';
	
	      if (false) {
	        errMsg = '"reset" and "overallReset" must not be both specified.';
	      }
	
	      util_1.assert(!(handler.reset && handler.overallReset), errMsg);
	      handler.reset && this._createSeriesStageTask(handler, record, ecModel, api);
	      handler.overallReset && this._createOverallStageTask(handler, record, ecModel, api);
	    }, this);
	  };
	
	  Scheduler.prototype.prepareView = function (view, model, ecModel, api) {
	    var renderTask = view.renderTask;
	    var context = renderTask.context;
	    context.model = model;
	    context.ecModel = ecModel;
	    context.api = api;
	    renderTask.__block = !view.incrementalPrepareRender;
	
	    this._pipe(model, renderTask);
	  };
	
	  Scheduler.prototype.performDataProcessorTasks = function (ecModel, payload) {
	    this._performStageTasks(this._dataProcessorHandlers, ecModel, payload, {
	      block: true
	    });
	  };
	
	  Scheduler.prototype.performVisualTasks = function (ecModel, payload, opt) {
	    this._performStageTasks(this._visualHandlers, ecModel, payload, opt);
	  };
	
	  Scheduler.prototype._performStageTasks = function (stageHandlers, ecModel, payload, opt) {
	    opt = opt || {};
	    var unfinished = false;
	    var scheduler = this;
	    util_1.each(stageHandlers, function (stageHandler, idx) {
	      if (opt.visualType && opt.visualType !== stageHandler.visualType) {
	        return;
	      }
	
	      var stageHandlerRecord = scheduler._stageTaskMap.get(stageHandler.uid);
	
	      var seriesTaskMap = stageHandlerRecord.seriesTaskMap;
	      var overallTask = stageHandlerRecord.overallTask;
	
	      if (overallTask) {
	        var overallNeedDirty_1;
	        var agentStubMap = overallTask.agentStubMap;
	        agentStubMap.each(function (stub) {
	          if (needSetDirty(opt, stub)) {
	            stub.dirty();
	            overallNeedDirty_1 = true;
	          }
	        });
	        overallNeedDirty_1 && overallTask.dirty();
	        scheduler.updatePayload(overallTask, payload);
	        var performArgs_1 = scheduler.getPerformArgs(overallTask, opt.block);
	        agentStubMap.each(function (stub) {
	          stub.perform(performArgs_1);
	        });
	
	        if (overallTask.perform(performArgs_1)) {
	          unfinished = true;
	        }
	      } else if (seriesTaskMap) {
	        seriesTaskMap.each(function (task, pipelineId) {
	          if (needSetDirty(opt, task)) {
	            task.dirty();
	          }
	
	          var performArgs = scheduler.getPerformArgs(task, opt.block);
	          performArgs.skip = !stageHandler.performRawSeries && ecModel.isSeriesFiltered(task.context.model);
	          scheduler.updatePayload(task, payload);
	
	          if (task.perform(performArgs)) {
	            unfinished = true;
	          }
	        });
	      }
	    });
	
	    function needSetDirty(opt, task) {
	      return opt.setDirty && (!opt.dirtyMap || opt.dirtyMap.get(task.__pipeline.id));
	    }
	
	    this.unfinished = unfinished || this.unfinished;
	  };
	
	  Scheduler.prototype.performSeriesTasks = function (ecModel) {
	    var unfinished;
	    ecModel.eachSeries(function (seriesModel) {
	      unfinished = seriesModel.dataTask.perform() || unfinished;
	    });
	    this.unfinished = unfinished || this.unfinished;
	  };
	
	  Scheduler.prototype.plan = function () {
	    this._pipelineMap.each(function (pipeline) {
	      var task = pipeline.tail;
	
	      do {
	        if (task.__block) {
	          pipeline.blockIndex = task.__idxInPipeline;
	          break;
	        }
	
	        task = task.getUpstream();
	      } while (task);
	    });
	  };
	
	  Scheduler.prototype.updatePayload = function (task, payload) {
	    payload !== 'remain' && (task.context.payload = payload);
	  };
	
	  Scheduler.prototype._createSeriesStageTask = function (stageHandler, stageHandlerRecord, ecModel, api) {
	    var scheduler = this;
	    var oldSeriesTaskMap = stageHandlerRecord.seriesTaskMap;
	    var newSeriesTaskMap = stageHandlerRecord.seriesTaskMap = util_1.createHashMap();
	    var seriesType = stageHandler.seriesType;
	    var getTargetSeries = stageHandler.getTargetSeries;
	
	    if (stageHandler.createOnAllSeries) {
	      ecModel.eachRawSeries(create);
	    } else if (seriesType) {
	      ecModel.eachRawSeriesByType(seriesType, create);
	    } else if (getTargetSeries) {
	      getTargetSeries(ecModel, api).each(create);
	    }
	
	    function create(seriesModel) {
	      var pipelineId = seriesModel.uid;
	      var task = newSeriesTaskMap.set(pipelineId, oldSeriesTaskMap && oldSeriesTaskMap.get(pipelineId) || task_1.createTask({
	        plan: seriesTaskPlan,
	        reset: seriesTaskReset,
	        count: seriesTaskCount
	      }));
	      task.context = {
	        model: seriesModel,
	        ecModel: ecModel,
	        api: api,
	        useClearVisual: stageHandler.isVisual && !stageHandler.isLayout,
	        plan: stageHandler.plan,
	        reset: stageHandler.reset,
	        scheduler: scheduler
	      };
	
	      scheduler._pipe(seriesModel, task);
	    }
	  };
	
	  Scheduler.prototype._createOverallStageTask = function (stageHandler, stageHandlerRecord, ecModel, api) {
	    var scheduler = this;
	    var overallTask = stageHandlerRecord.overallTask = stageHandlerRecord.overallTask || task_1.createTask({
	      reset: overallTaskReset
	    });
	    overallTask.context = {
	      ecModel: ecModel,
	      api: api,
	      overallReset: stageHandler.overallReset,
	      scheduler: scheduler
	    };
	    var oldAgentStubMap = overallTask.agentStubMap;
	    var newAgentStubMap = overallTask.agentStubMap = util_1.createHashMap();
	    var seriesType = stageHandler.seriesType;
	    var getTargetSeries = stageHandler.getTargetSeries;
	    var overallProgress = true;
	    var shouldOverallTaskDirty = false;
	    var errMsg = '';
	
	    if (false) {
	      errMsg = '"createOnAllSeries" do not supported for "overallReset", ' + 'becuase it will block all streams.';
	    }
	
	    util_1.assert(!stageHandler.createOnAllSeries, errMsg);
	
	    if (seriesType) {
	      ecModel.eachRawSeriesByType(seriesType, createStub);
	    } else if (getTargetSeries) {
	      getTargetSeries(ecModel, api).each(createStub);
	    } else {
	      overallProgress = false;
	      util_1.each(ecModel.getSeries(), createStub);
	    }
	
	    function createStub(seriesModel) {
	      var pipelineId = seriesModel.uid;
	      var stub = newAgentStubMap.set(pipelineId, oldAgentStubMap && oldAgentStubMap.get(pipelineId) || (shouldOverallTaskDirty = true, task_1.createTask({
	        reset: stubReset,
	        onDirty: stubOnDirty
	      })));
	      stub.context = {
	        model: seriesModel,
	        overallProgress: overallProgress
	      };
	      stub.agent = overallTask;
	      stub.__block = overallProgress;
	
	      scheduler._pipe(seriesModel, stub);
	    }
	
	    if (shouldOverallTaskDirty) {
	      overallTask.dirty();
	    }
	  };
	
	  Scheduler.prototype._pipe = function (seriesModel, task) {
	    var pipelineId = seriesModel.uid;
	
	    var pipeline = this._pipelineMap.get(pipelineId);
	
	    !pipeline.head && (pipeline.head = task);
	    pipeline.tail && pipeline.tail.pipe(task);
	    pipeline.tail = task;
	    task.__idxInPipeline = pipeline.count++;
	    task.__pipeline = pipeline;
	  };
	
	  Scheduler.wrapStageHandler = function (stageHandler, visualType) {
	    if (util_1.isFunction(stageHandler)) {
	      stageHandler = {
	        overallReset: stageHandler,
	        seriesType: detectSeriseType(stageHandler)
	      };
	    }
	
	    stageHandler.uid = component_1.getUID('stageHandler');
	    visualType && (stageHandler.visualType = visualType);
	    return stageHandler;
	  };
	
	  ;
	  return Scheduler;
	}();
	
	function overallTaskReset(context) {
	  context.overallReset(context.ecModel, context.api, context.payload);
	}
	
	function stubReset(context) {
	  return context.overallProgress && stubProgress;
	}
	
	function stubProgress() {
	  this.agent.dirty();
	  this.getDownstream().dirty();
	}
	
	function stubOnDirty() {
	  this.agent && this.agent.dirty();
	}
	
	function seriesTaskPlan(context) {
	  return context.plan ? context.plan(context.model, context.ecModel, context.api, context.payload) : null;
	}
	
	function seriesTaskReset(context) {
	  if (context.useClearVisual) {
	    context.data.clearAllVisual();
	  }
	
	  var resetDefines = context.resetDefines = model_1.normalizeToArray(context.reset(context.model, context.ecModel, context.api, context.payload));
	  return resetDefines.length > 1 ? util_1.map(resetDefines, function (v, idx) {
	    return makeSeriesTaskProgress(idx);
	  }) : singleSeriesTaskProgress;
	}
	
	var singleSeriesTaskProgress = makeSeriesTaskProgress(0);
	
	function makeSeriesTaskProgress(resetDefineIdx) {
	  return function (params, context) {
	    var data = context.data;
	    var resetDefine = context.resetDefines[resetDefineIdx];
	
	    if (resetDefine && resetDefine.dataEach) {
	      for (var i = params.start; i < params.end; i++) {
	        resetDefine.dataEach(data, i);
	      }
	    } else if (resetDefine && resetDefine.progress) {
	      resetDefine.progress(params, data);
	    }
	  };
	}
	
	function seriesTaskCount(context) {
	  return context.data.count();
	}
	
	function detectSeriseType(legacyFunc) {
	  seriesType = null;
	
	  try {
	    legacyFunc(ecModelMock, apiMock);
	  } catch (e) {}
	
	  return seriesType;
	}
	
	var ecModelMock = {};
	var apiMock = {};
	var seriesType;
	mockMethods(ecModelMock, Global_1["default"]);
	mockMethods(apiMock, ExtensionAPI_1["default"]);
	
	ecModelMock.eachSeriesByType = ecModelMock.eachRawSeriesByType = function (type) {
	  seriesType = type;
	};
	
	ecModelMock.eachComponent = function (cond) {
	  if (cond.mainType === 'series' && cond.subType) {
	    seriesType = cond.subType;
	  }
	};
	
	function mockMethods(target, Clz) {
	  for (var name_1 in Clz.prototype) {
	    target[name_1] = util_1.noop;
	  }
	}
	
	exports["default"] = Scheduler;

/***/ },
/* 371 */
/***/ function(module, exports) {

	
	/*
	* Licensed to the Apache Software Foundation (ASF) under one
	* or more contributor license agreements.  See the NOTICE file
	* distributed with this work for additional information
	* regarding copyright ownership.  The ASF licenses this file
	* to you under the Apache License, Version 2.0 (the
	* "License"); you may not use this file except in compliance
	* with the License.  You may obtain a copy of the License at
	*
	*   http://www.apache.org/licenses/LICENSE-2.0
	*
	* Unless required by applicable law or agreed to in writing,
	* software distributed under the License is distributed on an
	* "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
	* KIND, either express or implied.  See the License for the
	* specific language governing permissions and limitations
	* under the License.
	*/
	
	
	
	/**
	 * AUTO-GENERATED FILE. DO NOT MODIFY.
	 */
	
	"use strict";
	
	exports.__esModule = true;
	var contrastColor = '#B9B8CE';
	var backgroundColor = '#100C2A';
	
	var axisCommon = function () {
	  return {
	    axisLine: {
	      lineStyle: {
	        color: contrastColor
	      }
	    },
	    splitLine: {
	      lineStyle: {
	        color: '#484753'
	      }
	    },
	    splitArea: {
	      areaStyle: {
	        color: ['rgba(255,255,255,0.02)', 'rgba(255,255,255,0.05)']
	      }
	    },
	    minorSplitLine: {
	      lineStyle: {
	        color: '#20203B'
	      }
	    }
	  };
	};
	
	var colorPalette = ['#4992ff', '#7cffb2', '#fddd60', '#ff6e76', '#58d9f9', '#05c091', '#ff8a45', '#8d48e3', '#dd79ff'];
	var theme = {
	  darkMode: true,
	  color: colorPalette,
	  backgroundColor: backgroundColor,
	  axisPointer: {
	    lineStyle: {
	      color: '#817f91'
	    },
	    crossStyle: {
	      color: '#817f91'
	    },
	    label: {
	      color: '#fff'
	    }
	  },
	  legend: {
	    textStyle: {
	      color: contrastColor
	    }
	  },
	  textStyle: {
	    color: contrastColor
	  },
	  title: {
	    textStyle: {
	      color: '#EEF1FA'
	    },
	    subtextStyle: {
	      color: '#B9B8CE'
	    }
	  },
	  toolbox: {
	    iconStyle: {
	      borderColor: contrastColor
	    }
	  },
	  dataZoom: {
	    borderColor: '#71708A',
	    textStyle: {
	      color: contrastColor
	    },
	    brushStyle: {
	      color: 'rgba(135,163,206,0.3)'
	    },
	    handleStyle: {
	      color: '#353450',
	      borderColor: '#C5CBE3'
	    },
	    moveHandleStyle: {
	      color: '#B0B6C3',
	      opacity: 0.3
	    },
	    fillerColor: 'rgba(135,163,206,0.2)',
	    emphasis: {
	      handleStyle: {
	        borderColor: '#91B7F2',
	        color: '#4D587D'
	      },
	      moveHandleStyle: {
	        color: '#636D9A',
	        opacity: 0.7
	      }
	    },
	    dataBackground: {
	      lineStyle: {
	        color: '#71708A',
	        width: 1
	      },
	      areaStyle: {
	        color: '#71708A'
	      }
	    },
	    selectedDataBackground: {
	      lineStyle: {
	        color: '#87A3CE'
	      },
	      areaStyle: {
	        color: '#87A3CE'
	      }
	    }
	  },
	  visualMap: {
	    textStyle: {
	      color: contrastColor
	    }
	  },
	  timeline: {
	    lineStyle: {
	      color: contrastColor
	    },
	    label: {
	      color: contrastColor
	    },
	    controlStyle: {
	      color: contrastColor,
	      borderColor: contrastColor
	    }
	  },
	  calendar: {
	    itemStyle: {
	      color: backgroundColor
	    },
	    dayLabel: {
	      color: contrastColor
	    },
	    monthLabel: {
	      color: contrastColor
	    },
	    yearLabel: {
	      color: contrastColor
	    }
	  },
	  timeAxis: axisCommon(),
	  logAxis: axisCommon(),
	  valueAxis: axisCommon(),
	  categoryAxis: axisCommon(),
	  line: {
	    symbol: 'circle'
	  },
	  graph: {
	    color: colorPalette
	  },
	  gauge: {
	    title: {
	      color: contrastColor
	    },
	    axisLine: {
	      lineStyle: {
	        color: [[1, 'rgba(207,212,219,0.2)']]
	      }
	    },
	    axisLabel: {
	      color: contrastColor
	    },
	    detail: {
	      color: '#EEF1FA'
	    }
	  },
	  candlestick: {
	    itemStyle: {
	      color: '#FD1050',
	      color0: '#0CF49B',
	      borderColor: '#FD1050',
	      borderColor0: '#0CF49B'
	    }
	  }
	};
	theme.categoryAxis.splitLine.show = false;
	exports["default"] = theme;

/***/ },
/* 372 */
/***/ function(module, exports) {

	
	/*
	* Licensed to the Apache Software Foundation (ASF) under one
	* or more contributor license agreements.  See the NOTICE file
	* distributed with this work for additional information
	* regarding copyright ownership.  The ASF licenses this file
	* to you under the Apache License, Version 2.0 (the
	* "License"); you may not use this file except in compliance
	* with the License.  You may obtain a copy of the License at
	*
	*   http://www.apache.org/licenses/LICENSE-2.0
	*
	* Unless required by applicable law or agreed to in writing,
	* software distributed under the License is distributed on an
	* "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
	* KIND, either express or implied.  See the License for the
	* specific language governing permissions and limitations
	* under the License.
	*/
	
	
	
	/**
	 * AUTO-GENERATED FILE. DO NOT MODIFY.
	 */
	
	"use strict";
	
	exports.__esModule = true;
	var colorAll = ['#37A2DA', '#32C5E9', '#67E0E3', '#9FE6B8', '#FFDB5C', '#ff9f7f', '#fb7293', '#E062AE', '#E690D1', '#e7bcf3', '#9d96f5', '#8378EA', '#96BFFF'];
	exports["default"] = {
	  color: colorAll,
	  colorLayer: [['#37A2DA', '#ffd85c', '#fd7b5f'], ['#37A2DA', '#67E0E3', '#FFDB5C', '#ff9f7f', '#E062AE', '#9d96f5'], ['#37A2DA', '#32C5E9', '#9FE6B8', '#FFDB5C', '#ff9f7f', '#fb7293', '#e7bcf3', '#8378EA', '#96BFFF'], colorAll]
	};

/***/ },
/* 373 */
/***/ function(module, exports, __webpack_require__) {

	
	/*
	* Licensed to the Apache Software Foundation (ASF) under one
	* or more contributor license agreements.  See the NOTICE file
	* distributed with this work for additional information
	* regarding copyright ownership.  The ASF licenses this file
	* to you under the Apache License, Version 2.0 (the
	* "License"); you may not use this file except in compliance
	* with the License.  You may obtain a copy of the License at
	*
	*   http://www.apache.org/licenses/LICENSE-2.0
	*
	* Unless required by applicable law or agreed to in writing,
	* software distributed under the License is distributed on an
	* "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
	* KIND, either express or implied.  See the License for the
	* specific language governing permissions and limitations
	* under the License.
	*/
	
	
	
	/**
	 * AUTO-GENERATED FILE. DO NOT MODIFY.
	 */
	
	"use strict";
	
	exports.__esModule = true;
	
	var zrUtil = __webpack_require__(1);
	
	var clazz_1 = __webpack_require__(28);
	
	var ECEventProcessor = function () {
	  function ECEventProcessor() {}
	
	  ECEventProcessor.prototype.normalizeQuery = function (query) {
	    var cptQuery = {};
	    var dataQuery = {};
	    var otherQuery = {};
	
	    if (zrUtil.isString(query)) {
	      var condCptType = clazz_1.parseClassType(query);
	      cptQuery.mainType = condCptType.main || null;
	      cptQuery.subType = condCptType.sub || null;
	    } else {
	      var suffixes_1 = ['Index', 'Name', 'Id'];
	      var dataKeys_1 = {
	        name: 1,
	        dataIndex: 1,
	        dataType: 1
	      };
	      zrUtil.each(query, function (val, key) {
	        var reserved = false;
	
	        for (var i = 0; i < suffixes_1.length; i++) {
	          var propSuffix = suffixes_1[i];
	          var suffixPos = key.lastIndexOf(propSuffix);
	
	          if (suffixPos > 0 && suffixPos === key.length - propSuffix.length) {
	            var mainType = key.slice(0, suffixPos);
	
	            if (mainType !== 'data') {
	              cptQuery.mainType = mainType;
	              cptQuery[propSuffix.toLowerCase()] = val;
	              reserved = true;
	            }
	          }
	        }
	
	        if (dataKeys_1.hasOwnProperty(key)) {
	          dataQuery[key] = val;
	          reserved = true;
	        }
	
	        if (!reserved) {
	          otherQuery[key] = val;
	        }
	      });
	    }
	
	    return {
	      cptQuery: cptQuery,
	      dataQuery: dataQuery,
	      otherQuery: otherQuery
	    };
	  };
	
	  ECEventProcessor.prototype.filter = function (eventType, query) {
	    var eventInfo = this.eventInfo;
	
	    if (!eventInfo) {
	      return true;
	    }
	
	    var targetEl = eventInfo.targetEl;
	    var packedEvent = eventInfo.packedEvent;
	    var model = eventInfo.model;
	    var view = eventInfo.view;
	
	    if (!model || !view) {
	      return true;
	    }
	
	    var cptQuery = query.cptQuery;
	    var dataQuery = query.dataQuery;
	    return check(cptQuery, model, 'mainType') && check(cptQuery, model, 'subType') && check(cptQuery, model, 'index', 'componentIndex') && check(cptQuery, model, 'name') && check(cptQuery, model, 'id') && check(dataQuery, packedEvent, 'name') && check(dataQuery, packedEvent, 'dataIndex') && check(dataQuery, packedEvent, 'dataType') && (!view.filterForExposedEvent || view.filterForExposedEvent(eventType, query.otherQuery, targetEl, packedEvent));
	
	    function check(query, host, prop, propOnHost) {
	      return query[prop] == null || host[propOnHost || prop] === query[prop];
	    }
	  };
	
	  ECEventProcessor.prototype.afterTrigger = function () {
	    this.eventInfo = null;
	  };
	
	  return ECEventProcessor;
	}();
	
	exports.ECEventProcessor = ECEventProcessor;
	;

/***/ },
/* 374 */
/***/ function(module, exports, __webpack_require__) {

	
	/*
	* Licensed to the Apache Software Foundation (ASF) under one
	* or more contributor license agreements.  See the NOTICE file
	* distributed with this work for additional information
	* regarding copyright ownership.  The ASF licenses this file
	* to you under the Apache License, Version 2.0 (the
	* "License"); you may not use this file except in compliance
	* with the License.  You may obtain a copy of the License at
	*
	*   http://www.apache.org/licenses/LICENSE-2.0
	*
	* Unless required by applicable law or agreed to in writing,
	* software distributed under the License is distributed on an
	* "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
	* KIND, either express or implied.  See the License for the
	* specific language governing permissions and limitations
	* under the License.
	*/
	
	
	
	/**
	 * AUTO-GENERATED FILE. DO NOT MODIFY.
	 */
	
	"use strict";
	
	exports.__esModule = true;
	
	var WeakMap_1 = __webpack_require__(457);
	
	var LRU_1 = __webpack_require__(59);
	
	var util_1 = __webpack_require__(1);
	
	var number_1 = __webpack_require__(9);
	
	var symbol_1 = __webpack_require__(48);
	
	var graphic_1 = __webpack_require__(78);
	
	var decalMap = new WeakMap_1["default"]();
	var decalCache = new LRU_1["default"](100);
	var decalKeys = ['symbol', 'symbolSize', 'symbolKeepAspect', 'color', 'backgroundColor', 'dashArrayX', 'dashArrayY', 'dashLineOffset', 'maxTileWidth', 'maxTileHeight'];
	
	function createOrUpdatePatternFromDecal(decalObject, api) {
	  if (decalObject === 'none') {
	    return null;
	  }
	
	  var dpr = api.getDevicePixelRatio();
	  var zr = api.getZr();
	  var isSVG = zr.painter.type === 'svg';
	
	  if (decalObject.dirty) {
	    decalMap["delete"](decalObject);
	  }
	
	  var oldPattern = decalMap.get(decalObject);
	
	  if (oldPattern) {
	    return oldPattern;
	  }
	
	  var decalOpt = util_1.defaults(decalObject, {
	    symbol: 'rect',
	    symbolSize: 1,
	    symbolKeepAspect: true,
	    color: 'rgba(0, 0, 0, 0.2)',
	    backgroundColor: null,
	    dashArrayX: 5,
	    dashArrayY: 5,
	    dashLineOffset: 0,
	    rotation: 0,
	    maxTileWidth: 512,
	    maxTileHeight: 512
	  });
	
	  if (decalOpt.backgroundColor === 'none') {
	    decalOpt.backgroundColor = null;
	  }
	
	  var pattern = {
	    repeat: 'repeat'
	  };
	  setPatternnSource(pattern);
	  pattern.rotation = decalOpt.rotation;
	  pattern.scaleX = pattern.scaleY = isSVG ? 1 : 1 / dpr;
	  decalMap.set(decalObject, pattern);
	  decalObject.dirty = false;
	  return pattern;
	
	  function setPatternnSource(pattern) {
	    var keys = [dpr];
	    var isValidKey = true;
	
	    for (var i = 0; i < decalKeys.length; ++i) {
	      var value = decalOpt[decalKeys[i]];
	      var valueType = typeof value;
	
	      if (value != null && !util_1.isArray(value) && valueType !== 'string' && valueType !== 'number' && valueType !== 'boolean') {
	        isValidKey = false;
	        break;
	      }
	
	      keys.push(value);
	    }
	
	    var cacheKey;
	
	    if (isValidKey) {
	      cacheKey = keys.join(',') + (isSVG ? '-svg' : '');
	      var cache = decalCache.get(cacheKey);
	
	      if (cache) {
	        isSVG ? pattern.svgElement = cache : pattern.image = cache;
	      }
	    }
	
	    var dashArrayX = normalizeDashArrayX(decalOpt.dashArrayX);
	    var dashArrayY = normalizeDashArrayY(decalOpt.dashArrayY);
	    var symbolArray = normalizeSymbolArray(decalOpt.symbol);
	    var lineBlockLengthsX = getLineBlockLengthX(dashArrayX);
	    var lineBlockLengthY = getLineBlockLengthY(dashArrayY);
	    var canvas = !isSVG && util_1.createCanvas();
	    var svgRoot = isSVG && zr.painter.createSVGElement('g');
	    var pSize = getPatternSize();
	    var ctx;
	
	    if (canvas) {
	      canvas.width = pSize.width * dpr;
	      canvas.height = pSize.height * dpr;
	      ctx = canvas.getContext('2d');
	    }
	
	    brushDecal();
	
	    if (isValidKey) {
	      decalCache.put(cacheKey, canvas || svgRoot);
	    }
	
	    pattern.image = canvas;
	    pattern.svgElement = svgRoot;
	    pattern.svgWidth = pSize.width;
	    pattern.svgHeight = pSize.height;
	
	    function getPatternSize() {
	      var width = 1;
	
	      for (var i = 0, xlen = lineBlockLengthsX.length; i < xlen; ++i) {
	        width = number_1.getLeastCommonMultiple(width, lineBlockLengthsX[i]);
	      }
	
	      var symbolRepeats = 1;
	
	      for (var i = 0, xlen = symbolArray.length; i < xlen; ++i) {
	        symbolRepeats = number_1.getLeastCommonMultiple(symbolRepeats, symbolArray[i].length);
	      }
	
	      width *= symbolRepeats;
	      var height = lineBlockLengthY * lineBlockLengthsX.length * symbolArray.length;
	
	      if (false) {
	        var warn = function (attrName) {
	          console.warn("Calculated decal size is greater than " + attrName + " due to decal option settings so " + attrName + " is used for the decal size. Please consider changing the decal option to make a smaller decal or set " + attrName + " to be larger to avoid incontinuity.");
	        };
	
	        if (width > decalOpt.maxTileWidth) {
	          warn('maxTileWidth');
	        }
	
	        if (height > decalOpt.maxTileHeight) {
	          warn('maxTileHeight');
	        }
	      }
	
	      return {
	        width: Math.max(1, Math.min(width, decalOpt.maxTileWidth)),
	        height: Math.max(1, Math.min(height, decalOpt.maxTileHeight))
	      };
	    }
	
	    function brushDecal() {
	      if (ctx) {
	        ctx.clearRect(0, 0, canvas.width, canvas.height);
	
	        if (decalOpt.backgroundColor) {
	          ctx.fillStyle = decalOpt.backgroundColor;
	          ctx.fillRect(0, 0, canvas.width, canvas.height);
	        }
	      }
	
	      var ySum = 0;
	
	      for (var i = 0; i < dashArrayY.length; ++i) {
	        ySum += dashArrayY[i];
	      }
	
	      if (ySum <= 0) {
	        return;
	      }
	
	      var y = -lineBlockLengthY;
	      var yId = 0;
	      var yIdTotal = 0;
	      var xId0 = 0;
	
	      while (y < pSize.height) {
	        if (yId % 2 === 0) {
	          var symbolYId = yIdTotal / 2 % symbolArray.length;
	          var x = 0;
	          var xId1 = 0;
	          var xId1Total = 0;
	
	          while (x < pSize.width * 2) {
	            var xSum = 0;
	
	            for (var i = 0; i < dashArrayX[xId0].length; ++i) {
	              xSum += dashArrayX[xId0][i];
	            }
	
	            if (xSum <= 0) {
	              break;
	            }
	
	            if (xId1 % 2 === 0) {
	              var size = (1 - decalOpt.symbolSize) * 0.5;
	              var left = x + dashArrayX[xId0][xId1] * size;
	              var top_1 = y + dashArrayY[yId] * size;
	              var width = dashArrayX[xId0][xId1] * decalOpt.symbolSize;
	              var height = dashArrayY[yId] * decalOpt.symbolSize;
	              var symbolXId = xId1Total / 2 % symbolArray[symbolYId].length;
	              brushSymbol(left, top_1, width, height, symbolArray[symbolYId][symbolXId]);
	            }
	
	            x += dashArrayX[xId0][xId1];
	            ++xId1Total;
	            ++xId1;
	
	            if (xId1 === dashArrayX[xId0].length) {
	              xId1 = 0;
	            }
	          }
	
	          ++xId0;
	
	          if (xId0 === dashArrayX.length) {
	            xId0 = 0;
	          }
	        }
	
	        y += dashArrayY[yId];
	        ++yIdTotal;
	        ++yId;
	
	        if (yId === dashArrayY.length) {
	          yId = 0;
	        }
	      }
	
	      function brushSymbol(x, y, width, height, symbolType) {
	        var scale = isSVG ? 1 : dpr;
	        var symbol = symbol_1.createSymbol(symbolType, x * scale, y * scale, width * scale, height * scale, decalOpt.color, decalOpt.symbolKeepAspect);
	
	        if (isSVG) {
	          svgRoot.appendChild(zr.painter.paintOne(symbol));
	        } else {
	          graphic_1.brushSingle(ctx, symbol);
	        }
	      }
	    }
	  }
	}
	
	exports.createOrUpdatePatternFromDecal = createOrUpdatePatternFromDecal;
	
	function normalizeSymbolArray(symbol) {
	  if (!symbol || symbol.length === 0) {
	    return [['rect']];
	  }
	
	  if (typeof symbol === 'string') {
	    return [[symbol]];
	  }
	
	  var isAllString = true;
	
	  for (var i = 0; i < symbol.length; ++i) {
	    if (typeof symbol[i] !== 'string') {
	      isAllString = false;
	      break;
	    }
	  }
	
	  if (isAllString) {
	    return normalizeSymbolArray([symbol]);
	  }
	
	  var result = [];
	
	  for (var i = 0; i < symbol.length; ++i) {
	    if (typeof symbol[i] === 'string') {
	      result.push([symbol[i]]);
	    } else {
	      result.push(symbol[i]);
	    }
	  }
	
	  return result;
	}
	
	function normalizeDashArrayX(dash) {
	  if (!dash || dash.length === 0) {
	    return [[0, 0]];
	  }
	
	  if (typeof dash === 'number') {
	    var dashValue = Math.ceil(dash);
	    return [[dashValue, dashValue]];
	  }
	
	  var isAllNumber = true;
	
	  for (var i = 0; i < dash.length; ++i) {
	    if (typeof dash[i] !== 'number') {
	      isAllNumber = false;
	      break;
	    }
	  }
	
	  if (isAllNumber) {
	    return normalizeDashArrayX([dash]);
	  }
	
	  var result = [];
	
	  for (var i = 0; i < dash.length; ++i) {
	    if (typeof dash[i] === 'number') {
	      var dashValue = Math.ceil(dash[i]);
	      result.push([dashValue, dashValue]);
	    } else {
	      var dashValue = util_1.map(dash[i], function (n) {
	        return Math.ceil(n);
	      });
	
	      if (dashValue.length % 2 === 1) {
	        result.push(dashValue.concat(dashValue));
	      } else {
	        result.push(dashValue);
	      }
	    }
	  }
	
	  return result;
	}
	
	function normalizeDashArrayY(dash) {
	  if (!dash || typeof dash === 'object' && dash.length === 0) {
	    return [0, 0];
	  }
	
	  if (typeof dash === 'number') {
	    var dashValue_1 = Math.ceil(dash);
	    return [dashValue_1, dashValue_1];
	  }
	
	  var dashValue = util_1.map(dash, function (n) {
	    return Math.ceil(n);
	  });
	  return dash.length % 2 ? dashValue.concat(dashValue) : dashValue;
	}
	
	function getLineBlockLengthX(dash) {
	  return util_1.map(dash, function (line) {
	    return getLineBlockLengthY(line);
	  });
	}
	
	function getLineBlockLengthY(dash) {
	  var blockLength = 0;
	
	  for (var i = 0; i < dash.length; ++i) {
	    blockLength += dash[i];
	  }
	
	  if (dash.length % 2 === 1) {
	    return blockLength * 2;
	  }
	
	  return blockLength;
	}

/***/ },
/* 375 */
/***/ function(module, exports, __webpack_require__) {

	
	/*
	* Licensed to the Apache Software Foundation (ASF) under one
	* or more contributor license agreements.  See the NOTICE file
	* distributed with this work for additional information
	* regarding copyright ownership.  The ASF licenses this file
	* to you under the Apache License, Version 2.0 (the
	* "License"); you may not use this file except in compliance
	* with the License.  You may obtain a copy of the License at
	*
	*   http://www.apache.org/licenses/LICENSE-2.0
	*
	* Unless required by applicable law or agreed to in writing,
	* software distributed under the License is distributed on an
	* "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
	* KIND, either express or implied.  See the License for the
	* specific language governing permissions and limitations
	* under the License.
	*/
	
	
	
	/**
	 * AUTO-GENERATED FILE. DO NOT MODIFY.
	 */
	
	"use strict";
	
	exports.__esModule = true;
	
	var tslib_1 = __webpack_require__(3);
	
	var graphic_1 = __webpack_require__(7);
	
	var SausageShape = function () {
	  function SausageShape() {
	    this.cx = 0;
	    this.cy = 0;
	    this.r0 = 0;
	    this.r = 0;
	    this.startAngle = 0;
	    this.endAngle = Math.PI * 2;
	    this.clockwise = true;
	  }
	
	  return SausageShape;
	}();
	
	var SausagePath = function (_super) {
	  tslib_1.__extends(SausagePath, _super);
	
	  function SausagePath(opts) {
	    var _this = _super.call(this, opts) || this;
	
	    _this.type = 'sausage';
	    return _this;
	  }
	
	  SausagePath.prototype.getDefaultShape = function () {
	    return new SausageShape();
	  };
	
	  SausagePath.prototype.buildPath = function (ctx, shape) {
	    var x = shape.cx;
	    var y = shape.cy;
	    var r0 = Math.max(shape.r0 || 0, 0);
	    var r = Math.max(shape.r, 0);
	    var dr = (r - r0) * 0.5;
	    var rCenter = r0 + dr;
	    var startAngle = shape.startAngle;
	    var endAngle = shape.endAngle;
	    var clockwise = shape.clockwise;
	    var unitStartX = Math.cos(startAngle);
	    var unitStartY = Math.sin(startAngle);
	    var unitEndX = Math.cos(endAngle);
	    var unitEndY = Math.sin(endAngle);
	    var lessThanCircle = clockwise ? endAngle - startAngle < Math.PI * 2 : startAngle - endAngle < Math.PI * 2;
	
	    if (lessThanCircle) {
	      ctx.moveTo(unitStartX * r0 + x, unitStartY * r0 + y);
	      ctx.arc(unitStartX * rCenter + x, unitStartY * rCenter + y, dr, -Math.PI + startAngle, startAngle, !clockwise);
	    }
	
	    ctx.arc(x, y, r, startAngle, endAngle, !clockwise);
	    ctx.moveTo(unitEndX * r + x, unitEndY * r + y);
	    ctx.arc(unitEndX * rCenter + x, unitEndY * rCenter + y, dr, endAngle - Math.PI * 2, endAngle - Math.PI, !clockwise);
	
	    if (r0 !== 0) {
	      ctx.arc(x, y, r0, endAngle, startAngle, clockwise);
	      ctx.moveTo(unitStartX * r0 + x, unitEndY * r0 + y);
	    }
	
	    ctx.closePath();
	  };
	
	  return SausagePath;
	}(graphic_1.Path);
	
	exports["default"] = SausagePath;

/***/ },
/* 376 */
/***/ function(module, exports, __webpack_require__) {

	
	/*
	* Licensed to the Apache Software Foundation (ASF) under one
	* or more contributor license agreements.  See the NOTICE file
	* distributed with this work for additional information
	* regarding copyright ownership.  The ASF licenses this file
	* to you under the Apache License, Version 2.0 (the
	* "License"); you may not use this file except in compliance
	* with the License.  You may obtain a copy of the License at
	*
	*   http://www.apache.org/licenses/LICENSE-2.0
	*
	* Unless required by applicable law or agreed to in writing,
	* software distributed under the License is distributed on an
	* "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
	* KIND, either express or implied.  See the License for the
	* specific language governing permissions and limitations
	* under the License.
	*/
	
	
	
	/**
	 * AUTO-GENERATED FILE. DO NOT MODIFY.
	 */
	
	"use strict";
	
	exports.__esModule = true;
	
	var decal_1 = __webpack_require__(374);
	
	function decalVisual(ecModel, api) {
	  ecModel.eachRawSeries(function (seriesModel) {
	    if (ecModel.isSeriesFiltered(seriesModel)) {
	      return;
	    }
	
	    var data = seriesModel.getData();
	
	    if (data.hasItemVisual()) {
	      data.each(function (idx) {
	        var decal = data.getItemVisual(idx, 'decal');
	
	        if (decal) {
	          var itemStyle = data.ensureUniqueItemVisual(idx, 'style');
	          itemStyle.decal = decal_1.createOrUpdatePatternFromDecal(decal, api);
	        }
	      });
	    }
	
	    var decal = data.getVisual('decal');
	
	    if (decal) {
	      var style = data.getVisual('style');
	      style.decal = decal_1.createOrUpdatePatternFromDecal(decal, api);
	    }
	  });
	}
	
	exports["default"] = decalVisual;

/***/ },
/* 377 */
/***/ function(module, exports, __webpack_require__) {

	
	/*
	* Licensed to the Apache Software Foundation (ASF) under one
	* or more contributor license agreements.  See the NOTICE file
	* distributed with this work for additional information
	* regarding copyright ownership.  The ASF licenses this file
	* to you under the Apache License, Version 2.0 (the
	* "License"); you may not use this file except in compliance
	* with the License.  You may obtain a copy of the License at
	*
	*   http://www.apache.org/licenses/LICENSE-2.0
	*
	* Unless required by applicable law or agreed to in writing,
	* software distributed under the License is distributed on an
	* "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
	* KIND, either express or implied.  See the License for the
	* specific language governing permissions and limitations
	* under the License.
	*/
	
	
	
	/**
	 * AUTO-GENERATED FILE. DO NOT MODIFY.
	 */
	
	"use strict";
	
	exports.__esModule = true;
	
	var util_1 = __webpack_require__(1);
	
	var makeStyleMapper_1 = __webpack_require__(69);
	
	var itemStyle_1 = __webpack_require__(151);
	
	var lineStyle_1 = __webpack_require__(152);
	
	var Model_1 = __webpack_require__(24);
	
	var model_1 = __webpack_require__(4);
	
	var inner = model_1.makeInner();
	var defaultStyleMappers = {
	  itemStyle: makeStyleMapper_1["default"](itemStyle_1.ITEM_STYLE_KEY_MAP, true),
	  lineStyle: makeStyleMapper_1["default"](lineStyle_1.LINE_STYLE_KEY_MAP, true)
	};
	var defaultColorKey = {
	  lineStyle: 'stroke',
	  itemStyle: 'fill'
	};
	
	function getStyleMapper(seriesModel, stylePath) {
	  var styleMapper = seriesModel.visualStyleMapper || defaultStyleMappers[stylePath];
	
	  if (!styleMapper) {
	    console.warn("Unkown style type '" + stylePath + "'.");
	    return defaultStyleMappers.itemStyle;
	  }
	
	  return styleMapper;
	}
	
	function getDefaultColorKey(seriesModel, stylePath) {
	  var colorKey = seriesModel.visualDrawType || defaultColorKey[stylePath];
	
	  if (!colorKey) {
	    console.warn("Unkown style type '" + stylePath + "'.");
	    return 'fill';
	  }
	
	  return colorKey;
	}
	
	var seriesStyleTask = {
	  createOnAllSeries: true,
	  performRawSeries: true,
	  reset: function (seriesModel, ecModel) {
	    var data = seriesModel.getData();
	    var stylePath = seriesModel.visualStyleAccessPath || 'itemStyle';
	    var styleModel = seriesModel.getModel(stylePath);
	    var getStyle = getStyleMapper(seriesModel, stylePath);
	    var globalStyle = getStyle(styleModel);
	    var decalOption = styleModel.getShallow('decal');
	
	    if (decalOption) {
	      data.setVisual('decal', decalOption);
	      decalOption.dirty = true;
	    }
	
	    var colorKey = getDefaultColorKey(seriesModel, stylePath);
	    var color = globalStyle[colorKey];
	    var colorCallback = util_1.isFunction(color) ? color : null;
	
	    if (!globalStyle[colorKey] || colorCallback) {
	      globalStyle[colorKey] = seriesModel.getColorFromPalette(seriesModel.name, null, ecModel.getSeriesCount());
	      data.setVisual('colorFromPalette', true);
	    }
	
	    data.setVisual('style', globalStyle);
	    data.setVisual('drawType', colorKey);
	
	    if (!ecModel.isSeriesFiltered(seriesModel) && colorCallback) {
	      data.setVisual('colorFromPalette', false);
	      return {
	        dataEach: function (data, idx) {
	          var dataParams = seriesModel.getDataParams(idx);
	          var itemStyle = util_1.extend({}, globalStyle);
	          itemStyle[colorKey] = colorCallback(dataParams);
	          data.setItemVisual(idx, 'style', itemStyle);
	        }
	      };
	    }
	  }
	};
	exports.seriesStyleTask = seriesStyleTask;
	var sharedModel = new Model_1["default"]();
	var dataStyleTask = {
	  createOnAllSeries: true,
	  performRawSeries: true,
	  reset: function (seriesModel, ecModel) {
	    if (seriesModel.ignoreStyleOnData || ecModel.isSeriesFiltered(seriesModel)) {
	      return;
	    }
	
	    var data = seriesModel.getData();
	    var stylePath = seriesModel.visualStyleAccessPath || 'itemStyle';
	    var getStyle = getStyleMapper(seriesModel, stylePath);
	    var colorKey = data.getVisual('drawType');
	    return {
	      dataEach: data.hasItemOption ? function (data, idx) {
	        var rawItem = data.getRawDataItem(idx);
	
	        if (rawItem && rawItem[stylePath]) {
	          sharedModel.option = rawItem[stylePath];
	          var style = getStyle(sharedModel);
	          var existsStyle = data.ensureUniqueItemVisual(idx, 'style');
	          util_1.extend(existsStyle, style);
	
	          if (sharedModel.option.decal) {
	            data.setItemVisual(idx, 'decal', sharedModel.option.decal);
	            sharedModel.option.decal.dirty = true;
	          }
	
	          if (colorKey in style) {
	            data.setItemVisual(idx, 'colorFromPalette', false);
	          }
	        }
	      } : null
	    };
	  }
	};
	exports.dataStyleTask = dataStyleTask;
	var dataColorPaletteTask = {
	  performRawSeries: true,
	  overallReset: function (ecModel) {
	    var paletteScopeGroupByType = util_1.createHashMap();
	    ecModel.eachSeries(function (seriesModel) {
	      if (!seriesModel.useColorPaletteOnData) {
	        return;
	      }
	
	      var colorScope = paletteScopeGroupByType.get(seriesModel.type);
	
	      if (!colorScope) {
	        colorScope = {};
	        paletteScopeGroupByType.set(seriesModel.type, colorScope);
	      }
	
	      inner(seriesModel).scope = colorScope;
	    });
	    ecModel.eachSeries(function (seriesModel) {
	      if (!seriesModel.useColorPaletteOnData || ecModel.isSeriesFiltered(seriesModel)) {
	        return;
	      }
	
	      var dataAll = seriesModel.getRawData();
	      var idxMap = {};
	      var data = seriesModel.getData();
	      var colorScope = inner(seriesModel).scope;
	      var stylePath = seriesModel.visualStyleAccessPath || 'itemStyle';
	      var colorKey = getDefaultColorKey(seriesModel, stylePath);
	      data.each(function (idx) {
	        var rawIdx = data.getRawIndex(idx);
	        idxMap[rawIdx] = idx;
	      });
	      dataAll.each(function (rawIdx) {
	        var idx = idxMap[rawIdx];
	        var fromPalette = data.getItemVisual(idx, 'colorFromPalette');
	
	        if (fromPalette) {
	          var itemStyle = data.ensureUniqueItemVisual(idx, 'style');
	          var name_1 = dataAll.getName(rawIdx) || rawIdx + '';
	          var dataCount = dataAll.count();
	          itemStyle[colorKey] = seriesModel.getColorFromPalette(name_1, colorScope, dataCount);
	        }
	      });
	    });
	  }
	};
	exports.dataColorPaletteTask = dataColorPaletteTask;

/***/ },
/* 378 */
/***/ function(module, exports, __webpack_require__) {

	
	/*
	* Licensed to the Apache Software Foundation (ASF) under one
	* or more contributor license agreements.  See the NOTICE file
	* distributed with this work for additional information
	* regarding copyright ownership.  The ASF licenses this file
	* to you under the Apache License, Version 2.0 (the
	* "License"); you may not use this file except in compliance
	* with the License.  You may obtain a copy of the License at
	*
	*   http://www.apache.org/licenses/LICENSE-2.0
	*
	* Unless required by applicable law or agreed to in writing,
	* software distributed under the License is distributed on an
	* "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
	* KIND, either express or implied.  See the License for the
	* specific language governing permissions and limitations
	* under the License.
	*/
	
	
	
	/**
	 * AUTO-GENERATED FILE. DO NOT MODIFY.
	 */
	
	"use strict";
	
	exports.__esModule = true;
	
	var util_1 = __webpack_require__(1);
	
	var seriesSymbolTask = {
	  createOnAllSeries: true,
	  performRawSeries: true,
	  reset: function (seriesModel, ecModel) {
	    var data = seriesModel.getData();
	
	    if (seriesModel.legendSymbol) {
	      data.setVisual('legendSymbol', seriesModel.legendSymbol);
	    }
	
	    if (!seriesModel.hasSymbolVisual) {
	      return;
	    }
	
	    var symbolType = seriesModel.get('symbol');
	    var symbolSize = seriesModel.get('symbolSize');
	    var keepAspect = seriesModel.get('symbolKeepAspect');
	    var symbolRotate = seriesModel.get('symbolRotate');
	    var hasSymbolTypeCallback = util_1.isFunction(symbolType);
	    var hasSymbolSizeCallback = util_1.isFunction(symbolSize);
	    var hasSymbolRotateCallback = util_1.isFunction(symbolRotate);
	    var hasCallback = hasSymbolTypeCallback || hasSymbolSizeCallback || hasSymbolRotateCallback;
	    var seriesSymbol = !hasSymbolTypeCallback && symbolType ? symbolType : seriesModel.defaultSymbol;
	    var seriesSymbolSize = !hasSymbolSizeCallback ? symbolSize : null;
	    var seriesSymbolRotate = !hasSymbolRotateCallback ? symbolRotate : null;
	    data.setVisual({
	      legendSymbol: seriesModel.legendSymbol || seriesSymbol,
	      symbol: seriesSymbol,
	      symbolSize: seriesSymbolSize,
	      symbolKeepAspect: keepAspect,
	      symbolRotate: seriesSymbolRotate
	    });
	
	    if (ecModel.isSeriesFiltered(seriesModel)) {
	      return;
	    }
	
	    function dataEach(data, idx) {
	      var rawValue = seriesModel.getRawValue(idx);
	      var params = seriesModel.getDataParams(idx);
	      hasSymbolTypeCallback && data.setItemVisual(idx, 'symbol', symbolType(rawValue, params));
	      hasSymbolSizeCallback && data.setItemVisual(idx, 'symbolSize', symbolSize(rawValue, params));
	      hasSymbolRotateCallback && data.setItemVisual(idx, 'symbolRotate', symbolRotate(rawValue, params));
	    }
	
	    return {
	      dataEach: hasCallback ? dataEach : null
	    };
	  }
	};
	exports.seriesSymbolTask = seriesSymbolTask;
	var dataSymbolTask = {
	  createOnAllSeries: true,
	  performRawSeries: true,
	  reset: function (seriesModel, ecModel) {
	    if (!seriesModel.hasSymbolVisual) {
	      return;
	    }
	
	    if (ecModel.isSeriesFiltered(seriesModel)) {
	      return;
	    }
	
	    var data = seriesModel.getData();
	
	    function dataEach(data, idx) {
	      var itemModel = data.getItemModel(idx);
	      var itemSymbolType = itemModel.getShallow('symbol', true);
	      var itemSymbolSize = itemModel.getShallow('symbolSize', true);
	      var itemSymbolRotate = itemModel.getShallow('symbolRotate', true);
	      var itemSymbolKeepAspect = itemModel.getShallow('symbolKeepAspect', true);
	
	      if (itemSymbolType != null) {
	        data.setItemVisual(idx, 'symbol', itemSymbolType);
	      }
	
	      if (itemSymbolSize != null) {
	        data.setItemVisual(idx, 'symbolSize', itemSymbolSize);
	      }
	
	      if (itemSymbolRotate != null) {
	        data.setItemVisual(idx, 'symbolRotate', itemSymbolRotate);
	      }
	
	      if (itemSymbolKeepAspect != null) {
	        data.setItemVisual(idx, 'symbolKeepAspect', itemSymbolKeepAspect);
	      }
	    }
	
	    return {
	      dataEach: data.hasItemOption ? dataEach : null
	    };
	  }
	};
	exports.dataSymbolTask = dataSymbolTask;

/***/ },
/* 379 */
/***/ function(module, exports, __webpack_require__) {

	const Socket = __webpack_require__(380);
	
	module.exports = (uri, opts) => new Socket(uri, opts);
	
	/**
	 * Expose deps for legacy compatibility
	 * and standalone browser access.
	 */
	
	module.exports.Socket = Socket;
	module.exports.protocol = Socket.protocol; // this is an int
	module.exports.Transport = __webpack_require__(97);
	module.exports.transports = __webpack_require__(157);
	module.exports.parser = __webpack_require__(57);


/***/ },
/* 380 */
/***/ function(module, exports, __webpack_require__) {

	const transports = __webpack_require__(157);
	const Emitter = __webpack_require__(44);
	const debug = __webpack_require__(72)("engine.io-client:socket");
	const parser = __webpack_require__(57);
	const parseuri = __webpack_require__(163);
	const parseqs = __webpack_require__(99);
	
	class Socket extends Emitter {
	  /**
	   * Socket constructor.
	   *
	   * @param {String|Object} uri or options
	   * @param {Object} options
	   * @api public
	   */
	  constructor(uri, opts = {}) {
	    super();
	
	    if (uri && "object" === typeof uri) {
	      opts = uri;
	      uri = null;
	    }
	
	    if (uri) {
	      uri = parseuri(uri);
	      opts.hostname = uri.host;
	      opts.secure = uri.protocol === "https" || uri.protocol === "wss";
	      opts.port = uri.port;
	      if (uri.query) opts.query = uri.query;
	    } else if (opts.host) {
	      opts.hostname = parseuri(opts.host).host;
	    }
	
	    this.secure =
	      null != opts.secure
	        ? opts.secure
	        : typeof location !== "undefined" && "https:" === location.protocol;
	
	    if (opts.hostname && !opts.port) {
	      // if no port is specified manually, use the protocol default
	      opts.port = this.secure ? "443" : "80";
	    }
	
	    this.hostname =
	      opts.hostname ||
	      (typeof location !== "undefined" ? location.hostname : "localhost");
	    this.port =
	      opts.port ||
	      (typeof location !== "undefined" && location.port
	        ? location.port
	        : this.secure
	        ? 443
	        : 80);
	
	    this.transports = opts.transports || ["polling", "websocket"];
	    this.readyState = "";
	    this.writeBuffer = [];
	    this.prevBufferLen = 0;
	
	    this.opts = Object.assign(
	      {
	        path: "/engine.io",
	        agent: false,
	        withCredentials: false,
	        upgrade: true,
	        jsonp: true,
	        timestampParam: "t",
	        rememberUpgrade: false,
	        rejectUnauthorized: true,
	        perMessageDeflate: {
	          threshold: 1024
	        },
	        transportOptions: {}
	      },
	      opts
	    );
	
	    this.opts.path = this.opts.path.replace(/\/$/, "") + "/";
	
	    if (typeof this.opts.query === "string") {
	      this.opts.query = parseqs.decode(this.opts.query);
	    }
	
	    // set on handshake
	    this.id = null;
	    this.upgrades = null;
	    this.pingInterval = null;
	    this.pingTimeout = null;
	
	    // set on heartbeat
	    this.pingTimeoutTimer = null;
	
	    this.open();
	  }
	
	  /**
	   * Creates transport of the given type.
	   *
	   * @param {String} transport name
	   * @return {Transport}
	   * @api private
	   */
	  createTransport(name) {
	    debug('creating transport "%s"', name);
	    const query = clone(this.opts.query);
	
	    // append engine.io protocol identifier
	    query.EIO = parser.protocol;
	
	    // transport name
	    query.transport = name;
	
	    // session id if we already have one
	    if (this.id) query.sid = this.id;
	
	    const opts = Object.assign(
	      {},
	      this.opts.transportOptions[name],
	      this.opts,
	      {
	        query,
	        socket: this,
	        hostname: this.hostname,
	        secure: this.secure,
	        port: this.port
	      }
	    );
	
	    debug("options: %j", opts);
	
	    return new transports[name](opts);
	  }
	
	  /**
	   * Initializes transport to use and starts probe.
	   *
	   * @api private
	   */
	  open() {
	    let transport;
	    if (
	      this.opts.rememberUpgrade &&
	      Socket.priorWebsocketSuccess &&
	      this.transports.indexOf("websocket") !== -1
	    ) {
	      transport = "websocket";
	    } else if (0 === this.transports.length) {
	      // Emit error on next tick so it can be listened to
	      const self = this;
	      setTimeout(function() {
	        self.emit("error", "No transports available");
	      }, 0);
	      return;
	    } else {
	      transport = this.transports[0];
	    }
	    this.readyState = "opening";
	
	    // Retry with the next transport if the transport is disabled (jsonp: false)
	    try {
	      transport = this.createTransport(transport);
	    } catch (e) {
	      debug("error while creating transport: %s", e);
	      this.transports.shift();
	      this.open();
	      return;
	    }
	
	    transport.open();
	    this.setTransport(transport);
	  }
	
	  /**
	   * Sets the current transport. Disables the existing one (if any).
	   *
	   * @api private
	   */
	  setTransport(transport) {
	    debug("setting transport %s", transport.name);
	    const self = this;
	
	    if (this.transport) {
	      debug("clearing existing transport %s", this.transport.name);
	      this.transport.removeAllListeners();
	    }
	
	    // set up transport
	    this.transport = transport;
	
	    // set up transport listeners
	    transport
	      .on("drain", function() {
	        self.onDrain();
	      })
	      .on("packet", function(packet) {
	        self.onPacket(packet);
	      })
	      .on("error", function(e) {
	        self.onError(e);
	      })
	      .on("close", function() {
	        self.onClose("transport close");
	      });
	  }
	
	  /**
	   * Probes a transport.
	   *
	   * @param {String} transport name
	   * @api private
	   */
	  probe(name) {
	    debug('probing transport "%s"', name);
	    let transport = this.createTransport(name, { probe: 1 });
	    let failed = false;
	    const self = this;
	
	    Socket.priorWebsocketSuccess = false;
	
	    function onTransportOpen() {
	      if (self.onlyBinaryUpgrades) {
	        const upgradeLosesBinary =
	          !this.supportsBinary && self.transport.supportsBinary;
	        failed = failed || upgradeLosesBinary;
	      }
	      if (failed) return;
	
	      debug('probe transport "%s" opened', name);
	      transport.send([{ type: "ping", data: "probe" }]);
	      transport.once("packet", function(msg) {
	        if (failed) return;
	        if ("pong" === msg.type && "probe" === msg.data) {
	          debug('probe transport "%s" pong', name);
	          self.upgrading = true;
	          self.emit("upgrading", transport);
	          if (!transport) return;
	          Socket.priorWebsocketSuccess = "websocket" === transport.name;
	
	          debug('pausing current transport "%s"', self.transport.name);
	          self.transport.pause(function() {
	            if (failed) return;
	            if ("closed" === self.readyState) return;
	            debug("changing transport and sending upgrade packet");
	
	            cleanup();
	
	            self.setTransport(transport);
	            transport.send([{ type: "upgrade" }]);
	            self.emit("upgrade", transport);
	            transport = null;
	            self.upgrading = false;
	            self.flush();
	          });
	        } else {
	          debug('probe transport "%s" failed', name);
	          const err = new Error("probe error");
	          err.transport = transport.name;
	          self.emit("upgradeError", err);
	        }
	      });
	    }
	
	    function freezeTransport() {
	      if (failed) return;
	
	      // Any callback called by transport should be ignored since now
	      failed = true;
	
	      cleanup();
	
	      transport.close();
	      transport = null;
	    }
	
	    // Handle any error that happens while probing
	    function onerror(err) {
	      const error = new Error("probe error: " + err);
	      error.transport = transport.name;
	
	      freezeTransport();
	
	      debug('probe transport "%s" failed because of error: %s', name, err);
	
	      self.emit("upgradeError", error);
	    }
	
	    function onTransportClose() {
	      onerror("transport closed");
	    }
	
	    // When the socket is closed while we're probing
	    function onclose() {
	      onerror("socket closed");
	    }
	
	    // When the socket is upgraded while we're probing
	    function onupgrade(to) {
	      if (transport && to.name !== transport.name) {
	        debug('"%s" works - aborting "%s"', to.name, transport.name);
	        freezeTransport();
	      }
	    }
	
	    // Remove all listeners on the transport and on self
	    function cleanup() {
	      transport.removeListener("open", onTransportOpen);
	      transport.removeListener("error", onerror);
	      transport.removeListener("close", onTransportClose);
	      self.removeListener("close", onclose);
	      self.removeListener("upgrading", onupgrade);
	    }
	
	    transport.once("open", onTransportOpen);
	    transport.once("error", onerror);
	    transport.once("close", onTransportClose);
	
	    this.once("close", onclose);
	    this.once("upgrading", onupgrade);
	
	    transport.open();
	  }
	
	  /**
	   * Called when connection is deemed open.
	   *
	   * @api public
	   */
	  onOpen() {
	    debug("socket open");
	    this.readyState = "open";
	    Socket.priorWebsocketSuccess = "websocket" === this.transport.name;
	    this.emit("open");
	    this.flush();
	
	    // we check for `readyState` in case an `open`
	    // listener already closed the socket
	    if (
	      "open" === this.readyState &&
	      this.opts.upgrade &&
	      this.transport.pause
	    ) {
	      debug("starting upgrade probes");
	      let i = 0;
	      const l = this.upgrades.length;
	      for (; i < l; i++) {
	        this.probe(this.upgrades[i]);
	      }
	    }
	  }
	
	  /**
	   * Handles a packet.
	   *
	   * @api private
	   */
	  onPacket(packet) {
	    if (
	      "opening" === this.readyState ||
	      "open" === this.readyState ||
	      "closing" === this.readyState
	    ) {
	      debug('socket receive: type "%s", data "%s"', packet.type, packet.data);
	
	      this.emit("packet", packet);
	
	      // Socket is live - any packet counts
	      this.emit("heartbeat");
	
	      switch (packet.type) {
	        case "open":
	          this.onHandshake(JSON.parse(packet.data));
	          break;
	
	        case "ping":
	          this.resetPingTimeout();
	          this.sendPacket("pong");
	          this.emit("pong");
	          break;
	
	        case "error":
	          const err = new Error("server error");
	          err.code = packet.data;
	          this.onError(err);
	          break;
	
	        case "message":
	          this.emit("data", packet.data);
	          this.emit("message", packet.data);
	          break;
	      }
	    } else {
	      debug('packet received with socket readyState "%s"', this.readyState);
	    }
	  }
	
	  /**
	   * Called upon handshake completion.
	   *
	   * @param {Object} handshake obj
	   * @api private
	   */
	  onHandshake(data) {
	    this.emit("handshake", data);
	    this.id = data.sid;
	    this.transport.query.sid = data.sid;
	    this.upgrades = this.filterUpgrades(data.upgrades);
	    this.pingInterval = data.pingInterval;
	    this.pingTimeout = data.pingTimeout;
	    this.onOpen();
	    // In case open handler closes socket
	    if ("closed" === this.readyState) return;
	    this.resetPingTimeout();
	  }
	
	  /**
	   * Sets and resets ping timeout timer based on server pings.
	   *
	   * @api private
	   */
	  resetPingTimeout() {
	    clearTimeout(this.pingTimeoutTimer);
	    this.pingTimeoutTimer = setTimeout(() => {
	      this.onClose("ping timeout");
	    }, this.pingInterval + this.pingTimeout);
	  }
	
	  /**
	   * Called on `drain` event
	   *
	   * @api private
	   */
	  onDrain() {
	    this.writeBuffer.splice(0, this.prevBufferLen);
	
	    // setting prevBufferLen = 0 is very important
	    // for example, when upgrading, upgrade packet is sent over,
	    // and a nonzero prevBufferLen could cause problems on `drain`
	    this.prevBufferLen = 0;
	
	    if (0 === this.writeBuffer.length) {
	      this.emit("drain");
	    } else {
	      this.flush();
	    }
	  }
	
	  /**
	   * Flush write buffers.
	   *
	   * @api private
	   */
	  flush() {
	    if (
	      "closed" !== this.readyState &&
	      this.transport.writable &&
	      !this.upgrading &&
	      this.writeBuffer.length
	    ) {
	      debug("flushing %d packets in socket", this.writeBuffer.length);
	      this.transport.send(this.writeBuffer);
	      // keep track of current length of writeBuffer
	      // splice writeBuffer and callbackBuffer on `drain`
	      this.prevBufferLen = this.writeBuffer.length;
	      this.emit("flush");
	    }
	  }
	
	  /**
	   * Sends a message.
	   *
	   * @param {String} message.
	   * @param {Function} callback function.
	   * @param {Object} options.
	   * @return {Socket} for chaining.
	   * @api public
	   */
	  write(msg, options, fn) {
	    this.sendPacket("message", msg, options, fn);
	    return this;
	  }
	
	  send(msg, options, fn) {
	    this.sendPacket("message", msg, options, fn);
	    return this;
	  }
	
	  /**
	   * Sends a packet.
	   *
	   * @param {String} packet type.
	   * @param {String} data.
	   * @param {Object} options.
	   * @param {Function} callback function.
	   * @api private
	   */
	  sendPacket(type, data, options, fn) {
	    if ("function" === typeof data) {
	      fn = data;
	      data = undefined;
	    }
	
	    if ("function" === typeof options) {
	      fn = options;
	      options = null;
	    }
	
	    if ("closing" === this.readyState || "closed" === this.readyState) {
	      return;
	    }
	
	    options = options || {};
	    options.compress = false !== options.compress;
	
	    const packet = {
	      type: type,
	      data: data,
	      options: options
	    };
	    this.emit("packetCreate", packet);
	    this.writeBuffer.push(packet);
	    if (fn) this.once("flush", fn);
	    this.flush();
	  }
	
	  /**
	   * Closes the connection.
	   *
	   * @api private
	   */
	  close() {
	    const self = this;
	
	    if ("opening" === this.readyState || "open" === this.readyState) {
	      this.readyState = "closing";
	
	      if (this.writeBuffer.length) {
	        this.once("drain", function() {
	          if (this.upgrading) {
	            waitForUpgrade();
	          } else {
	            close();
	          }
	        });
	      } else if (this.upgrading) {
	        waitForUpgrade();
	      } else {
	        close();
	      }
	    }
	
	    function close() {
	      self.onClose("forced close");
	      debug("socket closing - telling transport to close");
	      self.transport.close();
	    }
	
	    function cleanupAndClose() {
	      self.removeListener("upgrade", cleanupAndClose);
	      self.removeListener("upgradeError", cleanupAndClose);
	      close();
	    }
	
	    function waitForUpgrade() {
	      // wait for upgrade to finish since we can't send packets while pausing a transport
	      self.once("upgrade", cleanupAndClose);
	      self.once("upgradeError", cleanupAndClose);
	    }
	
	    return this;
	  }
	
	  /**
	   * Called upon transport error
	   *
	   * @api private
	   */
	  onError(err) {
	    debug("socket error %j", err);
	    Socket.priorWebsocketSuccess = false;
	    this.emit("error", err);
	    this.onClose("transport error", err);
	  }
	
	  /**
	   * Called upon transport close.
	   *
	   * @api private
	   */
	  onClose(reason, desc) {
	    if (
	      "opening" === this.readyState ||
	      "open" === this.readyState ||
	      "closing" === this.readyState
	    ) {
	      debug('socket close with reason: "%s"', reason);
	      const self = this;
	
	      // clear timers
	      clearTimeout(this.pingIntervalTimer);
	      clearTimeout(this.pingTimeoutTimer);
	
	      // stop event from firing again for transport
	      this.transport.removeAllListeners("close");
	
	      // ensure transport won't stay open
	      this.transport.close();
	
	      // ignore further transport communication
	      this.transport.removeAllListeners();
	
	      // set ready state
	      this.readyState = "closed";
	
	      // clear session id
	      this.id = null;
	
	      // emit close event
	      this.emit("close", reason, desc);
	
	      // clean buffers after, so users can still
	      // grab the buffers on `close` event
	      self.writeBuffer = [];
	      self.prevBufferLen = 0;
	    }
	  }
	
	  /**
	   * Filters upgrades, returning only those matching client transports.
	   *
	   * @param {Array} server upgrades
	   * @api private
	   *
	   */
	  filterUpgrades(upgrades) {
	    const filteredUpgrades = [];
	    let i = 0;
	    const j = upgrades.length;
	    for (; i < j; i++) {
	      if (~this.transports.indexOf(upgrades[i]))
	        filteredUpgrades.push(upgrades[i]);
	    }
	    return filteredUpgrades;
	  }
	}
	
	Socket.priorWebsocketSuccess = false;
	
	/**
	 * Protocol version.
	 *
	 * @api public
	 */
	
	Socket.protocol = parser.protocol; // this is an int
	
	function clone(obj) {
	  const o = {};
	  for (let i in obj) {
	    if (obj.hasOwnProperty(i)) {
	      o[i] = obj[i];
	    }
	  }
	  return o;
	}
	
	module.exports = Socket;


/***/ },
/* 381 */
/***/ function(module, exports, __webpack_require__) {

	const Polling = __webpack_require__(158);
	const globalThis = __webpack_require__(71);
	
	const rNewline = /\n/g;
	const rEscapedNewline = /\\n/g;
	
	/**
	 * Global JSONP callbacks.
	 */
	
	let callbacks;
	
	/**
	 * Noop.
	 */
	
	function empty() {}
	
	class JSONPPolling extends Polling {
	  /**
	   * JSONP Polling constructor.
	   *
	   * @param {Object} opts.
	   * @api public
	   */
	  constructor(opts) {
	    super(opts);
	
	    this.query = this.query || {};
	
	    // define global callbacks array if not present
	    // we do this here (lazily) to avoid unneeded global pollution
	    if (!callbacks) {
	      // we need to consider multiple engines in the same page
	      callbacks = globalThis.___eio = globalThis.___eio || [];
	    }
	
	    // callback identifier
	    this.index = callbacks.length;
	
	    // add callback to jsonp global
	    const self = this;
	    callbacks.push(function(msg) {
	      self.onData(msg);
	    });
	
	    // append to query string
	    this.query.j = this.index;
	
	    // prevent spurious errors from being emitted when the window is unloaded
	    if (typeof addEventListener === "function") {
	      addEventListener(
	        "beforeunload",
	        function() {
	          if (self.script) self.script.onerror = empty;
	        },
	        false
	      );
	    }
	  }
	
	  /**
	   * JSONP only supports binary as base64 encoded strings
	   */
	  get supportsBinary() {
	    return false;
	  }
	
	  /**
	   * Closes the socket.
	   *
	   * @api private
	   */
	  doClose() {
	    if (this.script) {
	      this.script.parentNode.removeChild(this.script);
	      this.script = null;
	    }
	
	    if (this.form) {
	      this.form.parentNode.removeChild(this.form);
	      this.form = null;
	      this.iframe = null;
	    }
	
	    super.doClose();
	  }
	
	  /**
	   * Starts a poll cycle.
	   *
	   * @api private
	   */
	  doPoll() {
	    const self = this;
	    const script = document.createElement("script");
	
	    if (this.script) {
	      this.script.parentNode.removeChild(this.script);
	      this.script = null;
	    }
	
	    script.async = true;
	    script.src = this.uri();
	    script.onerror = function(e) {
	      self.onError("jsonp poll error", e);
	    };
	
	    const insertAt = document.getElementsByTagName("script")[0];
	    if (insertAt) {
	      insertAt.parentNode.insertBefore(script, insertAt);
	    } else {
	      (document.head || document.body).appendChild(script);
	    }
	    this.script = script;
	
	    const isUAgecko =
	      "undefined" !== typeof navigator && /gecko/i.test(navigator.userAgent);
	
	    if (isUAgecko) {
	      setTimeout(function() {
	        const iframe = document.createElement("iframe");
	        document.body.appendChild(iframe);
	        document.body.removeChild(iframe);
	      }, 100);
	    }
	  }
	
	  /**
	   * Writes with a hidden iframe.
	   *
	   * @param {String} data to send
	   * @param {Function} called upon flush.
	   * @api private
	   */
	  doWrite(data, fn) {
	    const self = this;
	    let iframe;
	
	    if (!this.form) {
	      const form = document.createElement("form");
	      const area = document.createElement("textarea");
	      const id = (this.iframeId = "eio_iframe_" + this.index);
	
	      form.className = "socketio";
	      form.style.position = "absolute";
	      form.style.top = "-1000px";
	      form.style.left = "-1000px";
	      form.target = id;
	      form.method = "POST";
	      form.setAttribute("accept-charset", "utf-8");
	      area.name = "d";
	      form.appendChild(area);
	      document.body.appendChild(form);
	
	      this.form = form;
	      this.area = area;
	    }
	
	    this.form.action = this.uri();
	
	    function complete() {
	      initIframe();
	      fn();
	    }
	
	    function initIframe() {
	      if (self.iframe) {
	        try {
	          self.form.removeChild(self.iframe);
	        } catch (e) {
	          self.onError("jsonp polling iframe removal error", e);
	        }
	      }
	
	      try {
	        // ie6 dynamic iframes with target="" support (thanks Chris Lambacher)
	        const html = '<iframe src="javascript:0" name="' + self.iframeId + '">';
	        iframe = document.createElement(html);
	      } catch (e) {
	        iframe = document.createElement("iframe");
	        iframe.name = self.iframeId;
	        iframe.src = "javascript:0";
	      }
	
	      iframe.id = self.iframeId;
	
	      self.form.appendChild(iframe);
	      self.iframe = iframe;
	    }
	
	    initIframe();
	
	    // escape \n to prevent it from being converted into \r\n by some UAs
	    // double escaping is required for escaped new lines because unescaping of new lines can be done safely on server-side
	    data = data.replace(rEscapedNewline, "\\\n");
	    this.area.value = data.replace(rNewline, "\\n");
	
	    try {
	      this.form.submit();
	    } catch (e) {}
	
	    if (this.iframe.attachEvent) {
	      this.iframe.onreadystatechange = function() {
	        if (self.iframe.readyState === "complete") {
	          complete();
	        }
	      };
	    } else {
	      this.iframe.onload = complete;
	    }
	  }
	}
	
	module.exports = JSONPPolling;


/***/ },
/* 382 */
/***/ function(module, exports, __webpack_require__) {

	/* global attachEvent */
	
	const XMLHttpRequest = __webpack_require__(160);
	const Polling = __webpack_require__(158);
	const Emitter = __webpack_require__(44);
	const { pick } = __webpack_require__(159);
	const globalThis = __webpack_require__(71);
	
	const debug = __webpack_require__(72)("engine.io-client:polling-xhr");
	
	/**
	 * Empty function
	 */
	
	function empty() {}
	
	const hasXHR2 = (function() {
	  const xhr = new XMLHttpRequest({ xdomain: false });
	  return null != xhr.responseType;
	})();
	
	class XHR extends Polling {
	  /**
	   * XHR Polling constructor.
	   *
	   * @param {Object} opts
	   * @api public
	   */
	  constructor(opts) {
	    super(opts);
	
	    if (typeof location !== "undefined") {
	      const isSSL = "https:" === location.protocol;
	      let port = location.port;
	
	      // some user agents have empty `location.port`
	      if (!port) {
	        port = isSSL ? 443 : 80;
	      }
	
	      this.xd =
	        (typeof location !== "undefined" &&
	          opts.hostname !== location.hostname) ||
	        port !== opts.port;
	      this.xs = opts.secure !== isSSL;
	    }
	    /**
	     * XHR supports binary
	     */
	    const forceBase64 = opts && opts.forceBase64;
	    this.supportsBinary = hasXHR2 && !forceBase64;
	  }
	
	  /**
	   * Creates a request.
	   *
	   * @param {String} method
	   * @api private
	   */
	  request(opts = {}) {
	    Object.assign(opts, { xd: this.xd, xs: this.xs }, this.opts);
	    return new Request(this.uri(), opts);
	  }
	
	  /**
	   * Sends data.
	   *
	   * @param {String} data to send.
	   * @param {Function} called upon flush.
	   * @api private
	   */
	  doWrite(data, fn) {
	    const req = this.request({
	      method: "POST",
	      data: data
	    });
	    const self = this;
	    req.on("success", fn);
	    req.on("error", function(err) {
	      self.onError("xhr post error", err);
	    });
	  }
	
	  /**
	   * Starts a poll cycle.
	   *
	   * @api private
	   */
	  doPoll() {
	    debug("xhr poll");
	    const req = this.request();
	    const self = this;
	    req.on("data", function(data) {
	      self.onData(data);
	    });
	    req.on("error", function(err) {
	      self.onError("xhr poll error", err);
	    });
	    this.pollXhr = req;
	  }
	}
	
	class Request extends Emitter {
	  /**
	   * Request constructor
	   *
	   * @param {Object} options
	   * @api public
	   */
	  constructor(uri, opts) {
	    super();
	    this.opts = opts;
	
	    this.method = opts.method || "GET";
	    this.uri = uri;
	    this.async = false !== opts.async;
	    this.data = undefined !== opts.data ? opts.data : null;
	
	    this.create();
	  }
	
	  /**
	   * Creates the XHR object and sends the request.
	   *
	   * @api private
	   */
	  create() {
	    const opts = pick(
	      this.opts,
	      "agent",
	      "enablesXDR",
	      "pfx",
	      "key",
	      "passphrase",
	      "cert",
	      "ca",
	      "ciphers",
	      "rejectUnauthorized"
	    );
	    opts.xdomain = !!this.opts.xd;
	    opts.xscheme = !!this.opts.xs;
	
	    const xhr = (this.xhr = new XMLHttpRequest(opts));
	    const self = this;
	
	    try {
	      debug("xhr open %s: %s", this.method, this.uri);
	      xhr.open(this.method, this.uri, this.async);
	      try {
	        if (this.opts.extraHeaders) {
	          xhr.setDisableHeaderCheck && xhr.setDisableHeaderCheck(true);
	          for (let i in this.opts.extraHeaders) {
	            if (this.opts.extraHeaders.hasOwnProperty(i)) {
	              xhr.setRequestHeader(i, this.opts.extraHeaders[i]);
	            }
	          }
	        }
	      } catch (e) {}
	
	      if ("POST" === this.method) {
	        try {
	          xhr.setRequestHeader("Content-type", "text/plain;charset=UTF-8");
	        } catch (e) {}
	      }
	
	      try {
	        xhr.setRequestHeader("Accept", "*/*");
	      } catch (e) {}
	
	      // ie6 check
	      if ("withCredentials" in xhr) {
	        xhr.withCredentials = this.opts.withCredentials;
	      }
	
	      if (this.opts.requestTimeout) {
	        xhr.timeout = this.opts.requestTimeout;
	      }
	
	      if (this.hasXDR()) {
	        xhr.onload = function() {
	          self.onLoad();
	        };
	        xhr.onerror = function() {
	          self.onError(xhr.responseText);
	        };
	      } else {
	        xhr.onreadystatechange = function() {
	          if (4 !== xhr.readyState) return;
	          if (200 === xhr.status || 1223 === xhr.status) {
	            self.onLoad();
	          } else {
	            // make sure the `error` event handler that's user-set
	            // does not throw in the same tick and gets caught here
	            setTimeout(function() {
	              self.onError(typeof xhr.status === "number" ? xhr.status : 0);
	            }, 0);
	          }
	        };
	      }
	
	      debug("xhr data %s", this.data);
	      xhr.send(this.data);
	    } catch (e) {
	      // Need to defer since .create() is called directly from the constructor
	      // and thus the 'error' event can only be only bound *after* this exception
	      // occurs.  Therefore, also, we cannot throw here at all.
	      setTimeout(function() {
	        self.onError(e);
	      }, 0);
	      return;
	    }
	
	    if (typeof document !== "undefined") {
	      this.index = Request.requestsCount++;
	      Request.requests[this.index] = this;
	    }
	  }
	
	  /**
	   * Called upon successful response.
	   *
	   * @api private
	   */
	  onSuccess() {
	    this.emit("success");
	    this.cleanup();
	  }
	
	  /**
	   * Called if we have data.
	   *
	   * @api private
	   */
	  onData(data) {
	    this.emit("data", data);
	    this.onSuccess();
	  }
	
	  /**
	   * Called upon error.
	   *
	   * @api private
	   */
	  onError(err) {
	    this.emit("error", err);
	    this.cleanup(true);
	  }
	
	  /**
	   * Cleans up house.
	   *
	   * @api private
	   */
	  cleanup(fromError) {
	    if ("undefined" === typeof this.xhr || null === this.xhr) {
	      return;
	    }
	    // xmlhttprequest
	    if (this.hasXDR()) {
	      this.xhr.onload = this.xhr.onerror = empty;
	    } else {
	      this.xhr.onreadystatechange = empty;
	    }
	
	    if (fromError) {
	      try {
	        this.xhr.abort();
	      } catch (e) {}
	    }
	
	    if (typeof document !== "undefined") {
	      delete Request.requests[this.index];
	    }
	
	    this.xhr = null;
	  }
	
	  /**
	   * Called upon load.
	   *
	   * @api private
	   */
	  onLoad() {
	    const data = this.xhr.responseText;
	    if (data !== null) {
	      this.onData(data);
	    }
	  }
	
	  /**
	   * Check if it has XDomainRequest.
	   *
	   * @api private
	   */
	  hasXDR() {
	    return typeof XDomainRequest !== "undefined" && !this.xs && this.enablesXDR;
	  }
	
	  /**
	   * Aborts the request.
	   *
	   * @api public
	   */
	  abort() {
	    this.cleanup();
	  }
	}
	
	/**
	 * Aborts pending requests when unloading the window. This is needed to prevent
	 * memory leaks (e.g. when using IE) and to ensure that no spurious error is
	 * emitted.
	 */
	
	Request.requestsCount = 0;
	Request.requests = {};
	
	if (typeof document !== "undefined") {
	  if (typeof attachEvent === "function") {
	    attachEvent("onunload", unloadHandler);
	  } else if (typeof addEventListener === "function") {
	    const terminationEvent = "onpagehide" in globalThis ? "pagehide" : "unload";
	    addEventListener(terminationEvent, unloadHandler, false);
	  }
	}
	
	function unloadHandler() {
	  for (let i in Request.requests) {
	    if (Request.requests.hasOwnProperty(i)) {
	      Request.requests[i].abort();
	    }
	  }
	}
	
	module.exports = XHR;
	module.exports.Request = Request;


/***/ },
/* 383 */
/***/ function(module, exports, __webpack_require__) {

	const globalThis = __webpack_require__(71);
	
	module.exports = {
	  WebSocket: globalThis.WebSocket || globalThis.MozWebSocket,
	  usingBrowserWebSocket: true,
	  defaultBinaryType: "arraybuffer"
	};


/***/ },
/* 384 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(Buffer) {const Transport = __webpack_require__(97);
	const parser = __webpack_require__(57);
	const parseqs = __webpack_require__(99);
	const yeast = __webpack_require__(176);
	const { pick } = __webpack_require__(159);
	const {
	  WebSocket,
	  usingBrowserWebSocket,
	  defaultBinaryType
	} = __webpack_require__(383);
	
	const debug = __webpack_require__(72)("engine.io-client:websocket");
	
	// detect ReactNative environment
	const isReactNative =
	  typeof navigator !== "undefined" &&
	  typeof navigator.product === "string" &&
	  navigator.product.toLowerCase() === "reactnative";
	
	class WS extends Transport {
	  /**
	   * WebSocket transport constructor.
	   *
	   * @api {Object} connection options
	   * @api public
	   */
	  constructor(opts) {
	    super(opts);
	
	    this.supportsBinary = !opts.forceBase64;
	  }
	
	  /**
	   * Transport name.
	   *
	   * @api public
	   */
	  get name() {
	    return "websocket";
	  }
	
	  /**
	   * Opens socket.
	   *
	   * @api private
	   */
	  doOpen() {
	    if (!this.check()) {
	      // let probe timeout
	      return;
	    }
	
	    const uri = this.uri();
	    const protocols = this.opts.protocols;
	
	    // React Native only supports the 'headers' option, and will print a warning if anything else is passed
	    const opts = isReactNative
	      ? {}
	      : pick(
	          this.opts,
	          "agent",
	          "perMessageDeflate",
	          "pfx",
	          "key",
	          "passphrase",
	          "cert",
	          "ca",
	          "ciphers",
	          "rejectUnauthorized",
	          "localAddress",
	          "protocolVersion",
	          "origin",
	          "maxPayload",
	          "family",
	          "checkServerIdentity"
	        );
	
	    if (this.opts.extraHeaders) {
	      opts.headers = this.opts.extraHeaders;
	    }
	
	    try {
	      this.ws =
	        usingBrowserWebSocket && !isReactNative
	          ? protocols
	            ? new WebSocket(uri, protocols)
	            : new WebSocket(uri)
	          : new WebSocket(uri, protocols, opts);
	    } catch (err) {
	      return this.emit("error", err);
	    }
	
	    this.ws.binaryType = this.socket.binaryType || defaultBinaryType;
	
	    this.addEventListeners();
	  }
	
	  /**
	   * Adds event listeners to the socket
	   *
	   * @api private
	   */
	  addEventListeners() {
	    const self = this;
	
	    this.ws.onopen = function() {
	      self.onOpen();
	    };
	    this.ws.onclose = function() {
	      self.onClose();
	    };
	    this.ws.onmessage = function(ev) {
	      self.onData(ev.data);
	    };
	    this.ws.onerror = function(e) {
	      self.onError("websocket error", e);
	    };
	  }
	
	  /**
	   * Writes data to socket.
	   *
	   * @param {Array} array of packets.
	   * @api private
	   */
	  write(packets) {
	    const self = this;
	    this.writable = false;
	
	    // encodePacket efficient as it uses WS framing
	    // no need for encodePayload
	    let total = packets.length;
	    let i = 0;
	    const l = total;
	    for (; i < l; i++) {
	      (function(packet) {
	        parser.encodePacket(packet, self.supportsBinary, function(data) {
	          // always create a new object (GH-437)
	          const opts = {};
	          if (!usingBrowserWebSocket) {
	            if (packet.options) {
	              opts.compress = packet.options.compress;
	            }
	
	            if (self.opts.perMessageDeflate) {
	              const len =
	                "string" === typeof data
	                  ? Buffer.byteLength(data)
	                  : data.length;
	              if (len < self.opts.perMessageDeflate.threshold) {
	                opts.compress = false;
	              }
	            }
	          }
	
	          // Sometimes the websocket has already been closed but the browser didn't
	          // have a chance of informing us about it yet, in that case send will
	          // throw an error
	          try {
	            if (usingBrowserWebSocket) {
	              // TypeError is thrown when passing the second argument on Safari
	              self.ws.send(data);
	            } else {
	              self.ws.send(data, opts);
	            }
	          } catch (e) {
	            debug("websocket closed before onclose event");
	          }
	
	          --total || done();
	        });
	      })(packets[i]);
	    }
	
	    function done() {
	      self.emit("flush");
	
	      // fake drain
	      // defer to next tick to allow Socket to clear writeBuffer
	      setTimeout(function() {
	        self.writable = true;
	        self.emit("drain");
	      }, 0);
	    }
	  }
	
	  /**
	   * Called upon close
	   *
	   * @api private
	   */
	  onClose() {
	    Transport.prototype.onClose.call(this);
	  }
	
	  /**
	   * Closes socket.
	   *
	   * @api private
	   */
	  doClose() {
	    if (typeof this.ws !== "undefined") {
	      this.ws.close();
	    }
	  }
	
	  /**
	   * Generates uri for connection.
	   *
	   * @api private
	   */
	  uri() {
	    let query = this.query || {};
	    const schema = this.opts.secure ? "wss" : "ws";
	    let port = "";
	
	    // avoid port if default for schema
	    if (
	      this.opts.port &&
	      (("wss" === schema && Number(this.opts.port) !== 443) ||
	        ("ws" === schema && Number(this.opts.port) !== 80))
	    ) {
	      port = ":" + this.opts.port;
	    }
	
	    // append timestamp to URI
	    if (this.opts.timestampRequests) {
	      query[this.opts.timestampParam] = yeast();
	    }
	
	    // communicate binary support capabilities
	    if (!this.supportsBinary) {
	      query.b64 = 1;
	    }
	
	    query = parseqs.encode(query);
	
	    // prepend ? to query
	    if (query.length) {
	      query = "?" + query;
	    }
	
	    const ipv6 = this.opts.hostname.indexOf(":") !== -1;
	    return (
	      schema +
	      "://" +
	      (ipv6 ? "[" + this.opts.hostname + "]" : this.opts.hostname) +
	      port +
	      this.opts.path +
	      query
	    );
	  }
	
	  /**
	   * Feature detection for WebSocket.
	   *
	   * @return {Boolean} whether this transport is available.
	   * @api public
	   */
	  check() {
	    return (
	      !!WebSocket &&
	      !("__initialize" in WebSocket && this.name === WS.prototype.name)
	    );
	  }
	}
	
	module.exports = WS;
	
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(288).Buffer))

/***/ },
/* 385 */
[486, 386],
/* 386 */
/***/ function(module, exports) {

	/**
	 * Helpers.
	 */
	
	var s = 1000;
	var m = s * 60;
	var h = m * 60;
	var d = h * 24;
	var w = d * 7;
	var y = d * 365.25;
	
	/**
	 * Parse or format the given `val`.
	 *
	 * Options:
	 *
	 *  - `long` verbose formatting [false]
	 *
	 * @param {String|Number} val
	 * @param {Object} [options]
	 * @throws {Error} throw an error if val is not a non-empty string or a number
	 * @return {String|Number}
	 * @api public
	 */
	
	module.exports = function(val, options) {
	  options = options || {};
	  var type = typeof val;
	  if (type === 'string' && val.length > 0) {
	    return parse(val);
	  } else if (type === 'number' && isFinite(val)) {
	    return options.long ? fmtLong(val) : fmtShort(val);
	  }
	  throw new Error(
	    'val is not a non-empty string or a valid number. val=' +
	      JSON.stringify(val)
	  );
	};
	
	/**
	 * Parse the given `str` and return milliseconds.
	 *
	 * @param {String} str
	 * @return {Number}
	 * @api private
	 */
	
	function parse(str) {
	  str = String(str);
	  if (str.length > 100) {
	    return;
	  }
	  var match = /^(-?(?:\d+)?\.?\d+) *(milliseconds?|msecs?|ms|seconds?|secs?|s|minutes?|mins?|m|hours?|hrs?|h|days?|d|weeks?|w|years?|yrs?|y)?$/i.exec(
	    str
	  );
	  if (!match) {
	    return;
	  }
	  var n = parseFloat(match[1]);
	  var type = (match[2] || 'ms').toLowerCase();
	  switch (type) {
	    case 'years':
	    case 'year':
	    case 'yrs':
	    case 'yr':
	    case 'y':
	      return n * y;
	    case 'weeks':
	    case 'week':
	    case 'w':
	      return n * w;
	    case 'days':
	    case 'day':
	    case 'd':
	      return n * d;
	    case 'hours':
	    case 'hour':
	    case 'hrs':
	    case 'hr':
	    case 'h':
	      return n * h;
	    case 'minutes':
	    case 'minute':
	    case 'mins':
	    case 'min':
	    case 'm':
	      return n * m;
	    case 'seconds':
	    case 'second':
	    case 'secs':
	    case 'sec':
	    case 's':
	      return n * s;
	    case 'milliseconds':
	    case 'millisecond':
	    case 'msecs':
	    case 'msec':
	    case 'ms':
	      return n;
	    default:
	      return undefined;
	  }
	}
	
	/**
	 * Short format for `ms`.
	 *
	 * @param {Number} ms
	 * @return {String}
	 * @api private
	 */
	
	function fmtShort(ms) {
	  var msAbs = Math.abs(ms);
	  if (msAbs >= d) {
	    return Math.round(ms / d) + 'd';
	  }
	  if (msAbs >= h) {
	    return Math.round(ms / h) + 'h';
	  }
	  if (msAbs >= m) {
	    return Math.round(ms / m) + 'm';
	  }
	  if (msAbs >= s) {
	    return Math.round(ms / s) + 's';
	  }
	  return ms + 'ms';
	}
	
	/**
	 * Long format for `ms`.
	 *
	 * @param {Number} ms
	 * @return {String}
	 * @api private
	 */
	
	function fmtLong(ms) {
	  var msAbs = Math.abs(ms);
	  if (msAbs >= d) {
	    return plural(ms, msAbs, d, 'day');
	  }
	  if (msAbs >= h) {
	    return plural(ms, msAbs, h, 'hour');
	  }
	  if (msAbs >= m) {
	    return plural(ms, msAbs, m, 'minute');
	  }
	  if (msAbs >= s) {
	    return plural(ms, msAbs, s, 'second');
	  }
	  return ms + ' ms';
	}
	
	/**
	 * Pluralization helper.
	 */
	
	function plural(ms, msAbs, n, name) {
	  var isPlural = msAbs >= n * 1.5;
	  return Math.round(ms / n) + ' ' + name + (isPlural ? 's' : '');
	}


/***/ },
/* 387 */
/***/ function(module, exports, __webpack_require__) {

	const { PACKET_TYPES_REVERSE, ERROR_PACKET } = __webpack_require__(161);
	
	const withNativeArrayBuffer = typeof ArrayBuffer === "function";
	
	let base64decoder;
	if (withNativeArrayBuffer) {
	  base64decoder = __webpack_require__(286);
	}
	
	const decodePacket = (encodedPacket, binaryType) => {
	  if (typeof encodedPacket !== "string") {
	    return {
	      type: "message",
	      data: mapBinary(encodedPacket, binaryType)
	    };
	  }
	  const type = encodedPacket.charAt(0);
	  if (type === "b") {
	    return {
	      type: "message",
	      data: decodeBase64Packet(encodedPacket.substring(1), binaryType)
	    };
	  }
	  const packetType = PACKET_TYPES_REVERSE[type];
	  if (!packetType) {
	    return ERROR_PACKET;
	  }
	  return encodedPacket.length > 1
	    ? {
	        type: PACKET_TYPES_REVERSE[type],
	        data: encodedPacket.substring(1)
	      }
	    : {
	        type: PACKET_TYPES_REVERSE[type]
	      };
	};
	
	const decodeBase64Packet = (data, binaryType) => {
	  if (base64decoder) {
	    const decoded = base64decoder.decode(data);
	    return mapBinary(decoded, binaryType);
	  } else {
	    return { base64: true, data }; // fallback for old browsers
	  }
	};
	
	const mapBinary = (data, binaryType) => {
	  switch (binaryType) {
	    case "blob":
	      return data instanceof ArrayBuffer ? new Blob([data]) : data;
	    case "arraybuffer":
	    default:
	      return data; // assuming the data is already an ArrayBuffer
	  }
	};
	
	module.exports = decodePacket;


/***/ },
/* 388 */
/***/ function(module, exports, __webpack_require__) {

	const { PACKET_TYPES } = __webpack_require__(161);
	
	const withNativeBlob =
	  typeof Blob === "function" ||
	  (typeof Blob !== "undefined" &&
	    Object.prototype.toString.call(Blob) === "[object BlobConstructor]");
	const withNativeArrayBuffer = typeof ArrayBuffer === "function";
	
	// ArrayBuffer.isView method is not defined in IE10
	const isView = obj => {
	  return typeof ArrayBuffer.isView === "function"
	    ? ArrayBuffer.isView(obj)
	    : obj && obj.buffer instanceof ArrayBuffer;
	};
	
	const encodePacket = ({ type, data }, supportsBinary, callback) => {
	  if (withNativeBlob && data instanceof Blob) {
	    if (supportsBinary) {
	      return callback(data);
	    } else {
	      return encodeBlobAsBase64(data, callback);
	    }
	  } else if (
	    withNativeArrayBuffer &&
	    (data instanceof ArrayBuffer || isView(data))
	  ) {
	    if (supportsBinary) {
	      return callback(data instanceof ArrayBuffer ? data : data.buffer);
	    } else {
	      return encodeBlobAsBase64(new Blob([data]), callback);
	    }
	  }
	  // plain string
	  return callback(PACKET_TYPES[type] + (data || ""));
	};
	
	const encodeBlobAsBase64 = (data, callback) => {
	  const fileReader = new FileReader();
	  fileReader.onload = function() {
	    const content = fileReader.result.split(",")[1];
	    callback("b" + content);
	  };
	  return fileReader.readAsDataURL(data);
	};
	
	module.exports = encodePacket;


/***/ },
/* 389 */
/***/ function(module, exports) {

	// removed by extract-text-webpack-plugin

/***/ },
/* 390 */
389,
/* 391 */
389,
/* 392 */
389,
/* 393 */
389,
/* 394 */
/***/ function(module, exports) {

	/* WEBPACK VAR INJECTION */(function(global) {// @flow
	'use strict';
	
	var key = '__global_unique_id__';
	
	module.exports = function() {
	  return global[key] = (global[key] || 0) + 1;
	};
	
	/* WEBPACK VAR INJECTION */}.call(exports, (function() { return this; }())))

/***/ },
/* 395 */
/***/ function(module, exports) {

	
	/**
	 * Module exports.
	 *
	 * Logic borrowed from Modernizr:
	 *
	 *   - https://github.com/Modernizr/Modernizr/blob/master/feature-detects/cors.js
	 */
	
	try {
	  module.exports = typeof XMLHttpRequest !== 'undefined' &&
	    'withCredentials' in new XMLHttpRequest();
	} catch (err) {
	  // if XMLHttp support is disabled in IE then it will throw
	  // when trying to create
	  module.exports = false;
	}


/***/ },
/* 396 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";function _interopDefault(t){return t&&"object"==typeof t&&"default"in t?t.default:t}Object.defineProperty(exports,"__esModule",{value:!0});var resolvePathname=_interopDefault(__webpack_require__(422)),valueEqual=_interopDefault(__webpack_require__(440));__webpack_require__(76);var invariant=_interopDefault(__webpack_require__(103));function _extends(){return(_extends=Object.assign||function(t){for(var n=1;n<arguments.length;n++){var e=arguments[n];for(var a in e)Object.prototype.hasOwnProperty.call(e,a)&&(t[a]=e[a])}return t}).apply(this,arguments)}function addLeadingSlash(t){return"/"===t.charAt(0)?t:"/"+t}function stripLeadingSlash(t){return"/"===t.charAt(0)?t.substr(1):t}function hasBasename(t,n){return 0===t.toLowerCase().indexOf(n.toLowerCase())&&-1!=="/?#".indexOf(t.charAt(n.length))}function stripBasename(t,n){return hasBasename(t,n)?t.substr(n.length):t}function stripTrailingSlash(t){return"/"===t.charAt(t.length-1)?t.slice(0,-1):t}function parsePath(t){var n=t||"/",e="",a="",r=n.indexOf("#");-1!==r&&(a=n.substr(r),n=n.substr(0,r));var o=n.indexOf("?");return-1!==o&&(e=n.substr(o),n=n.substr(0,o)),{pathname:n,search:"?"===e?"":e,hash:"#"===a?"":a}}function createPath(t){var n=t.pathname,e=t.search,a=t.hash,r=n||"/";return e&&"?"!==e&&(r+="?"===e.charAt(0)?e:"?"+e),a&&"#"!==a&&(r+="#"===a.charAt(0)?a:"#"+a),r}function createLocation(t,n,e,a){var r;"string"==typeof t?(r=parsePath(t)).state=n:(void 0===(r=_extends({},t)).pathname&&(r.pathname=""),r.search?"?"!==r.search.charAt(0)&&(r.search="?"+r.search):r.search="",r.hash?"#"!==r.hash.charAt(0)&&(r.hash="#"+r.hash):r.hash="",void 0!==n&&void 0===r.state&&(r.state=n));try{r.pathname=decodeURI(r.pathname)}catch(t){throw t instanceof URIError?new URIError('Pathname "'+r.pathname+'" could not be decoded. This is likely caused by an invalid percent-encoding.'):t}return e&&(r.key=e),a?r.pathname?"/"!==r.pathname.charAt(0)&&(r.pathname=resolvePathname(r.pathname,a.pathname)):r.pathname=a.pathname:r.pathname||(r.pathname="/"),r}function locationsAreEqual(t,n){return t.pathname===n.pathname&&t.search===n.search&&t.hash===n.hash&&t.key===n.key&&valueEqual(t.state,n.state)}function createTransitionManager(){var o=null;var a=[];return{setPrompt:function(t){return o=t,function(){o===t&&(o=null)}},confirmTransitionTo:function(t,n,e,a){if(null!=o){var r="function"==typeof o?o(t,n):o;"string"==typeof r?"function"==typeof e?e(r,a):a(!0):a(!1!==r)}else a(!0)},appendListener:function(t){var n=!0;function e(){n&&t.apply(void 0,arguments)}return a.push(e),function(){n=!1,a=a.filter(function(t){return t!==e})}},notifyListeners:function(){for(var t=arguments.length,n=new Array(t),e=0;e<t;e++)n[e]=arguments[e];a.forEach(function(t){return t.apply(void 0,n)})}}}var canUseDOM=!("undefined"==typeof window||!window.document||!window.document.createElement);function getConfirmation(t,n){n(window.confirm(t))}function supportsHistory(){var t=window.navigator.userAgent;return(-1===t.indexOf("Android 2.")&&-1===t.indexOf("Android 4.0")||-1===t.indexOf("Mobile Safari")||-1!==t.indexOf("Chrome")||-1!==t.indexOf("Windows Phone"))&&(window.history&&"pushState"in window.history)}function supportsPopStateOnHashChange(){return-1===window.navigator.userAgent.indexOf("Trident")}function supportsGoWithoutReloadUsingHash(){return-1===window.navigator.userAgent.indexOf("Firefox")}function isExtraneousPopstateEvent(t){return void 0===t.state&&-1===navigator.userAgent.indexOf("CriOS")}var PopStateEvent="popstate",HashChangeEvent="hashchange";function getHistoryState(){try{return window.history.state||{}}catch(t){return{}}}function createBrowserHistory(t){void 0===t&&(t={}),canUseDOM||invariant(!1);var s=window.history,c=supportsHistory(),n=!supportsPopStateOnHashChange(),e=t,a=e.forceRefresh,h=void 0!==a&&a,r=e.getUserConfirmation,u=void 0===r?getConfirmation:r,o=e.keyLength,i=void 0===o?6:o,f=t.basename?stripTrailingSlash(addLeadingSlash(t.basename)):"";function l(t){var n=t||{},e=n.key,a=n.state,r=window.location,o=r.pathname+r.search+r.hash;return f&&(o=stripBasename(o,f)),createLocation(o,a,e)}function d(){return Math.random().toString(36).substr(2,i)}var v=createTransitionManager();function p(t){_extends(T,t),T.length=s.length,v.notifyListeners(T.location,T.action)}function g(t){isExtraneousPopstateEvent(t)||w(l(t.state))}function P(){w(l(getHistoryState()))}var m=!1;function w(n){if(m)m=!1,p();else{v.confirmTransitionTo(n,"POP",u,function(t){t?p({action:"POP",location:n}):function(t){var n=T.location,e=H.indexOf(n.key);-1===e&&(e=0);var a=H.indexOf(t.key);-1===a&&(a=0);var r=e-a;r&&(m=!0,L(r))}(n)})}}var y=l(getHistoryState()),H=[y.key];function x(t){return f+createPath(t)}function L(t){s.go(t)}var O=0;function E(t){1===(O+=t)&&1===t?(window.addEventListener(PopStateEvent,g),n&&window.addEventListener(HashChangeEvent,P)):0===O&&(window.removeEventListener(PopStateEvent,g),n&&window.removeEventListener(HashChangeEvent,P))}var S=!1;var T={length:s.length,action:"POP",location:y,createHref:x,push:function(t,n){var i=createLocation(t,n,d(),T.location);v.confirmTransitionTo(i,"PUSH",u,function(t){if(t){var n=x(i),e=i.key,a=i.state;if(c)if(s.pushState({key:e,state:a},null,n),h)window.location.href=n;else{var r=H.indexOf(T.location.key),o=H.slice(0,r+1);o.push(i.key),H=o,p({action:"PUSH",location:i})}else window.location.href=n}})},replace:function(t,n){var o="REPLACE",i=createLocation(t,n,d(),T.location);v.confirmTransitionTo(i,o,u,function(t){if(t){var n=x(i),e=i.key,a=i.state;if(c)if(s.replaceState({key:e,state:a},null,n),h)window.location.replace(n);else{var r=H.indexOf(T.location.key);-1!==r&&(H[r]=i.key),p({action:o,location:i})}else window.location.replace(n)}})},go:L,goBack:function(){L(-1)},goForward:function(){L(1)},block:function(t){void 0===t&&(t=!1);var n=v.setPrompt(t);return S||(E(1),S=!0),function(){return S&&(S=!1,E(-1)),n()}},listen:function(t){var n=v.appendListener(t);return E(1),function(){E(-1),n()}}};return T}var HashChangeEvent$1="hashchange",HashPathCoders={hashbang:{encodePath:function(t){return"!"===t.charAt(0)?t:"!/"+stripLeadingSlash(t)},decodePath:function(t){return"!"===t.charAt(0)?t.substr(1):t}},noslash:{encodePath:stripLeadingSlash,decodePath:addLeadingSlash},slash:{encodePath:addLeadingSlash,decodePath:addLeadingSlash}};function stripHash(t){var n=t.indexOf("#");return-1===n?t:t.slice(0,n)}function getHashPath(){var t=window.location.href,n=t.indexOf("#");return-1===n?"":t.substring(n+1)}function pushHashPath(t){window.location.hash=t}function replaceHashPath(t){window.location.replace(stripHash(window.location.href)+"#"+t)}function createHashHistory(t){void 0===t&&(t={}),canUseDOM||invariant(!1);var n=window.history,e=(supportsGoWithoutReloadUsingHash(),t),a=e.getUserConfirmation,i=void 0===a?getConfirmation:a,r=e.hashType,o=void 0===r?"slash":r,s=t.basename?stripTrailingSlash(addLeadingSlash(t.basename)):"",c=HashPathCoders[o],h=c.encodePath,u=c.decodePath;function f(){var t=u(getHashPath());return s&&(t=stripBasename(t,s)),createLocation(t)}var l=createTransitionManager();function d(t){_extends(E,t),E.length=n.length,l.notifyListeners(E.location,E.action)}var v=!1,p=null;function g(){var t=getHashPath(),n=h(t);if(t!==n)replaceHashPath(n);else{var e=f(),a=E.location;if(!v&&function(t,n){return t.pathname===n.pathname&&t.search===n.search&&t.hash===n.hash}(a,e))return;if(p===createPath(e))return;p=null,function(n){if(v)v=!1,d();else{l.confirmTransitionTo(n,"POP",i,function(t){t?d({action:"POP",location:n}):function(t){var n=E.location,e=y.lastIndexOf(createPath(n));-1===e&&(e=0);var a=y.lastIndexOf(createPath(t));-1===a&&(a=0);var r=e-a;r&&(v=!0,H(r))}(n)})}}(e)}}var P=getHashPath(),m=h(P);P!==m&&replaceHashPath(m);var w=f(),y=[createPath(w)];function H(t){n.go(t)}var x=0;function L(t){1===(x+=t)&&1===t?window.addEventListener(HashChangeEvent$1,g):0===x&&window.removeEventListener(HashChangeEvent$1,g)}var O=!1;var E={length:n.length,action:"POP",location:w,createHref:function(t){var n=document.querySelector("base"),e="";return n&&n.getAttribute("href")&&(e=stripHash(window.location.href)),e+"#"+h(s+createPath(t))},push:function(t,n){var o=createLocation(t,void 0,void 0,E.location);l.confirmTransitionTo(o,"PUSH",i,function(t){if(t){var n=createPath(o),e=h(s+n);if(getHashPath()!==e){p=n,pushHashPath(e);var a=y.lastIndexOf(createPath(E.location)),r=y.slice(0,a+1);r.push(n),y=r,d({action:"PUSH",location:o})}else d()}})},replace:function(t,n){var r="REPLACE",o=createLocation(t,void 0,void 0,E.location);l.confirmTransitionTo(o,r,i,function(t){if(t){var n=createPath(o),e=h(s+n);getHashPath()!==e&&(p=n,replaceHashPath(e));var a=y.indexOf(createPath(E.location));-1!==a&&(y[a]=n),d({action:r,location:o})}})},go:H,goBack:function(){H(-1)},goForward:function(){H(1)},block:function(t){void 0===t&&(t=!1);var n=l.setPrompt(t);return O||(L(1),O=!0),function(){return O&&(O=!1,L(-1)),n()}},listen:function(t){var n=l.appendListener(t);return L(1),function(){L(-1),n()}}};return E}function clamp(t,n,e){return Math.min(Math.max(t,n),e)}function createMemoryHistory(t){void 0===t&&(t={});var n=t,r=n.getUserConfirmation,e=n.initialEntries,a=void 0===e?["/"]:e,o=n.initialIndex,i=void 0===o?0:o,s=n.keyLength,c=void 0===s?6:s,h=createTransitionManager();function u(t){_extends(g,t),g.length=g.entries.length,h.notifyListeners(g.location,g.action)}function f(){return Math.random().toString(36).substr(2,c)}var l=clamp(i,0,a.length-1),d=a.map(function(t){return createLocation(t,void 0,"string"==typeof t?f():t.key||f())}),v=createPath;function p(t){var n=clamp(g.index+t,0,g.entries.length-1),e=g.entries[n];h.confirmTransitionTo(e,"POP",r,function(t){t?u({action:"POP",location:e,index:n}):u()})}var g={length:d.length,action:"POP",location:d[l],index:l,entries:d,createHref:v,push:function(t,n){var a=createLocation(t,n,f(),g.location);h.confirmTransitionTo(a,"PUSH",r,function(t){if(t){var n=g.index+1,e=g.entries.slice(0);e.length>n?e.splice(n,e.length-n,a):e.push(a),u({action:"PUSH",location:a,index:n,entries:e})}})},replace:function(t,n){var e="REPLACE",a=createLocation(t,n,f(),g.location);h.confirmTransitionTo(a,e,r,function(t){t&&(g.entries[g.index]=a,u({action:e,location:a}))})},go:p,goBack:function(){p(-1)},goForward:function(){p(1)},canGo:function(t){var n=g.index+t;return 0<=n&&n<g.entries.length},block:function(t){return void 0===t&&(t=!1),h.setPrompt(t)},listen:function(t){return h.appendListener(t)}};return g}exports.createBrowserHistory=createBrowserHistory,exports.createHashHistory=createHashHistory,exports.createMemoryHistory=createMemoryHistory,exports.createLocation=createLocation,exports.locationsAreEqual=locationsAreEqual,exports.parsePath=parsePath,exports.createPath=createPath;


/***/ },
/* 397 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	var reactIs = __webpack_require__(165);
	
	/**
	 * Copyright 2015, Yahoo! Inc.
	 * Copyrights licensed under the New BSD License. See the accompanying LICENSE file for terms.
	 */
	var REACT_STATICS = {
	  childContextTypes: true,
	  contextType: true,
	  contextTypes: true,
	  defaultProps: true,
	  displayName: true,
	  getDefaultProps: true,
	  getDerivedStateFromError: true,
	  getDerivedStateFromProps: true,
	  mixins: true,
	  propTypes: true,
	  type: true
	};
	var KNOWN_STATICS = {
	  name: true,
	  length: true,
	  prototype: true,
	  caller: true,
	  callee: true,
	  arguments: true,
	  arity: true
	};
	var FORWARD_REF_STATICS = {
	  '$$typeof': true,
	  render: true,
	  defaultProps: true,
	  displayName: true,
	  propTypes: true
	};
	var MEMO_STATICS = {
	  '$$typeof': true,
	  compare: true,
	  defaultProps: true,
	  displayName: true,
	  propTypes: true,
	  type: true
	};
	var TYPE_STATICS = {};
	TYPE_STATICS[reactIs.ForwardRef] = FORWARD_REF_STATICS;
	TYPE_STATICS[reactIs.Memo] = MEMO_STATICS;
	
	function getStatics(component) {
	  // React v16.11 and below
	  if (reactIs.isMemo(component)) {
	    return MEMO_STATICS;
	  } // React v16.12 and above
	
	
	  return TYPE_STATICS[component['$$typeof']] || REACT_STATICS;
	}
	
	var defineProperty = Object.defineProperty;
	var getOwnPropertyNames = Object.getOwnPropertyNames;
	var getOwnPropertySymbols = Object.getOwnPropertySymbols;
	var getOwnPropertyDescriptor = Object.getOwnPropertyDescriptor;
	var getPrototypeOf = Object.getPrototypeOf;
	var objectPrototype = Object.prototype;
	function hoistNonReactStatics(targetComponent, sourceComponent, blacklist) {
	  if (typeof sourceComponent !== 'string') {
	    // don't hoist over string (html) components
	    if (objectPrototype) {
	      var inheritedComponent = getPrototypeOf(sourceComponent);
	
	      if (inheritedComponent && inheritedComponent !== objectPrototype) {
	        hoistNonReactStatics(targetComponent, inheritedComponent, blacklist);
	      }
	    }
	
	    var keys = getOwnPropertyNames(sourceComponent);
	
	    if (getOwnPropertySymbols) {
	      keys = keys.concat(getOwnPropertySymbols(sourceComponent));
	    }
	
	    var targetStatics = getStatics(targetComponent);
	    var sourceStatics = getStatics(sourceComponent);
	
	    for (var i = 0; i < keys.length; ++i) {
	      var key = keys[i];
	
	      if (!KNOWN_STATICS[key] && !(blacklist && blacklist[key]) && !(sourceStatics && sourceStatics[key]) && !(targetStatics && targetStatics[key])) {
	        var descriptor = getOwnPropertyDescriptor(sourceComponent, key);
	
	        try {
	          // Avoid failures from read-only properties
	          defineProperty(targetComponent, key, descriptor);
	        } catch (e) {}
	      }
	    }
	  }
	
	  return targetComponent;
	}
	
	module.exports = hoistNonReactStatics;


/***/ },
/* 398 */
/***/ function(module, exports) {

	exports.read = function (buffer, offset, isLE, mLen, nBytes) {
	  var e, m
	  var eLen = (nBytes * 8) - mLen - 1
	  var eMax = (1 << eLen) - 1
	  var eBias = eMax >> 1
	  var nBits = -7
	  var i = isLE ? (nBytes - 1) : 0
	  var d = isLE ? -1 : 1
	  var s = buffer[offset + i]
	
	  i += d
	
	  e = s & ((1 << (-nBits)) - 1)
	  s >>= (-nBits)
	  nBits += eLen
	  for (; nBits > 0; e = (e * 256) + buffer[offset + i], i += d, nBits -= 8) {}
	
	  m = e & ((1 << (-nBits)) - 1)
	  e >>= (-nBits)
	  nBits += mLen
	  for (; nBits > 0; m = (m * 256) + buffer[offset + i], i += d, nBits -= 8) {}
	
	  if (e === 0) {
	    e = 1 - eBias
	  } else if (e === eMax) {
	    return m ? NaN : ((s ? -1 : 1) * Infinity)
	  } else {
	    m = m + Math.pow(2, mLen)
	    e = e - eBias
	  }
	  return (s ? -1 : 1) * m * Math.pow(2, e - mLen)
	}
	
	exports.write = function (buffer, value, offset, isLE, mLen, nBytes) {
	  var e, m, c
	  var eLen = (nBytes * 8) - mLen - 1
	  var eMax = (1 << eLen) - 1
	  var eBias = eMax >> 1
	  var rt = (mLen === 23 ? Math.pow(2, -24) - Math.pow(2, -77) : 0)
	  var i = isLE ? 0 : (nBytes - 1)
	  var d = isLE ? 1 : -1
	  var s = value < 0 || (value === 0 && 1 / value < 0) ? 1 : 0
	
	  value = Math.abs(value)
	
	  if (isNaN(value) || value === Infinity) {
	    m = isNaN(value) ? 1 : 0
	    e = eMax
	  } else {
	    e = Math.floor(Math.log(value) / Math.LN2)
	    if (value * (c = Math.pow(2, -e)) < 1) {
	      e--
	      c *= 2
	    }
	    if (e + eBias >= 1) {
	      value += rt / c
	    } else {
	      value += rt * Math.pow(2, 1 - eBias)
	    }
	    if (value * c >= 2) {
	      e++
	      c /= 2
	    }
	
	    if (e + eBias >= eMax) {
	      m = 0
	      e = eMax
	    } else if (e + eBias >= 1) {
	      m = ((value * c) - 1) * Math.pow(2, mLen)
	      e = e + eBias
	    } else {
	      m = value * Math.pow(2, eBias - 1) * Math.pow(2, mLen)
	      e = 0
	    }
	  }
	
	  for (; mLen >= 8; buffer[offset + i] = m & 0xff, i += d, m /= 256, mLen -= 8) {}
	
	  e = (e << mLen) | m
	  eLen += mLen
	  for (; eLen > 0; buffer[offset + i] = e & 0xff, i += d, e /= 256, eLen -= 8) {}
	
	  buffer[offset + i - d] |= s * 128
	}


/***/ },
/* 399 */
/***/ function(module, exports) {

	var toString = {}.toString;
	
	module.exports = Array.isArray || function (arr) {
	  return toString.call(arr) == '[object Array]';
	};


/***/ },
/* 400 */
/***/ function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_RESULT__;/*!
	 * JavaScript Cookie v2.2.1
	 * https://github.com/js-cookie/js-cookie
	 *
	 * Copyright 2006, 2015 Klaus Hartl & Fagner Brack
	 * Released under the MIT license
	 */
	;(function (factory) {
		var registeredInModuleLoader;
		if (true) {
			!(__WEBPACK_AMD_DEFINE_FACTORY__ = (factory), __WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ? (__WEBPACK_AMD_DEFINE_FACTORY__.call(exports, __webpack_require__, exports, module)) : __WEBPACK_AMD_DEFINE_FACTORY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
			registeredInModuleLoader = true;
		}
		if (true) {
			module.exports = factory();
			registeredInModuleLoader = true;
		}
		if (!registeredInModuleLoader) {
			var OldCookies = window.Cookies;
			var api = window.Cookies = factory();
			api.noConflict = function () {
				window.Cookies = OldCookies;
				return api;
			};
		}
	}(function () {
		function extend () {
			var i = 0;
			var result = {};
			for (; i < arguments.length; i++) {
				var attributes = arguments[ i ];
				for (var key in attributes) {
					result[key] = attributes[key];
				}
			}
			return result;
		}
	
		function decode (s) {
			return s.replace(/(%[0-9A-Z]{2})+/g, decodeURIComponent);
		}
	
		function init (converter) {
			function api() {}
	
			function set (key, value, attributes) {
				if (typeof document === 'undefined') {
					return;
				}
	
				attributes = extend({
					path: '/'
				}, api.defaults, attributes);
	
				if (typeof attributes.expires === 'number') {
					attributes.expires = new Date(new Date() * 1 + attributes.expires * 864e+5);
				}
	
				// We're using "expires" because "max-age" is not supported by IE
				attributes.expires = attributes.expires ? attributes.expires.toUTCString() : '';
	
				try {
					var result = JSON.stringify(value);
					if (/^[\{\[]/.test(result)) {
						value = result;
					}
				} catch (e) {}
	
				value = converter.write ?
					converter.write(value, key) :
					encodeURIComponent(String(value))
						.replace(/%(23|24|26|2B|3A|3C|3E|3D|2F|3F|40|5B|5D|5E|60|7B|7D|7C)/g, decodeURIComponent);
	
				key = encodeURIComponent(String(key))
					.replace(/%(23|24|26|2B|5E|60|7C)/g, decodeURIComponent)
					.replace(/[\(\)]/g, escape);
	
				var stringifiedAttributes = '';
				for (var attributeName in attributes) {
					if (!attributes[attributeName]) {
						continue;
					}
					stringifiedAttributes += '; ' + attributeName;
					if (attributes[attributeName] === true) {
						continue;
					}
	
					// Considers RFC 6265 section 5.2:
					// ...
					// 3.  If the remaining unparsed-attributes contains a %x3B (";")
					//     character:
					// Consume the characters of the unparsed-attributes up to,
					// not including, the first %x3B (";") character.
					// ...
					stringifiedAttributes += '=' + attributes[attributeName].split(';')[0];
				}
	
				return (document.cookie = key + '=' + value + stringifiedAttributes);
			}
	
			function get (key, json) {
				if (typeof document === 'undefined') {
					return;
				}
	
				var jar = {};
				// To prevent the for loop in the first place assign an empty array
				// in case there are no cookies at all.
				var cookies = document.cookie ? document.cookie.split('; ') : [];
				var i = 0;
	
				for (; i < cookies.length; i++) {
					var parts = cookies[i].split('=');
					var cookie = parts.slice(1).join('=');
	
					if (!json && cookie.charAt(0) === '"') {
						cookie = cookie.slice(1, -1);
					}
	
					try {
						var name = decode(parts[0]);
						cookie = (converter.read || converter)(cookie, name) ||
							decode(cookie);
	
						if (json) {
							try {
								cookie = JSON.parse(cookie);
							} catch (e) {}
						}
	
						jar[name] = cookie;
	
						if (key === name) {
							break;
						}
					} catch (e) {}
				}
	
				return key ? jar[key] : jar;
			}
	
			api.set = set;
			api.get = function (key) {
				return get(key, false /* read as raw */);
			};
			api.getJSON = function (key) {
				return get(key, true /* read as json */);
			};
			api.remove = function (key, attributes) {
				set(key, '', extend(attributes, {
					expires: -1
				}));
			};
	
			api.defaults = {};
	
			api.withConverter = init;
	
			return api;
		}
	
		return init(function () {});
	}));


/***/ },
/* 401 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';function _interopDefault(e){return(e&&(typeof e==='object')&&'default'in e)?e['default']:e}var React=__webpack_require__(2),React__default=_interopDefault(React),_inheritsLoose=_interopDefault(__webpack_require__(196)),PropTypes=_interopDefault(__webpack_require__(31)),gud=_interopDefault(__webpack_require__(394)),warning=_interopDefault(__webpack_require__(76));var MAX_SIGNED_31_BIT_INT = 1073741823;
	
	function objectIs(x, y) {
	  if (x === y) {
	    return x !== 0 || 1 / x === 1 / y;
	  } else {
	    return x !== x && y !== y;
	  }
	}
	
	function createEventEmitter(value) {
	  var handlers = [];
	  return {
	    on: function on(handler) {
	      handlers.push(handler);
	    },
	    off: function off(handler) {
	      handlers = handlers.filter(function (h) {
	        return h !== handler;
	      });
	    },
	    get: function get() {
	      return value;
	    },
	    set: function set(newValue, changedBits) {
	      value = newValue;
	      handlers.forEach(function (handler) {
	        return handler(value, changedBits);
	      });
	    }
	  };
	}
	
	function onlyChild(children) {
	  return Array.isArray(children) ? children[0] : children;
	}
	
	function createReactContext(defaultValue, calculateChangedBits) {
	  var _Provider$childContex, _Consumer$contextType;
	
	  var contextProp = '__create-react-context-' + gud() + '__';
	
	  var Provider =
	  /*#__PURE__*/
	  function (_Component) {
	    _inheritsLoose(Provider, _Component);
	
	    function Provider() {
	      var _this;
	
	      _this = _Component.apply(this, arguments) || this;
	      _this.emitter = createEventEmitter(_this.props.value);
	      return _this;
	    }
	
	    var _proto = Provider.prototype;
	
	    _proto.getChildContext = function getChildContext() {
	      var _ref;
	
	      return _ref = {}, _ref[contextProp] = this.emitter, _ref;
	    };
	
	    _proto.componentWillReceiveProps = function componentWillReceiveProps(nextProps) {
	      if (this.props.value !== nextProps.value) {
	        var oldValue = this.props.value;
	        var newValue = nextProps.value;
	        var changedBits;
	
	        if (objectIs(oldValue, newValue)) {
	          changedBits = 0;
	        } else {
	          changedBits = typeof calculateChangedBits === 'function' ? calculateChangedBits(oldValue, newValue) : MAX_SIGNED_31_BIT_INT;
	
	          if (false) {
	            warning((changedBits & MAX_SIGNED_31_BIT_INT) === changedBits, 'calculateChangedBits: Expected the return value to be a ' + '31-bit integer. Instead received: ' + changedBits);
	          }
	
	          changedBits |= 0;
	
	          if (changedBits !== 0) {
	            this.emitter.set(nextProps.value, changedBits);
	          }
	        }
	      }
	    };
	
	    _proto.render = function render() {
	      return this.props.children;
	    };
	
	    return Provider;
	  }(React.Component);
	
	  Provider.childContextTypes = (_Provider$childContex = {}, _Provider$childContex[contextProp] = PropTypes.object.isRequired, _Provider$childContex);
	
	  var Consumer =
	  /*#__PURE__*/
	  function (_Component2) {
	    _inheritsLoose(Consumer, _Component2);
	
	    function Consumer() {
	      var _this2;
	
	      _this2 = _Component2.apply(this, arguments) || this;
	      _this2.state = {
	        value: _this2.getValue()
	      };
	
	      _this2.onUpdate = function (newValue, changedBits) {
	        var observedBits = _this2.observedBits | 0;
	
	        if ((observedBits & changedBits) !== 0) {
	          _this2.setState({
	            value: _this2.getValue()
	          });
	        }
	      };
	
	      return _this2;
	    }
	
	    var _proto2 = Consumer.prototype;
	
	    _proto2.componentWillReceiveProps = function componentWillReceiveProps(nextProps) {
	      var observedBits = nextProps.observedBits;
	      this.observedBits = observedBits === undefined || observedBits === null ? MAX_SIGNED_31_BIT_INT : observedBits;
	    };
	
	    _proto2.componentDidMount = function componentDidMount() {
	      if (this.context[contextProp]) {
	        this.context[contextProp].on(this.onUpdate);
	      }
	
	      var observedBits = this.props.observedBits;
	      this.observedBits = observedBits === undefined || observedBits === null ? MAX_SIGNED_31_BIT_INT : observedBits;
	    };
	
	    _proto2.componentWillUnmount = function componentWillUnmount() {
	      if (this.context[contextProp]) {
	        this.context[contextProp].off(this.onUpdate);
	      }
	    };
	
	    _proto2.getValue = function getValue() {
	      if (this.context[contextProp]) {
	        return this.context[contextProp].get();
	      } else {
	        return defaultValue;
	      }
	    };
	
	    _proto2.render = function render() {
	      return onlyChild(this.props.children)(this.state.value);
	    };
	
	    return Consumer;
	  }(React.Component);
	
	  Consumer.contextTypes = (_Consumer$contextType = {}, _Consumer$contextType[contextProp] = PropTypes.object, _Consumer$contextType);
	  return {
	    Provider: Provider,
	    Consumer: Consumer
	  };
	}var index = React__default.createContext || createReactContext;module.exports=index;

/***/ },
/* 402 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	//This file contains the ES6 extensions to the core Promises/A+ API
	
	var Promise = __webpack_require__(164);
	
	module.exports = Promise;
	
	/* Static Functions */
	
	var TRUE = valuePromise(true);
	var FALSE = valuePromise(false);
	var NULL = valuePromise(null);
	var UNDEFINED = valuePromise(undefined);
	var ZERO = valuePromise(0);
	var EMPTYSTRING = valuePromise('');
	
	function valuePromise(value) {
	  var p = new Promise(Promise._61);
	  p._81 = 1;
	  p._65 = value;
	  return p;
	}
	Promise.resolve = function (value) {
	  if (value instanceof Promise) return value;
	
	  if (value === null) return NULL;
	  if (value === undefined) return UNDEFINED;
	  if (value === true) return TRUE;
	  if (value === false) return FALSE;
	  if (value === 0) return ZERO;
	  if (value === '') return EMPTYSTRING;
	
	  if (typeof value === 'object' || typeof value === 'function') {
	    try {
	      var then = value.then;
	      if (typeof then === 'function') {
	        return new Promise(then.bind(value));
	      }
	    } catch (ex) {
	      return new Promise(function (resolve, reject) {
	        reject(ex);
	      });
	    }
	  }
	  return valuePromise(value);
	};
	
	Promise.all = function (arr) {
	  var args = Array.prototype.slice.call(arr);
	
	  return new Promise(function (resolve, reject) {
	    if (args.length === 0) return resolve([]);
	    var remaining = args.length;
	    function res(i, val) {
	      if (val && (typeof val === 'object' || typeof val === 'function')) {
	        if (val instanceof Promise && val.then === Promise.prototype.then) {
	          while (val._81 === 3) {
	            val = val._65;
	          }
	          if (val._81 === 1) return res(i, val._65);
	          if (val._81 === 2) reject(val._65);
	          val.then(function (val) {
	            res(i, val);
	          }, reject);
	          return;
	        } else {
	          var then = val.then;
	          if (typeof then === 'function') {
	            var p = new Promise(then.bind(val));
	            p.then(function (val) {
	              res(i, val);
	            }, reject);
	            return;
	          }
	        }
	      }
	      args[i] = val;
	      if (--remaining === 0) {
	        resolve(args);
	      }
	    }
	    for (var i = 0; i < args.length; i++) {
	      res(i, args[i]);
	    }
	  });
	};
	
	Promise.reject = function (value) {
	  return new Promise(function (resolve, reject) {
	    reject(value);
	  });
	};
	
	Promise.race = function (values) {
	  return new Promise(function (resolve, reject) {
	    values.forEach(function(value){
	      Promise.resolve(value).then(resolve, reject);
	    });
	  });
	};
	
	/* Prototype Methods */
	
	Promise.prototype['catch'] = function (onRejected) {
	  return this.then(null, onRejected);
	};


/***/ },
/* 403 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	var Promise = __webpack_require__(164);
	
	var DEFAULT_WHITELIST = [
	  ReferenceError,
	  TypeError,
	  RangeError
	];
	
	var enabled = false;
	exports.disable = disable;
	function disable() {
	  enabled = false;
	  Promise._10 = null;
	  Promise._97 = null;
	}
	
	exports.enable = enable;
	function enable(options) {
	  options = options || {};
	  if (enabled) disable();
	  enabled = true;
	  var id = 0;
	  var displayId = 0;
	  var rejections = {};
	  Promise._10 = function (promise) {
	    if (
	      promise._81 === 2 && // IS REJECTED
	      rejections[promise._72]
	    ) {
	      if (rejections[promise._72].logged) {
	        onHandled(promise._72);
	      } else {
	        clearTimeout(rejections[promise._72].timeout);
	      }
	      delete rejections[promise._72];
	    }
	  };
	  Promise._97 = function (promise, err) {
	    if (promise._45 === 0) { // not yet handled
	      promise._72 = id++;
	      rejections[promise._72] = {
	        displayId: null,
	        error: err,
	        timeout: setTimeout(
	          onUnhandled.bind(null, promise._72),
	          // For reference errors and type errors, this almost always
	          // means the programmer made a mistake, so log them after just
	          // 100ms
	          // otherwise, wait 2 seconds to see if they get handled
	          matchWhitelist(err, DEFAULT_WHITELIST)
	            ? 100
	            : 2000
	        ),
	        logged: false
	      };
	    }
	  };
	  function onUnhandled(id) {
	    if (
	      options.allRejections ||
	      matchWhitelist(
	        rejections[id].error,
	        options.whitelist || DEFAULT_WHITELIST
	      )
	    ) {
	      rejections[id].displayId = displayId++;
	      if (options.onUnhandled) {
	        rejections[id].logged = true;
	        options.onUnhandled(
	          rejections[id].displayId,
	          rejections[id].error
	        );
	      } else {
	        rejections[id].logged = true;
	        logError(
	          rejections[id].displayId,
	          rejections[id].error
	        );
	      }
	    }
	  }
	  function onHandled(id) {
	    if (rejections[id].logged) {
	      if (options.onHandled) {
	        options.onHandled(rejections[id].displayId, rejections[id].error);
	      } else if (!rejections[id].onUnhandled) {
	        console.warn(
	          'Promise Rejection Handled (id: ' + rejections[id].displayId + '):'
	        );
	        console.warn(
	          '  This means you can ignore any previous messages of the form "Possible Unhandled Promise Rejection" with id ' +
	          rejections[id].displayId + '.'
	        );
	      }
	    }
	  }
	}
	
	function logError(id, error) {
	  console.warn('Possible Unhandled Promise Rejection (id: ' + id + '):');
	  var errStr = (error && (error.stack || error)) + '';
	  errStr.split('\n').forEach(function (line) {
	    console.warn('  ' + line);
	  });
	}
	
	function matchWhitelist(error, list) {
	  return list.some(function (cls) {
	    return error instanceof cls;
	  });
	}

/***/ },
/* 404 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * Copyright (c) 2013-present, Facebook, Inc.
	 *
	 * This source code is licensed under the MIT license found in the
	 * LICENSE file in the root directory of this source tree.
	 */
	
	'use strict';
	
	var ReactPropTypesSecret = __webpack_require__(405);
	
	function emptyFunction() {}
	function emptyFunctionWithReset() {}
	emptyFunctionWithReset.resetWarningCache = emptyFunction;
	
	module.exports = function() {
	  function shim(props, propName, componentName, location, propFullName, secret) {
	    if (secret === ReactPropTypesSecret) {
	      // It is still safe when called from React.
	      return;
	    }
	    var err = new Error(
	      'Calling PropTypes validators directly is not supported by the `prop-types` package. ' +
	      'Use PropTypes.checkPropTypes() to call them. ' +
	      'Read more at http://fb.me/use-check-prop-types'
	    );
	    err.name = 'Invariant Violation';
	    throw err;
	  };
	  shim.isRequired = shim;
	  function getShim() {
	    return shim;
	  };
	  // Important!
	  // Keep this list in sync with production version in `./factoryWithTypeCheckers.js`.
	  var ReactPropTypes = {
	    array: shim,
	    bool: shim,
	    func: shim,
	    number: shim,
	    object: shim,
	    string: shim,
	    symbol: shim,
	
	    any: shim,
	    arrayOf: getShim,
	    element: shim,
	    elementType: shim,
	    instanceOf: getShim,
	    node: shim,
	    objectOf: getShim,
	    oneOf: getShim,
	    oneOfType: getShim,
	    shape: getShim,
	    exact: getShim,
	
	    checkPropTypes: emptyFunctionWithReset,
	    resetWarningCache: emptyFunction
	  };
	
	  ReactPropTypes.PropTypes = ReactPropTypes;
	
	  return ReactPropTypes;
	};


/***/ },
/* 405 */
/***/ function(module, exports) {

	/**
	 * Copyright (c) 2013-present, Facebook, Inc.
	 *
	 * This source code is licensed under the MIT license found in the
	 * LICENSE file in the root directory of this source tree.
	 */
	
	'use strict';
	
	var ReactPropTypesSecret = 'SECRET_DO_NOT_PASS_THIS_OR_YOU_WILL_BE_FIRED';
	
	module.exports = ReactPropTypesSecret;


/***/ },
/* 406 */
/***/ function(module, exports, __webpack_require__) {

	/** @license React v16.13.1
	 * react-dom.production.min.js
	 *
	 * Copyright (c) Facebook, Inc. and its affiliates.
	 *
	 * This source code is licensed under the MIT license found in the
	 * LICENSE file in the root directory of this source tree.
	 */
	
	/*
	 Modernizr 3.0.0pre (Custom Build) | MIT
	*/
	'use strict';var aa=__webpack_require__(2),n=__webpack_require__(98),r=__webpack_require__(424);function u(a){for(var b="https://reactjs.org/docs/error-decoder.html?invariant="+a,c=1;c<arguments.length;c++)b+="&args[]="+encodeURIComponent(arguments[c]);return"Minified React error #"+a+"; visit "+b+" for the full message or use the non-minified dev environment for full errors and additional helpful warnings."}if(!aa)throw Error(u(227));
	function ba(a,b,c,d,e,f,g,h,k){var l=Array.prototype.slice.call(arguments,3);try{b.apply(c,l)}catch(m){this.onError(m)}}var da=!1,ea=null,fa=!1,ha=null,ia={onError:function(a){da=!0;ea=a}};function ja(a,b,c,d,e,f,g,h,k){da=!1;ea=null;ba.apply(ia,arguments)}function ka(a,b,c,d,e,f,g,h,k){ja.apply(this,arguments);if(da){if(da){var l=ea;da=!1;ea=null}else throw Error(u(198));fa||(fa=!0,ha=l)}}var la=null,ma=null,na=null;
	function oa(a,b,c){var d=a.type||"unknown-event";a.currentTarget=na(c);ka(d,b,void 0,a);a.currentTarget=null}var pa=null,qa={};
	function ra(){if(pa)for(var a in qa){var b=qa[a],c=pa.indexOf(a);if(!(-1<c))throw Error(u(96,a));if(!sa[c]){if(!b.extractEvents)throw Error(u(97,a));sa[c]=b;c=b.eventTypes;for(var d in c){var e=void 0;var f=c[d],g=b,h=d;if(ta.hasOwnProperty(h))throw Error(u(99,h));ta[h]=f;var k=f.phasedRegistrationNames;if(k){for(e in k)k.hasOwnProperty(e)&&ua(k[e],g,h);e=!0}else f.registrationName?(ua(f.registrationName,g,h),e=!0):e=!1;if(!e)throw Error(u(98,d,a));}}}}
	function ua(a,b,c){if(va[a])throw Error(u(100,a));va[a]=b;wa[a]=b.eventTypes[c].dependencies}var sa=[],ta={},va={},wa={};function xa(a){var b=!1,c;for(c in a)if(a.hasOwnProperty(c)){var d=a[c];if(!qa.hasOwnProperty(c)||qa[c]!==d){if(qa[c])throw Error(u(102,c));qa[c]=d;b=!0}}b&&ra()}var ya=!("undefined"===typeof window||"undefined"===typeof window.document||"undefined"===typeof window.document.createElement),za=null,Aa=null,Ba=null;
	function Ca(a){if(a=ma(a)){if("function"!==typeof za)throw Error(u(280));var b=a.stateNode;b&&(b=la(b),za(a.stateNode,a.type,b))}}function Da(a){Aa?Ba?Ba.push(a):Ba=[a]:Aa=a}function Ea(){if(Aa){var a=Aa,b=Ba;Ba=Aa=null;Ca(a);if(b)for(a=0;a<b.length;a++)Ca(b[a])}}function Fa(a,b){return a(b)}function Ga(a,b,c,d,e){return a(b,c,d,e)}function Ha(){}var Ia=Fa,Ja=!1,Ka=!1;function La(){if(null!==Aa||null!==Ba)Ha(),Ea()}
	function Ma(a,b,c){if(Ka)return a(b,c);Ka=!0;try{return Ia(a,b,c)}finally{Ka=!1,La()}}var Na=/^[:A-Z_a-z\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD][:A-Z_a-z\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD\-.0-9\u00B7\u0300-\u036F\u203F-\u2040]*$/,Oa=Object.prototype.hasOwnProperty,Pa={},Qa={};
	function Ra(a){if(Oa.call(Qa,a))return!0;if(Oa.call(Pa,a))return!1;if(Na.test(a))return Qa[a]=!0;Pa[a]=!0;return!1}function Sa(a,b,c,d){if(null!==c&&0===c.type)return!1;switch(typeof b){case "function":case "symbol":return!0;case "boolean":if(d)return!1;if(null!==c)return!c.acceptsBooleans;a=a.toLowerCase().slice(0,5);return"data-"!==a&&"aria-"!==a;default:return!1}}
	function Ta(a,b,c,d){if(null===b||"undefined"===typeof b||Sa(a,b,c,d))return!0;if(d)return!1;if(null!==c)switch(c.type){case 3:return!b;case 4:return!1===b;case 5:return isNaN(b);case 6:return isNaN(b)||1>b}return!1}function v(a,b,c,d,e,f){this.acceptsBooleans=2===b||3===b||4===b;this.attributeName=d;this.attributeNamespace=e;this.mustUseProperty=c;this.propertyName=a;this.type=b;this.sanitizeURL=f}var C={};
	"children dangerouslySetInnerHTML defaultValue defaultChecked innerHTML suppressContentEditableWarning suppressHydrationWarning style".split(" ").forEach(function(a){C[a]=new v(a,0,!1,a,null,!1)});[["acceptCharset","accept-charset"],["className","class"],["htmlFor","for"],["httpEquiv","http-equiv"]].forEach(function(a){var b=a[0];C[b]=new v(b,1,!1,a[1],null,!1)});["contentEditable","draggable","spellCheck","value"].forEach(function(a){C[a]=new v(a,2,!1,a.toLowerCase(),null,!1)});
	["autoReverse","externalResourcesRequired","focusable","preserveAlpha"].forEach(function(a){C[a]=new v(a,2,!1,a,null,!1)});"allowFullScreen async autoFocus autoPlay controls default defer disabled disablePictureInPicture formNoValidate hidden loop noModule noValidate open playsInline readOnly required reversed scoped seamless itemScope".split(" ").forEach(function(a){C[a]=new v(a,3,!1,a.toLowerCase(),null,!1)});
	["checked","multiple","muted","selected"].forEach(function(a){C[a]=new v(a,3,!0,a,null,!1)});["capture","download"].forEach(function(a){C[a]=new v(a,4,!1,a,null,!1)});["cols","rows","size","span"].forEach(function(a){C[a]=new v(a,6,!1,a,null,!1)});["rowSpan","start"].forEach(function(a){C[a]=new v(a,5,!1,a.toLowerCase(),null,!1)});var Ua=/[\-:]([a-z])/g;function Va(a){return a[1].toUpperCase()}
	"accent-height alignment-baseline arabic-form baseline-shift cap-height clip-path clip-rule color-interpolation color-interpolation-filters color-profile color-rendering dominant-baseline enable-background fill-opacity fill-rule flood-color flood-opacity font-family font-size font-size-adjust font-stretch font-style font-variant font-weight glyph-name glyph-orientation-horizontal glyph-orientation-vertical horiz-adv-x horiz-origin-x image-rendering letter-spacing lighting-color marker-end marker-mid marker-start overline-position overline-thickness paint-order panose-1 pointer-events rendering-intent shape-rendering stop-color stop-opacity strikethrough-position strikethrough-thickness stroke-dasharray stroke-dashoffset stroke-linecap stroke-linejoin stroke-miterlimit stroke-opacity stroke-width text-anchor text-decoration text-rendering underline-position underline-thickness unicode-bidi unicode-range units-per-em v-alphabetic v-hanging v-ideographic v-mathematical vector-effect vert-adv-y vert-origin-x vert-origin-y word-spacing writing-mode xmlns:xlink x-height".split(" ").forEach(function(a){var b=a.replace(Ua,
	Va);C[b]=new v(b,1,!1,a,null,!1)});"xlink:actuate xlink:arcrole xlink:role xlink:show xlink:title xlink:type".split(" ").forEach(function(a){var b=a.replace(Ua,Va);C[b]=new v(b,1,!1,a,"http://www.w3.org/1999/xlink",!1)});["xml:base","xml:lang","xml:space"].forEach(function(a){var b=a.replace(Ua,Va);C[b]=new v(b,1,!1,a,"http://www.w3.org/XML/1998/namespace",!1)});["tabIndex","crossOrigin"].forEach(function(a){C[a]=new v(a,1,!1,a.toLowerCase(),null,!1)});
	C.xlinkHref=new v("xlinkHref",1,!1,"xlink:href","http://www.w3.org/1999/xlink",!0);["src","href","action","formAction"].forEach(function(a){C[a]=new v(a,1,!1,a.toLowerCase(),null,!0)});var Wa=aa.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED;Wa.hasOwnProperty("ReactCurrentDispatcher")||(Wa.ReactCurrentDispatcher={current:null});Wa.hasOwnProperty("ReactCurrentBatchConfig")||(Wa.ReactCurrentBatchConfig={suspense:null});
	function Xa(a,b,c,d){var e=C.hasOwnProperty(b)?C[b]:null;var f=null!==e?0===e.type:d?!1:!(2<b.length)||"o"!==b[0]&&"O"!==b[0]||"n"!==b[1]&&"N"!==b[1]?!1:!0;f||(Ta(b,c,e,d)&&(c=null),d||null===e?Ra(b)&&(null===c?a.removeAttribute(b):a.setAttribute(b,""+c)):e.mustUseProperty?a[e.propertyName]=null===c?3===e.type?!1:"":c:(b=e.attributeName,d=e.attributeNamespace,null===c?a.removeAttribute(b):(e=e.type,c=3===e||4===e&&!0===c?"":""+c,d?a.setAttributeNS(d,b,c):a.setAttribute(b,c))))}
	var Ya=/^(.*)[\\\/]/,E="function"===typeof Symbol&&Symbol.for,Za=E?Symbol.for("react.element"):60103,$a=E?Symbol.for("react.portal"):60106,ab=E?Symbol.for("react.fragment"):60107,bb=E?Symbol.for("react.strict_mode"):60108,cb=E?Symbol.for("react.profiler"):60114,db=E?Symbol.for("react.provider"):60109,eb=E?Symbol.for("react.context"):60110,fb=E?Symbol.for("react.concurrent_mode"):60111,gb=E?Symbol.for("react.forward_ref"):60112,hb=E?Symbol.for("react.suspense"):60113,ib=E?Symbol.for("react.suspense_list"):
	60120,jb=E?Symbol.for("react.memo"):60115,kb=E?Symbol.for("react.lazy"):60116,lb=E?Symbol.for("react.block"):60121,mb="function"===typeof Symbol&&Symbol.iterator;function nb(a){if(null===a||"object"!==typeof a)return null;a=mb&&a[mb]||a["@@iterator"];return"function"===typeof a?a:null}function ob(a){if(-1===a._status){a._status=0;var b=a._ctor;b=b();a._result=b;b.then(function(b){0===a._status&&(b=b.default,a._status=1,a._result=b)},function(b){0===a._status&&(a._status=2,a._result=b)})}}
	function pb(a){if(null==a)return null;if("function"===typeof a)return a.displayName||a.name||null;if("string"===typeof a)return a;switch(a){case ab:return"Fragment";case $a:return"Portal";case cb:return"Profiler";case bb:return"StrictMode";case hb:return"Suspense";case ib:return"SuspenseList"}if("object"===typeof a)switch(a.$$typeof){case eb:return"Context.Consumer";case db:return"Context.Provider";case gb:var b=a.render;b=b.displayName||b.name||"";return a.displayName||(""!==b?"ForwardRef("+b+")":
	"ForwardRef");case jb:return pb(a.type);case lb:return pb(a.render);case kb:if(a=1===a._status?a._result:null)return pb(a)}return null}function qb(a){var b="";do{a:switch(a.tag){case 3:case 4:case 6:case 7:case 10:case 9:var c="";break a;default:var d=a._debugOwner,e=a._debugSource,f=pb(a.type);c=null;d&&(c=pb(d.type));d=f;f="";e?f=" (at "+e.fileName.replace(Ya,"")+":"+e.lineNumber+")":c&&(f=" (created by "+c+")");c="\n    in "+(d||"Unknown")+f}b+=c;a=a.return}while(a);return b}
	function rb(a){switch(typeof a){case "boolean":case "number":case "object":case "string":case "undefined":return a;default:return""}}function sb(a){var b=a.type;return(a=a.nodeName)&&"input"===a.toLowerCase()&&("checkbox"===b||"radio"===b)}
	function tb(a){var b=sb(a)?"checked":"value",c=Object.getOwnPropertyDescriptor(a.constructor.prototype,b),d=""+a[b];if(!a.hasOwnProperty(b)&&"undefined"!==typeof c&&"function"===typeof c.get&&"function"===typeof c.set){var e=c.get,f=c.set;Object.defineProperty(a,b,{configurable:!0,get:function(){return e.call(this)},set:function(a){d=""+a;f.call(this,a)}});Object.defineProperty(a,b,{enumerable:c.enumerable});return{getValue:function(){return d},setValue:function(a){d=""+a},stopTracking:function(){a._valueTracker=
	null;delete a[b]}}}}function xb(a){a._valueTracker||(a._valueTracker=tb(a))}function yb(a){if(!a)return!1;var b=a._valueTracker;if(!b)return!0;var c=b.getValue();var d="";a&&(d=sb(a)?a.checked?"true":"false":a.value);a=d;return a!==c?(b.setValue(a),!0):!1}function zb(a,b){var c=b.checked;return n({},b,{defaultChecked:void 0,defaultValue:void 0,value:void 0,checked:null!=c?c:a._wrapperState.initialChecked})}
	function Ab(a,b){var c=null==b.defaultValue?"":b.defaultValue,d=null!=b.checked?b.checked:b.defaultChecked;c=rb(null!=b.value?b.value:c);a._wrapperState={initialChecked:d,initialValue:c,controlled:"checkbox"===b.type||"radio"===b.type?null!=b.checked:null!=b.value}}function Bb(a,b){b=b.checked;null!=b&&Xa(a,"checked",b,!1)}
	function Cb(a,b){Bb(a,b);var c=rb(b.value),d=b.type;if(null!=c)if("number"===d){if(0===c&&""===a.value||a.value!=c)a.value=""+c}else a.value!==""+c&&(a.value=""+c);else if("submit"===d||"reset"===d){a.removeAttribute("value");return}b.hasOwnProperty("value")?Db(a,b.type,c):b.hasOwnProperty("defaultValue")&&Db(a,b.type,rb(b.defaultValue));null==b.checked&&null!=b.defaultChecked&&(a.defaultChecked=!!b.defaultChecked)}
	function Eb(a,b,c){if(b.hasOwnProperty("value")||b.hasOwnProperty("defaultValue")){var d=b.type;if(!("submit"!==d&&"reset"!==d||void 0!==b.value&&null!==b.value))return;b=""+a._wrapperState.initialValue;c||b===a.value||(a.value=b);a.defaultValue=b}c=a.name;""!==c&&(a.name="");a.defaultChecked=!!a._wrapperState.initialChecked;""!==c&&(a.name=c)}
	function Db(a,b,c){if("number"!==b||a.ownerDocument.activeElement!==a)null==c?a.defaultValue=""+a._wrapperState.initialValue:a.defaultValue!==""+c&&(a.defaultValue=""+c)}function Fb(a){var b="";aa.Children.forEach(a,function(a){null!=a&&(b+=a)});return b}function Gb(a,b){a=n({children:void 0},b);if(b=Fb(b.children))a.children=b;return a}
	function Hb(a,b,c,d){a=a.options;if(b){b={};for(var e=0;e<c.length;e++)b["$"+c[e]]=!0;for(c=0;c<a.length;c++)e=b.hasOwnProperty("$"+a[c].value),a[c].selected!==e&&(a[c].selected=e),e&&d&&(a[c].defaultSelected=!0)}else{c=""+rb(c);b=null;for(e=0;e<a.length;e++){if(a[e].value===c){a[e].selected=!0;d&&(a[e].defaultSelected=!0);return}null!==b||a[e].disabled||(b=a[e])}null!==b&&(b.selected=!0)}}
	function Ib(a,b){if(null!=b.dangerouslySetInnerHTML)throw Error(u(91));return n({},b,{value:void 0,defaultValue:void 0,children:""+a._wrapperState.initialValue})}function Jb(a,b){var c=b.value;if(null==c){c=b.children;b=b.defaultValue;if(null!=c){if(null!=b)throw Error(u(92));if(Array.isArray(c)){if(!(1>=c.length))throw Error(u(93));c=c[0]}b=c}null==b&&(b="");c=b}a._wrapperState={initialValue:rb(c)}}
	function Kb(a,b){var c=rb(b.value),d=rb(b.defaultValue);null!=c&&(c=""+c,c!==a.value&&(a.value=c),null==b.defaultValue&&a.defaultValue!==c&&(a.defaultValue=c));null!=d&&(a.defaultValue=""+d)}function Lb(a){var b=a.textContent;b===a._wrapperState.initialValue&&""!==b&&null!==b&&(a.value=b)}var Mb={html:"http://www.w3.org/1999/xhtml",mathml:"http://www.w3.org/1998/Math/MathML",svg:"http://www.w3.org/2000/svg"};
	function Nb(a){switch(a){case "svg":return"http://www.w3.org/2000/svg";case "math":return"http://www.w3.org/1998/Math/MathML";default:return"http://www.w3.org/1999/xhtml"}}function Ob(a,b){return null==a||"http://www.w3.org/1999/xhtml"===a?Nb(b):"http://www.w3.org/2000/svg"===a&&"foreignObject"===b?"http://www.w3.org/1999/xhtml":a}
	var Pb,Qb=function(a){return"undefined"!==typeof MSApp&&MSApp.execUnsafeLocalFunction?function(b,c,d,e){MSApp.execUnsafeLocalFunction(function(){return a(b,c,d,e)})}:a}(function(a,b){if(a.namespaceURI!==Mb.svg||"innerHTML"in a)a.innerHTML=b;else{Pb=Pb||document.createElement("div");Pb.innerHTML="<svg>"+b.valueOf().toString()+"</svg>";for(b=Pb.firstChild;a.firstChild;)a.removeChild(a.firstChild);for(;b.firstChild;)a.appendChild(b.firstChild)}});
	function Rb(a,b){if(b){var c=a.firstChild;if(c&&c===a.lastChild&&3===c.nodeType){c.nodeValue=b;return}}a.textContent=b}function Sb(a,b){var c={};c[a.toLowerCase()]=b.toLowerCase();c["Webkit"+a]="webkit"+b;c["Moz"+a]="moz"+b;return c}var Tb={animationend:Sb("Animation","AnimationEnd"),animationiteration:Sb("Animation","AnimationIteration"),animationstart:Sb("Animation","AnimationStart"),transitionend:Sb("Transition","TransitionEnd")},Ub={},Vb={};
	ya&&(Vb=document.createElement("div").style,"AnimationEvent"in window||(delete Tb.animationend.animation,delete Tb.animationiteration.animation,delete Tb.animationstart.animation),"TransitionEvent"in window||delete Tb.transitionend.transition);function Wb(a){if(Ub[a])return Ub[a];if(!Tb[a])return a;var b=Tb[a],c;for(c in b)if(b.hasOwnProperty(c)&&c in Vb)return Ub[a]=b[c];return a}
	var Xb=Wb("animationend"),Yb=Wb("animationiteration"),Zb=Wb("animationstart"),$b=Wb("transitionend"),ac="abort canplay canplaythrough durationchange emptied encrypted ended error loadeddata loadedmetadata loadstart pause play playing progress ratechange seeked seeking stalled suspend timeupdate volumechange waiting".split(" "),bc=new ("function"===typeof WeakMap?WeakMap:Map);function cc(a){var b=bc.get(a);void 0===b&&(b=new Map,bc.set(a,b));return b}
	function dc(a){var b=a,c=a;if(a.alternate)for(;b.return;)b=b.return;else{a=b;do b=a,0!==(b.effectTag&1026)&&(c=b.return),a=b.return;while(a)}return 3===b.tag?c:null}function ec(a){if(13===a.tag){var b=a.memoizedState;null===b&&(a=a.alternate,null!==a&&(b=a.memoizedState));if(null!==b)return b.dehydrated}return null}function fc(a){if(dc(a)!==a)throw Error(u(188));}
	function gc(a){var b=a.alternate;if(!b){b=dc(a);if(null===b)throw Error(u(188));return b!==a?null:a}for(var c=a,d=b;;){var e=c.return;if(null===e)break;var f=e.alternate;if(null===f){d=e.return;if(null!==d){c=d;continue}break}if(e.child===f.child){for(f=e.child;f;){if(f===c)return fc(e),a;if(f===d)return fc(e),b;f=f.sibling}throw Error(u(188));}if(c.return!==d.return)c=e,d=f;else{for(var g=!1,h=e.child;h;){if(h===c){g=!0;c=e;d=f;break}if(h===d){g=!0;d=e;c=f;break}h=h.sibling}if(!g){for(h=f.child;h;){if(h===
	c){g=!0;c=f;d=e;break}if(h===d){g=!0;d=f;c=e;break}h=h.sibling}if(!g)throw Error(u(189));}}if(c.alternate!==d)throw Error(u(190));}if(3!==c.tag)throw Error(u(188));return c.stateNode.current===c?a:b}function hc(a){a=gc(a);if(!a)return null;for(var b=a;;){if(5===b.tag||6===b.tag)return b;if(b.child)b.child.return=b,b=b.child;else{if(b===a)break;for(;!b.sibling;){if(!b.return||b.return===a)return null;b=b.return}b.sibling.return=b.return;b=b.sibling}}return null}
	function ic(a,b){if(null==b)throw Error(u(30));if(null==a)return b;if(Array.isArray(a)){if(Array.isArray(b))return a.push.apply(a,b),a;a.push(b);return a}return Array.isArray(b)?[a].concat(b):[a,b]}function jc(a,b,c){Array.isArray(a)?a.forEach(b,c):a&&b.call(c,a)}var kc=null;
	function lc(a){if(a){var b=a._dispatchListeners,c=a._dispatchInstances;if(Array.isArray(b))for(var d=0;d<b.length&&!a.isPropagationStopped();d++)oa(a,b[d],c[d]);else b&&oa(a,b,c);a._dispatchListeners=null;a._dispatchInstances=null;a.isPersistent()||a.constructor.release(a)}}function mc(a){null!==a&&(kc=ic(kc,a));a=kc;kc=null;if(a){jc(a,lc);if(kc)throw Error(u(95));if(fa)throw a=ha,fa=!1,ha=null,a;}}
	function nc(a){a=a.target||a.srcElement||window;a.correspondingUseElement&&(a=a.correspondingUseElement);return 3===a.nodeType?a.parentNode:a}function oc(a){if(!ya)return!1;a="on"+a;var b=a in document;b||(b=document.createElement("div"),b.setAttribute(a,"return;"),b="function"===typeof b[a]);return b}var pc=[];function qc(a){a.topLevelType=null;a.nativeEvent=null;a.targetInst=null;a.ancestors.length=0;10>pc.length&&pc.push(a)}
	function rc(a,b,c,d){if(pc.length){var e=pc.pop();e.topLevelType=a;e.eventSystemFlags=d;e.nativeEvent=b;e.targetInst=c;return e}return{topLevelType:a,eventSystemFlags:d,nativeEvent:b,targetInst:c,ancestors:[]}}
	function sc(a){var b=a.targetInst,c=b;do{if(!c){a.ancestors.push(c);break}var d=c;if(3===d.tag)d=d.stateNode.containerInfo;else{for(;d.return;)d=d.return;d=3!==d.tag?null:d.stateNode.containerInfo}if(!d)break;b=c.tag;5!==b&&6!==b||a.ancestors.push(c);c=tc(d)}while(c);for(c=0;c<a.ancestors.length;c++){b=a.ancestors[c];var e=nc(a.nativeEvent);d=a.topLevelType;var f=a.nativeEvent,g=a.eventSystemFlags;0===c&&(g|=64);for(var h=null,k=0;k<sa.length;k++){var l=sa[k];l&&(l=l.extractEvents(d,b,f,e,g))&&(h=
	ic(h,l))}mc(h)}}function uc(a,b,c){if(!c.has(a)){switch(a){case "scroll":vc(b,"scroll",!0);break;case "focus":case "blur":vc(b,"focus",!0);vc(b,"blur",!0);c.set("blur",null);c.set("focus",null);break;case "cancel":case "close":oc(a)&&vc(b,a,!0);break;case "invalid":case "submit":case "reset":break;default:-1===ac.indexOf(a)&&F(a,b)}c.set(a,null)}}
	var wc,xc,yc,zc=!1,Ac=[],Bc=null,Cc=null,Dc=null,Ec=new Map,Fc=new Map,Gc=[],Hc="mousedown mouseup touchcancel touchend touchstart auxclick dblclick pointercancel pointerdown pointerup dragend dragstart drop compositionend compositionstart keydown keypress keyup input textInput close cancel copy cut paste click change contextmenu reset submit".split(" "),Ic="focus blur dragenter dragleave mouseover mouseout pointerover pointerout gotpointercapture lostpointercapture".split(" ");
	function Jc(a,b){var c=cc(b);Hc.forEach(function(a){uc(a,b,c)});Ic.forEach(function(a){uc(a,b,c)})}function Kc(a,b,c,d,e){return{blockedOn:a,topLevelType:b,eventSystemFlags:c|32,nativeEvent:e,container:d}}
	function Lc(a,b){switch(a){case "focus":case "blur":Bc=null;break;case "dragenter":case "dragleave":Cc=null;break;case "mouseover":case "mouseout":Dc=null;break;case "pointerover":case "pointerout":Ec.delete(b.pointerId);break;case "gotpointercapture":case "lostpointercapture":Fc.delete(b.pointerId)}}function Mc(a,b,c,d,e,f){if(null===a||a.nativeEvent!==f)return a=Kc(b,c,d,e,f),null!==b&&(b=Nc(b),null!==b&&xc(b)),a;a.eventSystemFlags|=d;return a}
	function Oc(a,b,c,d,e){switch(b){case "focus":return Bc=Mc(Bc,a,b,c,d,e),!0;case "dragenter":return Cc=Mc(Cc,a,b,c,d,e),!0;case "mouseover":return Dc=Mc(Dc,a,b,c,d,e),!0;case "pointerover":var f=e.pointerId;Ec.set(f,Mc(Ec.get(f)||null,a,b,c,d,e));return!0;case "gotpointercapture":return f=e.pointerId,Fc.set(f,Mc(Fc.get(f)||null,a,b,c,d,e)),!0}return!1}
	function Pc(a){var b=tc(a.target);if(null!==b){var c=dc(b);if(null!==c)if(b=c.tag,13===b){if(b=ec(c),null!==b){a.blockedOn=b;r.unstable_runWithPriority(a.priority,function(){yc(c)});return}}else if(3===b&&c.stateNode.hydrate){a.blockedOn=3===c.tag?c.stateNode.containerInfo:null;return}}a.blockedOn=null}function Qc(a){if(null!==a.blockedOn)return!1;var b=Rc(a.topLevelType,a.eventSystemFlags,a.container,a.nativeEvent);if(null!==b){var c=Nc(b);null!==c&&xc(c);a.blockedOn=b;return!1}return!0}
	function Sc(a,b,c){Qc(a)&&c.delete(b)}function Tc(){for(zc=!1;0<Ac.length;){var a=Ac[0];if(null!==a.blockedOn){a=Nc(a.blockedOn);null!==a&&wc(a);break}var b=Rc(a.topLevelType,a.eventSystemFlags,a.container,a.nativeEvent);null!==b?a.blockedOn=b:Ac.shift()}null!==Bc&&Qc(Bc)&&(Bc=null);null!==Cc&&Qc(Cc)&&(Cc=null);null!==Dc&&Qc(Dc)&&(Dc=null);Ec.forEach(Sc);Fc.forEach(Sc)}function Uc(a,b){a.blockedOn===b&&(a.blockedOn=null,zc||(zc=!0,r.unstable_scheduleCallback(r.unstable_NormalPriority,Tc)))}
	function Vc(a){function b(b){return Uc(b,a)}if(0<Ac.length){Uc(Ac[0],a);for(var c=1;c<Ac.length;c++){var d=Ac[c];d.blockedOn===a&&(d.blockedOn=null)}}null!==Bc&&Uc(Bc,a);null!==Cc&&Uc(Cc,a);null!==Dc&&Uc(Dc,a);Ec.forEach(b);Fc.forEach(b);for(c=0;c<Gc.length;c++)d=Gc[c],d.blockedOn===a&&(d.blockedOn=null);for(;0<Gc.length&&(c=Gc[0],null===c.blockedOn);)Pc(c),null===c.blockedOn&&Gc.shift()}
	var Wc={},Yc=new Map,Zc=new Map,$c=["abort","abort",Xb,"animationEnd",Yb,"animationIteration",Zb,"animationStart","canplay","canPlay","canplaythrough","canPlayThrough","durationchange","durationChange","emptied","emptied","encrypted","encrypted","ended","ended","error","error","gotpointercapture","gotPointerCapture","load","load","loadeddata","loadedData","loadedmetadata","loadedMetadata","loadstart","loadStart","lostpointercapture","lostPointerCapture","playing","playing","progress","progress","seeking",
	"seeking","stalled","stalled","suspend","suspend","timeupdate","timeUpdate",$b,"transitionEnd","waiting","waiting"];function ad(a,b){for(var c=0;c<a.length;c+=2){var d=a[c],e=a[c+1],f="on"+(e[0].toUpperCase()+e.slice(1));f={phasedRegistrationNames:{bubbled:f,captured:f+"Capture"},dependencies:[d],eventPriority:b};Zc.set(d,b);Yc.set(d,f);Wc[e]=f}}
	ad("blur blur cancel cancel click click close close contextmenu contextMenu copy copy cut cut auxclick auxClick dblclick doubleClick dragend dragEnd dragstart dragStart drop drop focus focus input input invalid invalid keydown keyDown keypress keyPress keyup keyUp mousedown mouseDown mouseup mouseUp paste paste pause pause play play pointercancel pointerCancel pointerdown pointerDown pointerup pointerUp ratechange rateChange reset reset seeked seeked submit submit touchcancel touchCancel touchend touchEnd touchstart touchStart volumechange volumeChange".split(" "),0);
	ad("drag drag dragenter dragEnter dragexit dragExit dragleave dragLeave dragover dragOver mousemove mouseMove mouseout mouseOut mouseover mouseOver pointermove pointerMove pointerout pointerOut pointerover pointerOver scroll scroll toggle toggle touchmove touchMove wheel wheel".split(" "),1);ad($c,2);for(var bd="change selectionchange textInput compositionstart compositionend compositionupdate".split(" "),cd=0;cd<bd.length;cd++)Zc.set(bd[cd],0);
	var dd=r.unstable_UserBlockingPriority,ed=r.unstable_runWithPriority,fd=!0;function F(a,b){vc(b,a,!1)}function vc(a,b,c){var d=Zc.get(b);switch(void 0===d?2:d){case 0:d=gd.bind(null,b,1,a);break;case 1:d=hd.bind(null,b,1,a);break;default:d=id.bind(null,b,1,a)}c?a.addEventListener(b,d,!0):a.addEventListener(b,d,!1)}function gd(a,b,c,d){Ja||Ha();var e=id,f=Ja;Ja=!0;try{Ga(e,a,b,c,d)}finally{(Ja=f)||La()}}function hd(a,b,c,d){ed(dd,id.bind(null,a,b,c,d))}
	function id(a,b,c,d){if(fd)if(0<Ac.length&&-1<Hc.indexOf(a))a=Kc(null,a,b,c,d),Ac.push(a);else{var e=Rc(a,b,c,d);if(null===e)Lc(a,d);else if(-1<Hc.indexOf(a))a=Kc(e,a,b,c,d),Ac.push(a);else if(!Oc(e,a,b,c,d)){Lc(a,d);a=rc(a,d,null,b);try{Ma(sc,a)}finally{qc(a)}}}}
	function Rc(a,b,c,d){c=nc(d);c=tc(c);if(null!==c){var e=dc(c);if(null===e)c=null;else{var f=e.tag;if(13===f){c=ec(e);if(null!==c)return c;c=null}else if(3===f){if(e.stateNode.hydrate)return 3===e.tag?e.stateNode.containerInfo:null;c=null}else e!==c&&(c=null)}}a=rc(a,d,c,b);try{Ma(sc,a)}finally{qc(a)}return null}
	var jd={animationIterationCount:!0,borderImageOutset:!0,borderImageSlice:!0,borderImageWidth:!0,boxFlex:!0,boxFlexGroup:!0,boxOrdinalGroup:!0,columnCount:!0,columns:!0,flex:!0,flexGrow:!0,flexPositive:!0,flexShrink:!0,flexNegative:!0,flexOrder:!0,gridArea:!0,gridRow:!0,gridRowEnd:!0,gridRowSpan:!0,gridRowStart:!0,gridColumn:!0,gridColumnEnd:!0,gridColumnSpan:!0,gridColumnStart:!0,fontWeight:!0,lineClamp:!0,lineHeight:!0,opacity:!0,order:!0,orphans:!0,tabSize:!0,widows:!0,zIndex:!0,zoom:!0,fillOpacity:!0,
	floodOpacity:!0,stopOpacity:!0,strokeDasharray:!0,strokeDashoffset:!0,strokeMiterlimit:!0,strokeOpacity:!0,strokeWidth:!0},kd=["Webkit","ms","Moz","O"];Object.keys(jd).forEach(function(a){kd.forEach(function(b){b=b+a.charAt(0).toUpperCase()+a.substring(1);jd[b]=jd[a]})});function ld(a,b,c){return null==b||"boolean"===typeof b||""===b?"":c||"number"!==typeof b||0===b||jd.hasOwnProperty(a)&&jd[a]?(""+b).trim():b+"px"}
	function md(a,b){a=a.style;for(var c in b)if(b.hasOwnProperty(c)){var d=0===c.indexOf("--"),e=ld(c,b[c],d);"float"===c&&(c="cssFloat");d?a.setProperty(c,e):a[c]=e}}var nd=n({menuitem:!0},{area:!0,base:!0,br:!0,col:!0,embed:!0,hr:!0,img:!0,input:!0,keygen:!0,link:!0,meta:!0,param:!0,source:!0,track:!0,wbr:!0});
	function od(a,b){if(b){if(nd[a]&&(null!=b.children||null!=b.dangerouslySetInnerHTML))throw Error(u(137,a,""));if(null!=b.dangerouslySetInnerHTML){if(null!=b.children)throw Error(u(60));if(!("object"===typeof b.dangerouslySetInnerHTML&&"__html"in b.dangerouslySetInnerHTML))throw Error(u(61));}if(null!=b.style&&"object"!==typeof b.style)throw Error(u(62,""));}}
	function pd(a,b){if(-1===a.indexOf("-"))return"string"===typeof b.is;switch(a){case "annotation-xml":case "color-profile":case "font-face":case "font-face-src":case "font-face-uri":case "font-face-format":case "font-face-name":case "missing-glyph":return!1;default:return!0}}var qd=Mb.html;function rd(a,b){a=9===a.nodeType||11===a.nodeType?a:a.ownerDocument;var c=cc(a);b=wa[b];for(var d=0;d<b.length;d++)uc(b[d],a,c)}function sd(){}
	function td(a){a=a||("undefined"!==typeof document?document:void 0);if("undefined"===typeof a)return null;try{return a.activeElement||a.body}catch(b){return a.body}}function ud(a){for(;a&&a.firstChild;)a=a.firstChild;return a}function vd(a,b){var c=ud(a);a=0;for(var d;c;){if(3===c.nodeType){d=a+c.textContent.length;if(a<=b&&d>=b)return{node:c,offset:b-a};a=d}a:{for(;c;){if(c.nextSibling){c=c.nextSibling;break a}c=c.parentNode}c=void 0}c=ud(c)}}
	function wd(a,b){return a&&b?a===b?!0:a&&3===a.nodeType?!1:b&&3===b.nodeType?wd(a,b.parentNode):"contains"in a?a.contains(b):a.compareDocumentPosition?!!(a.compareDocumentPosition(b)&16):!1:!1}function xd(){for(var a=window,b=td();b instanceof a.HTMLIFrameElement;){try{var c="string"===typeof b.contentWindow.location.href}catch(d){c=!1}if(c)a=b.contentWindow;else break;b=td(a.document)}return b}
	function yd(a){var b=a&&a.nodeName&&a.nodeName.toLowerCase();return b&&("input"===b&&("text"===a.type||"search"===a.type||"tel"===a.type||"url"===a.type||"password"===a.type)||"textarea"===b||"true"===a.contentEditable)}var zd="$",Ad="/$",Bd="$?",Cd="$!",Dd=null,Ed=null;function Fd(a,b){switch(a){case "button":case "input":case "select":case "textarea":return!!b.autoFocus}return!1}
	function Gd(a,b){return"textarea"===a||"option"===a||"noscript"===a||"string"===typeof b.children||"number"===typeof b.children||"object"===typeof b.dangerouslySetInnerHTML&&null!==b.dangerouslySetInnerHTML&&null!=b.dangerouslySetInnerHTML.__html}var Hd="function"===typeof setTimeout?setTimeout:void 0,Id="function"===typeof clearTimeout?clearTimeout:void 0;function Jd(a){for(;null!=a;a=a.nextSibling){var b=a.nodeType;if(1===b||3===b)break}return a}
	function Kd(a){a=a.previousSibling;for(var b=0;a;){if(8===a.nodeType){var c=a.data;if(c===zd||c===Cd||c===Bd){if(0===b)return a;b--}else c===Ad&&b++}a=a.previousSibling}return null}var Ld=Math.random().toString(36).slice(2),Md="__reactInternalInstance$"+Ld,Nd="__reactEventHandlers$"+Ld,Od="__reactContainere$"+Ld;
	function tc(a){var b=a[Md];if(b)return b;for(var c=a.parentNode;c;){if(b=c[Od]||c[Md]){c=b.alternate;if(null!==b.child||null!==c&&null!==c.child)for(a=Kd(a);null!==a;){if(c=a[Md])return c;a=Kd(a)}return b}a=c;c=a.parentNode}return null}function Nc(a){a=a[Md]||a[Od];return!a||5!==a.tag&&6!==a.tag&&13!==a.tag&&3!==a.tag?null:a}function Pd(a){if(5===a.tag||6===a.tag)return a.stateNode;throw Error(u(33));}function Qd(a){return a[Nd]||null}
	function Rd(a){do a=a.return;while(a&&5!==a.tag);return a?a:null}
	function Sd(a,b){var c=a.stateNode;if(!c)return null;var d=la(c);if(!d)return null;c=d[b];a:switch(b){case "onClick":case "onClickCapture":case "onDoubleClick":case "onDoubleClickCapture":case "onMouseDown":case "onMouseDownCapture":case "onMouseMove":case "onMouseMoveCapture":case "onMouseUp":case "onMouseUpCapture":case "onMouseEnter":(d=!d.disabled)||(a=a.type,d=!("button"===a||"input"===a||"select"===a||"textarea"===a));a=!d;break a;default:a=!1}if(a)return null;if(c&&"function"!==typeof c)throw Error(u(231,
	b,typeof c));return c}function Td(a,b,c){if(b=Sd(a,c.dispatchConfig.phasedRegistrationNames[b]))c._dispatchListeners=ic(c._dispatchListeners,b),c._dispatchInstances=ic(c._dispatchInstances,a)}function Ud(a){if(a&&a.dispatchConfig.phasedRegistrationNames){for(var b=a._targetInst,c=[];b;)c.push(b),b=Rd(b);for(b=c.length;0<b--;)Td(c[b],"captured",a);for(b=0;b<c.length;b++)Td(c[b],"bubbled",a)}}
	function Vd(a,b,c){a&&c&&c.dispatchConfig.registrationName&&(b=Sd(a,c.dispatchConfig.registrationName))&&(c._dispatchListeners=ic(c._dispatchListeners,b),c._dispatchInstances=ic(c._dispatchInstances,a))}function Wd(a){a&&a.dispatchConfig.registrationName&&Vd(a._targetInst,null,a)}function Xd(a){jc(a,Ud)}var Yd=null,Zd=null,$d=null;
	function ae(){if($d)return $d;var a,b=Zd,c=b.length,d,e="value"in Yd?Yd.value:Yd.textContent,f=e.length;for(a=0;a<c&&b[a]===e[a];a++);var g=c-a;for(d=1;d<=g&&b[c-d]===e[f-d];d++);return $d=e.slice(a,1<d?1-d:void 0)}function be(){return!0}function ce(){return!1}
	function G(a,b,c,d){this.dispatchConfig=a;this._targetInst=b;this.nativeEvent=c;a=this.constructor.Interface;for(var e in a)a.hasOwnProperty(e)&&((b=a[e])?this[e]=b(c):"target"===e?this.target=d:this[e]=c[e]);this.isDefaultPrevented=(null!=c.defaultPrevented?c.defaultPrevented:!1===c.returnValue)?be:ce;this.isPropagationStopped=ce;return this}
	n(G.prototype,{preventDefault:function(){this.defaultPrevented=!0;var a=this.nativeEvent;a&&(a.preventDefault?a.preventDefault():"unknown"!==typeof a.returnValue&&(a.returnValue=!1),this.isDefaultPrevented=be)},stopPropagation:function(){var a=this.nativeEvent;a&&(a.stopPropagation?a.stopPropagation():"unknown"!==typeof a.cancelBubble&&(a.cancelBubble=!0),this.isPropagationStopped=be)},persist:function(){this.isPersistent=be},isPersistent:ce,destructor:function(){var a=this.constructor.Interface,
	b;for(b in a)this[b]=null;this.nativeEvent=this._targetInst=this.dispatchConfig=null;this.isPropagationStopped=this.isDefaultPrevented=ce;this._dispatchInstances=this._dispatchListeners=null}});G.Interface={type:null,target:null,currentTarget:function(){return null},eventPhase:null,bubbles:null,cancelable:null,timeStamp:function(a){return a.timeStamp||Date.now()},defaultPrevented:null,isTrusted:null};
	G.extend=function(a){function b(){}function c(){return d.apply(this,arguments)}var d=this;b.prototype=d.prototype;var e=new b;n(e,c.prototype);c.prototype=e;c.prototype.constructor=c;c.Interface=n({},d.Interface,a);c.extend=d.extend;de(c);return c};de(G);function ee(a,b,c,d){if(this.eventPool.length){var e=this.eventPool.pop();this.call(e,a,b,c,d);return e}return new this(a,b,c,d)}
	function fe(a){if(!(a instanceof this))throw Error(u(279));a.destructor();10>this.eventPool.length&&this.eventPool.push(a)}function de(a){a.eventPool=[];a.getPooled=ee;a.release=fe}var ge=G.extend({data:null}),he=G.extend({data:null}),ie=[9,13,27,32],je=ya&&"CompositionEvent"in window,ke=null;ya&&"documentMode"in document&&(ke=document.documentMode);
	var le=ya&&"TextEvent"in window&&!ke,me=ya&&(!je||ke&&8<ke&&11>=ke),ne=String.fromCharCode(32),oe={beforeInput:{phasedRegistrationNames:{bubbled:"onBeforeInput",captured:"onBeforeInputCapture"},dependencies:["compositionend","keypress","textInput","paste"]},compositionEnd:{phasedRegistrationNames:{bubbled:"onCompositionEnd",captured:"onCompositionEndCapture"},dependencies:"blur compositionend keydown keypress keyup mousedown".split(" ")},compositionStart:{phasedRegistrationNames:{bubbled:"onCompositionStart",
	captured:"onCompositionStartCapture"},dependencies:"blur compositionstart keydown keypress keyup mousedown".split(" ")},compositionUpdate:{phasedRegistrationNames:{bubbled:"onCompositionUpdate",captured:"onCompositionUpdateCapture"},dependencies:"blur compositionupdate keydown keypress keyup mousedown".split(" ")}},pe=!1;
	function qe(a,b){switch(a){case "keyup":return-1!==ie.indexOf(b.keyCode);case "keydown":return 229!==b.keyCode;case "keypress":case "mousedown":case "blur":return!0;default:return!1}}function re(a){a=a.detail;return"object"===typeof a&&"data"in a?a.data:null}var se=!1;function te(a,b){switch(a){case "compositionend":return re(b);case "keypress":if(32!==b.which)return null;pe=!0;return ne;case "textInput":return a=b.data,a===ne&&pe?null:a;default:return null}}
	function ue(a,b){if(se)return"compositionend"===a||!je&&qe(a,b)?(a=ae(),$d=Zd=Yd=null,se=!1,a):null;switch(a){case "paste":return null;case "keypress":if(!(b.ctrlKey||b.altKey||b.metaKey)||b.ctrlKey&&b.altKey){if(b.char&&1<b.char.length)return b.char;if(b.which)return String.fromCharCode(b.which)}return null;case "compositionend":return me&&"ko"!==b.locale?null:b.data;default:return null}}
	var ve={eventTypes:oe,extractEvents:function(a,b,c,d){var e;if(je)b:{switch(a){case "compositionstart":var f=oe.compositionStart;break b;case "compositionend":f=oe.compositionEnd;break b;case "compositionupdate":f=oe.compositionUpdate;break b}f=void 0}else se?qe(a,c)&&(f=oe.compositionEnd):"keydown"===a&&229===c.keyCode&&(f=oe.compositionStart);f?(me&&"ko"!==c.locale&&(se||f!==oe.compositionStart?f===oe.compositionEnd&&se&&(e=ae()):(Yd=d,Zd="value"in Yd?Yd.value:Yd.textContent,se=!0)),f=ge.getPooled(f,
	b,c,d),e?f.data=e:(e=re(c),null!==e&&(f.data=e)),Xd(f),e=f):e=null;(a=le?te(a,c):ue(a,c))?(b=he.getPooled(oe.beforeInput,b,c,d),b.data=a,Xd(b)):b=null;return null===e?b:null===b?e:[e,b]}},we={color:!0,date:!0,datetime:!0,"datetime-local":!0,email:!0,month:!0,number:!0,password:!0,range:!0,search:!0,tel:!0,text:!0,time:!0,url:!0,week:!0};function xe(a){var b=a&&a.nodeName&&a.nodeName.toLowerCase();return"input"===b?!!we[a.type]:"textarea"===b?!0:!1}
	var ye={change:{phasedRegistrationNames:{bubbled:"onChange",captured:"onChangeCapture"},dependencies:"blur change click focus input keydown keyup selectionchange".split(" ")}};function ze(a,b,c){a=G.getPooled(ye.change,a,b,c);a.type="change";Da(c);Xd(a);return a}var Ae=null,Be=null;function Ce(a){mc(a)}function De(a){var b=Pd(a);if(yb(b))return a}function Ee(a,b){if("change"===a)return b}var Fe=!1;ya&&(Fe=oc("input")&&(!document.documentMode||9<document.documentMode));
	function Ge(){Ae&&(Ae.detachEvent("onpropertychange",He),Be=Ae=null)}function He(a){if("value"===a.propertyName&&De(Be))if(a=ze(Be,a,nc(a)),Ja)mc(a);else{Ja=!0;try{Fa(Ce,a)}finally{Ja=!1,La()}}}function Ie(a,b,c){"focus"===a?(Ge(),Ae=b,Be=c,Ae.attachEvent("onpropertychange",He)):"blur"===a&&Ge()}function Je(a){if("selectionchange"===a||"keyup"===a||"keydown"===a)return De(Be)}function Ke(a,b){if("click"===a)return De(b)}function Le(a,b){if("input"===a||"change"===a)return De(b)}
	var Me={eventTypes:ye,_isInputEventSupported:Fe,extractEvents:function(a,b,c,d){var e=b?Pd(b):window,f=e.nodeName&&e.nodeName.toLowerCase();if("select"===f||"input"===f&&"file"===e.type)var g=Ee;else if(xe(e))if(Fe)g=Le;else{g=Je;var h=Ie}else(f=e.nodeName)&&"input"===f.toLowerCase()&&("checkbox"===e.type||"radio"===e.type)&&(g=Ke);if(g&&(g=g(a,b)))return ze(g,c,d);h&&h(a,e,b);"blur"===a&&(a=e._wrapperState)&&a.controlled&&"number"===e.type&&Db(e,"number",e.value)}},Ne=G.extend({view:null,detail:null}),
	Oe={Alt:"altKey",Control:"ctrlKey",Meta:"metaKey",Shift:"shiftKey"};function Pe(a){var b=this.nativeEvent;return b.getModifierState?b.getModifierState(a):(a=Oe[a])?!!b[a]:!1}function Qe(){return Pe}
	var Re=0,Se=0,Te=!1,Ue=!1,Ve=Ne.extend({screenX:null,screenY:null,clientX:null,clientY:null,pageX:null,pageY:null,ctrlKey:null,shiftKey:null,altKey:null,metaKey:null,getModifierState:Qe,button:null,buttons:null,relatedTarget:function(a){return a.relatedTarget||(a.fromElement===a.srcElement?a.toElement:a.fromElement)},movementX:function(a){if("movementX"in a)return a.movementX;var b=Re;Re=a.screenX;return Te?"mousemove"===a.type?a.screenX-b:0:(Te=!0,0)},movementY:function(a){if("movementY"in a)return a.movementY;
	var b=Se;Se=a.screenY;return Ue?"mousemove"===a.type?a.screenY-b:0:(Ue=!0,0)}}),We=Ve.extend({pointerId:null,width:null,height:null,pressure:null,tangentialPressure:null,tiltX:null,tiltY:null,twist:null,pointerType:null,isPrimary:null}),Xe={mouseEnter:{registrationName:"onMouseEnter",dependencies:["mouseout","mouseover"]},mouseLeave:{registrationName:"onMouseLeave",dependencies:["mouseout","mouseover"]},pointerEnter:{registrationName:"onPointerEnter",dependencies:["pointerout","pointerover"]},pointerLeave:{registrationName:"onPointerLeave",
	dependencies:["pointerout","pointerover"]}},Ye={eventTypes:Xe,extractEvents:function(a,b,c,d,e){var f="mouseover"===a||"pointerover"===a,g="mouseout"===a||"pointerout"===a;if(f&&0===(e&32)&&(c.relatedTarget||c.fromElement)||!g&&!f)return null;f=d.window===d?d:(f=d.ownerDocument)?f.defaultView||f.parentWindow:window;if(g){if(g=b,b=(b=c.relatedTarget||c.toElement)?tc(b):null,null!==b){var h=dc(b);if(b!==h||5!==b.tag&&6!==b.tag)b=null}}else g=null;if(g===b)return null;if("mouseout"===a||"mouseover"===
	a){var k=Ve;var l=Xe.mouseLeave;var m=Xe.mouseEnter;var p="mouse"}else if("pointerout"===a||"pointerover"===a)k=We,l=Xe.pointerLeave,m=Xe.pointerEnter,p="pointer";a=null==g?f:Pd(g);f=null==b?f:Pd(b);l=k.getPooled(l,g,c,d);l.type=p+"leave";l.target=a;l.relatedTarget=f;c=k.getPooled(m,b,c,d);c.type=p+"enter";c.target=f;c.relatedTarget=a;d=g;p=b;if(d&&p)a:{k=d;m=p;g=0;for(a=k;a;a=Rd(a))g++;a=0;for(b=m;b;b=Rd(b))a++;for(;0<g-a;)k=Rd(k),g--;for(;0<a-g;)m=Rd(m),a--;for(;g--;){if(k===m||k===m.alternate)break a;
	k=Rd(k);m=Rd(m)}k=null}else k=null;m=k;for(k=[];d&&d!==m;){g=d.alternate;if(null!==g&&g===m)break;k.push(d);d=Rd(d)}for(d=[];p&&p!==m;){g=p.alternate;if(null!==g&&g===m)break;d.push(p);p=Rd(p)}for(p=0;p<k.length;p++)Vd(k[p],"bubbled",l);for(p=d.length;0<p--;)Vd(d[p],"captured",c);return 0===(e&64)?[l]:[l,c]}};function Ze(a,b){return a===b&&(0!==a||1/a===1/b)||a!==a&&b!==b}var $e="function"===typeof Object.is?Object.is:Ze,af=Object.prototype.hasOwnProperty;
	function bf(a,b){if($e(a,b))return!0;if("object"!==typeof a||null===a||"object"!==typeof b||null===b)return!1;var c=Object.keys(a),d=Object.keys(b);if(c.length!==d.length)return!1;for(d=0;d<c.length;d++)if(!af.call(b,c[d])||!$e(a[c[d]],b[c[d]]))return!1;return!0}
	var cf=ya&&"documentMode"in document&&11>=document.documentMode,df={select:{phasedRegistrationNames:{bubbled:"onSelect",captured:"onSelectCapture"},dependencies:"blur contextmenu dragend focus keydown keyup mousedown mouseup selectionchange".split(" ")}},ef=null,ff=null,gf=null,hf=!1;
	function jf(a,b){var c=b.window===b?b.document:9===b.nodeType?b:b.ownerDocument;if(hf||null==ef||ef!==td(c))return null;c=ef;"selectionStart"in c&&yd(c)?c={start:c.selectionStart,end:c.selectionEnd}:(c=(c.ownerDocument&&c.ownerDocument.defaultView||window).getSelection(),c={anchorNode:c.anchorNode,anchorOffset:c.anchorOffset,focusNode:c.focusNode,focusOffset:c.focusOffset});return gf&&bf(gf,c)?null:(gf=c,a=G.getPooled(df.select,ff,a,b),a.type="select",a.target=ef,Xd(a),a)}
	var kf={eventTypes:df,extractEvents:function(a,b,c,d,e,f){e=f||(d.window===d?d.document:9===d.nodeType?d:d.ownerDocument);if(!(f=!e)){a:{e=cc(e);f=wa.onSelect;for(var g=0;g<f.length;g++)if(!e.has(f[g])){e=!1;break a}e=!0}f=!e}if(f)return null;e=b?Pd(b):window;switch(a){case "focus":if(xe(e)||"true"===e.contentEditable)ef=e,ff=b,gf=null;break;case "blur":gf=ff=ef=null;break;case "mousedown":hf=!0;break;case "contextmenu":case "mouseup":case "dragend":return hf=!1,jf(c,d);case "selectionchange":if(cf)break;
	case "keydown":case "keyup":return jf(c,d)}return null}},lf=G.extend({animationName:null,elapsedTime:null,pseudoElement:null}),mf=G.extend({clipboardData:function(a){return"clipboardData"in a?a.clipboardData:window.clipboardData}}),nf=Ne.extend({relatedTarget:null});function of(a){var b=a.keyCode;"charCode"in a?(a=a.charCode,0===a&&13===b&&(a=13)):a=b;10===a&&(a=13);return 32<=a||13===a?a:0}
	var pf={Esc:"Escape",Spacebar:" ",Left:"ArrowLeft",Up:"ArrowUp",Right:"ArrowRight",Down:"ArrowDown",Del:"Delete",Win:"OS",Menu:"ContextMenu",Apps:"ContextMenu",Scroll:"ScrollLock",MozPrintableKey:"Unidentified"},qf={8:"Backspace",9:"Tab",12:"Clear",13:"Enter",16:"Shift",17:"Control",18:"Alt",19:"Pause",20:"CapsLock",27:"Escape",32:" ",33:"PageUp",34:"PageDown",35:"End",36:"Home",37:"ArrowLeft",38:"ArrowUp",39:"ArrowRight",40:"ArrowDown",45:"Insert",46:"Delete",112:"F1",113:"F2",114:"F3",115:"F4",
	116:"F5",117:"F6",118:"F7",119:"F8",120:"F9",121:"F10",122:"F11",123:"F12",144:"NumLock",145:"ScrollLock",224:"Meta"},rf=Ne.extend({key:function(a){if(a.key){var b=pf[a.key]||a.key;if("Unidentified"!==b)return b}return"keypress"===a.type?(a=of(a),13===a?"Enter":String.fromCharCode(a)):"keydown"===a.type||"keyup"===a.type?qf[a.keyCode]||"Unidentified":""},location:null,ctrlKey:null,shiftKey:null,altKey:null,metaKey:null,repeat:null,locale:null,getModifierState:Qe,charCode:function(a){return"keypress"===
	a.type?of(a):0},keyCode:function(a){return"keydown"===a.type||"keyup"===a.type?a.keyCode:0},which:function(a){return"keypress"===a.type?of(a):"keydown"===a.type||"keyup"===a.type?a.keyCode:0}}),sf=Ve.extend({dataTransfer:null}),tf=Ne.extend({touches:null,targetTouches:null,changedTouches:null,altKey:null,metaKey:null,ctrlKey:null,shiftKey:null,getModifierState:Qe}),uf=G.extend({propertyName:null,elapsedTime:null,pseudoElement:null}),vf=Ve.extend({deltaX:function(a){return"deltaX"in a?a.deltaX:"wheelDeltaX"in
	a?-a.wheelDeltaX:0},deltaY:function(a){return"deltaY"in a?a.deltaY:"wheelDeltaY"in a?-a.wheelDeltaY:"wheelDelta"in a?-a.wheelDelta:0},deltaZ:null,deltaMode:null}),wf={eventTypes:Wc,extractEvents:function(a,b,c,d){var e=Yc.get(a);if(!e)return null;switch(a){case "keypress":if(0===of(c))return null;case "keydown":case "keyup":a=rf;break;case "blur":case "focus":a=nf;break;case "click":if(2===c.button)return null;case "auxclick":case "dblclick":case "mousedown":case "mousemove":case "mouseup":case "mouseout":case "mouseover":case "contextmenu":a=
	Ve;break;case "drag":case "dragend":case "dragenter":case "dragexit":case "dragleave":case "dragover":case "dragstart":case "drop":a=sf;break;case "touchcancel":case "touchend":case "touchmove":case "touchstart":a=tf;break;case Xb:case Yb:case Zb:a=lf;break;case $b:a=uf;break;case "scroll":a=Ne;break;case "wheel":a=vf;break;case "copy":case "cut":case "paste":a=mf;break;case "gotpointercapture":case "lostpointercapture":case "pointercancel":case "pointerdown":case "pointermove":case "pointerout":case "pointerover":case "pointerup":a=
	We;break;default:a=G}b=a.getPooled(e,b,c,d);Xd(b);return b}};if(pa)throw Error(u(101));pa=Array.prototype.slice.call("ResponderEventPlugin SimpleEventPlugin EnterLeaveEventPlugin ChangeEventPlugin SelectEventPlugin BeforeInputEventPlugin".split(" "));ra();var xf=Nc;la=Qd;ma=xf;na=Pd;xa({SimpleEventPlugin:wf,EnterLeaveEventPlugin:Ye,ChangeEventPlugin:Me,SelectEventPlugin:kf,BeforeInputEventPlugin:ve});var yf=[],zf=-1;function H(a){0>zf||(a.current=yf[zf],yf[zf]=null,zf--)}
	function I(a,b){zf++;yf[zf]=a.current;a.current=b}var Af={},J={current:Af},K={current:!1},Bf=Af;function Cf(a,b){var c=a.type.contextTypes;if(!c)return Af;var d=a.stateNode;if(d&&d.__reactInternalMemoizedUnmaskedChildContext===b)return d.__reactInternalMemoizedMaskedChildContext;var e={},f;for(f in c)e[f]=b[f];d&&(a=a.stateNode,a.__reactInternalMemoizedUnmaskedChildContext=b,a.__reactInternalMemoizedMaskedChildContext=e);return e}function L(a){a=a.childContextTypes;return null!==a&&void 0!==a}
	function Df(){H(K);H(J)}function Ef(a,b,c){if(J.current!==Af)throw Error(u(168));I(J,b);I(K,c)}function Ff(a,b,c){var d=a.stateNode;a=b.childContextTypes;if("function"!==typeof d.getChildContext)return c;d=d.getChildContext();for(var e in d)if(!(e in a))throw Error(u(108,pb(b)||"Unknown",e));return n({},c,{},d)}function Gf(a){a=(a=a.stateNode)&&a.__reactInternalMemoizedMergedChildContext||Af;Bf=J.current;I(J,a);I(K,K.current);return!0}
	function Hf(a,b,c){var d=a.stateNode;if(!d)throw Error(u(169));c?(a=Ff(a,b,Bf),d.__reactInternalMemoizedMergedChildContext=a,H(K),H(J),I(J,a)):H(K);I(K,c)}
	var If=r.unstable_runWithPriority,Jf=r.unstable_scheduleCallback,Kf=r.unstable_cancelCallback,Lf=r.unstable_requestPaint,Mf=r.unstable_now,Nf=r.unstable_getCurrentPriorityLevel,Of=r.unstable_ImmediatePriority,Pf=r.unstable_UserBlockingPriority,Qf=r.unstable_NormalPriority,Rf=r.unstable_LowPriority,Sf=r.unstable_IdlePriority,Tf={},Uf=r.unstable_shouldYield,Vf=void 0!==Lf?Lf:function(){},Wf=null,Xf=null,Yf=!1,Zf=Mf(),$f=1E4>Zf?Mf:function(){return Mf()-Zf};
	function ag(){switch(Nf()){case Of:return 99;case Pf:return 98;case Qf:return 97;case Rf:return 96;case Sf:return 95;default:throw Error(u(332));}}function bg(a){switch(a){case 99:return Of;case 98:return Pf;case 97:return Qf;case 96:return Rf;case 95:return Sf;default:throw Error(u(332));}}function cg(a,b){a=bg(a);return If(a,b)}function dg(a,b,c){a=bg(a);return Jf(a,b,c)}function eg(a){null===Wf?(Wf=[a],Xf=Jf(Of,fg)):Wf.push(a);return Tf}function gg(){if(null!==Xf){var a=Xf;Xf=null;Kf(a)}fg()}
	function fg(){if(!Yf&&null!==Wf){Yf=!0;var a=0;try{var b=Wf;cg(99,function(){for(;a<b.length;a++){var c=b[a];do c=c(!0);while(null!==c)}});Wf=null}catch(c){throw null!==Wf&&(Wf=Wf.slice(a+1)),Jf(Of,gg),c;}finally{Yf=!1}}}function hg(a,b,c){c/=10;return 1073741821-(((1073741821-a+b/10)/c|0)+1)*c}function ig(a,b){if(a&&a.defaultProps){b=n({},b);a=a.defaultProps;for(var c in a)void 0===b[c]&&(b[c]=a[c])}return b}var jg={current:null},kg=null,lg=null,mg=null;function ng(){mg=lg=kg=null}
	function og(a){var b=jg.current;H(jg);a.type._context._currentValue=b}function pg(a,b){for(;null!==a;){var c=a.alternate;if(a.childExpirationTime<b)a.childExpirationTime=b,null!==c&&c.childExpirationTime<b&&(c.childExpirationTime=b);else if(null!==c&&c.childExpirationTime<b)c.childExpirationTime=b;else break;a=a.return}}function qg(a,b){kg=a;mg=lg=null;a=a.dependencies;null!==a&&null!==a.firstContext&&(a.expirationTime>=b&&(rg=!0),a.firstContext=null)}
	function sg(a,b){if(mg!==a&&!1!==b&&0!==b){if("number"!==typeof b||1073741823===b)mg=a,b=1073741823;b={context:a,observedBits:b,next:null};if(null===lg){if(null===kg)throw Error(u(308));lg=b;kg.dependencies={expirationTime:0,firstContext:b,responders:null}}else lg=lg.next=b}return a._currentValue}var tg=!1;function ug(a){a.updateQueue={baseState:a.memoizedState,baseQueue:null,shared:{pending:null},effects:null}}
	function vg(a,b){a=a.updateQueue;b.updateQueue===a&&(b.updateQueue={baseState:a.baseState,baseQueue:a.baseQueue,shared:a.shared,effects:a.effects})}function wg(a,b){a={expirationTime:a,suspenseConfig:b,tag:0,payload:null,callback:null,next:null};return a.next=a}function xg(a,b){a=a.updateQueue;if(null!==a){a=a.shared;var c=a.pending;null===c?b.next=b:(b.next=c.next,c.next=b);a.pending=b}}
	function yg(a,b){var c=a.alternate;null!==c&&vg(c,a);a=a.updateQueue;c=a.baseQueue;null===c?(a.baseQueue=b.next=b,b.next=b):(b.next=c.next,c.next=b)}
	function zg(a,b,c,d){var e=a.updateQueue;tg=!1;var f=e.baseQueue,g=e.shared.pending;if(null!==g){if(null!==f){var h=f.next;f.next=g.next;g.next=h}f=g;e.shared.pending=null;h=a.alternate;null!==h&&(h=h.updateQueue,null!==h&&(h.baseQueue=g))}if(null!==f){h=f.next;var k=e.baseState,l=0,m=null,p=null,x=null;if(null!==h){var z=h;do{g=z.expirationTime;if(g<d){var ca={expirationTime:z.expirationTime,suspenseConfig:z.suspenseConfig,tag:z.tag,payload:z.payload,callback:z.callback,next:null};null===x?(p=x=
	ca,m=k):x=x.next=ca;g>l&&(l=g)}else{null!==x&&(x=x.next={expirationTime:1073741823,suspenseConfig:z.suspenseConfig,tag:z.tag,payload:z.payload,callback:z.callback,next:null});Ag(g,z.suspenseConfig);a:{var D=a,t=z;g=b;ca=c;switch(t.tag){case 1:D=t.payload;if("function"===typeof D){k=D.call(ca,k,g);break a}k=D;break a;case 3:D.effectTag=D.effectTag&-4097|64;case 0:D=t.payload;g="function"===typeof D?D.call(ca,k,g):D;if(null===g||void 0===g)break a;k=n({},k,g);break a;case 2:tg=!0}}null!==z.callback&&
	(a.effectTag|=32,g=e.effects,null===g?e.effects=[z]:g.push(z))}z=z.next;if(null===z||z===h)if(g=e.shared.pending,null===g)break;else z=f.next=g.next,g.next=h,e.baseQueue=f=g,e.shared.pending=null}while(1)}null===x?m=k:x.next=p;e.baseState=m;e.baseQueue=x;Bg(l);a.expirationTime=l;a.memoizedState=k}}
	function Cg(a,b,c){a=b.effects;b.effects=null;if(null!==a)for(b=0;b<a.length;b++){var d=a[b],e=d.callback;if(null!==e){d.callback=null;d=e;e=c;if("function"!==typeof d)throw Error(u(191,d));d.call(e)}}}var Dg=Wa.ReactCurrentBatchConfig,Eg=(new aa.Component).refs;function Fg(a,b,c,d){b=a.memoizedState;c=c(d,b);c=null===c||void 0===c?b:n({},b,c);a.memoizedState=c;0===a.expirationTime&&(a.updateQueue.baseState=c)}
	var Jg={isMounted:function(a){return(a=a._reactInternalFiber)?dc(a)===a:!1},enqueueSetState:function(a,b,c){a=a._reactInternalFiber;var d=Gg(),e=Dg.suspense;d=Hg(d,a,e);e=wg(d,e);e.payload=b;void 0!==c&&null!==c&&(e.callback=c);xg(a,e);Ig(a,d)},enqueueReplaceState:function(a,b,c){a=a._reactInternalFiber;var d=Gg(),e=Dg.suspense;d=Hg(d,a,e);e=wg(d,e);e.tag=1;e.payload=b;void 0!==c&&null!==c&&(e.callback=c);xg(a,e);Ig(a,d)},enqueueForceUpdate:function(a,b){a=a._reactInternalFiber;var c=Gg(),d=Dg.suspense;
	c=Hg(c,a,d);d=wg(c,d);d.tag=2;void 0!==b&&null!==b&&(d.callback=b);xg(a,d);Ig(a,c)}};function Kg(a,b,c,d,e,f,g){a=a.stateNode;return"function"===typeof a.shouldComponentUpdate?a.shouldComponentUpdate(d,f,g):b.prototype&&b.prototype.isPureReactComponent?!bf(c,d)||!bf(e,f):!0}
	function Lg(a,b,c){var d=!1,e=Af;var f=b.contextType;"object"===typeof f&&null!==f?f=sg(f):(e=L(b)?Bf:J.current,d=b.contextTypes,f=(d=null!==d&&void 0!==d)?Cf(a,e):Af);b=new b(c,f);a.memoizedState=null!==b.state&&void 0!==b.state?b.state:null;b.updater=Jg;a.stateNode=b;b._reactInternalFiber=a;d&&(a=a.stateNode,a.__reactInternalMemoizedUnmaskedChildContext=e,a.__reactInternalMemoizedMaskedChildContext=f);return b}
	function Mg(a,b,c,d){a=b.state;"function"===typeof b.componentWillReceiveProps&&b.componentWillReceiveProps(c,d);"function"===typeof b.UNSAFE_componentWillReceiveProps&&b.UNSAFE_componentWillReceiveProps(c,d);b.state!==a&&Jg.enqueueReplaceState(b,b.state,null)}
	function Ng(a,b,c,d){var e=a.stateNode;e.props=c;e.state=a.memoizedState;e.refs=Eg;ug(a);var f=b.contextType;"object"===typeof f&&null!==f?e.context=sg(f):(f=L(b)?Bf:J.current,e.context=Cf(a,f));zg(a,c,e,d);e.state=a.memoizedState;f=b.getDerivedStateFromProps;"function"===typeof f&&(Fg(a,b,f,c),e.state=a.memoizedState);"function"===typeof b.getDerivedStateFromProps||"function"===typeof e.getSnapshotBeforeUpdate||"function"!==typeof e.UNSAFE_componentWillMount&&"function"!==typeof e.componentWillMount||
	(b=e.state,"function"===typeof e.componentWillMount&&e.componentWillMount(),"function"===typeof e.UNSAFE_componentWillMount&&e.UNSAFE_componentWillMount(),b!==e.state&&Jg.enqueueReplaceState(e,e.state,null),zg(a,c,e,d),e.state=a.memoizedState);"function"===typeof e.componentDidMount&&(a.effectTag|=4)}var Og=Array.isArray;
	function Pg(a,b,c){a=c.ref;if(null!==a&&"function"!==typeof a&&"object"!==typeof a){if(c._owner){c=c._owner;if(c){if(1!==c.tag)throw Error(u(309));var d=c.stateNode}if(!d)throw Error(u(147,a));var e=""+a;if(null!==b&&null!==b.ref&&"function"===typeof b.ref&&b.ref._stringRef===e)return b.ref;b=function(a){var b=d.refs;b===Eg&&(b=d.refs={});null===a?delete b[e]:b[e]=a};b._stringRef=e;return b}if("string"!==typeof a)throw Error(u(284));if(!c._owner)throw Error(u(290,a));}return a}
	function Qg(a,b){if("textarea"!==a.type)throw Error(u(31,"[object Object]"===Object.prototype.toString.call(b)?"object with keys {"+Object.keys(b).join(", ")+"}":b,""));}
	function Rg(a){function b(b,c){if(a){var d=b.lastEffect;null!==d?(d.nextEffect=c,b.lastEffect=c):b.firstEffect=b.lastEffect=c;c.nextEffect=null;c.effectTag=8}}function c(c,d){if(!a)return null;for(;null!==d;)b(c,d),d=d.sibling;return null}function d(a,b){for(a=new Map;null!==b;)null!==b.key?a.set(b.key,b):a.set(b.index,b),b=b.sibling;return a}function e(a,b){a=Sg(a,b);a.index=0;a.sibling=null;return a}function f(b,c,d){b.index=d;if(!a)return c;d=b.alternate;if(null!==d)return d=d.index,d<c?(b.effectTag=
	2,c):d;b.effectTag=2;return c}function g(b){a&&null===b.alternate&&(b.effectTag=2);return b}function h(a,b,c,d){if(null===b||6!==b.tag)return b=Tg(c,a.mode,d),b.return=a,b;b=e(b,c);b.return=a;return b}function k(a,b,c,d){if(null!==b&&b.elementType===c.type)return d=e(b,c.props),d.ref=Pg(a,b,c),d.return=a,d;d=Ug(c.type,c.key,c.props,null,a.mode,d);d.ref=Pg(a,b,c);d.return=a;return d}function l(a,b,c,d){if(null===b||4!==b.tag||b.stateNode.containerInfo!==c.containerInfo||b.stateNode.implementation!==
	c.implementation)return b=Vg(c,a.mode,d),b.return=a,b;b=e(b,c.children||[]);b.return=a;return b}function m(a,b,c,d,f){if(null===b||7!==b.tag)return b=Wg(c,a.mode,d,f),b.return=a,b;b=e(b,c);b.return=a;return b}function p(a,b,c){if("string"===typeof b||"number"===typeof b)return b=Tg(""+b,a.mode,c),b.return=a,b;if("object"===typeof b&&null!==b){switch(b.$$typeof){case Za:return c=Ug(b.type,b.key,b.props,null,a.mode,c),c.ref=Pg(a,null,b),c.return=a,c;case $a:return b=Vg(b,a.mode,c),b.return=a,b}if(Og(b)||
	nb(b))return b=Wg(b,a.mode,c,null),b.return=a,b;Qg(a,b)}return null}function x(a,b,c,d){var e=null!==b?b.key:null;if("string"===typeof c||"number"===typeof c)return null!==e?null:h(a,b,""+c,d);if("object"===typeof c&&null!==c){switch(c.$$typeof){case Za:return c.key===e?c.type===ab?m(a,b,c.props.children,d,e):k(a,b,c,d):null;case $a:return c.key===e?l(a,b,c,d):null}if(Og(c)||nb(c))return null!==e?null:m(a,b,c,d,null);Qg(a,c)}return null}function z(a,b,c,d,e){if("string"===typeof d||"number"===typeof d)return a=
	a.get(c)||null,h(b,a,""+d,e);if("object"===typeof d&&null!==d){switch(d.$$typeof){case Za:return a=a.get(null===d.key?c:d.key)||null,d.type===ab?m(b,a,d.props.children,e,d.key):k(b,a,d,e);case $a:return a=a.get(null===d.key?c:d.key)||null,l(b,a,d,e)}if(Og(d)||nb(d))return a=a.get(c)||null,m(b,a,d,e,null);Qg(b,d)}return null}function ca(e,g,h,k){for(var l=null,t=null,m=g,y=g=0,A=null;null!==m&&y<h.length;y++){m.index>y?(A=m,m=null):A=m.sibling;var q=x(e,m,h[y],k);if(null===q){null===m&&(m=A);break}a&&
	m&&null===q.alternate&&b(e,m);g=f(q,g,y);null===t?l=q:t.sibling=q;t=q;m=A}if(y===h.length)return c(e,m),l;if(null===m){for(;y<h.length;y++)m=p(e,h[y],k),null!==m&&(g=f(m,g,y),null===t?l=m:t.sibling=m,t=m);return l}for(m=d(e,m);y<h.length;y++)A=z(m,e,y,h[y],k),null!==A&&(a&&null!==A.alternate&&m.delete(null===A.key?y:A.key),g=f(A,g,y),null===t?l=A:t.sibling=A,t=A);a&&m.forEach(function(a){return b(e,a)});return l}function D(e,g,h,l){var k=nb(h);if("function"!==typeof k)throw Error(u(150));h=k.call(h);
	if(null==h)throw Error(u(151));for(var m=k=null,t=g,y=g=0,A=null,q=h.next();null!==t&&!q.done;y++,q=h.next()){t.index>y?(A=t,t=null):A=t.sibling;var D=x(e,t,q.value,l);if(null===D){null===t&&(t=A);break}a&&t&&null===D.alternate&&b(e,t);g=f(D,g,y);null===m?k=D:m.sibling=D;m=D;t=A}if(q.done)return c(e,t),k;if(null===t){for(;!q.done;y++,q=h.next())q=p(e,q.value,l),null!==q&&(g=f(q,g,y),null===m?k=q:m.sibling=q,m=q);return k}for(t=d(e,t);!q.done;y++,q=h.next())q=z(t,e,y,q.value,l),null!==q&&(a&&null!==
	q.alternate&&t.delete(null===q.key?y:q.key),g=f(q,g,y),null===m?k=q:m.sibling=q,m=q);a&&t.forEach(function(a){return b(e,a)});return k}return function(a,d,f,h){var k="object"===typeof f&&null!==f&&f.type===ab&&null===f.key;k&&(f=f.props.children);var l="object"===typeof f&&null!==f;if(l)switch(f.$$typeof){case Za:a:{l=f.key;for(k=d;null!==k;){if(k.key===l){switch(k.tag){case 7:if(f.type===ab){c(a,k.sibling);d=e(k,f.props.children);d.return=a;a=d;break a}break;default:if(k.elementType===f.type){c(a,
	k.sibling);d=e(k,f.props);d.ref=Pg(a,k,f);d.return=a;a=d;break a}}c(a,k);break}else b(a,k);k=k.sibling}f.type===ab?(d=Wg(f.props.children,a.mode,h,f.key),d.return=a,a=d):(h=Ug(f.type,f.key,f.props,null,a.mode,h),h.ref=Pg(a,d,f),h.return=a,a=h)}return g(a);case $a:a:{for(k=f.key;null!==d;){if(d.key===k)if(4===d.tag&&d.stateNode.containerInfo===f.containerInfo&&d.stateNode.implementation===f.implementation){c(a,d.sibling);d=e(d,f.children||[]);d.return=a;a=d;break a}else{c(a,d);break}else b(a,d);d=
	d.sibling}d=Vg(f,a.mode,h);d.return=a;a=d}return g(a)}if("string"===typeof f||"number"===typeof f)return f=""+f,null!==d&&6===d.tag?(c(a,d.sibling),d=e(d,f),d.return=a,a=d):(c(a,d),d=Tg(f,a.mode,h),d.return=a,a=d),g(a);if(Og(f))return ca(a,d,f,h);if(nb(f))return D(a,d,f,h);l&&Qg(a,f);if("undefined"===typeof f&&!k)switch(a.tag){case 1:case 0:throw a=a.type,Error(u(152,a.displayName||a.name||"Component"));}return c(a,d)}}var Xg=Rg(!0),Yg=Rg(!1),Zg={},$g={current:Zg},ah={current:Zg},bh={current:Zg};
	function ch(a){if(a===Zg)throw Error(u(174));return a}function dh(a,b){I(bh,b);I(ah,a);I($g,Zg);a=b.nodeType;switch(a){case 9:case 11:b=(b=b.documentElement)?b.namespaceURI:Ob(null,"");break;default:a=8===a?b.parentNode:b,b=a.namespaceURI||null,a=a.tagName,b=Ob(b,a)}H($g);I($g,b)}function eh(){H($g);H(ah);H(bh)}function fh(a){ch(bh.current);var b=ch($g.current);var c=Ob(b,a.type);b!==c&&(I(ah,a),I($g,c))}function gh(a){ah.current===a&&(H($g),H(ah))}var M={current:0};
	function hh(a){for(var b=a;null!==b;){if(13===b.tag){var c=b.memoizedState;if(null!==c&&(c=c.dehydrated,null===c||c.data===Bd||c.data===Cd))return b}else if(19===b.tag&&void 0!==b.memoizedProps.revealOrder){if(0!==(b.effectTag&64))return b}else if(null!==b.child){b.child.return=b;b=b.child;continue}if(b===a)break;for(;null===b.sibling;){if(null===b.return||b.return===a)return null;b=b.return}b.sibling.return=b.return;b=b.sibling}return null}function ih(a,b){return{responder:a,props:b}}
	var jh=Wa.ReactCurrentDispatcher,kh=Wa.ReactCurrentBatchConfig,lh=0,N=null,O=null,P=null,mh=!1;function Q(){throw Error(u(321));}function nh(a,b){if(null===b)return!1;for(var c=0;c<b.length&&c<a.length;c++)if(!$e(a[c],b[c]))return!1;return!0}
	function oh(a,b,c,d,e,f){lh=f;N=b;b.memoizedState=null;b.updateQueue=null;b.expirationTime=0;jh.current=null===a||null===a.memoizedState?ph:qh;a=c(d,e);if(b.expirationTime===lh){f=0;do{b.expirationTime=0;if(!(25>f))throw Error(u(301));f+=1;P=O=null;b.updateQueue=null;jh.current=rh;a=c(d,e)}while(b.expirationTime===lh)}jh.current=sh;b=null!==O&&null!==O.next;lh=0;P=O=N=null;mh=!1;if(b)throw Error(u(300));return a}
	function th(){var a={memoizedState:null,baseState:null,baseQueue:null,queue:null,next:null};null===P?N.memoizedState=P=a:P=P.next=a;return P}function uh(){if(null===O){var a=N.alternate;a=null!==a?a.memoizedState:null}else a=O.next;var b=null===P?N.memoizedState:P.next;if(null!==b)P=b,O=a;else{if(null===a)throw Error(u(310));O=a;a={memoizedState:O.memoizedState,baseState:O.baseState,baseQueue:O.baseQueue,queue:O.queue,next:null};null===P?N.memoizedState=P=a:P=P.next=a}return P}
	function vh(a,b){return"function"===typeof b?b(a):b}
	function wh(a){var b=uh(),c=b.queue;if(null===c)throw Error(u(311));c.lastRenderedReducer=a;var d=O,e=d.baseQueue,f=c.pending;if(null!==f){if(null!==e){var g=e.next;e.next=f.next;f.next=g}d.baseQueue=e=f;c.pending=null}if(null!==e){e=e.next;d=d.baseState;var h=g=f=null,k=e;do{var l=k.expirationTime;if(l<lh){var m={expirationTime:k.expirationTime,suspenseConfig:k.suspenseConfig,action:k.action,eagerReducer:k.eagerReducer,eagerState:k.eagerState,next:null};null===h?(g=h=m,f=d):h=h.next=m;l>N.expirationTime&&
	(N.expirationTime=l,Bg(l))}else null!==h&&(h=h.next={expirationTime:1073741823,suspenseConfig:k.suspenseConfig,action:k.action,eagerReducer:k.eagerReducer,eagerState:k.eagerState,next:null}),Ag(l,k.suspenseConfig),d=k.eagerReducer===a?k.eagerState:a(d,k.action);k=k.next}while(null!==k&&k!==e);null===h?f=d:h.next=g;$e(d,b.memoizedState)||(rg=!0);b.memoizedState=d;b.baseState=f;b.baseQueue=h;c.lastRenderedState=d}return[b.memoizedState,c.dispatch]}
	function xh(a){var b=uh(),c=b.queue;if(null===c)throw Error(u(311));c.lastRenderedReducer=a;var d=c.dispatch,e=c.pending,f=b.memoizedState;if(null!==e){c.pending=null;var g=e=e.next;do f=a(f,g.action),g=g.next;while(g!==e);$e(f,b.memoizedState)||(rg=!0);b.memoizedState=f;null===b.baseQueue&&(b.baseState=f);c.lastRenderedState=f}return[f,d]}
	function yh(a){var b=th();"function"===typeof a&&(a=a());b.memoizedState=b.baseState=a;a=b.queue={pending:null,dispatch:null,lastRenderedReducer:vh,lastRenderedState:a};a=a.dispatch=zh.bind(null,N,a);return[b.memoizedState,a]}function Ah(a,b,c,d){a={tag:a,create:b,destroy:c,deps:d,next:null};b=N.updateQueue;null===b?(b={lastEffect:null},N.updateQueue=b,b.lastEffect=a.next=a):(c=b.lastEffect,null===c?b.lastEffect=a.next=a:(d=c.next,c.next=a,a.next=d,b.lastEffect=a));return a}
	function Bh(){return uh().memoizedState}function Ch(a,b,c,d){var e=th();N.effectTag|=a;e.memoizedState=Ah(1|b,c,void 0,void 0===d?null:d)}function Dh(a,b,c,d){var e=uh();d=void 0===d?null:d;var f=void 0;if(null!==O){var g=O.memoizedState;f=g.destroy;if(null!==d&&nh(d,g.deps)){Ah(b,c,f,d);return}}N.effectTag|=a;e.memoizedState=Ah(1|b,c,f,d)}function Eh(a,b){return Ch(516,4,a,b)}function Fh(a,b){return Dh(516,4,a,b)}function Gh(a,b){return Dh(4,2,a,b)}
	function Hh(a,b){if("function"===typeof b)return a=a(),b(a),function(){b(null)};if(null!==b&&void 0!==b)return a=a(),b.current=a,function(){b.current=null}}function Ih(a,b,c){c=null!==c&&void 0!==c?c.concat([a]):null;return Dh(4,2,Hh.bind(null,b,a),c)}function Jh(){}function Kh(a,b){th().memoizedState=[a,void 0===b?null:b];return a}function Lh(a,b){var c=uh();b=void 0===b?null:b;var d=c.memoizedState;if(null!==d&&null!==b&&nh(b,d[1]))return d[0];c.memoizedState=[a,b];return a}
	function Mh(a,b){var c=uh();b=void 0===b?null:b;var d=c.memoizedState;if(null!==d&&null!==b&&nh(b,d[1]))return d[0];a=a();c.memoizedState=[a,b];return a}function Nh(a,b,c){var d=ag();cg(98>d?98:d,function(){a(!0)});cg(97<d?97:d,function(){var d=kh.suspense;kh.suspense=void 0===b?null:b;try{a(!1),c()}finally{kh.suspense=d}})}
	function zh(a,b,c){var d=Gg(),e=Dg.suspense;d=Hg(d,a,e);e={expirationTime:d,suspenseConfig:e,action:c,eagerReducer:null,eagerState:null,next:null};var f=b.pending;null===f?e.next=e:(e.next=f.next,f.next=e);b.pending=e;f=a.alternate;if(a===N||null!==f&&f===N)mh=!0,e.expirationTime=lh,N.expirationTime=lh;else{if(0===a.expirationTime&&(null===f||0===f.expirationTime)&&(f=b.lastRenderedReducer,null!==f))try{var g=b.lastRenderedState,h=f(g,c);e.eagerReducer=f;e.eagerState=h;if($e(h,g))return}catch(k){}finally{}Ig(a,
	d)}}
	var sh={readContext:sg,useCallback:Q,useContext:Q,useEffect:Q,useImperativeHandle:Q,useLayoutEffect:Q,useMemo:Q,useReducer:Q,useRef:Q,useState:Q,useDebugValue:Q,useResponder:Q,useDeferredValue:Q,useTransition:Q},ph={readContext:sg,useCallback:Kh,useContext:sg,useEffect:Eh,useImperativeHandle:function(a,b,c){c=null!==c&&void 0!==c?c.concat([a]):null;return Ch(4,2,Hh.bind(null,b,a),c)},useLayoutEffect:function(a,b){return Ch(4,2,a,b)},useMemo:function(a,b){var c=th();b=void 0===b?null:b;a=a();c.memoizedState=[a,
	b];return a},useReducer:function(a,b,c){var d=th();b=void 0!==c?c(b):b;d.memoizedState=d.baseState=b;a=d.queue={pending:null,dispatch:null,lastRenderedReducer:a,lastRenderedState:b};a=a.dispatch=zh.bind(null,N,a);return[d.memoizedState,a]},useRef:function(a){var b=th();a={current:a};return b.memoizedState=a},useState:yh,useDebugValue:Jh,useResponder:ih,useDeferredValue:function(a,b){var c=yh(a),d=c[0],e=c[1];Eh(function(){var c=kh.suspense;kh.suspense=void 0===b?null:b;try{e(a)}finally{kh.suspense=
	c}},[a,b]);return d},useTransition:function(a){var b=yh(!1),c=b[0];b=b[1];return[Kh(Nh.bind(null,b,a),[b,a]),c]}},qh={readContext:sg,useCallback:Lh,useContext:sg,useEffect:Fh,useImperativeHandle:Ih,useLayoutEffect:Gh,useMemo:Mh,useReducer:wh,useRef:Bh,useState:function(){return wh(vh)},useDebugValue:Jh,useResponder:ih,useDeferredValue:function(a,b){var c=wh(vh),d=c[0],e=c[1];Fh(function(){var c=kh.suspense;kh.suspense=void 0===b?null:b;try{e(a)}finally{kh.suspense=c}},[a,b]);return d},useTransition:function(a){var b=
	wh(vh),c=b[0];b=b[1];return[Lh(Nh.bind(null,b,a),[b,a]),c]}},rh={readContext:sg,useCallback:Lh,useContext:sg,useEffect:Fh,useImperativeHandle:Ih,useLayoutEffect:Gh,useMemo:Mh,useReducer:xh,useRef:Bh,useState:function(){return xh(vh)},useDebugValue:Jh,useResponder:ih,useDeferredValue:function(a,b){var c=xh(vh),d=c[0],e=c[1];Fh(function(){var c=kh.suspense;kh.suspense=void 0===b?null:b;try{e(a)}finally{kh.suspense=c}},[a,b]);return d},useTransition:function(a){var b=xh(vh),c=b[0];b=b[1];return[Lh(Nh.bind(null,
	b,a),[b,a]),c]}},Oh=null,Ph=null,Qh=!1;function Rh(a,b){var c=Sh(5,null,null,0);c.elementType="DELETED";c.type="DELETED";c.stateNode=b;c.return=a;c.effectTag=8;null!==a.lastEffect?(a.lastEffect.nextEffect=c,a.lastEffect=c):a.firstEffect=a.lastEffect=c}
	function Th(a,b){switch(a.tag){case 5:var c=a.type;b=1!==b.nodeType||c.toLowerCase()!==b.nodeName.toLowerCase()?null:b;return null!==b?(a.stateNode=b,!0):!1;case 6:return b=""===a.pendingProps||3!==b.nodeType?null:b,null!==b?(a.stateNode=b,!0):!1;case 13:return!1;default:return!1}}
	function Uh(a){if(Qh){var b=Ph;if(b){var c=b;if(!Th(a,b)){b=Jd(c.nextSibling);if(!b||!Th(a,b)){a.effectTag=a.effectTag&-1025|2;Qh=!1;Oh=a;return}Rh(Oh,c)}Oh=a;Ph=Jd(b.firstChild)}else a.effectTag=a.effectTag&-1025|2,Qh=!1,Oh=a}}function Vh(a){for(a=a.return;null!==a&&5!==a.tag&&3!==a.tag&&13!==a.tag;)a=a.return;Oh=a}
	function Wh(a){if(a!==Oh)return!1;if(!Qh)return Vh(a),Qh=!0,!1;var b=a.type;if(5!==a.tag||"head"!==b&&"body"!==b&&!Gd(b,a.memoizedProps))for(b=Ph;b;)Rh(a,b),b=Jd(b.nextSibling);Vh(a);if(13===a.tag){a=a.memoizedState;a=null!==a?a.dehydrated:null;if(!a)throw Error(u(317));a:{a=a.nextSibling;for(b=0;a;){if(8===a.nodeType){var c=a.data;if(c===Ad){if(0===b){Ph=Jd(a.nextSibling);break a}b--}else c!==zd&&c!==Cd&&c!==Bd||b++}a=a.nextSibling}Ph=null}}else Ph=Oh?Jd(a.stateNode.nextSibling):null;return!0}
	function Xh(){Ph=Oh=null;Qh=!1}var Yh=Wa.ReactCurrentOwner,rg=!1;function R(a,b,c,d){b.child=null===a?Yg(b,null,c,d):Xg(b,a.child,c,d)}function Zh(a,b,c,d,e){c=c.render;var f=b.ref;qg(b,e);d=oh(a,b,c,d,f,e);if(null!==a&&!rg)return b.updateQueue=a.updateQueue,b.effectTag&=-517,a.expirationTime<=e&&(a.expirationTime=0),$h(a,b,e);b.effectTag|=1;R(a,b,d,e);return b.child}
	function ai(a,b,c,d,e,f){if(null===a){var g=c.type;if("function"===typeof g&&!bi(g)&&void 0===g.defaultProps&&null===c.compare&&void 0===c.defaultProps)return b.tag=15,b.type=g,ci(a,b,g,d,e,f);a=Ug(c.type,null,d,null,b.mode,f);a.ref=b.ref;a.return=b;return b.child=a}g=a.child;if(e<f&&(e=g.memoizedProps,c=c.compare,c=null!==c?c:bf,c(e,d)&&a.ref===b.ref))return $h(a,b,f);b.effectTag|=1;a=Sg(g,d);a.ref=b.ref;a.return=b;return b.child=a}
	function ci(a,b,c,d,e,f){return null!==a&&bf(a.memoizedProps,d)&&a.ref===b.ref&&(rg=!1,e<f)?(b.expirationTime=a.expirationTime,$h(a,b,f)):di(a,b,c,d,f)}function ei(a,b){var c=b.ref;if(null===a&&null!==c||null!==a&&a.ref!==c)b.effectTag|=128}function di(a,b,c,d,e){var f=L(c)?Bf:J.current;f=Cf(b,f);qg(b,e);c=oh(a,b,c,d,f,e);if(null!==a&&!rg)return b.updateQueue=a.updateQueue,b.effectTag&=-517,a.expirationTime<=e&&(a.expirationTime=0),$h(a,b,e);b.effectTag|=1;R(a,b,c,e);return b.child}
	function fi(a,b,c,d,e){if(L(c)){var f=!0;Gf(b)}else f=!1;qg(b,e);if(null===b.stateNode)null!==a&&(a.alternate=null,b.alternate=null,b.effectTag|=2),Lg(b,c,d),Ng(b,c,d,e),d=!0;else if(null===a){var g=b.stateNode,h=b.memoizedProps;g.props=h;var k=g.context,l=c.contextType;"object"===typeof l&&null!==l?l=sg(l):(l=L(c)?Bf:J.current,l=Cf(b,l));var m=c.getDerivedStateFromProps,p="function"===typeof m||"function"===typeof g.getSnapshotBeforeUpdate;p||"function"!==typeof g.UNSAFE_componentWillReceiveProps&&
	"function"!==typeof g.componentWillReceiveProps||(h!==d||k!==l)&&Mg(b,g,d,l);tg=!1;var x=b.memoizedState;g.state=x;zg(b,d,g,e);k=b.memoizedState;h!==d||x!==k||K.current||tg?("function"===typeof m&&(Fg(b,c,m,d),k=b.memoizedState),(h=tg||Kg(b,c,h,d,x,k,l))?(p||"function"!==typeof g.UNSAFE_componentWillMount&&"function"!==typeof g.componentWillMount||("function"===typeof g.componentWillMount&&g.componentWillMount(),"function"===typeof g.UNSAFE_componentWillMount&&g.UNSAFE_componentWillMount()),"function"===
	typeof g.componentDidMount&&(b.effectTag|=4)):("function"===typeof g.componentDidMount&&(b.effectTag|=4),b.memoizedProps=d,b.memoizedState=k),g.props=d,g.state=k,g.context=l,d=h):("function"===typeof g.componentDidMount&&(b.effectTag|=4),d=!1)}else g=b.stateNode,vg(a,b),h=b.memoizedProps,g.props=b.type===b.elementType?h:ig(b.type,h),k=g.context,l=c.contextType,"object"===typeof l&&null!==l?l=sg(l):(l=L(c)?Bf:J.current,l=Cf(b,l)),m=c.getDerivedStateFromProps,(p="function"===typeof m||"function"===
	typeof g.getSnapshotBeforeUpdate)||"function"!==typeof g.UNSAFE_componentWillReceiveProps&&"function"!==typeof g.componentWillReceiveProps||(h!==d||k!==l)&&Mg(b,g,d,l),tg=!1,k=b.memoizedState,g.state=k,zg(b,d,g,e),x=b.memoizedState,h!==d||k!==x||K.current||tg?("function"===typeof m&&(Fg(b,c,m,d),x=b.memoizedState),(m=tg||Kg(b,c,h,d,k,x,l))?(p||"function"!==typeof g.UNSAFE_componentWillUpdate&&"function"!==typeof g.componentWillUpdate||("function"===typeof g.componentWillUpdate&&g.componentWillUpdate(d,
	x,l),"function"===typeof g.UNSAFE_componentWillUpdate&&g.UNSAFE_componentWillUpdate(d,x,l)),"function"===typeof g.componentDidUpdate&&(b.effectTag|=4),"function"===typeof g.getSnapshotBeforeUpdate&&(b.effectTag|=256)):("function"!==typeof g.componentDidUpdate||h===a.memoizedProps&&k===a.memoizedState||(b.effectTag|=4),"function"!==typeof g.getSnapshotBeforeUpdate||h===a.memoizedProps&&k===a.memoizedState||(b.effectTag|=256),b.memoizedProps=d,b.memoizedState=x),g.props=d,g.state=x,g.context=l,d=m):
	("function"!==typeof g.componentDidUpdate||h===a.memoizedProps&&k===a.memoizedState||(b.effectTag|=4),"function"!==typeof g.getSnapshotBeforeUpdate||h===a.memoizedProps&&k===a.memoizedState||(b.effectTag|=256),d=!1);return gi(a,b,c,d,f,e)}
	function gi(a,b,c,d,e,f){ei(a,b);var g=0!==(b.effectTag&64);if(!d&&!g)return e&&Hf(b,c,!1),$h(a,b,f);d=b.stateNode;Yh.current=b;var h=g&&"function"!==typeof c.getDerivedStateFromError?null:d.render();b.effectTag|=1;null!==a&&g?(b.child=Xg(b,a.child,null,f),b.child=Xg(b,null,h,f)):R(a,b,h,f);b.memoizedState=d.state;e&&Hf(b,c,!0);return b.child}function hi(a){var b=a.stateNode;b.pendingContext?Ef(a,b.pendingContext,b.pendingContext!==b.context):b.context&&Ef(a,b.context,!1);dh(a,b.containerInfo)}
	var ii={dehydrated:null,retryTime:0};
	function ji(a,b,c){var d=b.mode,e=b.pendingProps,f=M.current,g=!1,h;(h=0!==(b.effectTag&64))||(h=0!==(f&2)&&(null===a||null!==a.memoizedState));h?(g=!0,b.effectTag&=-65):null!==a&&null===a.memoizedState||void 0===e.fallback||!0===e.unstable_avoidThisFallback||(f|=1);I(M,f&1);if(null===a){void 0!==e.fallback&&Uh(b);if(g){g=e.fallback;e=Wg(null,d,0,null);e.return=b;if(0===(b.mode&2))for(a=null!==b.memoizedState?b.child.child:b.child,e.child=a;null!==a;)a.return=e,a=a.sibling;c=Wg(g,d,c,null);c.return=
	b;e.sibling=c;b.memoizedState=ii;b.child=e;return c}d=e.children;b.memoizedState=null;return b.child=Yg(b,null,d,c)}if(null!==a.memoizedState){a=a.child;d=a.sibling;if(g){e=e.fallback;c=Sg(a,a.pendingProps);c.return=b;if(0===(b.mode&2)&&(g=null!==b.memoizedState?b.child.child:b.child,g!==a.child))for(c.child=g;null!==g;)g.return=c,g=g.sibling;d=Sg(d,e);d.return=b;c.sibling=d;c.childExpirationTime=0;b.memoizedState=ii;b.child=c;return d}c=Xg(b,a.child,e.children,c);b.memoizedState=null;return b.child=
	c}a=a.child;if(g){g=e.fallback;e=Wg(null,d,0,null);e.return=b;e.child=a;null!==a&&(a.return=e);if(0===(b.mode&2))for(a=null!==b.memoizedState?b.child.child:b.child,e.child=a;null!==a;)a.return=e,a=a.sibling;c=Wg(g,d,c,null);c.return=b;e.sibling=c;c.effectTag|=2;e.childExpirationTime=0;b.memoizedState=ii;b.child=e;return c}b.memoizedState=null;return b.child=Xg(b,a,e.children,c)}
	function ki(a,b){a.expirationTime<b&&(a.expirationTime=b);var c=a.alternate;null!==c&&c.expirationTime<b&&(c.expirationTime=b);pg(a.return,b)}function li(a,b,c,d,e,f){var g=a.memoizedState;null===g?a.memoizedState={isBackwards:b,rendering:null,renderingStartTime:0,last:d,tail:c,tailExpiration:0,tailMode:e,lastEffect:f}:(g.isBackwards=b,g.rendering=null,g.renderingStartTime=0,g.last=d,g.tail=c,g.tailExpiration=0,g.tailMode=e,g.lastEffect=f)}
	function mi(a,b,c){var d=b.pendingProps,e=d.revealOrder,f=d.tail;R(a,b,d.children,c);d=M.current;if(0!==(d&2))d=d&1|2,b.effectTag|=64;else{if(null!==a&&0!==(a.effectTag&64))a:for(a=b.child;null!==a;){if(13===a.tag)null!==a.memoizedState&&ki(a,c);else if(19===a.tag)ki(a,c);else if(null!==a.child){a.child.return=a;a=a.child;continue}if(a===b)break a;for(;null===a.sibling;){if(null===a.return||a.return===b)break a;a=a.return}a.sibling.return=a.return;a=a.sibling}d&=1}I(M,d);if(0===(b.mode&2))b.memoizedState=
	null;else switch(e){case "forwards":c=b.child;for(e=null;null!==c;)a=c.alternate,null!==a&&null===hh(a)&&(e=c),c=c.sibling;c=e;null===c?(e=b.child,b.child=null):(e=c.sibling,c.sibling=null);li(b,!1,e,c,f,b.lastEffect);break;case "backwards":c=null;e=b.child;for(b.child=null;null!==e;){a=e.alternate;if(null!==a&&null===hh(a)){b.child=e;break}a=e.sibling;e.sibling=c;c=e;e=a}li(b,!0,c,null,f,b.lastEffect);break;case "together":li(b,!1,null,null,void 0,b.lastEffect);break;default:b.memoizedState=null}return b.child}
	function $h(a,b,c){null!==a&&(b.dependencies=a.dependencies);var d=b.expirationTime;0!==d&&Bg(d);if(b.childExpirationTime<c)return null;if(null!==a&&b.child!==a.child)throw Error(u(153));if(null!==b.child){a=b.child;c=Sg(a,a.pendingProps);b.child=c;for(c.return=b;null!==a.sibling;)a=a.sibling,c=c.sibling=Sg(a,a.pendingProps),c.return=b;c.sibling=null}return b.child}var ni,oi,pi,qi;
	ni=function(a,b){for(var c=b.child;null!==c;){if(5===c.tag||6===c.tag)a.appendChild(c.stateNode);else if(4!==c.tag&&null!==c.child){c.child.return=c;c=c.child;continue}if(c===b)break;for(;null===c.sibling;){if(null===c.return||c.return===b)return;c=c.return}c.sibling.return=c.return;c=c.sibling}};oi=function(){};
	pi=function(a,b,c,d,e){var f=a.memoizedProps;if(f!==d){var g=b.stateNode;ch($g.current);a=null;switch(c){case "input":f=zb(g,f);d=zb(g,d);a=[];break;case "option":f=Gb(g,f);d=Gb(g,d);a=[];break;case "select":f=n({},f,{value:void 0});d=n({},d,{value:void 0});a=[];break;case "textarea":f=Ib(g,f);d=Ib(g,d);a=[];break;default:"function"!==typeof f.onClick&&"function"===typeof d.onClick&&(g.onclick=sd)}od(c,d);var h,k;c=null;for(h in f)if(!d.hasOwnProperty(h)&&f.hasOwnProperty(h)&&null!=f[h])if("style"===
	h)for(k in g=f[h],g)g.hasOwnProperty(k)&&(c||(c={}),c[k]="");else"dangerouslySetInnerHTML"!==h&&"children"!==h&&"suppressContentEditableWarning"!==h&&"suppressHydrationWarning"!==h&&"autoFocus"!==h&&(va.hasOwnProperty(h)?a||(a=[]):(a=a||[]).push(h,null));for(h in d){var l=d[h];g=null!=f?f[h]:void 0;if(d.hasOwnProperty(h)&&l!==g&&(null!=l||null!=g))if("style"===h)if(g){for(k in g)!g.hasOwnProperty(k)||l&&l.hasOwnProperty(k)||(c||(c={}),c[k]="");for(k in l)l.hasOwnProperty(k)&&g[k]!==l[k]&&(c||(c={}),
	c[k]=l[k])}else c||(a||(a=[]),a.push(h,c)),c=l;else"dangerouslySetInnerHTML"===h?(l=l?l.__html:void 0,g=g?g.__html:void 0,null!=l&&g!==l&&(a=a||[]).push(h,l)):"children"===h?g===l||"string"!==typeof l&&"number"!==typeof l||(a=a||[]).push(h,""+l):"suppressContentEditableWarning"!==h&&"suppressHydrationWarning"!==h&&(va.hasOwnProperty(h)?(null!=l&&rd(e,h),a||g===l||(a=[])):(a=a||[]).push(h,l))}c&&(a=a||[]).push("style",c);e=a;if(b.updateQueue=e)b.effectTag|=4}};
	qi=function(a,b,c,d){c!==d&&(b.effectTag|=4)};function ri(a,b){switch(a.tailMode){case "hidden":b=a.tail;for(var c=null;null!==b;)null!==b.alternate&&(c=b),b=b.sibling;null===c?a.tail=null:c.sibling=null;break;case "collapsed":c=a.tail;for(var d=null;null!==c;)null!==c.alternate&&(d=c),c=c.sibling;null===d?b||null===a.tail?a.tail=null:a.tail.sibling=null:d.sibling=null}}
	function si(a,b,c){var d=b.pendingProps;switch(b.tag){case 2:case 16:case 15:case 0:case 11:case 7:case 8:case 12:case 9:case 14:return null;case 1:return L(b.type)&&Df(),null;case 3:return eh(),H(K),H(J),c=b.stateNode,c.pendingContext&&(c.context=c.pendingContext,c.pendingContext=null),null!==a&&null!==a.child||!Wh(b)||(b.effectTag|=4),oi(b),null;case 5:gh(b);c=ch(bh.current);var e=b.type;if(null!==a&&null!=b.stateNode)pi(a,b,e,d,c),a.ref!==b.ref&&(b.effectTag|=128);else{if(!d){if(null===b.stateNode)throw Error(u(166));
	return null}a=ch($g.current);if(Wh(b)){d=b.stateNode;e=b.type;var f=b.memoizedProps;d[Md]=b;d[Nd]=f;switch(e){case "iframe":case "object":case "embed":F("load",d);break;case "video":case "audio":for(a=0;a<ac.length;a++)F(ac[a],d);break;case "source":F("error",d);break;case "img":case "image":case "link":F("error",d);F("load",d);break;case "form":F("reset",d);F("submit",d);break;case "details":F("toggle",d);break;case "input":Ab(d,f);F("invalid",d);rd(c,"onChange");break;case "select":d._wrapperState=
	{wasMultiple:!!f.multiple};F("invalid",d);rd(c,"onChange");break;case "textarea":Jb(d,f),F("invalid",d),rd(c,"onChange")}od(e,f);a=null;for(var g in f)if(f.hasOwnProperty(g)){var h=f[g];"children"===g?"string"===typeof h?d.textContent!==h&&(a=["children",h]):"number"===typeof h&&d.textContent!==""+h&&(a=["children",""+h]):va.hasOwnProperty(g)&&null!=h&&rd(c,g)}switch(e){case "input":xb(d);Eb(d,f,!0);break;case "textarea":xb(d);Lb(d);break;case "select":case "option":break;default:"function"===typeof f.onClick&&
	(d.onclick=sd)}c=a;b.updateQueue=c;null!==c&&(b.effectTag|=4)}else{g=9===c.nodeType?c:c.ownerDocument;a===qd&&(a=Nb(e));a===qd?"script"===e?(a=g.createElement("div"),a.innerHTML="<script>\x3c/script>",a=a.removeChild(a.firstChild)):"string"===typeof d.is?a=g.createElement(e,{is:d.is}):(a=g.createElement(e),"select"===e&&(g=a,d.multiple?g.multiple=!0:d.size&&(g.size=d.size))):a=g.createElementNS(a,e);a[Md]=b;a[Nd]=d;ni(a,b,!1,!1);b.stateNode=a;g=pd(e,d);switch(e){case "iframe":case "object":case "embed":F("load",
	a);h=d;break;case "video":case "audio":for(h=0;h<ac.length;h++)F(ac[h],a);h=d;break;case "source":F("error",a);h=d;break;case "img":case "image":case "link":F("error",a);F("load",a);h=d;break;case "form":F("reset",a);F("submit",a);h=d;break;case "details":F("toggle",a);h=d;break;case "input":Ab(a,d);h=zb(a,d);F("invalid",a);rd(c,"onChange");break;case "option":h=Gb(a,d);break;case "select":a._wrapperState={wasMultiple:!!d.multiple};h=n({},d,{value:void 0});F("invalid",a);rd(c,"onChange");break;case "textarea":Jb(a,
	d);h=Ib(a,d);F("invalid",a);rd(c,"onChange");break;default:h=d}od(e,h);var k=h;for(f in k)if(k.hasOwnProperty(f)){var l=k[f];"style"===f?md(a,l):"dangerouslySetInnerHTML"===f?(l=l?l.__html:void 0,null!=l&&Qb(a,l)):"children"===f?"string"===typeof l?("textarea"!==e||""!==l)&&Rb(a,l):"number"===typeof l&&Rb(a,""+l):"suppressContentEditableWarning"!==f&&"suppressHydrationWarning"!==f&&"autoFocus"!==f&&(va.hasOwnProperty(f)?null!=l&&rd(c,f):null!=l&&Xa(a,f,l,g))}switch(e){case "input":xb(a);Eb(a,d,!1);
	break;case "textarea":xb(a);Lb(a);break;case "option":null!=d.value&&a.setAttribute("value",""+rb(d.value));break;case "select":a.multiple=!!d.multiple;c=d.value;null!=c?Hb(a,!!d.multiple,c,!1):null!=d.defaultValue&&Hb(a,!!d.multiple,d.defaultValue,!0);break;default:"function"===typeof h.onClick&&(a.onclick=sd)}Fd(e,d)&&(b.effectTag|=4)}null!==b.ref&&(b.effectTag|=128)}return null;case 6:if(a&&null!=b.stateNode)qi(a,b,a.memoizedProps,d);else{if("string"!==typeof d&&null===b.stateNode)throw Error(u(166));
	c=ch(bh.current);ch($g.current);Wh(b)?(c=b.stateNode,d=b.memoizedProps,c[Md]=b,c.nodeValue!==d&&(b.effectTag|=4)):(c=(9===c.nodeType?c:c.ownerDocument).createTextNode(d),c[Md]=b,b.stateNode=c)}return null;case 13:H(M);d=b.memoizedState;if(0!==(b.effectTag&64))return b.expirationTime=c,b;c=null!==d;d=!1;null===a?void 0!==b.memoizedProps.fallback&&Wh(b):(e=a.memoizedState,d=null!==e,c||null===e||(e=a.child.sibling,null!==e&&(f=b.firstEffect,null!==f?(b.firstEffect=e,e.nextEffect=f):(b.firstEffect=b.lastEffect=
	e,e.nextEffect=null),e.effectTag=8)));if(c&&!d&&0!==(b.mode&2))if(null===a&&!0!==b.memoizedProps.unstable_avoidThisFallback||0!==(M.current&1))S===ti&&(S=ui);else{if(S===ti||S===ui)S=vi;0!==wi&&null!==T&&(xi(T,U),yi(T,wi))}if(c||d)b.effectTag|=4;return null;case 4:return eh(),oi(b),null;case 10:return og(b),null;case 17:return L(b.type)&&Df(),null;case 19:H(M);d=b.memoizedState;if(null===d)return null;e=0!==(b.effectTag&64);f=d.rendering;if(null===f)if(e)ri(d,!1);else{if(S!==ti||null!==a&&0!==(a.effectTag&
	64))for(f=b.child;null!==f;){a=hh(f);if(null!==a){b.effectTag|=64;ri(d,!1);e=a.updateQueue;null!==e&&(b.updateQueue=e,b.effectTag|=4);null===d.lastEffect&&(b.firstEffect=null);b.lastEffect=d.lastEffect;for(d=b.child;null!==d;)e=d,f=c,e.effectTag&=2,e.nextEffect=null,e.firstEffect=null,e.lastEffect=null,a=e.alternate,null===a?(e.childExpirationTime=0,e.expirationTime=f,e.child=null,e.memoizedProps=null,e.memoizedState=null,e.updateQueue=null,e.dependencies=null):(e.childExpirationTime=a.childExpirationTime,
	e.expirationTime=a.expirationTime,e.child=a.child,e.memoizedProps=a.memoizedProps,e.memoizedState=a.memoizedState,e.updateQueue=a.updateQueue,f=a.dependencies,e.dependencies=null===f?null:{expirationTime:f.expirationTime,firstContext:f.firstContext,responders:f.responders}),d=d.sibling;I(M,M.current&1|2);return b.child}f=f.sibling}}else{if(!e)if(a=hh(f),null!==a){if(b.effectTag|=64,e=!0,c=a.updateQueue,null!==c&&(b.updateQueue=c,b.effectTag|=4),ri(d,!0),null===d.tail&&"hidden"===d.tailMode&&!f.alternate)return b=
	b.lastEffect=d.lastEffect,null!==b&&(b.nextEffect=null),null}else 2*$f()-d.renderingStartTime>d.tailExpiration&&1<c&&(b.effectTag|=64,e=!0,ri(d,!1),b.expirationTime=b.childExpirationTime=c-1);d.isBackwards?(f.sibling=b.child,b.child=f):(c=d.last,null!==c?c.sibling=f:b.child=f,d.last=f)}return null!==d.tail?(0===d.tailExpiration&&(d.tailExpiration=$f()+500),c=d.tail,d.rendering=c,d.tail=c.sibling,d.lastEffect=b.lastEffect,d.renderingStartTime=$f(),c.sibling=null,b=M.current,I(M,e?b&1|2:b&1),c):null}throw Error(u(156,
	b.tag));}function zi(a){switch(a.tag){case 1:L(a.type)&&Df();var b=a.effectTag;return b&4096?(a.effectTag=b&-4097|64,a):null;case 3:eh();H(K);H(J);b=a.effectTag;if(0!==(b&64))throw Error(u(285));a.effectTag=b&-4097|64;return a;case 5:return gh(a),null;case 13:return H(M),b=a.effectTag,b&4096?(a.effectTag=b&-4097|64,a):null;case 19:return H(M),null;case 4:return eh(),null;case 10:return og(a),null;default:return null}}function Ai(a,b){return{value:a,source:b,stack:qb(b)}}
	var Bi="function"===typeof WeakSet?WeakSet:Set;function Ci(a,b){var c=b.source,d=b.stack;null===d&&null!==c&&(d=qb(c));null!==c&&pb(c.type);b=b.value;null!==a&&1===a.tag&&pb(a.type);try{console.error(b)}catch(e){setTimeout(function(){throw e;})}}function Di(a,b){try{b.props=a.memoizedProps,b.state=a.memoizedState,b.componentWillUnmount()}catch(c){Ei(a,c)}}function Fi(a){var b=a.ref;if(null!==b)if("function"===typeof b)try{b(null)}catch(c){Ei(a,c)}else b.current=null}
	function Gi(a,b){switch(b.tag){case 0:case 11:case 15:case 22:return;case 1:if(b.effectTag&256&&null!==a){var c=a.memoizedProps,d=a.memoizedState;a=b.stateNode;b=a.getSnapshotBeforeUpdate(b.elementType===b.type?c:ig(b.type,c),d);a.__reactInternalSnapshotBeforeUpdate=b}return;case 3:case 5:case 6:case 4:case 17:return}throw Error(u(163));}
	function Hi(a,b){b=b.updateQueue;b=null!==b?b.lastEffect:null;if(null!==b){var c=b=b.next;do{if((c.tag&a)===a){var d=c.destroy;c.destroy=void 0;void 0!==d&&d()}c=c.next}while(c!==b)}}function Ii(a,b){b=b.updateQueue;b=null!==b?b.lastEffect:null;if(null!==b){var c=b=b.next;do{if((c.tag&a)===a){var d=c.create;c.destroy=d()}c=c.next}while(c!==b)}}
	function Ji(a,b,c){switch(c.tag){case 0:case 11:case 15:case 22:Ii(3,c);return;case 1:a=c.stateNode;if(c.effectTag&4)if(null===b)a.componentDidMount();else{var d=c.elementType===c.type?b.memoizedProps:ig(c.type,b.memoizedProps);a.componentDidUpdate(d,b.memoizedState,a.__reactInternalSnapshotBeforeUpdate)}b=c.updateQueue;null!==b&&Cg(c,b,a);return;case 3:b=c.updateQueue;if(null!==b){a=null;if(null!==c.child)switch(c.child.tag){case 5:a=c.child.stateNode;break;case 1:a=c.child.stateNode}Cg(c,b,a)}return;
	case 5:a=c.stateNode;null===b&&c.effectTag&4&&Fd(c.type,c.memoizedProps)&&a.focus();return;case 6:return;case 4:return;case 12:return;case 13:null===c.memoizedState&&(c=c.alternate,null!==c&&(c=c.memoizedState,null!==c&&(c=c.dehydrated,null!==c&&Vc(c))));return;case 19:case 17:case 20:case 21:return}throw Error(u(163));}
	function Ki(a,b,c){"function"===typeof Li&&Li(b);switch(b.tag){case 0:case 11:case 14:case 15:case 22:a=b.updateQueue;if(null!==a&&(a=a.lastEffect,null!==a)){var d=a.next;cg(97<c?97:c,function(){var a=d;do{var c=a.destroy;if(void 0!==c){var g=b;try{c()}catch(h){Ei(g,h)}}a=a.next}while(a!==d)})}break;case 1:Fi(b);c=b.stateNode;"function"===typeof c.componentWillUnmount&&Di(b,c);break;case 5:Fi(b);break;case 4:Mi(a,b,c)}}
	function Ni(a){var b=a.alternate;a.return=null;a.child=null;a.memoizedState=null;a.updateQueue=null;a.dependencies=null;a.alternate=null;a.firstEffect=null;a.lastEffect=null;a.pendingProps=null;a.memoizedProps=null;a.stateNode=null;null!==b&&Ni(b)}function Oi(a){return 5===a.tag||3===a.tag||4===a.tag}
	function Pi(a){a:{for(var b=a.return;null!==b;){if(Oi(b)){var c=b;break a}b=b.return}throw Error(u(160));}b=c.stateNode;switch(c.tag){case 5:var d=!1;break;case 3:b=b.containerInfo;d=!0;break;case 4:b=b.containerInfo;d=!0;break;default:throw Error(u(161));}c.effectTag&16&&(Rb(b,""),c.effectTag&=-17);a:b:for(c=a;;){for(;null===c.sibling;){if(null===c.return||Oi(c.return)){c=null;break a}c=c.return}c.sibling.return=c.return;for(c=c.sibling;5!==c.tag&&6!==c.tag&&18!==c.tag;){if(c.effectTag&2)continue b;
	if(null===c.child||4===c.tag)continue b;else c.child.return=c,c=c.child}if(!(c.effectTag&2)){c=c.stateNode;break a}}d?Qi(a,c,b):Ri(a,c,b)}
	function Qi(a,b,c){var d=a.tag,e=5===d||6===d;if(e)a=e?a.stateNode:a.stateNode.instance,b?8===c.nodeType?c.parentNode.insertBefore(a,b):c.insertBefore(a,b):(8===c.nodeType?(b=c.parentNode,b.insertBefore(a,c)):(b=c,b.appendChild(a)),c=c._reactRootContainer,null!==c&&void 0!==c||null!==b.onclick||(b.onclick=sd));else if(4!==d&&(a=a.child,null!==a))for(Qi(a,b,c),a=a.sibling;null!==a;)Qi(a,b,c),a=a.sibling}
	function Ri(a,b,c){var d=a.tag,e=5===d||6===d;if(e)a=e?a.stateNode:a.stateNode.instance,b?c.insertBefore(a,b):c.appendChild(a);else if(4!==d&&(a=a.child,null!==a))for(Ri(a,b,c),a=a.sibling;null!==a;)Ri(a,b,c),a=a.sibling}
	function Mi(a,b,c){for(var d=b,e=!1,f,g;;){if(!e){e=d.return;a:for(;;){if(null===e)throw Error(u(160));f=e.stateNode;switch(e.tag){case 5:g=!1;break a;case 3:f=f.containerInfo;g=!0;break a;case 4:f=f.containerInfo;g=!0;break a}e=e.return}e=!0}if(5===d.tag||6===d.tag){a:for(var h=a,k=d,l=c,m=k;;)if(Ki(h,m,l),null!==m.child&&4!==m.tag)m.child.return=m,m=m.child;else{if(m===k)break a;for(;null===m.sibling;){if(null===m.return||m.return===k)break a;m=m.return}m.sibling.return=m.return;m=m.sibling}g?(h=
	f,k=d.stateNode,8===h.nodeType?h.parentNode.removeChild(k):h.removeChild(k)):f.removeChild(d.stateNode)}else if(4===d.tag){if(null!==d.child){f=d.stateNode.containerInfo;g=!0;d.child.return=d;d=d.child;continue}}else if(Ki(a,d,c),null!==d.child){d.child.return=d;d=d.child;continue}if(d===b)break;for(;null===d.sibling;){if(null===d.return||d.return===b)return;d=d.return;4===d.tag&&(e=!1)}d.sibling.return=d.return;d=d.sibling}}
	function Si(a,b){switch(b.tag){case 0:case 11:case 14:case 15:case 22:Hi(3,b);return;case 1:return;case 5:var c=b.stateNode;if(null!=c){var d=b.memoizedProps,e=null!==a?a.memoizedProps:d;a=b.type;var f=b.updateQueue;b.updateQueue=null;if(null!==f){c[Nd]=d;"input"===a&&"radio"===d.type&&null!=d.name&&Bb(c,d);pd(a,e);b=pd(a,d);for(e=0;e<f.length;e+=2){var g=f[e],h=f[e+1];"style"===g?md(c,h):"dangerouslySetInnerHTML"===g?Qb(c,h):"children"===g?Rb(c,h):Xa(c,g,h,b)}switch(a){case "input":Cb(c,d);break;
	case "textarea":Kb(c,d);break;case "select":b=c._wrapperState.wasMultiple,c._wrapperState.wasMultiple=!!d.multiple,a=d.value,null!=a?Hb(c,!!d.multiple,a,!1):b!==!!d.multiple&&(null!=d.defaultValue?Hb(c,!!d.multiple,d.defaultValue,!0):Hb(c,!!d.multiple,d.multiple?[]:"",!1))}}}return;case 6:if(null===b.stateNode)throw Error(u(162));b.stateNode.nodeValue=b.memoizedProps;return;case 3:b=b.stateNode;b.hydrate&&(b.hydrate=!1,Vc(b.containerInfo));return;case 12:return;case 13:c=b;null===b.memoizedState?
	d=!1:(d=!0,c=b.child,Ti=$f());if(null!==c)a:for(a=c;;){if(5===a.tag)f=a.stateNode,d?(f=f.style,"function"===typeof f.setProperty?f.setProperty("display","none","important"):f.display="none"):(f=a.stateNode,e=a.memoizedProps.style,e=void 0!==e&&null!==e&&e.hasOwnProperty("display")?e.display:null,f.style.display=ld("display",e));else if(6===a.tag)a.stateNode.nodeValue=d?"":a.memoizedProps;else if(13===a.tag&&null!==a.memoizedState&&null===a.memoizedState.dehydrated){f=a.child.sibling;f.return=a;a=
	f;continue}else if(null!==a.child){a.child.return=a;a=a.child;continue}if(a===c)break;for(;null===a.sibling;){if(null===a.return||a.return===c)break a;a=a.return}a.sibling.return=a.return;a=a.sibling}Ui(b);return;case 19:Ui(b);return;case 17:return}throw Error(u(163));}function Ui(a){var b=a.updateQueue;if(null!==b){a.updateQueue=null;var c=a.stateNode;null===c&&(c=a.stateNode=new Bi);b.forEach(function(b){var d=Vi.bind(null,a,b);c.has(b)||(c.add(b),b.then(d,d))})}}
	var Wi="function"===typeof WeakMap?WeakMap:Map;function Xi(a,b,c){c=wg(c,null);c.tag=3;c.payload={element:null};var d=b.value;c.callback=function(){Yi||(Yi=!0,Zi=d);Ci(a,b)};return c}
	function $i(a,b,c){c=wg(c,null);c.tag=3;var d=a.type.getDerivedStateFromError;if("function"===typeof d){var e=b.value;c.payload=function(){Ci(a,b);return d(e)}}var f=a.stateNode;null!==f&&"function"===typeof f.componentDidCatch&&(c.callback=function(){"function"!==typeof d&&(null===aj?aj=new Set([this]):aj.add(this),Ci(a,b));var c=b.stack;this.componentDidCatch(b.value,{componentStack:null!==c?c:""})});return c}
	var bj=Math.ceil,cj=Wa.ReactCurrentDispatcher,dj=Wa.ReactCurrentOwner,V=0,ej=8,fj=16,gj=32,ti=0,hj=1,ij=2,ui=3,vi=4,jj=5,W=V,T=null,X=null,U=0,S=ti,kj=null,lj=1073741823,mj=1073741823,nj=null,wi=0,oj=!1,Ti=0,pj=500,Y=null,Yi=!1,Zi=null,aj=null,qj=!1,rj=null,sj=90,tj=null,uj=0,vj=null,wj=0;function Gg(){return(W&(fj|gj))!==V?1073741821-($f()/10|0):0!==wj?wj:wj=1073741821-($f()/10|0)}
	function Hg(a,b,c){b=b.mode;if(0===(b&2))return 1073741823;var d=ag();if(0===(b&4))return 99===d?1073741823:1073741822;if((W&fj)!==V)return U;if(null!==c)a=hg(a,c.timeoutMs|0||5E3,250);else switch(d){case 99:a=1073741823;break;case 98:a=hg(a,150,100);break;case 97:case 96:a=hg(a,5E3,250);break;case 95:a=2;break;default:throw Error(u(326));}null!==T&&a===U&&--a;return a}
	function Ig(a,b){if(50<uj)throw uj=0,vj=null,Error(u(185));a=xj(a,b);if(null!==a){var c=ag();1073741823===b?(W&ej)!==V&&(W&(fj|gj))===V?yj(a):(Z(a),W===V&&gg()):Z(a);(W&4)===V||98!==c&&99!==c||(null===tj?tj=new Map([[a,b]]):(c=tj.get(a),(void 0===c||c>b)&&tj.set(a,b)))}}
	function xj(a,b){a.expirationTime<b&&(a.expirationTime=b);var c=a.alternate;null!==c&&c.expirationTime<b&&(c.expirationTime=b);var d=a.return,e=null;if(null===d&&3===a.tag)e=a.stateNode;else for(;null!==d;){c=d.alternate;d.childExpirationTime<b&&(d.childExpirationTime=b);null!==c&&c.childExpirationTime<b&&(c.childExpirationTime=b);if(null===d.return&&3===d.tag){e=d.stateNode;break}d=d.return}null!==e&&(T===e&&(Bg(b),S===vi&&xi(e,U)),yi(e,b));return e}
	function zj(a){var b=a.lastExpiredTime;if(0!==b)return b;b=a.firstPendingTime;if(!Aj(a,b))return b;var c=a.lastPingedTime;a=a.nextKnownPendingLevel;a=c>a?c:a;return 2>=a&&b!==a?0:a}
	function Z(a){if(0!==a.lastExpiredTime)a.callbackExpirationTime=1073741823,a.callbackPriority=99,a.callbackNode=eg(yj.bind(null,a));else{var b=zj(a),c=a.callbackNode;if(0===b)null!==c&&(a.callbackNode=null,a.callbackExpirationTime=0,a.callbackPriority=90);else{var d=Gg();1073741823===b?d=99:1===b||2===b?d=95:(d=10*(1073741821-b)-10*(1073741821-d),d=0>=d?99:250>=d?98:5250>=d?97:95);if(null!==c){var e=a.callbackPriority;if(a.callbackExpirationTime===b&&e>=d)return;c!==Tf&&Kf(c)}a.callbackExpirationTime=
	b;a.callbackPriority=d;b=1073741823===b?eg(yj.bind(null,a)):dg(d,Bj.bind(null,a),{timeout:10*(1073741821-b)-$f()});a.callbackNode=b}}}
	function Bj(a,b){wj=0;if(b)return b=Gg(),Cj(a,b),Z(a),null;var c=zj(a);if(0!==c){b=a.callbackNode;if((W&(fj|gj))!==V)throw Error(u(327));Dj();a===T&&c===U||Ej(a,c);if(null!==X){var d=W;W|=fj;var e=Fj();do try{Gj();break}catch(h){Hj(a,h)}while(1);ng();W=d;cj.current=e;if(S===hj)throw b=kj,Ej(a,c),xi(a,c),Z(a),b;if(null===X)switch(e=a.finishedWork=a.current.alternate,a.finishedExpirationTime=c,d=S,T=null,d){case ti:case hj:throw Error(u(345));case ij:Cj(a,2<c?2:c);break;case ui:xi(a,c);d=a.lastSuspendedTime;
	c===d&&(a.nextKnownPendingLevel=Ij(e));if(1073741823===lj&&(e=Ti+pj-$f(),10<e)){if(oj){var f=a.lastPingedTime;if(0===f||f>=c){a.lastPingedTime=c;Ej(a,c);break}}f=zj(a);if(0!==f&&f!==c)break;if(0!==d&&d!==c){a.lastPingedTime=d;break}a.timeoutHandle=Hd(Jj.bind(null,a),e);break}Jj(a);break;case vi:xi(a,c);d=a.lastSuspendedTime;c===d&&(a.nextKnownPendingLevel=Ij(e));if(oj&&(e=a.lastPingedTime,0===e||e>=c)){a.lastPingedTime=c;Ej(a,c);break}e=zj(a);if(0!==e&&e!==c)break;if(0!==d&&d!==c){a.lastPingedTime=
	d;break}1073741823!==mj?d=10*(1073741821-mj)-$f():1073741823===lj?d=0:(d=10*(1073741821-lj)-5E3,e=$f(),c=10*(1073741821-c)-e,d=e-d,0>d&&(d=0),d=(120>d?120:480>d?480:1080>d?1080:1920>d?1920:3E3>d?3E3:4320>d?4320:1960*bj(d/1960))-d,c<d&&(d=c));if(10<d){a.timeoutHandle=Hd(Jj.bind(null,a),d);break}Jj(a);break;case jj:if(1073741823!==lj&&null!==nj){f=lj;var g=nj;d=g.busyMinDurationMs|0;0>=d?d=0:(e=g.busyDelayMs|0,f=$f()-(10*(1073741821-f)-(g.timeoutMs|0||5E3)),d=f<=e?0:e+d-f);if(10<d){xi(a,c);a.timeoutHandle=
	Hd(Jj.bind(null,a),d);break}}Jj(a);break;default:throw Error(u(329));}Z(a);if(a.callbackNode===b)return Bj.bind(null,a)}}return null}
	function yj(a){var b=a.lastExpiredTime;b=0!==b?b:1073741823;if((W&(fj|gj))!==V)throw Error(u(327));Dj();a===T&&b===U||Ej(a,b);if(null!==X){var c=W;W|=fj;var d=Fj();do try{Kj();break}catch(e){Hj(a,e)}while(1);ng();W=c;cj.current=d;if(S===hj)throw c=kj,Ej(a,b),xi(a,b),Z(a),c;if(null!==X)throw Error(u(261));a.finishedWork=a.current.alternate;a.finishedExpirationTime=b;T=null;Jj(a);Z(a)}return null}function Lj(){if(null!==tj){var a=tj;tj=null;a.forEach(function(a,c){Cj(c,a);Z(c)});gg()}}
	function Mj(a,b){var c=W;W|=1;try{return a(b)}finally{W=c,W===V&&gg()}}function Nj(a,b){var c=W;W&=-2;W|=ej;try{return a(b)}finally{W=c,W===V&&gg()}}
	function Ej(a,b){a.finishedWork=null;a.finishedExpirationTime=0;var c=a.timeoutHandle;-1!==c&&(a.timeoutHandle=-1,Id(c));if(null!==X)for(c=X.return;null!==c;){var d=c;switch(d.tag){case 1:d=d.type.childContextTypes;null!==d&&void 0!==d&&Df();break;case 3:eh();H(K);H(J);break;case 5:gh(d);break;case 4:eh();break;case 13:H(M);break;case 19:H(M);break;case 10:og(d)}c=c.return}T=a;X=Sg(a.current,null);U=b;S=ti;kj=null;mj=lj=1073741823;nj=null;wi=0;oj=!1}
	function Hj(a,b){do{try{ng();jh.current=sh;if(mh)for(var c=N.memoizedState;null!==c;){var d=c.queue;null!==d&&(d.pending=null);c=c.next}lh=0;P=O=N=null;mh=!1;if(null===X||null===X.return)return S=hj,kj=b,X=null;a:{var e=a,f=X.return,g=X,h=b;b=U;g.effectTag|=2048;g.firstEffect=g.lastEffect=null;if(null!==h&&"object"===typeof h&&"function"===typeof h.then){var k=h;if(0===(g.mode&2)){var l=g.alternate;l?(g.updateQueue=l.updateQueue,g.memoizedState=l.memoizedState,g.expirationTime=l.expirationTime):(g.updateQueue=
	null,g.memoizedState=null)}var m=0!==(M.current&1),p=f;do{var x;if(x=13===p.tag){var z=p.memoizedState;if(null!==z)x=null!==z.dehydrated?!0:!1;else{var ca=p.memoizedProps;x=void 0===ca.fallback?!1:!0!==ca.unstable_avoidThisFallback?!0:m?!1:!0}}if(x){var D=p.updateQueue;if(null===D){var t=new Set;t.add(k);p.updateQueue=t}else D.add(k);if(0===(p.mode&2)){p.effectTag|=64;g.effectTag&=-2981;if(1===g.tag)if(null===g.alternate)g.tag=17;else{var y=wg(1073741823,null);y.tag=2;xg(g,y)}g.expirationTime=1073741823;
	break a}h=void 0;g=b;var A=e.pingCache;null===A?(A=e.pingCache=new Wi,h=new Set,A.set(k,h)):(h=A.get(k),void 0===h&&(h=new Set,A.set(k,h)));if(!h.has(g)){h.add(g);var q=Oj.bind(null,e,k,g);k.then(q,q)}p.effectTag|=4096;p.expirationTime=b;break a}p=p.return}while(null!==p);h=Error((pb(g.type)||"A React component")+" suspended while rendering, but no fallback UI was specified.\n\nAdd a <Suspense fallback=...> component higher in the tree to provide a loading indicator or placeholder to display."+qb(g))}S!==
	jj&&(S=ij);h=Ai(h,g);p=f;do{switch(p.tag){case 3:k=h;p.effectTag|=4096;p.expirationTime=b;var B=Xi(p,k,b);yg(p,B);break a;case 1:k=h;var w=p.type,ub=p.stateNode;if(0===(p.effectTag&64)&&("function"===typeof w.getDerivedStateFromError||null!==ub&&"function"===typeof ub.componentDidCatch&&(null===aj||!aj.has(ub)))){p.effectTag|=4096;p.expirationTime=b;var vb=$i(p,k,b);yg(p,vb);break a}}p=p.return}while(null!==p)}X=Pj(X)}catch(Xc){b=Xc;continue}break}while(1)}
	function Fj(){var a=cj.current;cj.current=sh;return null===a?sh:a}function Ag(a,b){a<lj&&2<a&&(lj=a);null!==b&&a<mj&&2<a&&(mj=a,nj=b)}function Bg(a){a>wi&&(wi=a)}function Kj(){for(;null!==X;)X=Qj(X)}function Gj(){for(;null!==X&&!Uf();)X=Qj(X)}function Qj(a){var b=Rj(a.alternate,a,U);a.memoizedProps=a.pendingProps;null===b&&(b=Pj(a));dj.current=null;return b}
	function Pj(a){X=a;do{var b=X.alternate;a=X.return;if(0===(X.effectTag&2048)){b=si(b,X,U);if(1===U||1!==X.childExpirationTime){for(var c=0,d=X.child;null!==d;){var e=d.expirationTime,f=d.childExpirationTime;e>c&&(c=e);f>c&&(c=f);d=d.sibling}X.childExpirationTime=c}if(null!==b)return b;null!==a&&0===(a.effectTag&2048)&&(null===a.firstEffect&&(a.firstEffect=X.firstEffect),null!==X.lastEffect&&(null!==a.lastEffect&&(a.lastEffect.nextEffect=X.firstEffect),a.lastEffect=X.lastEffect),1<X.effectTag&&(null!==
	a.lastEffect?a.lastEffect.nextEffect=X:a.firstEffect=X,a.lastEffect=X))}else{b=zi(X);if(null!==b)return b.effectTag&=2047,b;null!==a&&(a.firstEffect=a.lastEffect=null,a.effectTag|=2048)}b=X.sibling;if(null!==b)return b;X=a}while(null!==X);S===ti&&(S=jj);return null}function Ij(a){var b=a.expirationTime;a=a.childExpirationTime;return b>a?b:a}function Jj(a){var b=ag();cg(99,Sj.bind(null,a,b));return null}
	function Sj(a,b){do Dj();while(null!==rj);if((W&(fj|gj))!==V)throw Error(u(327));var c=a.finishedWork,d=a.finishedExpirationTime;if(null===c)return null;a.finishedWork=null;a.finishedExpirationTime=0;if(c===a.current)throw Error(u(177));a.callbackNode=null;a.callbackExpirationTime=0;a.callbackPriority=90;a.nextKnownPendingLevel=0;var e=Ij(c);a.firstPendingTime=e;d<=a.lastSuspendedTime?a.firstSuspendedTime=a.lastSuspendedTime=a.nextKnownPendingLevel=0:d<=a.firstSuspendedTime&&(a.firstSuspendedTime=
	d-1);d<=a.lastPingedTime&&(a.lastPingedTime=0);d<=a.lastExpiredTime&&(a.lastExpiredTime=0);a===T&&(X=T=null,U=0);1<c.effectTag?null!==c.lastEffect?(c.lastEffect.nextEffect=c,e=c.firstEffect):e=c:e=c.firstEffect;if(null!==e){var f=W;W|=gj;dj.current=null;Dd=fd;var g=xd();if(yd(g)){if("selectionStart"in g)var h={start:g.selectionStart,end:g.selectionEnd};else a:{h=(h=g.ownerDocument)&&h.defaultView||window;var k=h.getSelection&&h.getSelection();if(k&&0!==k.rangeCount){h=k.anchorNode;var l=k.anchorOffset,
	m=k.focusNode;k=k.focusOffset;try{h.nodeType,m.nodeType}catch(wb){h=null;break a}var p=0,x=-1,z=-1,ca=0,D=0,t=g,y=null;b:for(;;){for(var A;;){t!==h||0!==l&&3!==t.nodeType||(x=p+l);t!==m||0!==k&&3!==t.nodeType||(z=p+k);3===t.nodeType&&(p+=t.nodeValue.length);if(null===(A=t.firstChild))break;y=t;t=A}for(;;){if(t===g)break b;y===h&&++ca===l&&(x=p);y===m&&++D===k&&(z=p);if(null!==(A=t.nextSibling))break;t=y;y=t.parentNode}t=A}h=-1===x||-1===z?null:{start:x,end:z}}else h=null}h=h||{start:0,end:0}}else h=
	null;Ed={activeElementDetached:null,focusedElem:g,selectionRange:h};fd=!1;Y=e;do try{Tj()}catch(wb){if(null===Y)throw Error(u(330));Ei(Y,wb);Y=Y.nextEffect}while(null!==Y);Y=e;do try{for(g=a,h=b;null!==Y;){var q=Y.effectTag;q&16&&Rb(Y.stateNode,"");if(q&128){var B=Y.alternate;if(null!==B){var w=B.ref;null!==w&&("function"===typeof w?w(null):w.current=null)}}switch(q&1038){case 2:Pi(Y);Y.effectTag&=-3;break;case 6:Pi(Y);Y.effectTag&=-3;Si(Y.alternate,Y);break;case 1024:Y.effectTag&=-1025;break;case 1028:Y.effectTag&=
	-1025;Si(Y.alternate,Y);break;case 4:Si(Y.alternate,Y);break;case 8:l=Y,Mi(g,l,h),Ni(l)}Y=Y.nextEffect}}catch(wb){if(null===Y)throw Error(u(330));Ei(Y,wb);Y=Y.nextEffect}while(null!==Y);w=Ed;B=xd();q=w.focusedElem;h=w.selectionRange;if(B!==q&&q&&q.ownerDocument&&wd(q.ownerDocument.documentElement,q)){null!==h&&yd(q)&&(B=h.start,w=h.end,void 0===w&&(w=B),"selectionStart"in q?(q.selectionStart=B,q.selectionEnd=Math.min(w,q.value.length)):(w=(B=q.ownerDocument||document)&&B.defaultView||window,w.getSelection&&
	(w=w.getSelection(),l=q.textContent.length,g=Math.min(h.start,l),h=void 0===h.end?g:Math.min(h.end,l),!w.extend&&g>h&&(l=h,h=g,g=l),l=vd(q,g),m=vd(q,h),l&&m&&(1!==w.rangeCount||w.anchorNode!==l.node||w.anchorOffset!==l.offset||w.focusNode!==m.node||w.focusOffset!==m.offset)&&(B=B.createRange(),B.setStart(l.node,l.offset),w.removeAllRanges(),g>h?(w.addRange(B),w.extend(m.node,m.offset)):(B.setEnd(m.node,m.offset),w.addRange(B))))));B=[];for(w=q;w=w.parentNode;)1===w.nodeType&&B.push({element:w,left:w.scrollLeft,
	top:w.scrollTop});"function"===typeof q.focus&&q.focus();for(q=0;q<B.length;q++)w=B[q],w.element.scrollLeft=w.left,w.element.scrollTop=w.top}fd=!!Dd;Ed=Dd=null;a.current=c;Y=e;do try{for(q=a;null!==Y;){var ub=Y.effectTag;ub&36&&Ji(q,Y.alternate,Y);if(ub&128){B=void 0;var vb=Y.ref;if(null!==vb){var Xc=Y.stateNode;switch(Y.tag){case 5:B=Xc;break;default:B=Xc}"function"===typeof vb?vb(B):vb.current=B}}Y=Y.nextEffect}}catch(wb){if(null===Y)throw Error(u(330));Ei(Y,wb);Y=Y.nextEffect}while(null!==Y);Y=
	null;Vf();W=f}else a.current=c;if(qj)qj=!1,rj=a,sj=b;else for(Y=e;null!==Y;)b=Y.nextEffect,Y.nextEffect=null,Y=b;b=a.firstPendingTime;0===b&&(aj=null);1073741823===b?a===vj?uj++:(uj=0,vj=a):uj=0;"function"===typeof Uj&&Uj(c.stateNode,d);Z(a);if(Yi)throw Yi=!1,a=Zi,Zi=null,a;if((W&ej)!==V)return null;gg();return null}function Tj(){for(;null!==Y;){var a=Y.effectTag;0!==(a&256)&&Gi(Y.alternate,Y);0===(a&512)||qj||(qj=!0,dg(97,function(){Dj();return null}));Y=Y.nextEffect}}
	function Dj(){if(90!==sj){var a=97<sj?97:sj;sj=90;return cg(a,Vj)}}function Vj(){if(null===rj)return!1;var a=rj;rj=null;if((W&(fj|gj))!==V)throw Error(u(331));var b=W;W|=gj;for(a=a.current.firstEffect;null!==a;){try{var c=a;if(0!==(c.effectTag&512))switch(c.tag){case 0:case 11:case 15:case 22:Hi(5,c),Ii(5,c)}}catch(d){if(null===a)throw Error(u(330));Ei(a,d)}c=a.nextEffect;a.nextEffect=null;a=c}W=b;gg();return!0}
	function Wj(a,b,c){b=Ai(c,b);b=Xi(a,b,1073741823);xg(a,b);a=xj(a,1073741823);null!==a&&Z(a)}function Ei(a,b){if(3===a.tag)Wj(a,a,b);else for(var c=a.return;null!==c;){if(3===c.tag){Wj(c,a,b);break}else if(1===c.tag){var d=c.stateNode;if("function"===typeof c.type.getDerivedStateFromError||"function"===typeof d.componentDidCatch&&(null===aj||!aj.has(d))){a=Ai(b,a);a=$i(c,a,1073741823);xg(c,a);c=xj(c,1073741823);null!==c&&Z(c);break}}c=c.return}}
	function Oj(a,b,c){var d=a.pingCache;null!==d&&d.delete(b);T===a&&U===c?S===vi||S===ui&&1073741823===lj&&$f()-Ti<pj?Ej(a,U):oj=!0:Aj(a,c)&&(b=a.lastPingedTime,0!==b&&b<c||(a.lastPingedTime=c,Z(a)))}function Vi(a,b){var c=a.stateNode;null!==c&&c.delete(b);b=0;0===b&&(b=Gg(),b=Hg(b,a,null));a=xj(a,b);null!==a&&Z(a)}var Rj;
	Rj=function(a,b,c){var d=b.expirationTime;if(null!==a){var e=b.pendingProps;if(a.memoizedProps!==e||K.current)rg=!0;else{if(d<c){rg=!1;switch(b.tag){case 3:hi(b);Xh();break;case 5:fh(b);if(b.mode&4&&1!==c&&e.hidden)return b.expirationTime=b.childExpirationTime=1,null;break;case 1:L(b.type)&&Gf(b);break;case 4:dh(b,b.stateNode.containerInfo);break;case 10:d=b.memoizedProps.value;e=b.type._context;I(jg,e._currentValue);e._currentValue=d;break;case 13:if(null!==b.memoizedState){d=b.child.childExpirationTime;
	if(0!==d&&d>=c)return ji(a,b,c);I(M,M.current&1);b=$h(a,b,c);return null!==b?b.sibling:null}I(M,M.current&1);break;case 19:d=b.childExpirationTime>=c;if(0!==(a.effectTag&64)){if(d)return mi(a,b,c);b.effectTag|=64}e=b.memoizedState;null!==e&&(e.rendering=null,e.tail=null);I(M,M.current);if(!d)return null}return $h(a,b,c)}rg=!1}}else rg=!1;b.expirationTime=0;switch(b.tag){case 2:d=b.type;null!==a&&(a.alternate=null,b.alternate=null,b.effectTag|=2);a=b.pendingProps;e=Cf(b,J.current);qg(b,c);e=oh(null,
	b,d,a,e,c);b.effectTag|=1;if("object"===typeof e&&null!==e&&"function"===typeof e.render&&void 0===e.$$typeof){b.tag=1;b.memoizedState=null;b.updateQueue=null;if(L(d)){var f=!0;Gf(b)}else f=!1;b.memoizedState=null!==e.state&&void 0!==e.state?e.state:null;ug(b);var g=d.getDerivedStateFromProps;"function"===typeof g&&Fg(b,d,g,a);e.updater=Jg;b.stateNode=e;e._reactInternalFiber=b;Ng(b,d,a,c);b=gi(null,b,d,!0,f,c)}else b.tag=0,R(null,b,e,c),b=b.child;return b;case 16:a:{e=b.elementType;null!==a&&(a.alternate=
	null,b.alternate=null,b.effectTag|=2);a=b.pendingProps;ob(e);if(1!==e._status)throw e._result;e=e._result;b.type=e;f=b.tag=Xj(e);a=ig(e,a);switch(f){case 0:b=di(null,b,e,a,c);break a;case 1:b=fi(null,b,e,a,c);break a;case 11:b=Zh(null,b,e,a,c);break a;case 14:b=ai(null,b,e,ig(e.type,a),d,c);break a}throw Error(u(306,e,""));}return b;case 0:return d=b.type,e=b.pendingProps,e=b.elementType===d?e:ig(d,e),di(a,b,d,e,c);case 1:return d=b.type,e=b.pendingProps,e=b.elementType===d?e:ig(d,e),fi(a,b,d,e,c);
	case 3:hi(b);d=b.updateQueue;if(null===a||null===d)throw Error(u(282));d=b.pendingProps;e=b.memoizedState;e=null!==e?e.element:null;vg(a,b);zg(b,d,null,c);d=b.memoizedState.element;if(d===e)Xh(),b=$h(a,b,c);else{if(e=b.stateNode.hydrate)Ph=Jd(b.stateNode.containerInfo.firstChild),Oh=b,e=Qh=!0;if(e)for(c=Yg(b,null,d,c),b.child=c;c;)c.effectTag=c.effectTag&-3|1024,c=c.sibling;else R(a,b,d,c),Xh();b=b.child}return b;case 5:return fh(b),null===a&&Uh(b),d=b.type,e=b.pendingProps,f=null!==a?a.memoizedProps:
	null,g=e.children,Gd(d,e)?g=null:null!==f&&Gd(d,f)&&(b.effectTag|=16),ei(a,b),b.mode&4&&1!==c&&e.hidden?(b.expirationTime=b.childExpirationTime=1,b=null):(R(a,b,g,c),b=b.child),b;case 6:return null===a&&Uh(b),null;case 13:return ji(a,b,c);case 4:return dh(b,b.stateNode.containerInfo),d=b.pendingProps,null===a?b.child=Xg(b,null,d,c):R(a,b,d,c),b.child;case 11:return d=b.type,e=b.pendingProps,e=b.elementType===d?e:ig(d,e),Zh(a,b,d,e,c);case 7:return R(a,b,b.pendingProps,c),b.child;case 8:return R(a,
	b,b.pendingProps.children,c),b.child;case 12:return R(a,b,b.pendingProps.children,c),b.child;case 10:a:{d=b.type._context;e=b.pendingProps;g=b.memoizedProps;f=e.value;var h=b.type._context;I(jg,h._currentValue);h._currentValue=f;if(null!==g)if(h=g.value,f=$e(h,f)?0:("function"===typeof d._calculateChangedBits?d._calculateChangedBits(h,f):1073741823)|0,0===f){if(g.children===e.children&&!K.current){b=$h(a,b,c);break a}}else for(h=b.child,null!==h&&(h.return=b);null!==h;){var k=h.dependencies;if(null!==
	k){g=h.child;for(var l=k.firstContext;null!==l;){if(l.context===d&&0!==(l.observedBits&f)){1===h.tag&&(l=wg(c,null),l.tag=2,xg(h,l));h.expirationTime<c&&(h.expirationTime=c);l=h.alternate;null!==l&&l.expirationTime<c&&(l.expirationTime=c);pg(h.return,c);k.expirationTime<c&&(k.expirationTime=c);break}l=l.next}}else g=10===h.tag?h.type===b.type?null:h.child:h.child;if(null!==g)g.return=h;else for(g=h;null!==g;){if(g===b){g=null;break}h=g.sibling;if(null!==h){h.return=g.return;g=h;break}g=g.return}h=
	g}R(a,b,e.children,c);b=b.child}return b;case 9:return e=b.type,f=b.pendingProps,d=f.children,qg(b,c),e=sg(e,f.unstable_observedBits),d=d(e),b.effectTag|=1,R(a,b,d,c),b.child;case 14:return e=b.type,f=ig(e,b.pendingProps),f=ig(e.type,f),ai(a,b,e,f,d,c);case 15:return ci(a,b,b.type,b.pendingProps,d,c);case 17:return d=b.type,e=b.pendingProps,e=b.elementType===d?e:ig(d,e),null!==a&&(a.alternate=null,b.alternate=null,b.effectTag|=2),b.tag=1,L(d)?(a=!0,Gf(b)):a=!1,qg(b,c),Lg(b,d,e),Ng(b,d,e,c),gi(null,
	b,d,!0,a,c);case 19:return mi(a,b,c)}throw Error(u(156,b.tag));};var Uj=null,Li=null;function Yj(a){if("undefined"===typeof __REACT_DEVTOOLS_GLOBAL_HOOK__)return!1;var b=__REACT_DEVTOOLS_GLOBAL_HOOK__;if(b.isDisabled||!b.supportsFiber)return!0;try{var c=b.inject(a);Uj=function(a){try{b.onCommitFiberRoot(c,a,void 0,64===(a.current.effectTag&64))}catch(e){}};Li=function(a){try{b.onCommitFiberUnmount(c,a)}catch(e){}}}catch(d){}return!0}
	function Zj(a,b,c,d){this.tag=a;this.key=c;this.sibling=this.child=this.return=this.stateNode=this.type=this.elementType=null;this.index=0;this.ref=null;this.pendingProps=b;this.dependencies=this.memoizedState=this.updateQueue=this.memoizedProps=null;this.mode=d;this.effectTag=0;this.lastEffect=this.firstEffect=this.nextEffect=null;this.childExpirationTime=this.expirationTime=0;this.alternate=null}function Sh(a,b,c,d){return new Zj(a,b,c,d)}
	function bi(a){a=a.prototype;return!(!a||!a.isReactComponent)}function Xj(a){if("function"===typeof a)return bi(a)?1:0;if(void 0!==a&&null!==a){a=a.$$typeof;if(a===gb)return 11;if(a===jb)return 14}return 2}
	function Sg(a,b){var c=a.alternate;null===c?(c=Sh(a.tag,b,a.key,a.mode),c.elementType=a.elementType,c.type=a.type,c.stateNode=a.stateNode,c.alternate=a,a.alternate=c):(c.pendingProps=b,c.effectTag=0,c.nextEffect=null,c.firstEffect=null,c.lastEffect=null);c.childExpirationTime=a.childExpirationTime;c.expirationTime=a.expirationTime;c.child=a.child;c.memoizedProps=a.memoizedProps;c.memoizedState=a.memoizedState;c.updateQueue=a.updateQueue;b=a.dependencies;c.dependencies=null===b?null:{expirationTime:b.expirationTime,
	firstContext:b.firstContext,responders:b.responders};c.sibling=a.sibling;c.index=a.index;c.ref=a.ref;return c}
	function Ug(a,b,c,d,e,f){var g=2;d=a;if("function"===typeof a)bi(a)&&(g=1);else if("string"===typeof a)g=5;else a:switch(a){case ab:return Wg(c.children,e,f,b);case fb:g=8;e|=7;break;case bb:g=8;e|=1;break;case cb:return a=Sh(12,c,b,e|8),a.elementType=cb,a.type=cb,a.expirationTime=f,a;case hb:return a=Sh(13,c,b,e),a.type=hb,a.elementType=hb,a.expirationTime=f,a;case ib:return a=Sh(19,c,b,e),a.elementType=ib,a.expirationTime=f,a;default:if("object"===typeof a&&null!==a)switch(a.$$typeof){case db:g=
	10;break a;case eb:g=9;break a;case gb:g=11;break a;case jb:g=14;break a;case kb:g=16;d=null;break a;case lb:g=22;break a}throw Error(u(130,null==a?a:typeof a,""));}b=Sh(g,c,b,e);b.elementType=a;b.type=d;b.expirationTime=f;return b}function Wg(a,b,c,d){a=Sh(7,a,d,b);a.expirationTime=c;return a}function Tg(a,b,c){a=Sh(6,a,null,b);a.expirationTime=c;return a}
	function Vg(a,b,c){b=Sh(4,null!==a.children?a.children:[],a.key,b);b.expirationTime=c;b.stateNode={containerInfo:a.containerInfo,pendingChildren:null,implementation:a.implementation};return b}
	function ak(a,b,c){this.tag=b;this.current=null;this.containerInfo=a;this.pingCache=this.pendingChildren=null;this.finishedExpirationTime=0;this.finishedWork=null;this.timeoutHandle=-1;this.pendingContext=this.context=null;this.hydrate=c;this.callbackNode=null;this.callbackPriority=90;this.lastExpiredTime=this.lastPingedTime=this.nextKnownPendingLevel=this.lastSuspendedTime=this.firstSuspendedTime=this.firstPendingTime=0}
	function Aj(a,b){var c=a.firstSuspendedTime;a=a.lastSuspendedTime;return 0!==c&&c>=b&&a<=b}function xi(a,b){var c=a.firstSuspendedTime,d=a.lastSuspendedTime;c<b&&(a.firstSuspendedTime=b);if(d>b||0===c)a.lastSuspendedTime=b;b<=a.lastPingedTime&&(a.lastPingedTime=0);b<=a.lastExpiredTime&&(a.lastExpiredTime=0)}
	function yi(a,b){b>a.firstPendingTime&&(a.firstPendingTime=b);var c=a.firstSuspendedTime;0!==c&&(b>=c?a.firstSuspendedTime=a.lastSuspendedTime=a.nextKnownPendingLevel=0:b>=a.lastSuspendedTime&&(a.lastSuspendedTime=b+1),b>a.nextKnownPendingLevel&&(a.nextKnownPendingLevel=b))}function Cj(a,b){var c=a.lastExpiredTime;if(0===c||c>b)a.lastExpiredTime=b}
	function bk(a,b,c,d){var e=b.current,f=Gg(),g=Dg.suspense;f=Hg(f,e,g);a:if(c){c=c._reactInternalFiber;b:{if(dc(c)!==c||1!==c.tag)throw Error(u(170));var h=c;do{switch(h.tag){case 3:h=h.stateNode.context;break b;case 1:if(L(h.type)){h=h.stateNode.__reactInternalMemoizedMergedChildContext;break b}}h=h.return}while(null!==h);throw Error(u(171));}if(1===c.tag){var k=c.type;if(L(k)){c=Ff(c,k,h);break a}}c=h}else c=Af;null===b.context?b.context=c:b.pendingContext=c;b=wg(f,g);b.payload={element:a};d=void 0===
	d?null:d;null!==d&&(b.callback=d);xg(e,b);Ig(e,f);return f}function ck(a){a=a.current;if(!a.child)return null;switch(a.child.tag){case 5:return a.child.stateNode;default:return a.child.stateNode}}function dk(a,b){a=a.memoizedState;null!==a&&null!==a.dehydrated&&a.retryTime<b&&(a.retryTime=b)}function ek(a,b){dk(a,b);(a=a.alternate)&&dk(a,b)}
	function fk(a,b,c){c=null!=c&&!0===c.hydrate;var d=new ak(a,b,c),e=Sh(3,null,null,2===b?7:1===b?3:0);d.current=e;e.stateNode=d;ug(e);a[Od]=d.current;c&&0!==b&&Jc(a,9===a.nodeType?a:a.ownerDocument);this._internalRoot=d}fk.prototype.render=function(a){bk(a,this._internalRoot,null,null)};fk.prototype.unmount=function(){var a=this._internalRoot,b=a.containerInfo;bk(null,a,null,function(){b[Od]=null})};
	function gk(a){return!(!a||1!==a.nodeType&&9!==a.nodeType&&11!==a.nodeType&&(8!==a.nodeType||" react-mount-point-unstable "!==a.nodeValue))}function hk(a,b){b||(b=a?9===a.nodeType?a.documentElement:a.firstChild:null,b=!(!b||1!==b.nodeType||!b.hasAttribute("data-reactroot")));if(!b)for(var c;c=a.lastChild;)a.removeChild(c);return new fk(a,0,b?{hydrate:!0}:void 0)}
	function ik(a,b,c,d,e){var f=c._reactRootContainer;if(f){var g=f._internalRoot;if("function"===typeof e){var h=e;e=function(){var a=ck(g);h.call(a)}}bk(b,g,a,e)}else{f=c._reactRootContainer=hk(c,d);g=f._internalRoot;if("function"===typeof e){var k=e;e=function(){var a=ck(g);k.call(a)}}Nj(function(){bk(b,g,a,e)})}return ck(g)}function jk(a,b,c){var d=3<arguments.length&&void 0!==arguments[3]?arguments[3]:null;return{$$typeof:$a,key:null==d?null:""+d,children:a,containerInfo:b,implementation:c}}
	wc=function(a){if(13===a.tag){var b=hg(Gg(),150,100);Ig(a,b);ek(a,b)}};xc=function(a){13===a.tag&&(Ig(a,3),ek(a,3))};yc=function(a){if(13===a.tag){var b=Gg();b=Hg(b,a,null);Ig(a,b);ek(a,b)}};
	za=function(a,b,c){switch(b){case "input":Cb(a,c);b=c.name;if("radio"===c.type&&null!=b){for(c=a;c.parentNode;)c=c.parentNode;c=c.querySelectorAll("input[name="+JSON.stringify(""+b)+'][type="radio"]');for(b=0;b<c.length;b++){var d=c[b];if(d!==a&&d.form===a.form){var e=Qd(d);if(!e)throw Error(u(90));yb(d);Cb(d,e)}}}break;case "textarea":Kb(a,c);break;case "select":b=c.value,null!=b&&Hb(a,!!c.multiple,b,!1)}};Fa=Mj;
	Ga=function(a,b,c,d,e){var f=W;W|=4;try{return cg(98,a.bind(null,b,c,d,e))}finally{W=f,W===V&&gg()}};Ha=function(){(W&(1|fj|gj))===V&&(Lj(),Dj())};Ia=function(a,b){var c=W;W|=2;try{return a(b)}finally{W=c,W===V&&gg()}};function kk(a,b){var c=2<arguments.length&&void 0!==arguments[2]?arguments[2]:null;if(!gk(b))throw Error(u(200));return jk(a,b,null,c)}var lk={Events:[Nc,Pd,Qd,xa,ta,Xd,function(a){jc(a,Wd)},Da,Ea,id,mc,Dj,{current:!1}]};
	(function(a){var b=a.findFiberByHostInstance;return Yj(n({},a,{overrideHookState:null,overrideProps:null,setSuspenseHandler:null,scheduleUpdate:null,currentDispatcherRef:Wa.ReactCurrentDispatcher,findHostInstanceByFiber:function(a){a=hc(a);return null===a?null:a.stateNode},findFiberByHostInstance:function(a){return b?b(a):null},findHostInstancesForRefresh:null,scheduleRefresh:null,scheduleRoot:null,setRefreshHandler:null,getCurrentFiber:null}))})({findFiberByHostInstance:tc,bundleType:0,version:"16.13.1",
	rendererPackageName:"react-dom"});exports.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED=lk;exports.createPortal=kk;exports.findDOMNode=function(a){if(null==a)return null;if(1===a.nodeType)return a;var b=a._reactInternalFiber;if(void 0===b){if("function"===typeof a.render)throw Error(u(188));throw Error(u(268,Object.keys(a)));}a=hc(b);a=null===a?null:a.stateNode;return a};
	exports.flushSync=function(a,b){if((W&(fj|gj))!==V)throw Error(u(187));var c=W;W|=1;try{return cg(99,a.bind(null,b))}finally{W=c,gg()}};exports.hydrate=function(a,b,c){if(!gk(b))throw Error(u(200));return ik(null,a,b,!0,c)};exports.render=function(a,b,c){if(!gk(b))throw Error(u(200));return ik(null,a,b,!1,c)};
	exports.unmountComponentAtNode=function(a){if(!gk(a))throw Error(u(40));return a._reactRootContainer?(Nj(function(){ik(null,null,a,!1,function(){a._reactRootContainer=null;a[Od]=null})}),!0):!1};exports.unstable_batchedUpdates=Mj;exports.unstable_createPortal=function(a,b){return kk(a,b,2<arguments.length&&void 0!==arguments[2]?arguments[2]:null)};
	exports.unstable_renderSubtreeIntoContainer=function(a,b,c,d){if(!gk(c))throw Error(u(200));if(null==a||void 0===a._reactInternalFiber)throw Error(u(38));return ik(a,b,c,!1,d)};exports.version="16.13.1";


/***/ },
/* 407 */
/***/ function(module, exports) {

	/** @license React v16.13.1
	 * react-is.production.min.js
	 *
	 * Copyright (c) Facebook, Inc. and its affiliates.
	 *
	 * This source code is licensed under the MIT license found in the
	 * LICENSE file in the root directory of this source tree.
	 */
	
	'use strict';var b="function"===typeof Symbol&&Symbol.for,c=b?Symbol.for("react.element"):60103,d=b?Symbol.for("react.portal"):60106,e=b?Symbol.for("react.fragment"):60107,f=b?Symbol.for("react.strict_mode"):60108,g=b?Symbol.for("react.profiler"):60114,h=b?Symbol.for("react.provider"):60109,k=b?Symbol.for("react.context"):60110,l=b?Symbol.for("react.async_mode"):60111,m=b?Symbol.for("react.concurrent_mode"):60111,n=b?Symbol.for("react.forward_ref"):60112,p=b?Symbol.for("react.suspense"):60113,q=b?
	Symbol.for("react.suspense_list"):60120,r=b?Symbol.for("react.memo"):60115,t=b?Symbol.for("react.lazy"):60116,v=b?Symbol.for("react.block"):60121,w=b?Symbol.for("react.fundamental"):60117,x=b?Symbol.for("react.responder"):60118,y=b?Symbol.for("react.scope"):60119;
	function z(a){if("object"===typeof a&&null!==a){var u=a.$$typeof;switch(u){case c:switch(a=a.type,a){case l:case m:case e:case g:case f:case p:return a;default:switch(a=a&&a.$$typeof,a){case k:case n:case t:case r:case h:return a;default:return u}}case d:return u}}}function A(a){return z(a)===m}exports.AsyncMode=l;exports.ConcurrentMode=m;exports.ContextConsumer=k;exports.ContextProvider=h;exports.Element=c;exports.ForwardRef=n;exports.Fragment=e;exports.Lazy=t;exports.Memo=r;exports.Portal=d;
	exports.Profiler=g;exports.StrictMode=f;exports.Suspense=p;exports.isAsyncMode=function(a){return A(a)||z(a)===l};exports.isConcurrentMode=A;exports.isContextConsumer=function(a){return z(a)===k};exports.isContextProvider=function(a){return z(a)===h};exports.isElement=function(a){return"object"===typeof a&&null!==a&&a.$$typeof===c};exports.isForwardRef=function(a){return z(a)===n};exports.isFragment=function(a){return z(a)===e};exports.isLazy=function(a){return z(a)===t};
	exports.isMemo=function(a){return z(a)===r};exports.isPortal=function(a){return z(a)===d};exports.isProfiler=function(a){return z(a)===g};exports.isStrictMode=function(a){return z(a)===f};exports.isSuspense=function(a){return z(a)===p};
	exports.isValidElementType=function(a){return"string"===typeof a||"function"===typeof a||a===e||a===m||a===g||a===f||a===p||a===q||"object"===typeof a&&null!==a&&(a.$$typeof===t||a.$$typeof===r||a.$$typeof===h||a.$$typeof===k||a.$$typeof===n||a.$$typeof===w||a.$$typeof===x||a.$$typeof===y||a.$$typeof===v)};exports.typeOf=z;


/***/ },
/* 408 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";function _interopDefault(e){return e&&"object"==typeof e&&"default"in e?e.default:e}Object.defineProperty(exports,"__esModule",{value:!0});var reactRouter=__webpack_require__(411),React=_interopDefault(__webpack_require__(2)),history=__webpack_require__(162);__webpack_require__(31),__webpack_require__(76);var invariant=_interopDefault(__webpack_require__(103));function _extends(){return(_extends=Object.assign||function(e){for(var r=1;r<arguments.length;r++){var t=arguments[r];for(var o in t)Object.prototype.hasOwnProperty.call(t,o)&&(e[o]=t[o])}return e}).apply(this,arguments)}function _inheritsLoose(e,r){e.prototype=Object.create(r.prototype),(e.prototype.constructor=e).__proto__=r}function _objectWithoutPropertiesLoose(e,r){if(null==e)return{};var t,o,n={},a=Object.keys(e);for(o=0;o<a.length;o++)t=a[o],0<=r.indexOf(t)||(n[t]=e[t]);return n}var BrowserRouter=function(n){function e(){for(var e,r=arguments.length,t=new Array(r),o=0;o<r;o++)t[o]=arguments[o];return(e=n.call.apply(n,[this].concat(t))||this).history=history.createBrowserHistory(e.props),e}return _inheritsLoose(e,n),e.prototype.render=function(){return React.createElement(reactRouter.Router,{history:this.history,children:this.props.children})},e}(React.Component),HashRouter=function(n){function e(){for(var e,r=arguments.length,t=new Array(r),o=0;o<r;o++)t[o]=arguments[o];return(e=n.call.apply(n,[this].concat(t))||this).history=history.createHashHistory(e.props),e}return _inheritsLoose(e,n),e.prototype.render=function(){return React.createElement(reactRouter.Router,{history:this.history,children:this.props.children})},e}(React.Component),resolveToLocation=function(e,r){return"function"==typeof e?e(r):e},normalizeToLocation=function(e,r){return"string"==typeof e?history.createLocation(e,null,null,r):e},forwardRefShim=function(e){return e},forwardRef=React.forwardRef;function isModifiedEvent(e){return!!(e.metaKey||e.altKey||e.ctrlKey||e.shiftKey)}void 0===forwardRef&&(forwardRef=forwardRefShim);var LinkAnchor=forwardRef(function(e,r){var t=e.innerRef,o=e.navigate,n=e.onClick,a=_objectWithoutPropertiesLoose(e,["innerRef","navigate","onClick"]),i=a.target,c=_extends({},a,{onClick:function(r){try{n&&n(r)}catch(e){throw r.preventDefault(),e}r.defaultPrevented||0!==r.button||i&&"_self"!==i||isModifiedEvent(r)||(r.preventDefault(),o())}});return c.ref=forwardRefShim!==forwardRef&&r||t,React.createElement("a",c)}),Link=forwardRef(function(e,a){var r=e.component,i=void 0===r?LinkAnchor:r,c=e.replace,f=e.to,u=e.innerRef,s=_objectWithoutPropertiesLoose(e,["component","replace","to","innerRef"]);return React.createElement(reactRouter.__RouterContext.Consumer,null,function(r){r||invariant(!1);var t=r.history,e=normalizeToLocation(resolveToLocation(f,r.location),r.location),o=e?t.createHref(e):"",n=_extends({},s,{href:o,navigate:function(){var e=resolveToLocation(f,r.location);(c?t.replace:t.push)(e)}});return forwardRefShim!==forwardRef?n.ref=a||u:n.innerRef=u,React.createElement(i,n)})}),forwardRefShim$1=function(e){return e},forwardRef$1=React.forwardRef;function joinClassnames(){for(var e=arguments.length,r=new Array(e),t=0;t<e;t++)r[t]=arguments[t];return r.filter(function(e){return e}).join(" ")}void 0===forwardRef$1&&(forwardRef$1=forwardRefShim$1);var NavLink=forwardRef$1(function(e,s){var r=e["aria-current"],l=void 0===r?"page":r,t=e.activeClassName,p=void 0===t?"active":t,h=e.activeStyle,R=e.className,d=e.exact,v=e.isActive,y=e.location,m=e.strict,w=e.style,_=e.to,L=e.innerRef,x=_objectWithoutPropertiesLoose(e,["aria-current","activeClassName","activeStyle","className","exact","isActive","location","strict","style","to","innerRef"]);return React.createElement(reactRouter.__RouterContext.Consumer,null,function(e){e||invariant(!1);var r=y||e.location,t=normalizeToLocation(resolveToLocation(_,r),r),o=t.pathname,n=o&&o.replace(/([.+*?=^!:${}()[\]|/\\])/g,"\\$1"),a=n?reactRouter.matchPath(r.pathname,{path:n,exact:d,strict:m}):null,i=!!(v?v(a,r):a),c=i?joinClassnames(R,p):R,f=i?_extends({},w,{},h):w,u=_extends({"aria-current":i&&l||null,className:c,style:f,to:t},x);return forwardRefShim$1!==forwardRef$1?u.ref=s||L:u.innerRef=L,React.createElement(Link,u)})});Object.keys(reactRouter).forEach(function(e){"default"!==e&&Object.defineProperty(exports,e,{enumerable:!0,get:function(){return reactRouter[e]}})}),exports.BrowserRouter=BrowserRouter,exports.HashRouter=HashRouter,exports.Link=Link,exports.NavLink=NavLink;
	//# sourceMappingURL=react-router-dom.min.js.map


/***/ },
/* 409 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	
	if (true) {
	  module.exports = __webpack_require__(408);
	} else {
	  module.exports = require("./cjs/react-router-dom.js");
	}


/***/ },
/* 410 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";function _interopDefault(t){return t&&"object"==typeof t&&"default"in t?t.default:t}Object.defineProperty(exports,"__esModule",{value:!0});var React=_interopDefault(__webpack_require__(2));__webpack_require__(31);var history=__webpack_require__(162);__webpack_require__(76);var createContext=_interopDefault(__webpack_require__(401)),invariant=_interopDefault(__webpack_require__(103)),pathToRegexp=_interopDefault(__webpack_require__(413));__webpack_require__(165);var hoistStatics=_interopDefault(__webpack_require__(397));function _extends(){return(_extends=Object.assign||function(t){for(var e=1;e<arguments.length;e++){var n=arguments[e];for(var o in n)Object.prototype.hasOwnProperty.call(n,o)&&(t[o]=n[o])}return t}).apply(this,arguments)}function _inheritsLoose(t,e){t.prototype=Object.create(e.prototype),(t.prototype.constructor=t).__proto__=e}function _objectWithoutPropertiesLoose(t,e){if(null==t)return{};var n,o,r={},a=Object.keys(t);for(o=0;o<a.length;o++)n=a[o],0<=e.indexOf(n)||(r[n]=t[n]);return r}var createNamedContext=function(t){var e=createContext();return e.displayName=t,e},context=createNamedContext("Router"),Router=function(n){function t(t){var e;return(e=n.call(this,t)||this).state={location:t.history.location},e._isMounted=!1,e._pendingLocation=null,t.staticContext||(e.unlisten=t.history.listen(function(t){e._isMounted?e.setState({location:t}):e._pendingLocation=t})),e}_inheritsLoose(t,n),t.computeRootMatch=function(t){return{path:"/",url:"/",params:{},isExact:"/"===t}};var e=t.prototype;return e.componentDidMount=function(){this._isMounted=!0,this._pendingLocation&&this.setState({location:this._pendingLocation})},e.componentWillUnmount=function(){this.unlisten&&this.unlisten()},e.render=function(){return React.createElement(context.Provider,{children:this.props.children||null,value:{history:this.props.history,location:this.state.location,match:t.computeRootMatch(this.state.location.pathname),staticContext:this.props.staticContext}})},t}(React.Component),MemoryRouter=function(r){function t(){for(var t,e=arguments.length,n=new Array(e),o=0;o<e;o++)n[o]=arguments[o];return(t=r.call.apply(r,[this].concat(n))||this).history=history.createMemoryHistory(t.props),t}return _inheritsLoose(t,r),t.prototype.render=function(){return React.createElement(Router,{history:this.history,children:this.props.children})},t}(React.Component),Lifecycle=function(t){function e(){return t.apply(this,arguments)||this}_inheritsLoose(e,t);var n=e.prototype;return n.componentDidMount=function(){this.props.onMount&&this.props.onMount.call(this,this)},n.componentDidUpdate=function(t){this.props.onUpdate&&this.props.onUpdate.call(this,this,t)},n.componentWillUnmount=function(){this.props.onUnmount&&this.props.onUnmount.call(this,this)},n.render=function(){return null},e}(React.Component);function Prompt(t){var o=t.message,e=t.when,r=void 0===e||e;return React.createElement(context.Consumer,null,function(t){if(t||invariant(!1),!r||t.staticContext)return null;var n=t.history.block;return React.createElement(Lifecycle,{onMount:function(t){t.release=n(o)},onUpdate:function(t,e){e.message!==o&&(t.release(),t.release=n(o))},onUnmount:function(t){t.release()},message:o})})}var cache={},cacheLimit=1e4,cacheCount=0;function compilePath(t){if(cache[t])return cache[t];var e=pathToRegexp.compile(t);return cacheCount<cacheLimit&&(cache[t]=e,cacheCount++),e}function generatePath(t,e){return void 0===t&&(t="/"),void 0===e&&(e={}),"/"===t?t:compilePath(t)(e,{pretty:!0})}function Redirect(t){var a=t.computedMatch,i=t.to,e=t.push,c=void 0!==e&&e;return React.createElement(context.Consumer,null,function(t){t||invariant(!1);var e=t.history,n=t.staticContext,o=c?e.push:e.replace,r=history.createLocation(a?"string"==typeof i?generatePath(i,a.params):_extends({},i,{pathname:generatePath(i.pathname,a.params)}):i);return n?(o(r),null):React.createElement(Lifecycle,{onMount:function(){o(r)},onUpdate:function(t,e){var n=history.createLocation(e.to);history.locationsAreEqual(n,_extends({},r,{key:n.key}))||o(r)},to:i})})}var cache$1={},cacheLimit$1=1e4,cacheCount$1=0;function compilePath$1(t,e){var n=""+e.end+e.strict+e.sensitive,o=cache$1[n]||(cache$1[n]={});if(o[t])return o[t];var r=[],a={regexp:pathToRegexp(t,r,e),keys:r};return cacheCount$1<cacheLimit$1&&(o[t]=a,cacheCount$1++),a}function matchPath(u,t){void 0===t&&(t={}),"string"!=typeof t&&!Array.isArray(t)||(t={path:t});var e=t,n=e.path,o=e.exact,p=void 0!==o&&o,r=e.strict,h=void 0!==r&&r,a=e.sensitive,l=void 0!==a&&a;return[].concat(n).reduce(function(t,e){if(!e&&""!==e)return null;if(t)return t;var n=compilePath$1(e,{end:p,strict:h,sensitive:l}),o=n.regexp,r=n.keys,a=o.exec(u);if(!a)return null;var i=a[0],c=a.slice(1),s=u===i;return p&&!s?null:{path:e,url:"/"===e&&""===i?"/":i,isExact:s,params:r.reduce(function(t,e,n){return t[e.name]=c[n],t},{})}},null)}var Route=function(t){function e(){return t.apply(this,arguments)||this}return _inheritsLoose(e,t),e.prototype.render=function(){var c=this;return React.createElement(context.Consumer,null,function(t){t||invariant(!1);var e=c.props.location||t.location,n=_extends({},t,{location:e,match:c.props.computedMatch?c.props.computedMatch:c.props.path?matchPath(e.pathname,c.props):t.match}),o=c.props,r=o.children,a=o.component,i=o.render;return Array.isArray(r)&&0===r.length&&(r=null),React.createElement(context.Provider,{value:n},n.match?r?"function"==typeof r?r(n):r:a?React.createElement(a,n):i?i(n):null:"function"==typeof r?r(n):null)})},e}(React.Component);function addLeadingSlash(t){return"/"===t.charAt(0)?t:"/"+t}function addBasename(t,e){return t?_extends({},e,{pathname:addLeadingSlash(t)+e.pathname}):e}function stripBasename(t,e){if(!t)return e;var n=addLeadingSlash(t);return 0!==e.pathname.indexOf(n)?e:_extends({},e,{pathname:e.pathname.substr(n.length)})}function createURL(t){return"string"==typeof t?t:history.createPath(t)}function staticHandler(t){return function(){invariant(!1)}}function noop(){}var StaticRouter=function(r){function t(){for(var e,t=arguments.length,n=new Array(t),o=0;o<t;o++)n[o]=arguments[o];return(e=r.call.apply(r,[this].concat(n))||this).handlePush=function(t){return e.navigateTo(t,"PUSH")},e.handleReplace=function(t){return e.navigateTo(t,"REPLACE")},e.handleListen=function(){return noop},e.handleBlock=function(){return noop},e}_inheritsLoose(t,r);var e=t.prototype;return e.navigateTo=function(t,e){var n=this.props,o=n.basename,r=void 0===o?"":o,a=n.context,i=void 0===a?{}:a;i.action=e,i.location=addBasename(r,history.createLocation(t)),i.url=createURL(i.location)},e.render=function(){var t=this.props,e=t.basename,n=void 0===e?"":e,o=t.context,r=void 0===o?{}:o,a=t.location,i=void 0===a?"/":a,c=_objectWithoutPropertiesLoose(t,["basename","context","location"]),s={createHref:function(t){return addLeadingSlash(n+createURL(t))},action:"POP",location:stripBasename(n,history.createLocation(i)),push:this.handlePush,replace:this.handleReplace,go:staticHandler(),goBack:staticHandler(),goForward:staticHandler(),listen:this.handleListen,block:this.handleBlock};return React.createElement(Router,_extends({},c,{history:s,staticContext:r}))},t}(React.Component),Switch=function(t){function e(){return t.apply(this,arguments)||this}return _inheritsLoose(e,t),e.prototype.render=function(){var t=this;return React.createElement(context.Consumer,null,function(n){n||invariant(!1);var o,r,a=t.props.location||n.location;return React.Children.forEach(t.props.children,function(t){if(null==r&&React.isValidElement(t)){var e=(o=t).props.path||t.props.from;r=e?matchPath(a.pathname,_extends({},t.props,{path:e})):n.match}}),r?React.cloneElement(o,{location:a,computedMatch:r}):null})},e}(React.Component);function withRouter(o){function t(t){var e=t.wrappedComponentRef,n=_objectWithoutPropertiesLoose(t,["wrappedComponentRef"]);return React.createElement(context.Consumer,null,function(t){return t||invariant(!1),React.createElement(o,_extends({},n,t,{ref:e}))})}var e="withRouter("+(o.displayName||o.name)+")";return t.displayName=e,t.WrappedComponent=o,hoistStatics(t,o)}var useContext=React.useContext;function useHistory(){return useContext(context).history}function useLocation(){return useContext(context).location}function useParams(){var t=useContext(context).match;return t?t.params:{}}function useRouteMatch(t){return t?matchPath(useLocation().pathname,t):useContext(context).match}exports.MemoryRouter=MemoryRouter,exports.Prompt=Prompt,exports.Redirect=Redirect,exports.Route=Route,exports.Router=Router,exports.StaticRouter=StaticRouter,exports.Switch=Switch,exports.__RouterContext=context,exports.generatePath=generatePath,exports.matchPath=matchPath,exports.useHistory=useHistory,exports.useLocation=useLocation,exports.useParams=useParams,exports.useRouteMatch=useRouteMatch,exports.withRouter=withRouter;
	//# sourceMappingURL=react-router.min.js.map


/***/ },
/* 411 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	
	if (true) {
	  module.exports = __webpack_require__(410);
	} else {
	  module.exports = require("./cjs/react-router.js");
	}


/***/ },
/* 412 */
/***/ function(module, exports) {

	module.exports = Array.isArray || function (arr) {
	  return Object.prototype.toString.call(arr) == '[object Array]';
	};


/***/ },
/* 413 */
/***/ function(module, exports, __webpack_require__) {

	var isarray = __webpack_require__(412)
	
	/**
	 * Expose `pathToRegexp`.
	 */
	module.exports = pathToRegexp
	module.exports.parse = parse
	module.exports.compile = compile
	module.exports.tokensToFunction = tokensToFunction
	module.exports.tokensToRegExp = tokensToRegExp
	
	/**
	 * The main path matching regexp utility.
	 *
	 * @type {RegExp}
	 */
	var PATH_REGEXP = new RegExp([
	  // Match escaped characters that would otherwise appear in future matches.
	  // This allows the user to escape special characters that won't transform.
	  '(\\\\.)',
	  // Match Express-style parameters and un-named parameters with a prefix
	  // and optional suffixes. Matches appear as:
	  //
	  // "/:test(\\d+)?" => ["/", "test", "\d+", undefined, "?", undefined]
	  // "/route(\\d+)"  => [undefined, undefined, undefined, "\d+", undefined, undefined]
	  // "/*"            => ["/", undefined, undefined, undefined, undefined, "*"]
	  '([\\/.])?(?:(?:\\:(\\w+)(?:\\(((?:\\\\.|[^\\\\()])+)\\))?|\\(((?:\\\\.|[^\\\\()])+)\\))([+*?])?|(\\*))'
	].join('|'), 'g')
	
	/**
	 * Parse a string for the raw tokens.
	 *
	 * @param  {string}  str
	 * @param  {Object=} options
	 * @return {!Array}
	 */
	function parse (str, options) {
	  var tokens = []
	  var key = 0
	  var index = 0
	  var path = ''
	  var defaultDelimiter = options && options.delimiter || '/'
	  var res
	
	  while ((res = PATH_REGEXP.exec(str)) != null) {
	    var m = res[0]
	    var escaped = res[1]
	    var offset = res.index
	    path += str.slice(index, offset)
	    index = offset + m.length
	
	    // Ignore already escaped sequences.
	    if (escaped) {
	      path += escaped[1]
	      continue
	    }
	
	    var next = str[index]
	    var prefix = res[2]
	    var name = res[3]
	    var capture = res[4]
	    var group = res[5]
	    var modifier = res[6]
	    var asterisk = res[7]
	
	    // Push the current path onto the tokens.
	    if (path) {
	      tokens.push(path)
	      path = ''
	    }
	
	    var partial = prefix != null && next != null && next !== prefix
	    var repeat = modifier === '+' || modifier === '*'
	    var optional = modifier === '?' || modifier === '*'
	    var delimiter = res[2] || defaultDelimiter
	    var pattern = capture || group
	
	    tokens.push({
	      name: name || key++,
	      prefix: prefix || '',
	      delimiter: delimiter,
	      optional: optional,
	      repeat: repeat,
	      partial: partial,
	      asterisk: !!asterisk,
	      pattern: pattern ? escapeGroup(pattern) : (asterisk ? '.*' : '[^' + escapeString(delimiter) + ']+?')
	    })
	  }
	
	  // Match any characters still remaining.
	  if (index < str.length) {
	    path += str.substr(index)
	  }
	
	  // If the path exists, push it onto the end.
	  if (path) {
	    tokens.push(path)
	  }
	
	  return tokens
	}
	
	/**
	 * Compile a string to a template function for the path.
	 *
	 * @param  {string}             str
	 * @param  {Object=}            options
	 * @return {!function(Object=, Object=)}
	 */
	function compile (str, options) {
	  return tokensToFunction(parse(str, options), options)
	}
	
	/**
	 * Prettier encoding of URI path segments.
	 *
	 * @param  {string}
	 * @return {string}
	 */
	function encodeURIComponentPretty (str) {
	  return encodeURI(str).replace(/[\/?#]/g, function (c) {
	    return '%' + c.charCodeAt(0).toString(16).toUpperCase()
	  })
	}
	
	/**
	 * Encode the asterisk parameter. Similar to `pretty`, but allows slashes.
	 *
	 * @param  {string}
	 * @return {string}
	 */
	function encodeAsterisk (str) {
	  return encodeURI(str).replace(/[?#]/g, function (c) {
	    return '%' + c.charCodeAt(0).toString(16).toUpperCase()
	  })
	}
	
	/**
	 * Expose a method for transforming tokens into the path function.
	 */
	function tokensToFunction (tokens, options) {
	  // Compile all the tokens into regexps.
	  var matches = new Array(tokens.length)
	
	  // Compile all the patterns before compilation.
	  for (var i = 0; i < tokens.length; i++) {
	    if (typeof tokens[i] === 'object') {
	      matches[i] = new RegExp('^(?:' + tokens[i].pattern + ')$', flags(options))
	    }
	  }
	
	  return function (obj, opts) {
	    var path = ''
	    var data = obj || {}
	    var options = opts || {}
	    var encode = options.pretty ? encodeURIComponentPretty : encodeURIComponent
	
	    for (var i = 0; i < tokens.length; i++) {
	      var token = tokens[i]
	
	      if (typeof token === 'string') {
	        path += token
	
	        continue
	      }
	
	      var value = data[token.name]
	      var segment
	
	      if (value == null) {
	        if (token.optional) {
	          // Prepend partial segment prefixes.
	          if (token.partial) {
	            path += token.prefix
	          }
	
	          continue
	        } else {
	          throw new TypeError('Expected "' + token.name + '" to be defined')
	        }
	      }
	
	      if (isarray(value)) {
	        if (!token.repeat) {
	          throw new TypeError('Expected "' + token.name + '" to not repeat, but received `' + JSON.stringify(value) + '`')
	        }
	
	        if (value.length === 0) {
	          if (token.optional) {
	            continue
	          } else {
	            throw new TypeError('Expected "' + token.name + '" to not be empty')
	          }
	        }
	
	        for (var j = 0; j < value.length; j++) {
	          segment = encode(value[j])
	
	          if (!matches[i].test(segment)) {
	            throw new TypeError('Expected all "' + token.name + '" to match "' + token.pattern + '", but received `' + JSON.stringify(segment) + '`')
	          }
	
	          path += (j === 0 ? token.prefix : token.delimiter) + segment
	        }
	
	        continue
	      }
	
	      segment = token.asterisk ? encodeAsterisk(value) : encode(value)
	
	      if (!matches[i].test(segment)) {
	        throw new TypeError('Expected "' + token.name + '" to match "' + token.pattern + '", but received "' + segment + '"')
	      }
	
	      path += token.prefix + segment
	    }
	
	    return path
	  }
	}
	
	/**
	 * Escape a regular expression string.
	 *
	 * @param  {string} str
	 * @return {string}
	 */
	function escapeString (str) {
	  return str.replace(/([.+*?=^!:${}()[\]|\/\\])/g, '\\$1')
	}
	
	/**
	 * Escape the capturing group by escaping special characters and meaning.
	 *
	 * @param  {string} group
	 * @return {string}
	 */
	function escapeGroup (group) {
	  return group.replace(/([=!:$\/()])/g, '\\$1')
	}
	
	/**
	 * Attach the keys as a property of the regexp.
	 *
	 * @param  {!RegExp} re
	 * @param  {Array}   keys
	 * @return {!RegExp}
	 */
	function attachKeys (re, keys) {
	  re.keys = keys
	  return re
	}
	
	/**
	 * Get the flags for a regexp from the options.
	 *
	 * @param  {Object} options
	 * @return {string}
	 */
	function flags (options) {
	  return options && options.sensitive ? '' : 'i'
	}
	
	/**
	 * Pull out keys from a regexp.
	 *
	 * @param  {!RegExp} path
	 * @param  {!Array}  keys
	 * @return {!RegExp}
	 */
	function regexpToRegexp (path, keys) {
	  // Use a negative lookahead to match only capturing groups.
	  var groups = path.source.match(/\((?!\?)/g)
	
	  if (groups) {
	    for (var i = 0; i < groups.length; i++) {
	      keys.push({
	        name: i,
	        prefix: null,
	        delimiter: null,
	        optional: false,
	        repeat: false,
	        partial: false,
	        asterisk: false,
	        pattern: null
	      })
	    }
	  }
	
	  return attachKeys(path, keys)
	}
	
	/**
	 * Transform an array into a regexp.
	 *
	 * @param  {!Array}  path
	 * @param  {Array}   keys
	 * @param  {!Object} options
	 * @return {!RegExp}
	 */
	function arrayToRegexp (path, keys, options) {
	  var parts = []
	
	  for (var i = 0; i < path.length; i++) {
	    parts.push(pathToRegexp(path[i], keys, options).source)
	  }
	
	  var regexp = new RegExp('(?:' + parts.join('|') + ')', flags(options))
	
	  return attachKeys(regexp, keys)
	}
	
	/**
	 * Create a path regexp from string input.
	 *
	 * @param  {string}  path
	 * @param  {!Array}  keys
	 * @param  {!Object} options
	 * @return {!RegExp}
	 */
	function stringToRegexp (path, keys, options) {
	  return tokensToRegExp(parse(path, options), keys, options)
	}
	
	/**
	 * Expose a function for taking tokens and returning a RegExp.
	 *
	 * @param  {!Array}          tokens
	 * @param  {(Array|Object)=} keys
	 * @param  {Object=}         options
	 * @return {!RegExp}
	 */
	function tokensToRegExp (tokens, keys, options) {
	  if (!isarray(keys)) {
	    options = /** @type {!Object} */ (keys || options)
	    keys = []
	  }
	
	  options = options || {}
	
	  var strict = options.strict
	  var end = options.end !== false
	  var route = ''
	
	  // Iterate over the tokens and create our regexp string.
	  for (var i = 0; i < tokens.length; i++) {
	    var token = tokens[i]
	
	    if (typeof token === 'string') {
	      route += escapeString(token)
	    } else {
	      var prefix = escapeString(token.prefix)
	      var capture = '(?:' + token.pattern + ')'
	
	      keys.push(token)
	
	      if (token.repeat) {
	        capture += '(?:' + prefix + capture + ')*'
	      }
	
	      if (token.optional) {
	        if (!token.partial) {
	          capture = '(?:' + prefix + '(' + capture + '))?'
	        } else {
	          capture = prefix + '(' + capture + ')?'
	        }
	      } else {
	        capture = prefix + '(' + capture + ')'
	      }
	
	      route += capture
	    }
	  }
	
	  var delimiter = escapeString(options.delimiter || '/')
	  var endsWithDelimiter = route.slice(-delimiter.length) === delimiter
	
	  // In non-strict mode we allow a slash at the end of match. If the path to
	  // match already ends with a slash, we remove it for consistency. The slash
	  // is valid at the end of a path match, not in the middle. This is important
	  // in non-ending mode, where "/test/" shouldn't match "/test//route".
	  if (!strict) {
	    route = (endsWithDelimiter ? route.slice(0, -delimiter.length) : route) + '(?:' + delimiter + '(?=$))?'
	  }
	
	  if (end) {
	    route += '$'
	  } else {
	    // In non-ending mode, we need the capturing groups to match as much as
	    // possible by using a positive lookahead to the end or next path segment.
	    route += strict && endsWithDelimiter ? '' : '(?=' + delimiter + '|$)'
	  }
	
	  return attachKeys(new RegExp('^' + route, flags(options)), keys)
	}
	
	/**
	 * Normalize the given path string, returning a regular expression.
	 *
	 * An empty array can be passed in for the keys, which will hold the
	 * placeholder key descriptions. For example, using `/user/:id`, `keys` will
	 * contain `[{ name: 'id', delimiter: '/', optional: false, repeat: false }]`.
	 *
	 * @param  {(string|RegExp|Array)} path
	 * @param  {(Array|Object)=}       keys
	 * @param  {Object=}               options
	 * @return {!RegExp}
	 */
	function pathToRegexp (path, keys, options) {
	  if (!isarray(keys)) {
	    options = /** @type {!Object} */ (keys || options)
	    keys = []
	  }
	
	  options = options || {}
	
	  if (path instanceof RegExp) {
	    return regexpToRegexp(path, /** @type {!Array} */ (keys))
	  }
	
	  if (isarray(path)) {
	    return arrayToRegexp(/** @type {!Array} */ (path), /** @type {!Array} */ (keys), options)
	  }
	
	  return stringToRegexp(/** @type {string} */ (path), /** @type {!Array} */ (keys), options)
	}


/***/ },
/* 414 */
/***/ function(module, exports, __webpack_require__) {

	// @remove-on-eject-begin
	/**
	 * Copyright (c) 2015-present, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 */
	// @remove-on-eject-end
	'use strict';
	
	if (typeof Promise === 'undefined') {
	  // Rejection tracking prevents a common issue where React gets into an
	  // inconsistent state due to an error, but it gets swallowed by a Promise,
	  // and the user has no idea what causes React's erratic future behavior.
	  __webpack_require__(403).enable();
	  window.Promise = __webpack_require__(402);
	}
	
	// fetch() polyfill for making API calls.
	__webpack_require__(441);
	
	// Object.assign() is commonly used with React.
	// It will use the native implementation if it's present and isn't buggy.
	Object.assign = __webpack_require__(98);


/***/ },
/* 415 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	
	exports.__esModule = true;
	exports["default"] = void 0;
	
	var _propTypes = _interopRequireDefault(__webpack_require__(31));
	
	var _react = _interopRequireWildcard(__webpack_require__(2));
	
	var _classnames = _interopRequireDefault(__webpack_require__(62));
	
	function _getRequireWildcardCache() { if (typeof WeakMap !== "function") return null; var cache = new WeakMap(); _getRequireWildcardCache = function _getRequireWildcardCache() { return cache; }; return cache; }
	
	function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== "object" && typeof obj !== "function") { return { "default": obj }; } var cache = _getRequireWildcardCache(); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj["default"] = obj; if (cache) { cache.set(obj, newObj); } return newObj; }
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { "default": obj }; }
	
	function _extends() { _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }
	
	function _objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }
	
	function _inheritsLoose(subClass, superClass) { subClass.prototype = Object.create(superClass.prototype); subClass.prototype.constructor = subClass; subClass.__proto__ = superClass; }
	
	var DEFAULT_CLASS = 'react-tabs__tab';
	
	var Tab =
	/*#__PURE__*/
	function (_Component) {
	  _inheritsLoose(Tab, _Component);
	
	  function Tab() {
	    return _Component.apply(this, arguments) || this;
	  }
	
	  var _proto = Tab.prototype;
	
	  _proto.componentDidMount = function componentDidMount() {
	    this.checkFocus();
	  };
	
	  _proto.componentDidUpdate = function componentDidUpdate() {
	    this.checkFocus();
	  };
	
	  _proto.checkFocus = function checkFocus() {
	    var _this$props = this.props,
	        selected = _this$props.selected,
	        focus = _this$props.focus;
	
	    if (selected && focus) {
	      this.node.focus();
	    }
	  };
	
	  _proto.render = function render() {
	    var _cx,
	        _this = this;
	
	    var _this$props2 = this.props,
	        children = _this$props2.children,
	        className = _this$props2.className,
	        disabled = _this$props2.disabled,
	        disabledClassName = _this$props2.disabledClassName,
	        focus = _this$props2.focus,
	        id = _this$props2.id,
	        panelId = _this$props2.panelId,
	        selected = _this$props2.selected,
	        selectedClassName = _this$props2.selectedClassName,
	        tabIndex = _this$props2.tabIndex,
	        tabRef = _this$props2.tabRef,
	        attributes = _objectWithoutPropertiesLoose(_this$props2, ["children", "className", "disabled", "disabledClassName", "focus", "id", "panelId", "selected", "selectedClassName", "tabIndex", "tabRef"]);
	
	    return _react["default"].createElement("li", _extends({}, attributes, {
	      className: (0, _classnames["default"])(className, (_cx = {}, _cx[selectedClassName] = selected, _cx[disabledClassName] = disabled, _cx)),
	      ref: function ref(node) {
	        _this.node = node;
	        if (tabRef) tabRef(node);
	      },
	      role: "tab",
	      id: id,
	      "aria-selected": selected ? 'true' : 'false',
	      "aria-disabled": disabled ? 'true' : 'false',
	      "aria-controls": panelId,
	      tabIndex: tabIndex || (selected ? '0' : null)
	    }), children);
	  };
	
	  return Tab;
	}(_react.Component);
	
	exports["default"] = Tab;
	Tab.defaultProps = {
	  className: DEFAULT_CLASS,
	  disabledClassName: DEFAULT_CLASS + "--disabled",
	  focus: false,
	  id: null,
	  panelId: null,
	  selected: false,
	  selectedClassName: DEFAULT_CLASS + "--selected"
	};
	Tab.propTypes =  false ? {
	  children: _propTypes["default"].oneOfType([_propTypes["default"].array, _propTypes["default"].object, _propTypes["default"].string]),
	  className: _propTypes["default"].oneOfType([_propTypes["default"].string, _propTypes["default"].array, _propTypes["default"].object]),
	  disabled: _propTypes["default"].bool,
	  tabIndex: _propTypes["default"].string,
	  disabledClassName: _propTypes["default"].string,
	  focus: _propTypes["default"].bool,
	  // private
	  id: _propTypes["default"].string,
	  // private
	  panelId: _propTypes["default"].string,
	  // private
	  selected: _propTypes["default"].bool,
	  // private
	  selectedClassName: _propTypes["default"].string,
	  tabRef: _propTypes["default"].func // private
	
	} : {};
	Tab.tabsRole = 'Tab';

/***/ },
/* 416 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	
	exports.__esModule = true;
	exports["default"] = void 0;
	
	var _propTypes = _interopRequireDefault(__webpack_require__(31));
	
	var _react = _interopRequireWildcard(__webpack_require__(2));
	
	var _classnames = _interopRequireDefault(__webpack_require__(62));
	
	function _getRequireWildcardCache() { if (typeof WeakMap !== "function") return null; var cache = new WeakMap(); _getRequireWildcardCache = function _getRequireWildcardCache() { return cache; }; return cache; }
	
	function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== "object" && typeof obj !== "function") { return { "default": obj }; } var cache = _getRequireWildcardCache(); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj["default"] = obj; if (cache) { cache.set(obj, newObj); } return newObj; }
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { "default": obj }; }
	
	function _extends() { _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }
	
	function _objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }
	
	function _inheritsLoose(subClass, superClass) { subClass.prototype = Object.create(superClass.prototype); subClass.prototype.constructor = subClass; subClass.__proto__ = superClass; }
	
	var TabList =
	/*#__PURE__*/
	function (_Component) {
	  _inheritsLoose(TabList, _Component);
	
	  function TabList() {
	    return _Component.apply(this, arguments) || this;
	  }
	
	  var _proto = TabList.prototype;
	
	  _proto.render = function render() {
	    var _this$props = this.props,
	        children = _this$props.children,
	        className = _this$props.className,
	        attributes = _objectWithoutPropertiesLoose(_this$props, ["children", "className"]);
	
	    return _react["default"].createElement("ul", _extends({}, attributes, {
	      className: (0, _classnames["default"])(className),
	      role: "tablist"
	    }), children);
	  };
	
	  return TabList;
	}(_react.Component);
	
	exports["default"] = TabList;
	TabList.defaultProps = {
	  className: 'react-tabs__tab-list'
	};
	TabList.propTypes =  false ? {
	  children: _propTypes["default"].oneOfType([_propTypes["default"].object, _propTypes["default"].array]),
	  className: _propTypes["default"].oneOfType([_propTypes["default"].string, _propTypes["default"].array, _propTypes["default"].object])
	} : {};
	TabList.tabsRole = 'TabList';

/***/ },
/* 417 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	
	exports.__esModule = true;
	exports["default"] = void 0;
	
	var _propTypes = _interopRequireDefault(__webpack_require__(31));
	
	var _react = _interopRequireWildcard(__webpack_require__(2));
	
	var _classnames = _interopRequireDefault(__webpack_require__(62));
	
	function _getRequireWildcardCache() { if (typeof WeakMap !== "function") return null; var cache = new WeakMap(); _getRequireWildcardCache = function _getRequireWildcardCache() { return cache; }; return cache; }
	
	function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== "object" && typeof obj !== "function") { return { "default": obj }; } var cache = _getRequireWildcardCache(); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj["default"] = obj; if (cache) { cache.set(obj, newObj); } return newObj; }
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { "default": obj }; }
	
	function _extends() { _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }
	
	function _objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }
	
	function _inheritsLoose(subClass, superClass) { subClass.prototype = Object.create(superClass.prototype); subClass.prototype.constructor = subClass; subClass.__proto__ = superClass; }
	
	var DEFAULT_CLASS = 'react-tabs__tab-panel';
	
	var TabPanel =
	/*#__PURE__*/
	function (_Component) {
	  _inheritsLoose(TabPanel, _Component);
	
	  function TabPanel() {
	    return _Component.apply(this, arguments) || this;
	  }
	
	  var _proto = TabPanel.prototype;
	
	  _proto.render = function render() {
	    var _cx;
	
	    var _this$props = this.props,
	        children = _this$props.children,
	        className = _this$props.className,
	        forceRender = _this$props.forceRender,
	        id = _this$props.id,
	        selected = _this$props.selected,
	        selectedClassName = _this$props.selectedClassName,
	        tabId = _this$props.tabId,
	        attributes = _objectWithoutPropertiesLoose(_this$props, ["children", "className", "forceRender", "id", "selected", "selectedClassName", "tabId"]);
	
	    return _react["default"].createElement("div", _extends({}, attributes, {
	      className: (0, _classnames["default"])(className, (_cx = {}, _cx[selectedClassName] = selected, _cx)),
	      role: "tabpanel",
	      id: id,
	      "aria-labelledby": tabId
	    }), forceRender || selected ? children : null);
	  };
	
	  return TabPanel;
	}(_react.Component);
	
	exports["default"] = TabPanel;
	TabPanel.defaultProps = {
	  className: DEFAULT_CLASS,
	  forceRender: false,
	  selectedClassName: DEFAULT_CLASS + "--selected"
	};
	TabPanel.propTypes =  false ? {
	  children: _propTypes["default"].node,
	  className: _propTypes["default"].oneOfType([_propTypes["default"].string, _propTypes["default"].array, _propTypes["default"].object]),
	  forceRender: _propTypes["default"].bool,
	  id: _propTypes["default"].string,
	  // private
	  selected: _propTypes["default"].bool,
	  // private
	  selectedClassName: _propTypes["default"].string,
	  tabId: _propTypes["default"].string // private
	
	} : {};
	TabPanel.tabsRole = 'TabPanel';

/***/ },
/* 418 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	
	exports.__esModule = true;
	exports["default"] = void 0;
	
	var _propTypes = _interopRequireDefault(__webpack_require__(31));
	
	var _react = _interopRequireWildcard(__webpack_require__(2));
	
	var _propTypes2 = __webpack_require__(167);
	
	var _UncontrolledTabs = _interopRequireDefault(__webpack_require__(419));
	
	var _count = __webpack_require__(166);
	
	function _getRequireWildcardCache() { if (typeof WeakMap !== "function") return null; var cache = new WeakMap(); _getRequireWildcardCache = function _getRequireWildcardCache() { return cache; }; return cache; }
	
	function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== "object" && typeof obj !== "function") { return { "default": obj }; } var cache = _getRequireWildcardCache(); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj["default"] = obj; if (cache) { cache.set(obj, newObj); } return newObj; }
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { "default": obj }; }
	
	function _objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }
	
	function _inheritsLoose(subClass, superClass) { subClass.prototype = Object.create(superClass.prototype); subClass.prototype.constructor = subClass; subClass.__proto__ = superClass; }
	
	var MODE_CONTROLLED = 0;
	var MODE_UNCONTROLLED = 1;
	
	var Tabs =
	/*#__PURE__*/
	function (_Component) {
	  _inheritsLoose(Tabs, _Component);
	
	  function Tabs(props) {
	    var _this;
	
	    _this = _Component.call(this, props) || this;
	
	    _this.handleSelected = function (index, last, event) {
	      var onSelect = _this.props.onSelect;
	      var mode = _this.state.mode; // Call change event handler
	
	      if (typeof onSelect === 'function') {
	        // Check if the change event handler cancels the tab change
	        if (onSelect(index, last, event) === false) return;
	      }
	
	      var state = {
	        // Set focus if the change was triggered from the keyboard
	        focus: event.type === 'keydown'
	      };
	
	      if (mode === MODE_UNCONTROLLED) {
	        // Update selected index
	        state.selectedIndex = index;
	      }
	
	      _this.setState(state);
	    };
	
	    _this.state = Tabs.copyPropsToState(_this.props, {}, props.defaultFocus);
	    return _this;
	  }
	
	  Tabs.getDerivedStateFromProps = function getDerivedStateFromProps(props, state) {
	    return Tabs.copyPropsToState(props, state);
	  };
	
	  Tabs.getModeFromProps = function getModeFromProps(props) {
	    return props.selectedIndex === null ? MODE_UNCONTROLLED : MODE_CONTROLLED;
	  };
	
	  // preserve the existing selectedIndex from state.
	  // If the state has not selectedIndex, default to the defaultIndex or 0
	  Tabs.copyPropsToState = function copyPropsToState(props, state, focus) {
	    if (focus === void 0) {
	      focus = false;
	    }
	
	    if (false) {
	      throw new Error("Switching between controlled mode (by using `selectedIndex`) and uncontrolled mode is not supported in `Tabs`.\nFor more information about controlled and uncontrolled mode of react-tabs see the README.");
	    }
	
	    var newState = {
	      focus: focus,
	      mode: Tabs.getModeFromProps(props)
	    };
	
	    if (newState.mode === MODE_UNCONTROLLED) {
	      var maxTabIndex = (0, _count.getTabsCount)(props.children) - 1;
	      var selectedIndex = null;
	
	      if (state.selectedIndex != null) {
	        selectedIndex = Math.min(state.selectedIndex, maxTabIndex);
	      } else {
	        selectedIndex = props.defaultIndex || 0;
	      }
	
	      newState.selectedIndex = selectedIndex;
	    }
	
	    return newState;
	  };
	
	  var _proto = Tabs.prototype;
	
	  _proto.render = function render() {
	    var _this$props = this.props,
	        children = _this$props.children,
	        defaultIndex = _this$props.defaultIndex,
	        defaultFocus = _this$props.defaultFocus,
	        props = _objectWithoutPropertiesLoose(_this$props, ["children", "defaultIndex", "defaultFocus"]);
	
	    var _this$state = this.state,
	        focus = _this$state.focus,
	        selectedIndex = _this$state.selectedIndex;
	    props.focus = focus;
	    props.onSelect = this.handleSelected;
	
	    if (selectedIndex != null) {
	      props.selectedIndex = selectedIndex;
	    }
	
	    return _react["default"].createElement(_UncontrolledTabs["default"], props, children);
	  };
	
	  return Tabs;
	}(_react.Component);
	
	exports["default"] = Tabs;
	Tabs.defaultProps = {
	  defaultFocus: false,
	  forceRenderTabPanel: false,
	  selectedIndex: null,
	  defaultIndex: null
	};
	Tabs.propTypes =  false ? {
	  children: _propTypes2.childrenPropType,
	  direction: _propTypes["default"].oneOf(['rtl', 'ltr']),
	  className: _propTypes["default"].oneOfType([_propTypes["default"].string, _propTypes["default"].array, _propTypes["default"].object]),
	  defaultFocus: _propTypes["default"].bool,
	  defaultIndex: _propTypes["default"].number,
	  disabledTabClassName: _propTypes["default"].string,
	  domRef: _propTypes["default"].func,
	  forceRenderTabPanel: _propTypes["default"].bool,
	  onSelect: _propTypes2.onSelectPropType,
	  selectedIndex: _propTypes2.selectedIndexPropType,
	  selectedTabClassName: _propTypes["default"].string,
	  selectedTabPanelClassName: _propTypes["default"].string
	} : {};
	Tabs.tabsRole = 'Tabs';

/***/ },
/* 419 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	
	exports.__esModule = true;
	exports["default"] = void 0;
	
	var _propTypes = _interopRequireDefault(__webpack_require__(31));
	
	var _react = _interopRequireWildcard(__webpack_require__(2));
	
	var _classnames = _interopRequireDefault(__webpack_require__(62));
	
	var _uuid = _interopRequireDefault(__webpack_require__(168));
	
	var _propTypes2 = __webpack_require__(167);
	
	var _count = __webpack_require__(166);
	
	var _childrenDeepMap = __webpack_require__(101);
	
	var _elementTypes = __webpack_require__(73);
	
	function _getRequireWildcardCache() { if (typeof WeakMap !== "function") return null; var cache = new WeakMap(); _getRequireWildcardCache = function _getRequireWildcardCache() { return cache; }; return cache; }
	
	function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== "object" && typeof obj !== "function") { return { "default": obj }; } var cache = _getRequireWildcardCache(); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj["default"] = obj; if (cache) { cache.set(obj, newObj); } return newObj; }
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { "default": obj }; }
	
	function _extends() { _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }
	
	function _objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }
	
	function _inheritsLoose(subClass, superClass) { subClass.prototype = Object.create(superClass.prototype); subClass.prototype.constructor = subClass; subClass.__proto__ = superClass; }
	
	function isNode(node) {
	  return node && 'getAttribute' in node;
	} // Determine if a node from event.target is a Tab element
	
	
	function isTabNode(node) {
	  return isNode(node) && node.getAttribute('role') === 'tab';
	} // Determine if a tab node is disabled
	
	
	function isTabDisabled(node) {
	  return isNode(node) && node.getAttribute('aria-disabled') === 'true';
	}
	
	var canUseActiveElement;
	
	try {
	  canUseActiveElement = !!(typeof window !== 'undefined' && window.document && window.document.activeElement);
	} catch (e) {
	  // Work around for IE bug when accessing document.activeElement in an iframe
	  // Refer to the following resources:
	  // http://stackoverflow.com/a/10982960/369687
	  // https://developer.microsoft.com/en-us/microsoft-edge/platform/issues/12733599
	  canUseActiveElement = false;
	}
	
	var UncontrolledTabs =
	/*#__PURE__*/
	function (_Component) {
	  _inheritsLoose(UncontrolledTabs, _Component);
	
	  function UncontrolledTabs() {
	    var _this;
	
	    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
	      args[_key] = arguments[_key];
	    }
	
	    _this = _Component.call.apply(_Component, [this].concat(args)) || this;
	    _this.tabNodes = [];
	
	    _this.handleKeyDown = function (e) {
	      var direction = _this.props.direction;
	
	      if (_this.isTabFromContainer(e.target)) {
	        var index = _this.props.selectedIndex;
	        var preventDefault = false;
	        var useSelectedIndex = false;
	
	        if (e.keyCode === 32 || e.keyCode === 13) {
	          preventDefault = true;
	          useSelectedIndex = false;
	
	          _this.handleClick(e);
	        }
	
	        if (e.keyCode === 37 || e.keyCode === 38) {
	          // Select next tab to the left
	          if (direction === 'rtl') {
	            index = _this.getNextTab(index);
	          } else {
	            index = _this.getPrevTab(index);
	          }
	
	          preventDefault = true;
	          useSelectedIndex = true;
	        } else if (e.keyCode === 39 || e.keyCode === 40) {
	          // Select next tab to the right
	          if (direction === 'rtl') {
	            index = _this.getPrevTab(index);
	          } else {
	            index = _this.getNextTab(index);
	          }
	
	          preventDefault = true;
	          useSelectedIndex = true;
	        } else if (e.keyCode === 35) {
	          // Select last tab (End key)
	          index = _this.getLastTab();
	          preventDefault = true;
	          useSelectedIndex = true;
	        } else if (e.keyCode === 36) {
	          // Select first tab (Home key)
	          index = _this.getFirstTab();
	          preventDefault = true;
	          useSelectedIndex = true;
	        } // This prevents scrollbars from moving around
	
	
	        if (preventDefault) {
	          e.preventDefault();
	        } // Only use the selected index in the state if we're not using the tabbed index
	
	
	        if (useSelectedIndex) {
	          _this.setSelected(index, e);
	        }
	      }
	    };
	
	    _this.handleClick = function (e) {
	      var node = e.target;
	
	      do {
	        if (_this.isTabFromContainer(node)) {
	          if (isTabDisabled(node)) {
	            return;
	          }
	
	          var index = [].slice.call(node.parentNode.children).filter(isTabNode).indexOf(node);
	
	          _this.setSelected(index, e);
	
	          return;
	        } // eslint-disable-next-line no-cond-assign
	
	      } while ((node = node.parentNode) != null);
	    };
	
	    return _this;
	  }
	
	  var _proto = UncontrolledTabs.prototype;
	
	  _proto.setSelected = function setSelected(index, event) {
	    // Check index boundary
	    if (index < 0 || index >= this.getTabsCount()) return;
	    var _this$props = this.props,
	        onSelect = _this$props.onSelect,
	        selectedIndex = _this$props.selectedIndex; // Call change event handler
	
	    onSelect(index, selectedIndex, event);
	  };
	
	  _proto.getNextTab = function getNextTab(index) {
	    var count = this.getTabsCount(); // Look for non-disabled tab from index to the last tab on the right
	
	    for (var i = index + 1; i < count; i++) {
	      if (!isTabDisabled(this.getTab(i))) {
	        return i;
	      }
	    } // If no tab found, continue searching from first on left to index
	
	
	    for (var _i = 0; _i < index; _i++) {
	      if (!isTabDisabled(this.getTab(_i))) {
	        return _i;
	      }
	    } // No tabs are disabled, return index
	
	
	    return index;
	  };
	
	  _proto.getPrevTab = function getPrevTab(index) {
	    var i = index; // Look for non-disabled tab from index to first tab on the left
	
	    while (i--) {
	      if (!isTabDisabled(this.getTab(i))) {
	        return i;
	      }
	    } // If no tab found, continue searching from last tab on right to index
	
	
	    i = this.getTabsCount();
	
	    while (i-- > index) {
	      if (!isTabDisabled(this.getTab(i))) {
	        return i;
	      }
	    } // No tabs are disabled, return index
	
	
	    return index;
	  };
	
	  _proto.getFirstTab = function getFirstTab() {
	    var count = this.getTabsCount(); // Look for non disabled tab from the first tab
	
	    for (var i = 0; i < count; i++) {
	      if (!isTabDisabled(this.getTab(i))) {
	        return i;
	      }
	    }
	
	    return null;
	  };
	
	  _proto.getLastTab = function getLastTab() {
	    var i = this.getTabsCount(); // Look for non disabled tab from the last tab
	
	    while (i--) {
	      if (!isTabDisabled(this.getTab(i))) {
	        return i;
	      }
	    }
	
	    return null;
	  };
	
	  _proto.getTabsCount = function getTabsCount() {
	    var children = this.props.children;
	    return (0, _count.getTabsCount)(children);
	  };
	
	  _proto.getPanelsCount = function getPanelsCount() {
	    var children = this.props.children;
	    return (0, _count.getPanelsCount)(children);
	  };
	
	  _proto.getTab = function getTab(index) {
	    return this.tabNodes["tabs-" + index];
	  };
	
	  _proto.getChildren = function getChildren() {
	    var _this2 = this;
	
	    var index = 0;
	    var _this$props2 = this.props,
	        children = _this$props2.children,
	        disabledTabClassName = _this$props2.disabledTabClassName,
	        focus = _this$props2.focus,
	        forceRenderTabPanel = _this$props2.forceRenderTabPanel,
	        selectedIndex = _this$props2.selectedIndex,
	        selectedTabClassName = _this$props2.selectedTabClassName,
	        selectedTabPanelClassName = _this$props2.selectedTabPanelClassName;
	    this.tabIds = this.tabIds || [];
	    this.panelIds = this.panelIds || [];
	    var diff = this.tabIds.length - this.getTabsCount(); // Add ids if new tabs have been added
	    // Don't bother removing ids, just keep them in case they are added again
	    // This is more efficient, and keeps the uuid counter under control
	
	    while (diff++ < 0) {
	      this.tabIds.push((0, _uuid["default"])());
	      this.panelIds.push((0, _uuid["default"])());
	    } // Map children to dynamically setup refs
	
	
	    return (0, _childrenDeepMap.deepMap)(children, function (child) {
	      var result = child; // Clone TabList and Tab components to have refs
	
	      if ((0, _elementTypes.isTabList)(child)) {
	        var listIndex = 0; // Figure out if the current focus in the DOM is set on a Tab
	        // If it is we should keep the focus on the next selected tab
	
	        var wasTabFocused = false;
	
	        if (canUseActiveElement) {
	          wasTabFocused = _react["default"].Children.toArray(child.props.children).filter(_elementTypes.isTab).some(function (tab, i) {
	            return document.activeElement === _this2.getTab(i);
	          });
	        }
	
	        result = (0, _react.cloneElement)(child, {
	          children: (0, _childrenDeepMap.deepMap)(child.props.children, function (tab) {
	            var key = "tabs-" + listIndex;
	            var selected = selectedIndex === listIndex;
	            var props = {
	              tabRef: function tabRef(node) {
	                _this2.tabNodes[key] = node;
	              },
	              id: _this2.tabIds[listIndex],
	              panelId: _this2.panelIds[listIndex],
	              selected: selected,
	              focus: selected && (focus || wasTabFocused)
	            };
	            if (selectedTabClassName) props.selectedClassName = selectedTabClassName;
	            if (disabledTabClassName) props.disabledClassName = disabledTabClassName;
	            listIndex++;
	            return (0, _react.cloneElement)(tab, props);
	          })
	        });
	      } else if ((0, _elementTypes.isTabPanel)(child)) {
	        var props = {
	          id: _this2.panelIds[index],
	          tabId: _this2.tabIds[index],
	          selected: selectedIndex === index
	        };
	        if (forceRenderTabPanel) props.forceRender = forceRenderTabPanel;
	        if (selectedTabPanelClassName) props.selectedClassName = selectedTabPanelClassName;
	        index++;
	        result = (0, _react.cloneElement)(child, props);
	      }
	
	      return result;
	    });
	  };
	
	  /**
	   * Determine if a node from event.target is a Tab element for the current Tabs container.
	   * If the clicked element is not a Tab, it returns false.
	   * If it finds another Tabs container between the Tab and `this`, it returns false.
	   */
	  _proto.isTabFromContainer = function isTabFromContainer(node) {
	    // return immediately if the clicked element is not a Tab.
	    if (!isTabNode(node)) {
	      return false;
	    } // Check if the first occurrence of a Tabs container is `this` one.
	
	
	    var nodeAncestor = node.parentElement;
	
	    do {
	      if (nodeAncestor === this.node) return true;
	      if (nodeAncestor.getAttribute('data-tabs')) break;
	      nodeAncestor = nodeAncestor.parentElement;
	    } while (nodeAncestor);
	
	    return false;
	  };
	
	  _proto.render = function render() {
	    var _this3 = this;
	
	    // Delete all known props, so they don't get added to DOM
	    var _this$props3 = this.props,
	        children = _this$props3.children,
	        className = _this$props3.className,
	        disabledTabClassName = _this$props3.disabledTabClassName,
	        domRef = _this$props3.domRef,
	        focus = _this$props3.focus,
	        forceRenderTabPanel = _this$props3.forceRenderTabPanel,
	        onSelect = _this$props3.onSelect,
	        selectedIndex = _this$props3.selectedIndex,
	        selectedTabClassName = _this$props3.selectedTabClassName,
	        selectedTabPanelClassName = _this$props3.selectedTabPanelClassName,
	        attributes = _objectWithoutPropertiesLoose(_this$props3, ["children", "className", "disabledTabClassName", "domRef", "focus", "forceRenderTabPanel", "onSelect", "selectedIndex", "selectedTabClassName", "selectedTabPanelClassName"]);
	
	    return _react["default"].createElement("div", _extends({}, attributes, {
	      className: (0, _classnames["default"])(className),
	      onClick: this.handleClick,
	      onKeyDown: this.handleKeyDown,
	      ref: function ref(node) {
	        _this3.node = node;
	        if (domRef) domRef(node);
	      },
	      "data-tabs": true
	    }), this.getChildren());
	  };
	
	  return UncontrolledTabs;
	}(_react.Component);
	
	exports["default"] = UncontrolledTabs;
	UncontrolledTabs.defaultProps = {
	  className: 'react-tabs',
	  focus: false
	};
	UncontrolledTabs.propTypes =  false ? {
	  children: _propTypes2.childrenPropType,
	  direction: _propTypes["default"].oneOf(['rtl', 'ltr']),
	  className: _propTypes["default"].oneOfType([_propTypes["default"].string, _propTypes["default"].array, _propTypes["default"].object]),
	  disabledTabClassName: _propTypes["default"].string,
	  domRef: _propTypes["default"].func,
	  focus: _propTypes["default"].bool,
	  forceRenderTabPanel: _propTypes["default"].bool,
	  onSelect: _propTypes["default"].func.isRequired,
	  selectedIndex: _propTypes["default"].number.isRequired,
	  selectedTabClassName: _propTypes["default"].string,
	  selectedTabPanelClassName: _propTypes["default"].string
	} : {};

/***/ },
/* 420 */
/***/ function(module, exports, __webpack_require__) {

	/** @license React v16.13.1
	 * react.production.min.js
	 *
	 * Copyright (c) Facebook, Inc. and its affiliates.
	 *
	 * This source code is licensed under the MIT license found in the
	 * LICENSE file in the root directory of this source tree.
	 */
	
	'use strict';var l=__webpack_require__(98),n="function"===typeof Symbol&&Symbol.for,p=n?Symbol.for("react.element"):60103,q=n?Symbol.for("react.portal"):60106,r=n?Symbol.for("react.fragment"):60107,t=n?Symbol.for("react.strict_mode"):60108,u=n?Symbol.for("react.profiler"):60114,v=n?Symbol.for("react.provider"):60109,w=n?Symbol.for("react.context"):60110,x=n?Symbol.for("react.forward_ref"):60112,y=n?Symbol.for("react.suspense"):60113,z=n?Symbol.for("react.memo"):60115,A=n?Symbol.for("react.lazy"):
	60116,B="function"===typeof Symbol&&Symbol.iterator;function C(a){for(var b="https://reactjs.org/docs/error-decoder.html?invariant="+a,c=1;c<arguments.length;c++)b+="&args[]="+encodeURIComponent(arguments[c]);return"Minified React error #"+a+"; visit "+b+" for the full message or use the non-minified dev environment for full errors and additional helpful warnings."}
	var D={isMounted:function(){return!1},enqueueForceUpdate:function(){},enqueueReplaceState:function(){},enqueueSetState:function(){}},E={};function F(a,b,c){this.props=a;this.context=b;this.refs=E;this.updater=c||D}F.prototype.isReactComponent={};F.prototype.setState=function(a,b){if("object"!==typeof a&&"function"!==typeof a&&null!=a)throw Error(C(85));this.updater.enqueueSetState(this,a,b,"setState")};F.prototype.forceUpdate=function(a){this.updater.enqueueForceUpdate(this,a,"forceUpdate")};
	function G(){}G.prototype=F.prototype;function H(a,b,c){this.props=a;this.context=b;this.refs=E;this.updater=c||D}var I=H.prototype=new G;I.constructor=H;l(I,F.prototype);I.isPureReactComponent=!0;var J={current:null},K=Object.prototype.hasOwnProperty,L={key:!0,ref:!0,__self:!0,__source:!0};
	function M(a,b,c){var e,d={},g=null,k=null;if(null!=b)for(e in void 0!==b.ref&&(k=b.ref),void 0!==b.key&&(g=""+b.key),b)K.call(b,e)&&!L.hasOwnProperty(e)&&(d[e]=b[e]);var f=arguments.length-2;if(1===f)d.children=c;else if(1<f){for(var h=Array(f),m=0;m<f;m++)h[m]=arguments[m+2];d.children=h}if(a&&a.defaultProps)for(e in f=a.defaultProps,f)void 0===d[e]&&(d[e]=f[e]);return{$$typeof:p,type:a,key:g,ref:k,props:d,_owner:J.current}}
	function N(a,b){return{$$typeof:p,type:a.type,key:b,ref:a.ref,props:a.props,_owner:a._owner}}function O(a){return"object"===typeof a&&null!==a&&a.$$typeof===p}function escape(a){var b={"=":"=0",":":"=2"};return"$"+(""+a).replace(/[=:]/g,function(a){return b[a]})}var P=/\/+/g,Q=[];function R(a,b,c,e){if(Q.length){var d=Q.pop();d.result=a;d.keyPrefix=b;d.func=c;d.context=e;d.count=0;return d}return{result:a,keyPrefix:b,func:c,context:e,count:0}}
	function S(a){a.result=null;a.keyPrefix=null;a.func=null;a.context=null;a.count=0;10>Q.length&&Q.push(a)}
	function T(a,b,c,e){var d=typeof a;if("undefined"===d||"boolean"===d)a=null;var g=!1;if(null===a)g=!0;else switch(d){case "string":case "number":g=!0;break;case "object":switch(a.$$typeof){case p:case q:g=!0}}if(g)return c(e,a,""===b?"."+U(a,0):b),1;g=0;b=""===b?".":b+":";if(Array.isArray(a))for(var k=0;k<a.length;k++){d=a[k];var f=b+U(d,k);g+=T(d,f,c,e)}else if(null===a||"object"!==typeof a?f=null:(f=B&&a[B]||a["@@iterator"],f="function"===typeof f?f:null),"function"===typeof f)for(a=f.call(a),k=
	0;!(d=a.next()).done;)d=d.value,f=b+U(d,k++),g+=T(d,f,c,e);else if("object"===d)throw c=""+a,Error(C(31,"[object Object]"===c?"object with keys {"+Object.keys(a).join(", ")+"}":c,""));return g}function V(a,b,c){return null==a?0:T(a,"",b,c)}function U(a,b){return"object"===typeof a&&null!==a&&null!=a.key?escape(a.key):b.toString(36)}function W(a,b){a.func.call(a.context,b,a.count++)}
	function aa(a,b,c){var e=a.result,d=a.keyPrefix;a=a.func.call(a.context,b,a.count++);Array.isArray(a)?X(a,e,c,function(a){return a}):null!=a&&(O(a)&&(a=N(a,d+(!a.key||b&&b.key===a.key?"":(""+a.key).replace(P,"$&/")+"/")+c)),e.push(a))}function X(a,b,c,e,d){var g="";null!=c&&(g=(""+c).replace(P,"$&/")+"/");b=R(b,g,e,d);V(a,aa,b);S(b)}var Y={current:null};function Z(){var a=Y.current;if(null===a)throw Error(C(321));return a}
	var ba={ReactCurrentDispatcher:Y,ReactCurrentBatchConfig:{suspense:null},ReactCurrentOwner:J,IsSomeRendererActing:{current:!1},assign:l};exports.Children={map:function(a,b,c){if(null==a)return a;var e=[];X(a,e,null,b,c);return e},forEach:function(a,b,c){if(null==a)return a;b=R(null,null,b,c);V(a,W,b);S(b)},count:function(a){return V(a,function(){return null},null)},toArray:function(a){var b=[];X(a,b,null,function(a){return a});return b},only:function(a){if(!O(a))throw Error(C(143));return a}};
	exports.Component=F;exports.Fragment=r;exports.Profiler=u;exports.PureComponent=H;exports.StrictMode=t;exports.Suspense=y;exports.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED=ba;
	exports.cloneElement=function(a,b,c){if(null===a||void 0===a)throw Error(C(267,a));var e=l({},a.props),d=a.key,g=a.ref,k=a._owner;if(null!=b){void 0!==b.ref&&(g=b.ref,k=J.current);void 0!==b.key&&(d=""+b.key);if(a.type&&a.type.defaultProps)var f=a.type.defaultProps;for(h in b)K.call(b,h)&&!L.hasOwnProperty(h)&&(e[h]=void 0===b[h]&&void 0!==f?f[h]:b[h])}var h=arguments.length-2;if(1===h)e.children=c;else if(1<h){f=Array(h);for(var m=0;m<h;m++)f[m]=arguments[m+2];e.children=f}return{$$typeof:p,type:a.type,
	key:d,ref:g,props:e,_owner:k}};exports.createContext=function(a,b){void 0===b&&(b=null);a={$$typeof:w,_calculateChangedBits:b,_currentValue:a,_currentValue2:a,_threadCount:0,Provider:null,Consumer:null};a.Provider={$$typeof:v,_context:a};return a.Consumer=a};exports.createElement=M;exports.createFactory=function(a){var b=M.bind(null,a);b.type=a;return b};exports.createRef=function(){return{current:null}};exports.forwardRef=function(a){return{$$typeof:x,render:a}};exports.isValidElement=O;
	exports.lazy=function(a){return{$$typeof:A,_ctor:a,_status:-1,_result:null}};exports.memo=function(a,b){return{$$typeof:z,type:a,compare:void 0===b?null:b}};exports.useCallback=function(a,b){return Z().useCallback(a,b)};exports.useContext=function(a,b){return Z().useContext(a,b)};exports.useDebugValue=function(){};exports.useEffect=function(a,b){return Z().useEffect(a,b)};exports.useImperativeHandle=function(a,b,c){return Z().useImperativeHandle(a,b,c)};
	exports.useLayoutEffect=function(a,b){return Z().useLayoutEffect(a,b)};exports.useMemo=function(a,b){return Z().useMemo(a,b)};exports.useReducer=function(a,b,c){return Z().useReducer(a,b,c)};exports.useRef=function(a){return Z().useRef(a)};exports.useState=function(a){return Z().useState(a)};exports.version="16.13.1";


/***/ },
/* 421 */
/***/ function(module, exports) {

	"use strict";function isAbsolute(e){return"/"===e.charAt(0)}function spliceOne(e,t){for(var s=t,n=s+1,i=e.length;n<i;s+=1,n+=1)e[s]=e[n];e.pop()}function resolvePathname(e,t){void 0===t&&(t="");var s,n=e&&e.split("/")||[],i=t&&t.split("/")||[],l=e&&isAbsolute(e),r=t&&isAbsolute(t),o=l||r;if(e&&isAbsolute(e)?i=n:n.length&&(i.pop(),i=i.concat(n)),!i.length)return"/";if(i.length){var u=i[i.length-1];s="."===u||".."===u||""===u}else s=!1;for(var a=0,c=i.length;0<=c;c--){var f=i[c];"."===f?spliceOne(i,c):".."===f?(spliceOne(i,c),a++):a&&(spliceOne(i,c),a--)}if(!o)for(;a--;a)i.unshift("..");!o||""===i[0]||i[0]&&isAbsolute(i[0])||i.unshift("");var h=i.join("/");return s&&"/"!==h.substr(-1)&&(h+="/"),h}module.exports=resolvePathname;


/***/ },
/* 422 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	if (true) {
	  module.exports = __webpack_require__(421);
	} else {
	  module.exports = require('./cjs/resolve-pathname.js');
	}


/***/ },
/* 423 */
/***/ function(module, exports) {

	/** @license React v0.19.1
	 * scheduler.production.min.js
	 *
	 * Copyright (c) Facebook, Inc. and its affiliates.
	 *
	 * This source code is licensed under the MIT license found in the
	 * LICENSE file in the root directory of this source tree.
	 */
	
	'use strict';var f,g,h,k,l;
	if("undefined"===typeof window||"function"!==typeof MessageChannel){var p=null,q=null,t=function(){if(null!==p)try{var a=exports.unstable_now();p(!0,a);p=null}catch(b){throw setTimeout(t,0),b;}},u=Date.now();exports.unstable_now=function(){return Date.now()-u};f=function(a){null!==p?setTimeout(f,0,a):(p=a,setTimeout(t,0))};g=function(a,b){q=setTimeout(a,b)};h=function(){clearTimeout(q)};k=function(){return!1};l=exports.unstable_forceFrameRate=function(){}}else{var w=window.performance,x=window.Date,
	y=window.setTimeout,z=window.clearTimeout;if("undefined"!==typeof console){var A=window.cancelAnimationFrame;"function"!==typeof window.requestAnimationFrame&&console.error("This browser doesn't support requestAnimationFrame. Make sure that you load a polyfill in older browsers. https://fb.me/react-polyfills");"function"!==typeof A&&console.error("This browser doesn't support cancelAnimationFrame. Make sure that you load a polyfill in older browsers. https://fb.me/react-polyfills")}if("object"===
	typeof w&&"function"===typeof w.now)exports.unstable_now=function(){return w.now()};else{var B=x.now();exports.unstable_now=function(){return x.now()-B}}var C=!1,D=null,E=-1,F=5,G=0;k=function(){return exports.unstable_now()>=G};l=function(){};exports.unstable_forceFrameRate=function(a){0>a||125<a?console.error("forceFrameRate takes a positive int between 0 and 125, forcing framerates higher than 125 fps is not unsupported"):F=0<a?Math.floor(1E3/a):5};var H=new MessageChannel,I=H.port2;H.port1.onmessage=
	function(){if(null!==D){var a=exports.unstable_now();G=a+F;try{D(!0,a)?I.postMessage(null):(C=!1,D=null)}catch(b){throw I.postMessage(null),b;}}else C=!1};f=function(a){D=a;C||(C=!0,I.postMessage(null))};g=function(a,b){E=y(function(){a(exports.unstable_now())},b)};h=function(){z(E);E=-1}}function J(a,b){var c=a.length;a.push(b);a:for(;;){var d=c-1>>>1,e=a[d];if(void 0!==e&&0<K(e,b))a[d]=b,a[c]=e,c=d;else break a}}function L(a){a=a[0];return void 0===a?null:a}
	function M(a){var b=a[0];if(void 0!==b){var c=a.pop();if(c!==b){a[0]=c;a:for(var d=0,e=a.length;d<e;){var m=2*(d+1)-1,n=a[m],v=m+1,r=a[v];if(void 0!==n&&0>K(n,c))void 0!==r&&0>K(r,n)?(a[d]=r,a[v]=c,d=v):(a[d]=n,a[m]=c,d=m);else if(void 0!==r&&0>K(r,c))a[d]=r,a[v]=c,d=v;else break a}}return b}return null}function K(a,b){var c=a.sortIndex-b.sortIndex;return 0!==c?c:a.id-b.id}var N=[],O=[],P=1,Q=null,R=3,S=!1,T=!1,U=!1;
	function V(a){for(var b=L(O);null!==b;){if(null===b.callback)M(O);else if(b.startTime<=a)M(O),b.sortIndex=b.expirationTime,J(N,b);else break;b=L(O)}}function W(a){U=!1;V(a);if(!T)if(null!==L(N))T=!0,f(X);else{var b=L(O);null!==b&&g(W,b.startTime-a)}}
	function X(a,b){T=!1;U&&(U=!1,h());S=!0;var c=R;try{V(b);for(Q=L(N);null!==Q&&(!(Q.expirationTime>b)||a&&!k());){var d=Q.callback;if(null!==d){Q.callback=null;R=Q.priorityLevel;var e=d(Q.expirationTime<=b);b=exports.unstable_now();"function"===typeof e?Q.callback=e:Q===L(N)&&M(N);V(b)}else M(N);Q=L(N)}if(null!==Q)var m=!0;else{var n=L(O);null!==n&&g(W,n.startTime-b);m=!1}return m}finally{Q=null,R=c,S=!1}}
	function Y(a){switch(a){case 1:return-1;case 2:return 250;case 5:return 1073741823;case 4:return 1E4;default:return 5E3}}var Z=l;exports.unstable_IdlePriority=5;exports.unstable_ImmediatePriority=1;exports.unstable_LowPriority=4;exports.unstable_NormalPriority=3;exports.unstable_Profiling=null;exports.unstable_UserBlockingPriority=2;exports.unstable_cancelCallback=function(a){a.callback=null};exports.unstable_continueExecution=function(){T||S||(T=!0,f(X))};
	exports.unstable_getCurrentPriorityLevel=function(){return R};exports.unstable_getFirstCallbackNode=function(){return L(N)};exports.unstable_next=function(a){switch(R){case 1:case 2:case 3:var b=3;break;default:b=R}var c=R;R=b;try{return a()}finally{R=c}};exports.unstable_pauseExecution=function(){};exports.unstable_requestPaint=Z;exports.unstable_runWithPriority=function(a,b){switch(a){case 1:case 2:case 3:case 4:case 5:break;default:a=3}var c=R;R=a;try{return b()}finally{R=c}};
	exports.unstable_scheduleCallback=function(a,b,c){var d=exports.unstable_now();if("object"===typeof c&&null!==c){var e=c.delay;e="number"===typeof e&&0<e?d+e:d;c="number"===typeof c.timeout?c.timeout:Y(a)}else c=Y(a),e=d;c=e+c;a={id:P++,callback:b,priorityLevel:a,startTime:e,expirationTime:c,sortIndex:-1};e>d?(a.sortIndex=e,J(O,a),null===L(N)&&a===L(O)&&(U?h():U=!0,g(W,e-d))):(a.sortIndex=c,J(N,a),T||S||(T=!0,f(X)));return a};
	exports.unstable_shouldYield=function(){var a=exports.unstable_now();V(a);var b=L(N);return b!==Q&&null!==Q&&null!==b&&null!==b.callback&&b.startTime<=a&&b.expirationTime<Q.expirationTime||k()};exports.unstable_wrapCallback=function(a){var b=R;return function(){var c=R;R=b;try{return a.apply(this,arguments)}finally{R=c}}};


/***/ },
/* 424 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	if (true) {
	  module.exports = __webpack_require__(423);
	} else {
	  module.exports = require('./cjs/scheduler.development.js');
	}


/***/ },
/* 425 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	Object.defineProperty(exports, "__esModule", { value: true });
	exports.Socket = exports.io = exports.Manager = exports.protocol = void 0;
	const url_1 = __webpack_require__(426);
	const manager_1 = __webpack_require__(169);
	const socket_1 = __webpack_require__(171);
	Object.defineProperty(exports, "Socket", { enumerable: true, get: function () { return socket_1.Socket; } });
	const debug = __webpack_require__(75)("socket.io-client");
	/**
	 * Module exports.
	 */
	module.exports = exports = lookup;
	/**
	 * Managers cache.
	 */
	const cache = (exports.managers = {});
	function lookup(uri, opts) {
	    if (typeof uri === "object") {
	        opts = uri;
	        uri = undefined;
	    }
	    opts = opts || {};
	    const parsed = url_1.url(uri);
	    const source = parsed.source;
	    const id = parsed.id;
	    const path = parsed.path;
	    const sameNamespace = cache[id] && path in cache[id]["nsps"];
	    const newConnection = opts.forceNew ||
	        opts["force new connection"] ||
	        false === opts.multiplex ||
	        sameNamespace;
	    let io;
	    if (newConnection) {
	        debug("ignoring socket cache for %s", source);
	        io = new manager_1.Manager(source, opts);
	    }
	    else {
	        if (!cache[id]) {
	            debug("new io instance for %s", source);
	            cache[id] = new manager_1.Manager(source, opts);
	        }
	        io = cache[id];
	    }
	    if (parsed.query && !opts.query) {
	        opts.query = parsed.query;
	    }
	    return io.socket(parsed.path, opts);
	}
	exports.io = lookup;
	/**
	 * Protocol version.
	 *
	 * @public
	 */
	var socket_io_parser_1 = __webpack_require__(102);
	Object.defineProperty(exports, "protocol", { enumerable: true, get: function () { return socket_io_parser_1.protocol; } });
	/**
	 * `connect`.
	 *
	 * @param {String} uri
	 * @public
	 */
	exports.connect = lookup;
	/**
	 * Expose constructors for standalone build.
	 *
	 * @public
	 */
	var manager_2 = __webpack_require__(169);
	Object.defineProperty(exports, "Manager", { enumerable: true, get: function () { return manager_2.Manager; } });


/***/ },
/* 426 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	Object.defineProperty(exports, "__esModule", { value: true });
	exports.url = void 0;
	const parseuri = __webpack_require__(163);
	const debug = __webpack_require__(75)("socket.io-client:url");
	/**
	 * URL parser.
	 *
	 * @param uri - url
	 * @param loc - An object meant to mimic window.location.
	 *        Defaults to window.location.
	 * @public
	 */
	function url(uri, loc) {
	    let obj = uri;
	    // default to window.location
	    loc = loc || (typeof location !== "undefined" && location);
	    if (null == uri)
	        uri = loc.protocol + "//" + loc.host;
	    // relative path support
	    if (typeof uri === "string") {
	        if ("/" === uri.charAt(0)) {
	            if ("/" === uri.charAt(1)) {
	                uri = loc.protocol + uri;
	            }
	            else {
	                uri = loc.host + uri;
	            }
	        }
	        if (!/^(https?|wss?):\/\//.test(uri)) {
	            debug("protocol-less url %s", uri);
	            if ("undefined" !== typeof loc) {
	                uri = loc.protocol + "//" + uri;
	            }
	            else {
	                uri = "https://" + uri;
	            }
	        }
	        // parse
	        debug("parse %s", uri);
	        obj = parseuri(uri);
	    }
	    // make sure we treat `localhost:80` and `localhost` equally
	    if (!obj.port) {
	        if (/^(http|ws)$/.test(obj.protocol)) {
	            obj.port = "80";
	        }
	        else if (/^(http|ws)s$/.test(obj.protocol)) {
	            obj.port = "443";
	        }
	    }
	    obj.path = obj.path || "/";
	    const ipv6 = obj.host.indexOf(":") !== -1;
	    const host = ipv6 ? "[" + obj.host + "]" : obj.host;
	    // define unique id
	    obj.id = obj.protocol + "://" + host + ":" + obj.port;
	    // define href
	    obj.href =
	        obj.protocol +
	            "://" +
	            host +
	            (loc && loc.port === obj.port ? "" : ":" + obj.port);
	    return obj;
	}
	exports.url = url;


/***/ },
/* 427 */
[486, 428],
/* 428 */
386,
/* 429 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	Object.defineProperty(exports, "__esModule", { value: true });
	exports.reconstructPacket = exports.deconstructPacket = void 0;
	const is_binary_1 = __webpack_require__(172);
	/**
	 * Replaces every Buffer | ArrayBuffer | Blob | File in packet with a numbered placeholder.
	 *
	 * @param {Object} packet - socket.io event packet
	 * @return {Object} with deconstructed packet and list of buffers
	 * @public
	 */
	function deconstructPacket(packet) {
	    const buffers = [];
	    const packetData = packet.data;
	    const pack = packet;
	    pack.data = _deconstructPacket(packetData, buffers);
	    pack.attachments = buffers.length; // number of binary 'attachments'
	    return { packet: pack, buffers: buffers };
	}
	exports.deconstructPacket = deconstructPacket;
	function _deconstructPacket(data, buffers) {
	    if (!data)
	        return data;
	    if (is_binary_1.isBinary(data)) {
	        const placeholder = { _placeholder: true, num: buffers.length };
	        buffers.push(data);
	        return placeholder;
	    }
	    else if (Array.isArray(data)) {
	        const newData = new Array(data.length);
	        for (let i = 0; i < data.length; i++) {
	            newData[i] = _deconstructPacket(data[i], buffers);
	        }
	        return newData;
	    }
	    else if (typeof data === "object" && !(data instanceof Date)) {
	        const newData = {};
	        for (const key in data) {
	            if (data.hasOwnProperty(key)) {
	                newData[key] = _deconstructPacket(data[key], buffers);
	            }
	        }
	        return newData;
	    }
	    return data;
	}
	/**
	 * Reconstructs a binary packet from its placeholder packet and buffers
	 *
	 * @param {Object} packet - event packet with placeholders
	 * @param {Array} buffers - binary buffers to put in placeholder positions
	 * @return {Object} reconstructed packet
	 * @public
	 */
	function reconstructPacket(packet, buffers) {
	    packet.data = _reconstructPacket(packet.data, buffers);
	    packet.attachments = undefined; // no longer useful
	    return packet;
	}
	exports.reconstructPacket = reconstructPacket;
	function _reconstructPacket(data, buffers) {
	    if (!data)
	        return data;
	    if (data && data._placeholder) {
	        return buffers[data.num]; // appropriate buffer (should be natural order anyway)
	    }
	    else if (Array.isArray(data)) {
	        for (let i = 0; i < data.length; i++) {
	            data[i] = _reconstructPacket(data[i], buffers);
	        }
	    }
	    else if (typeof data === "object") {
	        for (const key in data) {
	            if (data.hasOwnProperty(key)) {
	                data[key] = _reconstructPacket(data[key], buffers);
	            }
	        }
	    }
	    return data;
	}


/***/ },
/* 430 */
[485, 431],
/* 431 */
[486, 432],
/* 432 */
386,
/* 433 */
/***/ function(module, exports) {

	module.exports = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAA+8AAAPvCAYAAACyev8lAAAAGXRFWHRTb2Z0d2FyZQBBZG9iZSBJbWFnZVJlYWR5ccllPAAAJBxJREFUeNrs3f9x20bewOFNxv8fr4LgKghTgeAKTFdguILIFZiuQE4FkiugU4GoCkRXIKYC6a1AL/YIJbJO1g+KWCyWzzOzYzszZzpf+gJ8iAUYAgAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAsGM/GQEjMWnXtFvx5wfdP6+6BcDLrdp11a51u/7qfr3ufgQAxDv8jxjpdRfpU4EOMLhlF/Fn3c+vjAQAxDv7adauN92PE+MAyFoM+S/t+ho2V+cBAPFOwep2vRPsAEWE/ElwRR4AxDvFiJHetOv3YDs8QGlOupBfGgUAiHfGqboV7a6yA5QtxvsfYbOtHgAQ74xADPXDdn00CoC9E7fUfwiuxAOAeCdr8+BKOwCbeP8QfO0cAIh3slK36zi4px2A731u16fgwXYAIN4ZVLzCHrfHHxoFAD+wDpur8O6HBwDxzgDq4Go7AE/nKjwAiHcSmwcPpAPg+eI98O+De+EBQLzTq7hNfhE2V90BYBvxynvcRn9iFAAg3tm9aRfulVEAsAOfu4gHAMQ7Owz30+Ar4ADYrZOw2UYPAIh3XqgJmwfTAUAf4v3vr4MH2QGAeEe4AyDgAUC8I9wBQMADgHhHuAMg4AFAvMOGh9MBMKST4CF2AIh3EO4ACHgAEO+M1aQL96lRAJCB913EA4B4h1sW7ZoZAwAZ+S1s7oMHAPEOrcN2HRkDAJlZdwHvAXYAiHf2Xtwmfz6Ck7d45eVb9/O1tw3gRep2/as7BtSZ/1m/tuuttwwA2Hcx3K8zW5dh81V1cRu/h+cB9C9G/GGmx4Tr4LYuAGDPzTM7OXPfPcDwqu74cBHy+lDXh7kAwN6enOVyUnbc/XkAyEuTUcQvvB0AwD46zeRETLQDjCPiLzM4btTeCgBgn8wGPvm6cAIGMDpx2/rRwMePc28DALBPhtwCeRzctwgwZnUY9ip84y0AAPZB44QLgBeKH8IO9WT6C+MHAPbBEFfd4xWaqdEDFOc4+DAYAGDnGuEOQAEB7+o7AFC01FfdhTuAgHf1HQDgGWrhDkBBAX9q5ABAiRbBd/EC0K/TxMcaHxIDAEWZJD6ZOjRygL093qS8RevIyAGAkhwG2xgBSKMOaW/RAgAoRqrv4o0nURPjBth784QBPzNuAKAEVbBdHoC0Um6fPzZuAKAETaKTp3OjBuCWWfCd7wAAT5bqKfO1UQNwR6qnz3vqPAAwepfBQ+oAGEYd3LYFAPCoafCwIACGleKhqQtjBgDGLMVXxLnXEICHNMFXxgEAPOg4wQnT3JgBeMAkpLmFqzJqAGCsUmxVdLIEwGNSfJjsFi4AYLRsmQcgB02wEwwA4F4pHlZ3ZMwAPMEkeGgdADzZz0awdydKfTszZgCe4KpdqwKOewAg3tm5aYLXWBkzAJkcM6ZGDIB4Z4z6vgIRr6KsjRmAJ/o28uMeAIh3RslVdwAcNwBAvPNCBz3//ldGDEBmx43amAEQ7/C9b0YAwDO48g4A4h0AAADEOwAAACDeAQAAAPEOAAAA4h0AAAAQ7wAAACDeAQAAAPEOAAAAiHcAAAAQ7wAAAIB4BwAAAPEOAAAAiHcAAABAvAMAAIB4BwAAAMQ7AAAAIN4BAABAvAMAAADiHQAAAMQ7AAAAIN4BAAAA8Q4AAADiHQAAABDvAAAAIN4BAAAA8Q4AAACIdwAAABDvAAAAgHgHAAAAxDsAAACIdwAAAEC8AwAAgHgHAAAAxDsAAAAg3gEAAEC8AwAAAOIdAAAAxDsAAAAg3gEAAADxDgAAAOIdAAAAEO8AAACAeAcAAADxDgAAAOzEKyMA2Erd/Thp19Q4IFvvbv3/FRi3q3atup+vuwXiHYBQdWEe169dqIsAGJfGCKBoNxEfo/5b9/OlsSDeAco27eL8oPtxYiQAkLWqW/Wdf77sgv6s+/mVUSHeAcYrxvmsXW/EOgAUpe7WYffrGPJ/tutr+GfrPYh3gJEE+8w4AGAv3NwG9zFsttbHiP8i5BkTT5sH9kUM9UW7Ltt1LNwBYG9VYXNF/rxdF93P7b5DvAMMKB6I592BeSHYAYB7Qv4o/PPhfm0kiHeAtAfi4y7aP3a/BgB4SNOu0241xoF4B0gT7fGgawscAPBc9Z3zCRDvADsycZAFAHas6s4vzoPt9Ih3gBebi3YAoEfxKfU32+kr40C8AzxPHf65p932eAAg1bnHkXMPxDvA4+LBMj453qffAMAQbr5mzrfYIN4BfiAeJC8cLAGAgVVhczEhLlfhEe8AnYkDJACQoXhBwQPtEO8AYfOQGFvTAIBcVWFzO9/cKBDvwL66uaesMgoAIHMfu4i3SxDxDuyNm+9tPzIKAGBE6rB5Ps/UKBDvwD6Ee/zUujEKAMC5DIh3ID8397f7tBoAGHvAx12Eh0aBeAdKDHff3Q4AlOSoi3gQ70BR4e4BLwBAaRoBj3gHSjmgCXcAQMDDA14ZATCgmQMZALBHAR+9NwrEOzAm04LCfd0tAKAfk1DGA20FPOIdGF24j3Gr/Kpb37ofRTsApFeHzQNu4zrofi3ggaLEWLrucc2NmCeIB9rLnv8u7mpdhM1TYmfBPfkAkLN4YeAwwfnuLpevkQPEO9mKAXw+kmD3XfMAMN7zjaZdixEEfOPtAsQ7Ocr5IBrvv6+9RQBQlKo7R73I9Pwj7kZ0wQAQ72TlKNMD5nF3YAcAytZkGvHxz+T2PEC8k4VZhgfKuQMlAIj4TNaptwUQ7wytCnk9oG4RXGkHADYPjMvpHMW5NCDeGVQuD6iLn7DX3g4A4Ja4C+84o4B3rgKIdwYxDz7JBgDyF6M5h6307n8HxDvJTYOr7QDAeORyFf7IWwGId1Iaerv8IvjkGgB4viYMfy987W0A8S7eSWEebJMHAMZrOnDA2z4P4l0w0btq4INd4y0AAHYgxvOQOwmdW4N49x8YerUY6AAXPzCYGj8AsOOA7/sc+qFVeQtAvIt3+lALdwCgQEM9yG5h9CDexTt9GGJrmXAHAEoO+NroQbyLd3apEe4AQOGGuFBxauwg3sU7u3QxwMFsZuwAQEJDPcSuNnoQ7+KdXWiCp8oDAPsT8Km/WcfVdxDv4p2dSH3V/djIAYABTYOr74B4Z2RmiQ9c50YOAGSgCa6+A+Idf69++IC6ysgBgEwsgu99B8Q7I1AlPmAdGjkAkJF4/3vK2wfdOgjiXbyzlZTfd2qrGACQozqk3YU4MXIQ7+Kd50r1pFXb5QGAnKXcPt8YN4h38c5zNAkPUv5uAQA5S/n1cR7eC+JdYPEsqT5hvjBqAGAE5sGD6wDxTmYmwdYwAIC7Uj28zkN899DPRgBsYZbodVbtOjFuAGAkPiV6nXdGLd4BnuJNotf5w6gBgBE5adc6wetMg63zUDTb5tkV97oDANyvCbbO0wNX3oHnSrVl/pNRAwAj9LVdVwle58CoxTvA0AeKq+7ABwAwNvE85iTB68yMWrwDPKRO8BqpPrEGAOhDquf21EYt3gHuE78iblrQAQ8AoA/rsPnWHPGOeAcGkSLcUx3sAAD69CXBa7jvXbwD3KtO8BrudQcASpDinGZqzOId4D4pPt3905gBgAKsQ/+7CeMtjZVRi3eAu/o+OMSH1C2NGQAoRIrzGlffxTtA8ngX7gBASVLsKBTv4h3gO3WC1zgzZgCgIMsEr/GrMYt3gNuqBK/hKfMAQGlS3PeOeAdIGu9LYwYAxPuz2DYv3gG+86+ef/+1EQMABfqr59/flXfxDvCdvj/VFe8AQImWBZynId4B/uZhdQBAia4SvIar7+Id4G+VEQAAPJsH8iLegaLi3YENAGA7rryLd4BkrowAACiUJ84j3gEAADLnIgXiHQAAAMQ7AAAAIN4BAAAA8Q4AAADiHQAAABDvAAAAIN4BAAAA8Q4AAACIdwAAABDvAAAAgHgHAAAAxDsAAACIdwAAAEC8AwAAgHgHAAAAxDsAAAAg3gEAAEC8AwAAAOIdAAAAxDsAAAAg3gEAAADxDgAAAOIdAAAAEO8AAACAeAcAAADxDgAAAIh3AAAAEO8AAACAeAcAAADEOwAAAIh3AAAAQLwDAACAeAcAAADEOwAAACDeAQAAQLwDAAAA4h0AAAAQ7wAAACDeAQAAAPEOAAAA4h0AAAAQ7wAAAIB4BwAAAPEOAAAAiHcAAAAQ7wAAAIB4BwAAAMQ7AAAAiHcAAABAvAMAAADiHQAAAMQ7AAAAIN4BAABAvAMAAADiHQAAABDvAAAAIN4BAAAA8Q4AAADi3QgAAABAvAMAAADiHQAAAMQ7AAAAIN4BAAAA8Q4AAADiHQAAABDvAAAAIN4BAAAA8Q4AAACIdwAAABDvAAAAgHgHAAAAxDsAAACIdwAAAEC8AwAAgHgHAAAAxDsAAAAg3gEAAEC8AwAAAOIdAAAAxDsAAAAg3gEAAADxDgAAAOIdAAAAEO8AAACAeAcAAADxDgAAAIh3AAAAEO8AAACAeAcAAADEO2n8YgQAAADinZdZ9fz7V0YMAAAg3nmZ/xPvAAAA4p39Jt4BAADEOy+0SvAatTEDAACId7Z3Jd4BAADEO3lbJniNA2MGAAAQ77zMuuffv27XxJgBAADEO9tLcd/7zJgBAADEO9v7luA1fjdmAAAA8c72lgleYxp8bRwAAIB4Z2urRK/z0agBAADEO9uJXxe3TPA6TXD1HQAAQLyztbNEr+PqOwAAgHhnS18TvU4TNl8dBwAAgHjnmeJ97+tEr3Vk3AAAAOKd7aS6+h6fPD83bgAAAPHO831J+Frx3vfayAEAAMQ7z7MK6b42Llq0a2LsAAAA4p3n+SPha8VwPxXwAAAA4p3nife9XyV8vXj/+8LYAQAAxDtPF8P9j8SvWbfr2OgBAADEO0/3OaS9+h417ToPttADAACId54khvvJAK8bt9DHe+ArbwEAAIB453GfQvqr7zcBH6/Az7wFAAAA4p2HDXHv+424dT4+xO4o2EYPAAAg3nlQvPd9PeDrH7brImzuhwcAAEC8c4949f3DwH+GeOU9Pok+bqWvvSUAAADinf8Vv/d9mcGf4+ZhdjdX4m2nBwAAxDvc8j4M8/C6+1RhcyX+ovtxJuQBAABgo2nXdcYrXpWfdzFfe7uS6ft99V4CAKU67fk8am7E5XtlBNzjpF1vQr5f4Vb/IPTijoFVj68bf/+zsLm9YO2vCQAAAEOL29PjdvVr694Vv95uumd/J1x5BwDYjivvvJh73vmReJX5bcjn/vfcxF0J5/5DCQAAiHeGFregfzCGB30Mm4fpAQAAiHcGcyLgH9UIeAAAQLwztM9dxPNwwDfGAAAAiHeG9F7AP+oo+B56AABAvCPgsxbDvTEGAABAvCPg8/bOCAAAAPGOgM9b/O73qsB/Lw/kAwAA8c5IA/69MdyrtHiP4d54WwEAQLwzTiftet2uK6P4zlS4AwAA4p2cLNv1W7tWRvG3Up44L9wBAEC8U5B1F/CfjaIYwh0AAMQ7hfoQNtvo10Yh3AEAAPFOvpbBVXjhDgAAiHeyFx9g96GL+KVxCHcAAEC8k6/4ELu4jT5+pdzaOIQ7AAAg3snXSbv+I+KFOwAAIN4ZV8QvjUO4AwAA4p28Iz5up795sN2VkQh3AABAvJOneE98fLDdv9v1tot6IS/cAQAA8U6mvobNdvoY8vGq/Kdga71wBwAA/uuVEZCh5Z1wr9s1bdcv3Y9VtxDuAAAg3iHTmL8x6WL+tmn3zx/ybk/jX7gDAIB4h+Su7on65RP+dwd7GO/CHQAARsw97yDcAQAA8Q4IdwAAQLwDwh0AAMQ7INwBAADxDgh3AABAvINwBwAAxDsg3AEAAPEOCHcAABDvgHAHAADEOyDcAQAA8Q7CHQAAEO+AcAcAAMQ7INwBAADxDsIdAAAQ74BwBwAAxDsIdwAAQLwDwh0AABDvQObhvvJWAACAeAfyDvfX3g4AABDvQN7hfuUtAQAA8Q4IdwAAQLyDcBfuAAAg3gHhDgAAiHcQ7sIdAADEOyDchTsAAIh3QLgDAADiHYS7cAcAAPEOCHcAAEC8g3AX7gAAgHgH4S7cAQBAvAPCHQAAEO8g3IU7AACId0C4AwAA4h2Eu3AHAADEOwh34Q4AAOIdEO4AAEA/XhkB7Nzv7ZoIdwAAYFdceYfdE+4AAIB4B4Q7AACId0C4AwAA4h0Q7gAAgHgH4Q4AAIh3QLgDAADiHRDuAAAg3o0AhDsAACDeAeEOAACIdxDuAACAeAeEOwAAIN4B4Q4AAIh3EO4AAIB4B4Q7AAAg3kG4AwAA4h0Q7gAAgHgHhDsAACDeQbgDAADiHRDuAACAeAfhDgAAIN5BuAMAAOIdEO4AAIB4B+EOAACId0C4AwAA4h2EOwAAgHgH4Q4AAIh3QLgDAADiHYQ7AAAg3gHhDgAAiHcQ7gAAAOIdhDsAACDeYdTOhDsAACDeIW8r4Q4AAIh3yNvXdq2FOwAAIN4hb1+EOwAAIN4hb/Ow++3zwh0AABDvsGPvdxjawh0AABDv0INdBbdwBwAAxDskCPj1lv/7z+36TbgDAADiHfoP+Bjgn54R4csu+j8YHwAA0LdXRgD/FaN9HjZX0mftOmhX1a5puyZhc2U+rrOw+aq5lZEBAAAAubnuedVGDAAU6rTn86i5EZfPtnkAAAAQ7wAAAIB4BwAAAPEOAAAAiHcAAABAvAMAAIB4BwAAAMQ7AAAAiHcAAABAvAMAAADiHQAAAMQ7AAAAIN4BAAAA8Q4AAADiHQAAABDvAAAAIN4BAAAA8Q4AAACIdwAAABDvAAAAgHgHAAAA8Q4AAACIdwAAAEC8AwAAgHgHAAAAxDsAAAAg3gEAAEC8AwAAAOIdAAAAxDsAAAAg3gEAAADxDgAAAOIdAAAAEO8AAAAg3gEAAADxDgAAAIh3AAAAEO8AAACAeAcAAADEOwAAAIh3AAAAQLwDAACAeAcAAADEOwAAACDeAQAAQLwDAAAA4h0AAADEOwAAACDeAQAAAPEOAAAA4h0AAAAQ7wAAAIB4BwAAAPEOAAAAiHcAAAAQ7wAAAIB4BwAAAMQ7AAAAiHcAAABAvAMAAIB4BwAAAMQ7AAAAIN4BAABAvAMAAADiHQAAABDvAAAAIN4BAAAA8Q4UaGIEAECh6p5//7URi3eAVAeFqREDAIh3xDvgoAAAkFplBIh3oCQHRgAAiPetXBmzeAe4se7593fPOwBQohS3Bq6MWbwD3PirgAMbAEBqvxgB4h1IaZ3gNWpjBgAK0/f5zdKIxTtA6nh39R0AKE3f5zfudxfvAN9JcS+Vh9YBACWpE7zGN2MG4K7Ldl33uC6NGAAoyLznc6e4ZsYMwF2nCQ5Ats4DAKU4T3DuVBkzAHfNExyAjowZAChAleC8ya5FAO41S3AQujBmAKAATYLzplNjBuA+kwQHIVvnAYASpNgyPzdmAIY8ENk6DwCMWRXSXPCojRqAHzkK7t8CAHjIPFG8A8APpbjvPa7GqAGAker763Xd7w7Ao1Ld935u1ADACDWJzpUOjRqAxyyC+7gAAO5zkeg8qTJqAB5zmOigZDsYADAmTaJzJF+tC8CTVIkOTK6+AwBjkuqqu2/mAeDJToNPlgEAbqTamRjX1LgBeKom4QHKA1kAgJzFB/qmeMK8h/oCkPVB6rJ7PQCAHB0FFzUAyNhxwgPVwrgBgAzVCc+H4nJBA4BnmyY+WM2MHADISAzpVA+pi+vYyAHYVqoH19k+DwDkJuUuRA+qA+BFmsQHLd/9DgA4BwKALaTcLua7TQGAocUr4Kke3Ov2QQB2pkl88LruXhMAILV4C9954vOeC2MHYFdSX3133xcAMITU4e6iBQA71QxwILsU8ABAQqkfUHfdfVgAADs1xNV3AQ8AlBrucdVGD8Cu1QMd1AQ8AFBiuHvCPAC9Sfm97wIeACg13D3fB4BeVQMe4GLA+xoVAGAXhniqvK/GBSCp+YAHurgOvQUAwAtMBw73i+7DAwDo1SQM8/C62+vYQQ8A2ELcxXc58HmMnYQAJFMPfNC7+WoV94oBAE91lMH5y8LbAMA+HgBtowcAHjP0Nvnbz++xcxCAQeRwIHQVHgC4TwzleSbnKr7THYBBxWAe+r6xu09u9Yk2ANCE4Z/R4+nyAGR3cLzOaMUPE+YiHgD2Ut2u08zOTc69LQDk4jizg6SIBwDRnsv5iHMRALKSy/3v9x0044cL7okHgLLEKG5CXtvj7y7nHwBkeQDN+eB5s20tPp2+8nYBwGjF70nPcdff3dV4qwDIVW4PsHss5OfBk18BIHdVF8KLEZ1neEAdz/KTEQADBXy852xs93ct23XWrnW3lt5KABgk1OOq2/Vrd15Rjezf4aRd772ViHdgDJqw2c42dlftWt369Zm3FuBBy+6/m1dGkX0g1xlE8S+3/gxVKOO2NuGOeAcEPACj8bVdfwS7mHI8Nn8Mnv3Sl/j3/bUxIN4BAQ/AGCM+XoV0JX5YdXc8Fu39WXXh7u864h0Q8ACMNmreh+9vQ8JxuCQnwVZ5xDtQiDpsnhA7MQqAvRSvRr4W8MJduIN4B/I31qfQAyDgx3rcPTeGXn1u1wdjQLwDJarC5gr81CgABDy9One87VW82n5iDIh3oGTxynvcwjczCgABTy+aYLt8n39/3wbfpMCO/WwEQMYHvU9GAbCX4oe48TYqV4X788YIehE/cPpNuNMHV96B3NXBg+wA9pUr8P2Ix9RLY9i5eH/7p+Cr4BDvwJ6fZCy6kAdAwPMy8Xh6agw7/Tsa72//ahT0ybZ5YEwnbh+CT7MB9o0t9LtXGcHOLNv1H+GOeAf4XtyO5j4yAAGPeB/azdX218GFBcQ7wL3W3YHyvYMlgICHAZyEzdX2E6NAvAM8/cD52SgABDwkEJ+74AIC4h1gC/HA+SH49BtAwEN/1l2wu3UP8Q6wo4PqawdVAAEPOz6/cJEA8Q6wY8su4H9zkAUQ8CDaEe8AeVvdOujGe+LdlwYg4OExy3a9Fe2Id4D01mFzT/y/u5hfGgmAgIc75wqfu2CPu/d8XzvZ+skIgD1TtWvWrndO9ACKctXF18ooHjVv18c9/7sSI/1PsY54BxhXyL9pV20cAAJevBdr3YX6mWBHvAOM26QL+IOwuSIv5gEEvHgfd6wvu1hfdr8G8Q5QqGm3fu1+rLoFgIAX7/m4ifO/up+vgofVIt4B6EJ+0q27980fGA9AFruXBPxw8X61w7nfRPl9v/fSWwkAALC9pl3XGazL4OGkP4r3Pud+asQAAAACXsCLdwAAAAS8eBfvAAAAAl7Ai3cAAAAEvIAX7wAAAAh48S7eAQAABLyAF+8AAAAIePEu3gEAABDw4h0AAAABL+DFOwAAAAJevIt3AAAAAS/gxTsAAAACXsCLdwAAAAS8eBfvAAAAAl7Ai3cAAAAEfOkBL94BAAAQ8OIdAAAAAS/gxTsAAAACvuCAF+8AAAAIePEOAACAgBfw4h0AAAABX3DAi3cAAAAEvHgHAABAwAt48Q4AAICALzjgxTsAAAACXrwDAACAgBfvAAAACPiCA168AwAAIODFOwAAAAh48Q4AAICALzjgxTsAAAACPvOAF+8AAAAI+MwDXrwDAAAg4DMPePEOAACAgM884MU7AAAAAj7zgBfvAAAACPjMA168AwAAIOAzD3jxDgAAgIDPPODFOwAAAAI+84AX7wAAAAj4zANevAMAACDgMw948Q4AAICAzzzgxTsAAAACPvOAF+8AAAAI+MwDXrwDAAAg4DMPePEOAACAgM884MU7AAAAAj7zgBfvAAAACPjMA168AwAAIOAzD3jxDgAAgIDPPODFOwAAAAI+84AX7wAAAAj4zANevAMAACDgMw948Q4AAICAzzzgxTsAAAACPvOAF+8AAAAI+MwDXrwDAAAg4DMPePEOAACAgM884MU7AAAAAj7zgBfvAAAACPjMA168AwAAIOAzD3jxDgAAgIDPPODFOwAAAAI+84AX7wAAAAj4zANevAMAAEDmAS/eAQAAIPOAF+8AAACQecCLdwAAAMg84MU7AAAAZB7wC/EOAAAAeQd830u8AwAAIODFOwAAAAh48Q4AAICAF+8AAAAg4MU7AAAACHjxDgAAgIAX7wAAACDgxTsAAADsW8CLdwAAAAS8eAcAAAABL94BAACg4IAX7wAAAAh48Q4AAAACXrwDAABAwQEv3gEAABDw4h0AAAAEvHgHAACAggNevAMAACDgxTsAAAAIePEOAAAABQe8eAcAAIDMA168AwAAQOYBL94BAAAg84AX7wAAAJB5wIt3AAAAyDzgxTsAAABkHvDiHQAAADIPePEOAAAAmQe8eAcAAIDMA168AwAAQOYBL94BAAAg84BfGDcAAADkHfCHRg0AAAB5B3xlzAAAAJBvwLvfHQAAADIP+NpoAQAAIN+APzJSAAAAyDfgbZcHAACAjAM+fjXcxBgBAACgX9N2nT8z2i+Dr4UDAACA5Jqw2QL/ULRftGseXG2HpH4yAgAA4I4Y5vFqfH3rn63bteoWAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAD/zx4cEAAAAAAI+f+6IQEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAJhJAgAEAAcXGVZQBXIEAAAAASUVORK5CYII="

/***/ },
/* 434 */
/***/ function(module, exports, __webpack_require__) {

	module.exports = __webpack_require__.p + "static/media/Home_botton.19ed7c8b.png";

/***/ },
/* 435 */
/***/ function(module, exports, __webpack_require__) {

	module.exports = __webpack_require__.p + "static/media/explamation_ark.ff5d40a7.png";

/***/ },
/* 436 */
/***/ function(module, exports, __webpack_require__) {

	module.exports = __webpack_require__.p + "static/media/green_checkmark.56fcf640.png";

/***/ },
/* 437 */
/***/ function(module, exports) {

	module.exports = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAgAAAAIACAMAAADDpiTIAAAAA3NCSVQICAjb4U/gAAAACXBIWXMAAA8KAAAPCgFMBeqcAAAAGXRFWHRTb2Z0d2FyZQB3d3cuaW5rc2NhcGUub3Jnm+48GgAAAtNQTFRF////AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAACOdhNgAAAPB0Uk5TAAECAwQFBgcICQoLDA0ODxAREhMUFRYXGBkaGxwdHh8gISIjJCUmJygpKissLS4vMDEyMzQ1Njc4OTo7PD0+P0BBQkNERkdISktMTU5PUFFSU1RWV1hZWltcXV5fYGFiY2RlZmdoaWpsbW5vcHFyc3V2d3h5ent8fX5/gIGCg4SFhoqLjI2Oj5CRkpOUlZaYmZqbnJ2en6ChoqOlpqeoqaqrrK2ur7CxsrO1tre4uru8vb6/wMHCw8TFxsfIycrLzM3Oz9HS09TV1tfZ29zd3t/g4eLj5OXm5+jp6uvs7e7v8PHy8/T19vf4+fr7/P3+05A07wAADURJREFUeNrt3f1/1WUdx/Hdghs3G8iNoDJZ3qCYAgKKw3ClFJVCqBVIGskUREvCOxjMeRtRLLktU0NAWE6EMAMJSNkQUGxMzIGAyJRtjrnt+hP6rR4+1Ov7/Z7t+u46n8/r9Rfw+LyfnO2cnbOlpMTROd+5q3TxH9dt2rHv0MnPjR+1HKlaP71vCjkte8SPi5+vrDe+1rL+EkZy1RmFJds/N77XsqwbU3V8GWMe3PKZSY72nMdeHfxf/6byUyaJOn4hm3VgY5fWmSTrQC6zdVD5xdUmCStnuQ75wj9lm0nSvs167a7LHQdN0vYv9mvvE/57PjDJ3EgmbE89HzhmkruFjJh4WcV1JtmrZMaE+36NSf5OsWOC5W0wIuIF4YTKnNsgY38zmDETqPBtI6UzWTP6U78VYuY3zansGbWh++Xsb2rYM2q3NQja3yxn0Gh1e8aI6odMGqlL35G1/0dZbBql2xtl7W/uZdMoLRQ2v3mvK6OGL+0P0vZvGsOq4eu6Vtr+Zhqrhq/nq9LmPz2dVcPXr1La/ocLWDV8g98VNv+p+d1ZNXwDa0St37SxqA+jRij3rXZc++MdL6xYVDKnaMotfjT5mnye/EXrjK2JTf/Jy49PH8vncJO+9PWJfI3dOGdUOrcT0dLI6x/77dUZ3E1KJVG/w1r7g0yuJqc7o81/4M5e3ExSVzZHmX/vLWmcTFS9orwA8MaNvMFOWhGeALw7gXOJa3bo+T+bx6sr8hp1Ouz+FflcS165YT/4/+FEjiWxdSH3f/UsbiWxn4Sbv3U+T/1ElnMk1P5HCjmVzBaH2n9nfy4lsxEtYfZ/OZtLySxtV5j9n+GHflKbEWb/x3npV2p9Pw6x/xzuJLaVIfYv5Uxiu6iVT9arblXw/uW8409uecF/8ON1PlgvuLLA/Q/yxi/BDWgK/Fwlv2NZck8EPgDM4kiCOzPwr72t5UiSC/wgQHUORxJcl4+C3gAwmiNJ7sagB4AybiS6FwP2P8ozQNH1Dnon8K3cSHRBnwXcyolkt8O+f8tQTiS6CwIeAP7MiWQX8NtgWy/mRLIL+DDQGi4ku6EBXwGGcSLZzbTv/xIXEl7Aq0D8dlXhpdnfDHyACwlvhP0B4EEuJLxfWfdvy+NCwquwAvg7BxJexqdWALdxIeGNsf8K0B5cSHizrABe40DSW2IFMI8DSW+LFcBYDiS9Wtv+9fwOcOn1sD4AvMKBpDeKXwehu6lWANdzIOmVWgEM4kDSs/5q2AZ+IZT4qmwAqriP+KptAP7CfcR3zAZgAfcRX6MNwDTuI71065OASRxIejm8DKC7s60AruZA0htiBXAZB5LeSCsA/iyY+AqtAPpxIOmNtwLI5UDS+y4AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABwIAAQAAgABAACAAGAAEAAIAAQAAgABAACAAGAAEAAIAAQAAgABAACAAGAAEAAIAAQAAgABAACAAGAAEAAIAAQAAgABAACAAGAAEAAIAAQAESVed0T63cd2LZ6/hWpANDXgCWf/O+qtb/OAoCy//2lX/wj7bVTAKCpfv/40mV/lwEANZ136CtOu6U7AJTUbc9X3nZbdwDoaPXXHNcPAQBw3df/dWYvBADAcamVxmsBAHDcBNt9PRAAAMctNX4LAIDjrwCHjd8CAOC2gcb4LQAAbhtuPBcAgM68rwcCAOC2a43nAgDgtouN5wIA4LbcNs8FAMBxu43fAgDguGLjtwAAuP4moNVvAQBw3Z+M1wIA4Lq8Jq8FAMB5Pzc+CwCA+xb5LAAA7ktf47EAAMRQhscCAKBcAACUCwCAcgEAUC4AAMoFAEC5AAAoFwAA5QIAoFwAAJQLAIByAQBQLgAAygUAQLkAACgXAADlAgCgXAAAlAsAgHIBAFAuAADKBQBAuQAAKBcAAOUCAKBcAACUCwCAcgEAUC4AAMoFAEC5AAAoFwAA5QIAoFwAAJQLAIByAQBQLgAAygUAQLkAACgXAADlAgCgXAAAlAsAgHIBAFAuAADKBQBAuQAAKBcAAOUCAKBcAACUCwCAcgEAUC4AAMoFAEC5AAAoFwAA5QIAoFwAAJQLAIByAQBQLgAAygUAQLkAACgXAADlAgCgXAAAlAvoTADDbrr3sUUUqt83ORLQaQCGl31gyEXRBHQSgPzn2ljKCwGdA2ByPTN5IqBTABTz39+xgGyvAcxiIdet9hnAdS0M5LyH/QXQpYZ53Nc61FsAs1knjjb4CiDjKOPE0nBPAVzLNPH0iKcAnmKaeNrjKYCdTBNTPfwEcIhlYuoCPwE0sUxMFXgJIJVXgXQDSDnMMjGV7yeASpaJqSw/AaximXiq9PRp4ESmiaeFngLo1sg2sTTC1x8GPck2cVTh7U8Dz6xjHfe1Xe7vG0LuYh73PeHzW8KWsY/rNqb7DCCzgoXc9laO3+8KTnucjZzu39f7D4bccICZvNi/0z4aljGD14QdtTfK/p354dBzi55avXUnhavJzf58PDxJmutofwAo3x8AyvcHgPL9AaB8fwAo3x8AyvcHgO/d73Z/ACjfHwDK9weA8v0BoHx/ACjfHwDK9weA8v0BoHx/AHjaAzHtDwDl+wMgufff1979AaB8fwAo3x8Aybx/vxQAsD8A2B8A7A8AGT0Y9/4AUL4/AJTvDwDl+wNA+f4AUL4/AJTvDwDl+wNA+f4A8KKHOm1/ACjfHwDK9weA8v0BkDz773exPwCU7w8A5fsDQPn+AOjUHu70/QGgfH8AKN8fAMr3B4Dy/QGgfH8AeL9//xQAsD8A2B8Acprnz/4AUL4/AJTvDwDl+wNA+f4AUL4/AJTvDwA/9387rv0BEGfz/dsfAMr3B4Dy/QGgfH8AKN8fAMr3B4Dy/QGgfH8AKN8fADE0w+P9AeC+a5o93h8Azuv5oc/7A8B5JV7vDwDX9a/3en8AuG623/sDwHV/83t/ADguu9nv/QHguPND7X9WCgCEVuD5/gBw3PeC93+nM/cHgONGe74/AByX5/n+AHBc5qd+7w8A163xe38AuO5Wv/cHgOuyPvB6fwA47xde7w8A56Xv9nl/AMTwTPCYx/sDIIbGNfn2+i8A4u3K2i9ddrMvpwVAHA3Y/MW7tvwmIwUAqhpf9f+rtq0Z4s8/DABxNbJkd50xrUdemZnn0z8LAHGWfVa6b/8kACgPAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAgABgABAACAAEAAIAAQAAgABgABAACAAEAAIAAQAAgABgABAACAAEAAIAAQAAgABgABAACAAEAAIAAQAAgABgABAACAAEAAozsYDQHeFVgD9OJD0RloB5HMg6Q2xAriMA0nvbCuAqzmQ9HKsAK7nQNJLtwKYxIHE12gD8DPuI75jNgALuY/4qm0AVnMf8VXZAOzhPuJbZwPQmMqBpFdqfRqQx4GkN9UKYDwHkt4oK4C5HEh6Pa0ANnEg8dXaADR04UDSe9X6EPAtDiS9MiuAYg4kvbutALZyIOkVWAGc7smFhJdZbxUwnQtJbyNfA3R3nxVA22AuJDz7G4PNPC4kvLSTVgD/5kLS22B/CBjHhVS/EmA2ciHhfdMOwFzBiWSXesgOYD0nEp79XUGm7VJOJLuLAr4GPMeJhLfLDqD1ck4ku5kBDwHbeXew7Po0Bwi4nRvJrjwAwPHe3Eh0PwoAYJ7mRqLr+nEAgNYxHEl0jwY9BNTwG8NE17chSMA6jiS6J4MAmFkcSXIDmoIAnOaHQqJbEvgQUN2LKwluUHOggG1ZnElwKwIBmPJ0ziS381uCBSznTIJbFgzAPMKZ5NbnRAgBc7iT3O4IAcA8xo+GxZa6K4yAVRlcSmpXtIYR8BLPBsW2JAwA83pfLiW03KOhBNTym2OkNi0UANPyUBq3ktlfwwkwm/iDUjLrfSikgMM3cCyRXdUcUoCp4I+KieyXYQGYz4rP4FwC2xBagKnm64DAetWEF2CqJvN8QFyjmyMIMG9P4V0C0ioykaq+uw83k1VJNAGmuXwSv1dcVMtN1E6UXYsBOaWXm+g1bpo7mu8HhJT1ukmouorHbi/gWwIJTwb3m8Q78c8XVixaeF/RT2/xoYlXncsDU/TOed/Iqe75m3nVMmoX1hhJvX8bDwMRG7BHlADz5rlsGq2c12QJODqWTaPVda0sAQ3D2TRaaWWyBLzfn00j9rAsARtYNGpTG0QJ4A3NkbtknyQA2xk0ctkrJQkYxKAJfBmolwNgJnMm0JC9YgDw9y8SKmupFACVjJlY4/bLAHCUKRMsc46I7wSaWDLhBr0oAMB77NiOJhzkhQDl3wzOr0tyACsZsX3lPHA8qQFMYsJ2vzJ4T20Sfw/YnQHbX9cZSfu9wDLW65Aypm5Pyv0bz2a7juobxdXJB2ABu3VkBU+fTK79X+bD7B393cDk9Z8kz/57c1is40u/8v7Njcnx/5/9nT0QjFuwrdn37/8W8Pjv9kXCYTfPe/bNU74+/1/G9//xNLCwqHTxqnWbduw7dPJzL7Zv/s8bz97cg2VS/guFBce4ubthagAAAABJRU5ErkJggg=="

/***/ },
/* 438 */
/***/ function(module, exports, __webpack_require__) {

	module.exports = __webpack_require__.p + "static/media/settings_wheel.7211a9fa.png";

/***/ },
/* 439 */
/***/ function(module, exports) {

	"use strict";function valueOf(e){return e.valueOf?e.valueOf():Object.prototype.valueOf.call(e)}function valueEqual(u,r){if(u===r)return!0;if(null==u||null==r)return!1;if(Array.isArray(u))return Array.isArray(r)&&u.length===r.length&&u.every(function(e,u){return valueEqual(e,r[u])});if("object"!=typeof u&&"object"!=typeof r)return!1;var e=valueOf(u),t=valueOf(r);return e!==u||t!==r?valueEqual(e,t):Object.keys(Object.assign({},u,r)).every(function(e){return valueEqual(u[e],r[e])})}module.exports=valueEqual;


/***/ },
/* 440 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	if (true) {
	  module.exports = __webpack_require__(439);
	} else {
	  module.exports = require('./cjs/value-equal.js');
	}


/***/ },
/* 441 */
/***/ function(module, exports) {

	(function(self) {
	  'use strict';
	
	  if (self.fetch) {
	    return
	  }
	
	  var support = {
	    searchParams: 'URLSearchParams' in self,
	    iterable: 'Symbol' in self && 'iterator' in Symbol,
	    blob: 'FileReader' in self && 'Blob' in self && (function() {
	      try {
	        new Blob()
	        return true
	      } catch(e) {
	        return false
	      }
	    })(),
	    formData: 'FormData' in self,
	    arrayBuffer: 'ArrayBuffer' in self
	  }
	
	  if (support.arrayBuffer) {
	    var viewClasses = [
	      '[object Int8Array]',
	      '[object Uint8Array]',
	      '[object Uint8ClampedArray]',
	      '[object Int16Array]',
	      '[object Uint16Array]',
	      '[object Int32Array]',
	      '[object Uint32Array]',
	      '[object Float32Array]',
	      '[object Float64Array]'
	    ]
	
	    var isDataView = function(obj) {
	      return obj && DataView.prototype.isPrototypeOf(obj)
	    }
	
	    var isArrayBufferView = ArrayBuffer.isView || function(obj) {
	      return obj && viewClasses.indexOf(Object.prototype.toString.call(obj)) > -1
	    }
	  }
	
	  function normalizeName(name) {
	    if (typeof name !== 'string') {
	      name = String(name)
	    }
	    if (/[^a-z0-9\-#$%&'*+.\^_`|~]/i.test(name)) {
	      throw new TypeError('Invalid character in header field name')
	    }
	    return name.toLowerCase()
	  }
	
	  function normalizeValue(value) {
	    if (typeof value !== 'string') {
	      value = String(value)
	    }
	    return value
	  }
	
	  // Build a destructive iterator for the value list
	  function iteratorFor(items) {
	    var iterator = {
	      next: function() {
	        var value = items.shift()
	        return {done: value === undefined, value: value}
	      }
	    }
	
	    if (support.iterable) {
	      iterator[Symbol.iterator] = function() {
	        return iterator
	      }
	    }
	
	    return iterator
	  }
	
	  function Headers(headers) {
	    this.map = {}
	
	    if (headers instanceof Headers) {
	      headers.forEach(function(value, name) {
	        this.append(name, value)
	      }, this)
	
	    } else if (headers) {
	      Object.getOwnPropertyNames(headers).forEach(function(name) {
	        this.append(name, headers[name])
	      }, this)
	    }
	  }
	
	  Headers.prototype.append = function(name, value) {
	    name = normalizeName(name)
	    value = normalizeValue(value)
	    var oldValue = this.map[name]
	    this.map[name] = oldValue ? oldValue+','+value : value
	  }
	
	  Headers.prototype['delete'] = function(name) {
	    delete this.map[normalizeName(name)]
	  }
	
	  Headers.prototype.get = function(name) {
	    name = normalizeName(name)
	    return this.has(name) ? this.map[name] : null
	  }
	
	  Headers.prototype.has = function(name) {
	    return this.map.hasOwnProperty(normalizeName(name))
	  }
	
	  Headers.prototype.set = function(name, value) {
	    this.map[normalizeName(name)] = normalizeValue(value)
	  }
	
	  Headers.prototype.forEach = function(callback, thisArg) {
	    for (var name in this.map) {
	      if (this.map.hasOwnProperty(name)) {
	        callback.call(thisArg, this.map[name], name, this)
	      }
	    }
	  }
	
	  Headers.prototype.keys = function() {
	    var items = []
	    this.forEach(function(value, name) { items.push(name) })
	    return iteratorFor(items)
	  }
	
	  Headers.prototype.values = function() {
	    var items = []
	    this.forEach(function(value) { items.push(value) })
	    return iteratorFor(items)
	  }
	
	  Headers.prototype.entries = function() {
	    var items = []
	    this.forEach(function(value, name) { items.push([name, value]) })
	    return iteratorFor(items)
	  }
	
	  if (support.iterable) {
	    Headers.prototype[Symbol.iterator] = Headers.prototype.entries
	  }
	
	  function consumed(body) {
	    if (body.bodyUsed) {
	      return Promise.reject(new TypeError('Already read'))
	    }
	    body.bodyUsed = true
	  }
	
	  function fileReaderReady(reader) {
	    return new Promise(function(resolve, reject) {
	      reader.onload = function() {
	        resolve(reader.result)
	      }
	      reader.onerror = function() {
	        reject(reader.error)
	      }
	    })
	  }
	
	  function readBlobAsArrayBuffer(blob) {
	    var reader = new FileReader()
	    var promise = fileReaderReady(reader)
	    reader.readAsArrayBuffer(blob)
	    return promise
	  }
	
	  function readBlobAsText(blob) {
	    var reader = new FileReader()
	    var promise = fileReaderReady(reader)
	    reader.readAsText(blob)
	    return promise
	  }
	
	  function readArrayBufferAsText(buf) {
	    var view = new Uint8Array(buf)
	    var chars = new Array(view.length)
	
	    for (var i = 0; i < view.length; i++) {
	      chars[i] = String.fromCharCode(view[i])
	    }
	    return chars.join('')
	  }
	
	  function bufferClone(buf) {
	    if (buf.slice) {
	      return buf.slice(0)
	    } else {
	      var view = new Uint8Array(buf.byteLength)
	      view.set(new Uint8Array(buf))
	      return view.buffer
	    }
	  }
	
	  function Body() {
	    this.bodyUsed = false
	
	    this._initBody = function(body) {
	      this._bodyInit = body
	      if (!body) {
	        this._bodyText = ''
	      } else if (typeof body === 'string') {
	        this._bodyText = body
	      } else if (support.blob && Blob.prototype.isPrototypeOf(body)) {
	        this._bodyBlob = body
	      } else if (support.formData && FormData.prototype.isPrototypeOf(body)) {
	        this._bodyFormData = body
	      } else if (support.searchParams && URLSearchParams.prototype.isPrototypeOf(body)) {
	        this._bodyText = body.toString()
	      } else if (support.arrayBuffer && support.blob && isDataView(body)) {
	        this._bodyArrayBuffer = bufferClone(body.buffer)
	        // IE 10-11 can't handle a DataView body.
	        this._bodyInit = new Blob([this._bodyArrayBuffer])
	      } else if (support.arrayBuffer && (ArrayBuffer.prototype.isPrototypeOf(body) || isArrayBufferView(body))) {
	        this._bodyArrayBuffer = bufferClone(body)
	      } else {
	        throw new Error('unsupported BodyInit type')
	      }
	
	      if (!this.headers.get('content-type')) {
	        if (typeof body === 'string') {
	          this.headers.set('content-type', 'text/plain;charset=UTF-8')
	        } else if (this._bodyBlob && this._bodyBlob.type) {
	          this.headers.set('content-type', this._bodyBlob.type)
	        } else if (support.searchParams && URLSearchParams.prototype.isPrototypeOf(body)) {
	          this.headers.set('content-type', 'application/x-www-form-urlencoded;charset=UTF-8')
	        }
	      }
	    }
	
	    if (support.blob) {
	      this.blob = function() {
	        var rejected = consumed(this)
	        if (rejected) {
	          return rejected
	        }
	
	        if (this._bodyBlob) {
	          return Promise.resolve(this._bodyBlob)
	        } else if (this._bodyArrayBuffer) {
	          return Promise.resolve(new Blob([this._bodyArrayBuffer]))
	        } else if (this._bodyFormData) {
	          throw new Error('could not read FormData body as blob')
	        } else {
	          return Promise.resolve(new Blob([this._bodyText]))
	        }
	      }
	
	      this.arrayBuffer = function() {
	        if (this._bodyArrayBuffer) {
	          return consumed(this) || Promise.resolve(this._bodyArrayBuffer)
	        } else {
	          return this.blob().then(readBlobAsArrayBuffer)
	        }
	      }
	    }
	
	    this.text = function() {
	      var rejected = consumed(this)
	      if (rejected) {
	        return rejected
	      }
	
	      if (this._bodyBlob) {
	        return readBlobAsText(this._bodyBlob)
	      } else if (this._bodyArrayBuffer) {
	        return Promise.resolve(readArrayBufferAsText(this._bodyArrayBuffer))
	      } else if (this._bodyFormData) {
	        throw new Error('could not read FormData body as text')
	      } else {
	        return Promise.resolve(this._bodyText)
	      }
	    }
	
	    if (support.formData) {
	      this.formData = function() {
	        return this.text().then(decode)
	      }
	    }
	
	    this.json = function() {
	      return this.text().then(JSON.parse)
	    }
	
	    return this
	  }
	
	  // HTTP methods whose capitalization should be normalized
	  var methods = ['DELETE', 'GET', 'HEAD', 'OPTIONS', 'POST', 'PUT']
	
	  function normalizeMethod(method) {
	    var upcased = method.toUpperCase()
	    return (methods.indexOf(upcased) > -1) ? upcased : method
	  }
	
	  function Request(input, options) {
	    options = options || {}
	    var body = options.body
	
	    if (input instanceof Request) {
	      if (input.bodyUsed) {
	        throw new TypeError('Already read')
	      }
	      this.url = input.url
	      this.credentials = input.credentials
	      if (!options.headers) {
	        this.headers = new Headers(input.headers)
	      }
	      this.method = input.method
	      this.mode = input.mode
	      if (!body && input._bodyInit != null) {
	        body = input._bodyInit
	        input.bodyUsed = true
	      }
	    } else {
	      this.url = String(input)
	    }
	
	    this.credentials = options.credentials || this.credentials || 'omit'
	    if (options.headers || !this.headers) {
	      this.headers = new Headers(options.headers)
	    }
	    this.method = normalizeMethod(options.method || this.method || 'GET')
	    this.mode = options.mode || this.mode || null
	    this.referrer = null
	
	    if ((this.method === 'GET' || this.method === 'HEAD') && body) {
	      throw new TypeError('Body not allowed for GET or HEAD requests')
	    }
	    this._initBody(body)
	  }
	
	  Request.prototype.clone = function() {
	    return new Request(this, { body: this._bodyInit })
	  }
	
	  function decode(body) {
	    var form = new FormData()
	    body.trim().split('&').forEach(function(bytes) {
	      if (bytes) {
	        var split = bytes.split('=')
	        var name = split.shift().replace(/\+/g, ' ')
	        var value = split.join('=').replace(/\+/g, ' ')
	        form.append(decodeURIComponent(name), decodeURIComponent(value))
	      }
	    })
	    return form
	  }
	
	  function parseHeaders(rawHeaders) {
	    var headers = new Headers()
	    rawHeaders.split(/\r?\n/).forEach(function(line) {
	      var parts = line.split(':')
	      var key = parts.shift().trim()
	      if (key) {
	        var value = parts.join(':').trim()
	        headers.append(key, value)
	      }
	    })
	    return headers
	  }
	
	  Body.call(Request.prototype)
	
	  function Response(bodyInit, options) {
	    if (!options) {
	      options = {}
	    }
	
	    this.type = 'default'
	    this.status = 'status' in options ? options.status : 200
	    this.ok = this.status >= 200 && this.status < 300
	    this.statusText = 'statusText' in options ? options.statusText : 'OK'
	    this.headers = new Headers(options.headers)
	    this.url = options.url || ''
	    this._initBody(bodyInit)
	  }
	
	  Body.call(Response.prototype)
	
	  Response.prototype.clone = function() {
	    return new Response(this._bodyInit, {
	      status: this.status,
	      statusText: this.statusText,
	      headers: new Headers(this.headers),
	      url: this.url
	    })
	  }
	
	  Response.error = function() {
	    var response = new Response(null, {status: 0, statusText: ''})
	    response.type = 'error'
	    return response
	  }
	
	  var redirectStatuses = [301, 302, 303, 307, 308]
	
	  Response.redirect = function(url, status) {
	    if (redirectStatuses.indexOf(status) === -1) {
	      throw new RangeError('Invalid status code')
	    }
	
	    return new Response(null, {status: status, headers: {location: url}})
	  }
	
	  self.Headers = Headers
	  self.Request = Request
	  self.Response = Response
	
	  self.fetch = function(input, init) {
	    return new Promise(function(resolve, reject) {
	      var request = new Request(input, init)
	      var xhr = new XMLHttpRequest()
	
	      xhr.onload = function() {
	        var options = {
	          status: xhr.status,
	          statusText: xhr.statusText,
	          headers: parseHeaders(xhr.getAllResponseHeaders() || '')
	        }
	        options.url = 'responseURL' in xhr ? xhr.responseURL : options.headers.get('X-Request-URL')
	        var body = 'response' in xhr ? xhr.response : xhr.responseText
	        resolve(new Response(body, options))
	      }
	
	      xhr.onerror = function() {
	        reject(new TypeError('Network request failed'))
	      }
	
	      xhr.ontimeout = function() {
	        reject(new TypeError('Network request failed'))
	      }
	
	      xhr.open(request.method, request.url, true)
	
	      if (request.credentials === 'include') {
	        xhr.withCredentials = true
	      }
	
	      if ('responseType' in xhr && support.blob) {
	        xhr.responseType = 'blob'
	      }
	
	      request.headers.forEach(function(value, name) {
	        xhr.setRequestHeader(name, value)
	      })
	
	      xhr.send(typeof request._bodyInit === 'undefined' ? null : request._bodyInit)
	    })
	  }
	  self.fetch.polyfill = true
	})(typeof self !== 'undefined' ? self : this);


/***/ },
/* 442 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	exports.__esModule = true;
	var tslib_1 = __webpack_require__(5);
	var util = __webpack_require__(1);
	var vec2 = __webpack_require__(11);
	var Draggable_1 = __webpack_require__(474);
	var Eventful_1 = __webpack_require__(37);
	var eventTool = __webpack_require__(42);
	var GestureMgr_1 = __webpack_require__(456);
	var SILENT = 'silent';
	function makeEventPacket(eveType, targetInfo, event) {
	    return {
	        type: eveType,
	        event: event,
	        target: targetInfo.target,
	        topTarget: targetInfo.topTarget,
	        cancelBubble: false,
	        offsetX: event.zrX,
	        offsetY: event.zrY,
	        gestureEvent: event.gestureEvent,
	        pinchX: event.pinchX,
	        pinchY: event.pinchY,
	        pinchScale: event.pinchScale,
	        wheelDelta: event.zrDelta,
	        zrByTouch: event.zrByTouch,
	        which: event.which,
	        stop: stopEvent
	    };
	}
	function stopEvent() {
	    eventTool.stop(this.event);
	}
	var EmptyProxy = (function (_super) {
	    tslib_1.__extends(EmptyProxy, _super);
	    function EmptyProxy() {
	        var _this = _super !== null && _super.apply(this, arguments) || this;
	        _this.handler = null;
	        return _this;
	    }
	    EmptyProxy.prototype.dispose = function () { };
	    EmptyProxy.prototype.setCursor = function () { };
	    return EmptyProxy;
	}(Eventful_1["default"]));
	var HoveredResult = (function () {
	    function HoveredResult(x, y) {
	        this.x = x;
	        this.y = y;
	    }
	    return HoveredResult;
	}());
	var handlerNames = [
	    'click', 'dblclick', 'mousewheel', 'mouseout',
	    'mouseup', 'mousedown', 'mousemove', 'contextmenu'
	];
	var Handler = (function (_super) {
	    tslib_1.__extends(Handler, _super);
	    function Handler(storage, painter, proxy, painterRoot) {
	        var _this = _super.call(this) || this;
	        _this._hovered = new HoveredResult(0, 0);
	        _this.storage = storage;
	        _this.painter = painter;
	        _this.painterRoot = painterRoot;
	        proxy = proxy || new EmptyProxy();
	        _this.proxy = null;
	        _this.setHandlerProxy(proxy);
	        _this._draggingMgr = new Draggable_1["default"](_this);
	        return _this;
	    }
	    Handler.prototype.setHandlerProxy = function (proxy) {
	        if (this.proxy) {
	            this.proxy.dispose();
	        }
	        if (proxy) {
	            util.each(handlerNames, function (name) {
	                proxy.on && proxy.on(name, this[name], this);
	            }, this);
	            proxy.handler = this;
	        }
	        this.proxy = proxy;
	    };
	    Handler.prototype.mousemove = function (event) {
	        var x = event.zrX;
	        var y = event.zrY;
	        var isOutside = isOutsideBoundary(this, x, y);
	        var lastHovered = this._hovered;
	        var lastHoveredTarget = lastHovered.target;
	        if (lastHoveredTarget && !lastHoveredTarget.__zr) {
	            lastHovered = this.findHover(lastHovered.x, lastHovered.y);
	            lastHoveredTarget = lastHovered.target;
	        }
	        var hovered = this._hovered = isOutside ? new HoveredResult(x, y) : this.findHover(x, y);
	        var hoveredTarget = hovered.target;
	        var proxy = this.proxy;
	        proxy.setCursor && proxy.setCursor(hoveredTarget ? hoveredTarget.cursor : 'default');
	        if (lastHoveredTarget && hoveredTarget !== lastHoveredTarget) {
	            this.dispatchToElement(lastHovered, 'mouseout', event);
	        }
	        this.dispatchToElement(hovered, 'mousemove', event);
	        if (hoveredTarget && hoveredTarget !== lastHoveredTarget) {
	            this.dispatchToElement(hovered, 'mouseover', event);
	        }
	    };
	    Handler.prototype.mouseout = function (event) {
	        var eventControl = event.zrEventControl;
	        var zrIsToLocalDOM = event.zrIsToLocalDOM;
	        if (eventControl !== 'only_globalout') {
	            this.dispatchToElement(this._hovered, 'mouseout', event);
	        }
	        if (eventControl !== 'no_globalout') {
	            !zrIsToLocalDOM && this.trigger('globalout', { type: 'globalout', event: event });
	        }
	    };
	    Handler.prototype.resize = function () {
	        this._hovered = new HoveredResult(0, 0);
	    };
	    Handler.prototype.dispatch = function (eventName, eventArgs) {
	        var handler = this[eventName];
	        handler && handler.call(this, eventArgs);
	    };
	    Handler.prototype.dispose = function () {
	        this.proxy.dispose();
	        this.storage = null;
	        this.proxy = null;
	        this.painter = null;
	    };
	    Handler.prototype.setCursorStyle = function (cursorStyle) {
	        var proxy = this.proxy;
	        proxy.setCursor && proxy.setCursor(cursorStyle);
	    };
	    Handler.prototype.dispatchToElement = function (targetInfo, eventName, event) {
	        targetInfo = targetInfo || {};
	        var el = targetInfo.target;
	        if (el && el.silent) {
	            return;
	        }
	        var eventKey = ('on' + eventName);
	        var eventPacket = makeEventPacket(eventName, targetInfo, event);
	        while (el) {
	            el[eventKey]
	                && (eventPacket.cancelBubble = !!el[eventKey].call(el, eventPacket));
	            el.trigger(eventName, eventPacket);
	            el = el.__hostTarget ? el.__hostTarget : el.parent;
	            if (eventPacket.cancelBubble) {
	                break;
	            }
	        }
	        if (!eventPacket.cancelBubble) {
	            this.trigger(eventName, eventPacket);
	            if (this.painter && this.painter.eachOtherLayer) {
	                this.painter.eachOtherLayer(function (layer) {
	                    if (typeof (layer[eventKey]) === 'function') {
	                        layer[eventKey].call(layer, eventPacket);
	                    }
	                    if (layer.trigger) {
	                        layer.trigger(eventName, eventPacket);
	                    }
	                });
	            }
	        }
	    };
	    Handler.prototype.findHover = function (x, y, exclude) {
	        var list = this.storage.getDisplayList();
	        var out = new HoveredResult(x, y);
	        for (var i = list.length - 1; i >= 0; i--) {
	            var hoverCheckResult = void 0;
	            if (list[i] !== exclude
	                && !list[i].ignore
	                && (hoverCheckResult = isHover(list[i], x, y))) {
	                !out.topTarget && (out.topTarget = list[i]);
	                if (hoverCheckResult !== SILENT) {
	                    out.target = list[i];
	                    break;
	                }
	            }
	        }
	        return out;
	    };
	    Handler.prototype.processGesture = function (event, stage) {
	        if (!this._gestureMgr) {
	            this._gestureMgr = new GestureMgr_1.GestureMgr();
	        }
	        var gestureMgr = this._gestureMgr;
	        stage === 'start' && gestureMgr.clear();
	        var gestureInfo = gestureMgr.recognize(event, this.findHover(event.zrX, event.zrY, null).target, this.proxy.dom);
	        stage === 'end' && gestureMgr.clear();
	        if (gestureInfo) {
	            var type = gestureInfo.type;
	            event.gestureEvent = type;
	            var res = new HoveredResult();
	            res.target = gestureInfo.target;
	            this.dispatchToElement(res, type, gestureInfo.event);
	        }
	    };
	    return Handler;
	}(Eventful_1["default"]));
	util.each(['click', 'mousedown', 'mouseup', 'mousewheel', 'dblclick', 'contextmenu'], function (name) {
	    Handler.prototype[name] = function (event) {
	        var x = event.zrX;
	        var y = event.zrY;
	        var isOutside = isOutsideBoundary(this, x, y);
	        var hovered;
	        var hoveredTarget;
	        if (name !== 'mouseup' || !isOutside) {
	            hovered = this.findHover(x, y);
	            hoveredTarget = hovered.target;
	        }
	        if (name === 'mousedown') {
	            this._downEl = hoveredTarget;
	            this._downPoint = [event.zrX, event.zrY];
	            this._upEl = hoveredTarget;
	        }
	        else if (name === 'mouseup') {
	            this._upEl = hoveredTarget;
	        }
	        else if (name === 'click') {
	            if (this._downEl !== this._upEl
	                || !this._downPoint
	                || vec2.dist(this._downPoint, [event.zrX, event.zrY]) > 4) {
	                return;
	            }
	            this._downPoint = null;
	        }
	        this.dispatchToElement(hovered, name, event);
	    };
	});
	function isHover(displayable, x, y) {
	    if (displayable[displayable.rectHover ? 'rectContain' : 'contain'](x, y)) {
	        var el = displayable;
	        var isSilent = void 0;
	        var ignoreClip = false;
	        while (el) {
	            if (el.ignoreClip) {
	                ignoreClip = true;
	            }
	            if (!ignoreClip) {
	                var clipPath = el.getClipPath();
	                if (clipPath && !clipPath.contain(x, y)) {
	                    return false;
	                }
	                if (el.silent) {
	                    isSilent = true;
	                }
	            }
	            var hostEl = el.__hostTarget;
	            el = hostEl ? hostEl : el.parent;
	        }
	        return isSilent ? SILENT : true;
	    }
	    return false;
	}
	function isOutsideBoundary(handlerInstance, x, y) {
	    var painter = handlerInstance.painter;
	    return x < 0 || x > painter.getWidth() || y < 0 || y > painter.getHeight();
	}
	exports["default"] = Handler;


/***/ },
/* 443 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	exports.__esModule = true;
	var util = __webpack_require__(1);
	var env_1 = __webpack_require__(13);
	var Element_1 = __webpack_require__(36);
	var timsort_1 = __webpack_require__(182);
	var invalidZErrorLogged = false;
	function logInvalidZError() {
	    if (invalidZErrorLogged) {
	        return;
	    }
	    invalidZErrorLogged = true;
	    console.warn('z / z2 / zlevel of displayable is invalid, which may cause unexpected errors');
	}
	function shapeCompareFunc(a, b) {
	    if (a.zlevel === b.zlevel) {
	        if (a.z === b.z) {
	            return a.z2 - b.z2;
	        }
	        return a.z - b.z;
	    }
	    return a.zlevel - b.zlevel;
	}
	var Storage = (function () {
	    function Storage() {
	        this._roots = [];
	        this._displayList = [];
	        this._displayListLen = 0;
	        this.displayableSortFunc = shapeCompareFunc;
	    }
	    Storage.prototype.traverse = function (cb, context) {
	        for (var i = 0; i < this._roots.length; i++) {
	            this._roots[i].traverse(cb, context);
	        }
	    };
	    Storage.prototype.getDisplayList = function (update, includeIgnore) {
	        includeIgnore = includeIgnore || false;
	        var displayList = this._displayList;
	        if (update || !displayList.length) {
	            this.updateDisplayList(includeIgnore);
	        }
	        return displayList;
	    };
	    Storage.prototype.updateDisplayList = function (includeIgnore) {
	        this._displayListLen = 0;
	        var roots = this._roots;
	        var displayList = this._displayList;
	        for (var i = 0, len = roots.length; i < len; i++) {
	            this._updateAndAddDisplayable(roots[i], null, includeIgnore);
	        }
	        displayList.length = this._displayListLen;
	        env_1["default"].canvasSupported && timsort_1["default"](displayList, shapeCompareFunc);
	    };
	    Storage.prototype._updateAndAddDisplayable = function (el, clipPaths, includeIgnore) {
	        if (el.ignore && !includeIgnore) {
	            return;
	        }
	        el.beforeUpdate();
	        el.update();
	        el.afterUpdate();
	        var userSetClipPath = el.getClipPath();
	        if (el.ignoreClip) {
	            clipPaths = null;
	        }
	        else if (userSetClipPath) {
	            if (clipPaths) {
	                clipPaths = clipPaths.slice();
	            }
	            else {
	                clipPaths = [];
	            }
	            var currentClipPath = userSetClipPath;
	            var parentClipPath = el;
	            while (currentClipPath) {
	                currentClipPath.parent = parentClipPath;
	                currentClipPath.updateTransform();
	                clipPaths.push(currentClipPath);
	                parentClipPath = currentClipPath;
	                currentClipPath = currentClipPath.getClipPath();
	            }
	        }
	        if (el.childrenRef) {
	            var children = el.childrenRef();
	            for (var i = 0; i < children.length; i++) {
	                var child = children[i];
	                if (el.__dirty) {
	                    child.__dirty |= Element_1["default"].REDARAW_BIT;
	                }
	                this._updateAndAddDisplayable(child, clipPaths, includeIgnore);
	            }
	            el.__dirty = 0;
	        }
	        else {
	            var disp = el;
	            if (clipPaths && clipPaths.length) {
	                disp.__clipPaths = clipPaths;
	            }
	            else if (disp.__clipPaths && disp.__clipPaths.length > 0) {
	                disp.__clipPaths = [];
	            }
	            if (isNaN(disp.z)) {
	                logInvalidZError();
	                disp.z = 0;
	            }
	            if (isNaN(disp.z2)) {
	                logInvalidZError();
	                disp.z2 = 0;
	            }
	            if (isNaN(disp.zlevel)) {
	                logInvalidZError();
	                disp.zlevel = 0;
	            }
	            this._displayList[this._displayListLen++] = disp;
	        }
	        var decalEl = el.getDecalElement && el.getDecalElement();
	        if (decalEl) {
	            this._updateAndAddDisplayable(decalEl, clipPaths, includeIgnore);
	        }
	        var textGuide = el.getTextGuideLine();
	        if (textGuide) {
	            this._updateAndAddDisplayable(textGuide, clipPaths, includeIgnore);
	        }
	        var textEl = el.getTextContent();
	        if (textEl) {
	            this._updateAndAddDisplayable(textEl, clipPaths, includeIgnore);
	        }
	    };
	    Storage.prototype.addRoot = function (el) {
	        if (el.__zr && el.__zr.storage === this) {
	            return;
	        }
	        this._roots.push(el);
	    };
	    Storage.prototype.delRoot = function (el) {
	        if (el instanceof Array) {
	            for (var i = 0, l = el.length; i < l; i++) {
	                this.delRoot(el[i]);
	            }
	            return;
	        }
	        var idx = util.indexOf(this._roots, el);
	        if (idx >= 0) {
	            this._roots.splice(idx, 1);
	        }
	    };
	    Storage.prototype.delAllRoots = function () {
	        this._roots = [];
	        this._displayList = [];
	        this._displayListLen = 0;
	        return;
	    };
	    Storage.prototype.getRoots = function () {
	        return this._roots;
	    };
	    Storage.prototype.dispose = function () {
	        this._displayList = null;
	        this._roots = null;
	    };
	    return Storage;
	}());
	exports["default"] = Storage;


/***/ },
/* 444 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	exports.__esModule = true;
	var tslib_1 = __webpack_require__(5);
	var Eventful_1 = __webpack_require__(37);
	var requestAnimationFrame_1 = __webpack_require__(177);
	var Animator_1 = __webpack_require__(107);
	var Animation = (function (_super) {
	    tslib_1.__extends(Animation, _super);
	    function Animation(opts) {
	        var _this = _super.call(this) || this;
	        _this._running = false;
	        _this._time = 0;
	        _this._pausedTime = 0;
	        _this._pauseStart = 0;
	        _this._paused = false;
	        opts = opts || {};
	        _this.stage = opts.stage || {};
	        _this.onframe = opts.onframe || function () { };
	        return _this;
	    }
	    Animation.prototype.addClip = function (clip) {
	        if (clip.animation) {
	            this.removeClip(clip);
	        }
	        if (!this._clipsHead) {
	            this._clipsHead = this._clipsTail = clip;
	        }
	        else {
	            this._clipsTail.next = clip;
	            clip.prev = this._clipsTail;
	            clip.next = null;
	            this._clipsTail = clip;
	        }
	        clip.animation = this;
	    };
	    Animation.prototype.addAnimator = function (animator) {
	        animator.animation = this;
	        var clip = animator.getClip();
	        if (clip) {
	            this.addClip(clip);
	        }
	    };
	    Animation.prototype.removeClip = function (clip) {
	        if (!clip.animation) {
	            return;
	        }
	        var prev = clip.prev;
	        var next = clip.next;
	        if (prev) {
	            prev.next = next;
	        }
	        else {
	            this._clipsHead = next;
	        }
	        if (next) {
	            next.prev = prev;
	        }
	        else {
	            this._clipsTail = prev;
	        }
	        clip.next = clip.prev = clip.animation = null;
	    };
	    Animation.prototype.removeAnimator = function (animator) {
	        var clip = animator.getClip();
	        if (clip) {
	            this.removeClip(clip);
	        }
	        animator.animation = null;
	    };
	    Animation.prototype.update = function (notTriggerFrameAndStageUpdate) {
	        var time = new Date().getTime() - this._pausedTime;
	        var delta = time - this._time;
	        var clip = this._clipsHead;
	        while (clip) {
	            var nextClip = clip.next;
	            var finished = clip.step(time, delta);
	            if (finished) {
	                clip.ondestroy && clip.ondestroy();
	                this.removeClip(clip);
	                clip = nextClip;
	            }
	            else {
	                clip = nextClip;
	            }
	        }
	        this._time = time;
	        if (!notTriggerFrameAndStageUpdate) {
	            this.onframe(delta);
	            this.trigger('frame', delta);
	            this.stage.update && this.stage.update();
	        }
	    };
	    Animation.prototype._startLoop = function () {
	        var self = this;
	        this._running = true;
	        function step() {
	            if (self._running) {
	                requestAnimationFrame_1["default"](step);
	                !self._paused && self.update();
	            }
	        }
	        requestAnimationFrame_1["default"](step);
	    };
	    Animation.prototype.start = function () {
	        if (this._running) {
	            return;
	        }
	        this._time = new Date().getTime();
	        this._pausedTime = 0;
	        this._startLoop();
	    };
	    Animation.prototype.stop = function () {
	        this._running = false;
	    };
	    Animation.prototype.pause = function () {
	        if (!this._paused) {
	            this._pauseStart = new Date().getTime();
	            this._paused = true;
	        }
	    };
	    Animation.prototype.resume = function () {
	        if (this._paused) {
	            this._pausedTime += (new Date().getTime()) - this._pauseStart;
	            this._paused = false;
	        }
	    };
	    Animation.prototype.clear = function () {
	        var clip = this._clipsHead;
	        while (clip) {
	            var nextClip = clip.next;
	            clip.prev = clip.next = clip.animation = null;
	            clip = nextClip;
	        }
	        this._clipsHead = this._clipsTail = null;
	    };
	    Animation.prototype.isFinished = function () {
	        return this._clipsHead == null;
	    };
	    Animation.prototype.animate = function (target, options) {
	        options = options || {};
	        this.start();
	        var animator = new Animator_1["default"](target, options.loop);
	        this.addAnimator(animator);
	        return animator;
	    };
	    return Animation;
	}(Eventful_1["default"]));
	exports["default"] = Animation;


/***/ },
/* 445 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	exports.__esModule = true;
	var easing_1 = __webpack_require__(446);
	var Clip = (function () {
	    function Clip(opts) {
	        this._initialized = false;
	        this._startTime = 0;
	        this._pausedTime = 0;
	        this._paused = false;
	        this._life = opts.life || 1000;
	        this._delay = opts.delay || 0;
	        this.loop = opts.loop == null ? false : opts.loop;
	        this.gap = opts.gap || 0;
	        this.easing = opts.easing || 'linear';
	        this.onframe = opts.onframe;
	        this.ondestroy = opts.ondestroy;
	        this.onrestart = opts.onrestart;
	    }
	    Clip.prototype.step = function (globalTime, deltaTime) {
	        if (!this._initialized) {
	            this._startTime = globalTime + this._delay;
	            this._initialized = true;
	        }
	        if (this._paused) {
	            this._pausedTime += deltaTime;
	            return;
	        }
	        var percent = (globalTime - this._startTime - this._pausedTime) / this._life;
	        if (percent < 0) {
	            percent = 0;
	        }
	        percent = Math.min(percent, 1);
	        var easing = this.easing;
	        var easingFunc = typeof easing === 'string'
	            ? easing_1["default"][easing] : easing;
	        var schedule = typeof easingFunc === 'function'
	            ? easingFunc(percent)
	            : percent;
	        this.onframe && this.onframe(schedule);
	        if (percent === 1) {
	            if (this.loop) {
	                this._restart(globalTime);
	                this.onrestart && this.onrestart();
	            }
	            else {
	                return true;
	            }
	        }
	        return false;
	    };
	    Clip.prototype._restart = function (globalTime) {
	        var remainder = (globalTime - this._startTime - this._pausedTime) % this._life;
	        this._startTime = globalTime - remainder + this.gap;
	        this._pausedTime = 0;
	    };
	    Clip.prototype.pause = function () {
	        this._paused = true;
	    };
	    Clip.prototype.resume = function () {
	        this._paused = false;
	    };
	    return Clip;
	}());
	exports["default"] = Clip;


/***/ },
/* 446 */
/***/ function(module, exports) {

	"use strict";
	exports.__esModule = true;
	var easing = {
	    linear: function (k) {
	        return k;
	    },
	    quadraticIn: function (k) {
	        return k * k;
	    },
	    quadraticOut: function (k) {
	        return k * (2 - k);
	    },
	    quadraticInOut: function (k) {
	        if ((k *= 2) < 1) {
	            return 0.5 * k * k;
	        }
	        return -0.5 * (--k * (k - 2) - 1);
	    },
	    cubicIn: function (k) {
	        return k * k * k;
	    },
	    cubicOut: function (k) {
	        return --k * k * k + 1;
	    },
	    cubicInOut: function (k) {
	        if ((k *= 2) < 1) {
	            return 0.5 * k * k * k;
	        }
	        return 0.5 * ((k -= 2) * k * k + 2);
	    },
	    quarticIn: function (k) {
	        return k * k * k * k;
	    },
	    quarticOut: function (k) {
	        return 1 - (--k * k * k * k);
	    },
	    quarticInOut: function (k) {
	        if ((k *= 2) < 1) {
	            return 0.5 * k * k * k * k;
	        }
	        return -0.5 * ((k -= 2) * k * k * k - 2);
	    },
	    quinticIn: function (k) {
	        return k * k * k * k * k;
	    },
	    quinticOut: function (k) {
	        return --k * k * k * k * k + 1;
	    },
	    quinticInOut: function (k) {
	        if ((k *= 2) < 1) {
	            return 0.5 * k * k * k * k * k;
	        }
	        return 0.5 * ((k -= 2) * k * k * k * k + 2);
	    },
	    sinusoidalIn: function (k) {
	        return 1 - Math.cos(k * Math.PI / 2);
	    },
	    sinusoidalOut: function (k) {
	        return Math.sin(k * Math.PI / 2);
	    },
	    sinusoidalInOut: function (k) {
	        return 0.5 * (1 - Math.cos(Math.PI * k));
	    },
	    exponentialIn: function (k) {
	        return k === 0 ? 0 : Math.pow(1024, k - 1);
	    },
	    exponentialOut: function (k) {
	        return k === 1 ? 1 : 1 - Math.pow(2, -10 * k);
	    },
	    exponentialInOut: function (k) {
	        if (k === 0) {
	            return 0;
	        }
	        if (k === 1) {
	            return 1;
	        }
	        if ((k *= 2) < 1) {
	            return 0.5 * Math.pow(1024, k - 1);
	        }
	        return 0.5 * (-Math.pow(2, -10 * (k - 1)) + 2);
	    },
	    circularIn: function (k) {
	        return 1 - Math.sqrt(1 - k * k);
	    },
	    circularOut: function (k) {
	        return Math.sqrt(1 - (--k * k));
	    },
	    circularInOut: function (k) {
	        if ((k *= 2) < 1) {
	            return -0.5 * (Math.sqrt(1 - k * k) - 1);
	        }
	        return 0.5 * (Math.sqrt(1 - (k -= 2) * k) + 1);
	    },
	    elasticIn: function (k) {
	        var s;
	        var a = 0.1;
	        var p = 0.4;
	        if (k === 0) {
	            return 0;
	        }
	        if (k === 1) {
	            return 1;
	        }
	        if (!a || a < 1) {
	            a = 1;
	            s = p / 4;
	        }
	        else {
	            s = p * Math.asin(1 / a) / (2 * Math.PI);
	        }
	        return -(a * Math.pow(2, 10 * (k -= 1))
	            * Math.sin((k - s) * (2 * Math.PI) / p));
	    },
	    elasticOut: function (k) {
	        var s;
	        var a = 0.1;
	        var p = 0.4;
	        if (k === 0) {
	            return 0;
	        }
	        if (k === 1) {
	            return 1;
	        }
	        if (!a || a < 1) {
	            a = 1;
	            s = p / 4;
	        }
	        else {
	            s = p * Math.asin(1 / a) / (2 * Math.PI);
	        }
	        return (a * Math.pow(2, -10 * k)
	            * Math.sin((k - s) * (2 * Math.PI) / p) + 1);
	    },
	    elasticInOut: function (k) {
	        var s;
	        var a = 0.1;
	        var p = 0.4;
	        if (k === 0) {
	            return 0;
	        }
	        if (k === 1) {
	            return 1;
	        }
	        if (!a || a < 1) {
	            a = 1;
	            s = p / 4;
	        }
	        else {
	            s = p * Math.asin(1 / a) / (2 * Math.PI);
	        }
	        if ((k *= 2) < 1) {
	            return -0.5 * (a * Math.pow(2, 10 * (k -= 1))
	                * Math.sin((k - s) * (2 * Math.PI) / p));
	        }
	        return a * Math.pow(2, -10 * (k -= 1))
	            * Math.sin((k - s) * (2 * Math.PI) / p) * 0.5 + 1;
	    },
	    backIn: function (k) {
	        var s = 1.70158;
	        return k * k * ((s + 1) * k - s);
	    },
	    backOut: function (k) {
	        var s = 1.70158;
	        return --k * k * ((s + 1) * k + s) + 1;
	    },
	    backInOut: function (k) {
	        var s = 1.70158 * 1.525;
	        if ((k *= 2) < 1) {
	            return 0.5 * (k * k * ((s + 1) * k - s));
	        }
	        return 0.5 * ((k -= 2) * k * ((s + 1) * k + s) + 2);
	    },
	    bounceIn: function (k) {
	        return 1 - easing.bounceOut(1 - k);
	    },
	    bounceOut: function (k) {
	        if (k < (1 / 2.75)) {
	            return 7.5625 * k * k;
	        }
	        else if (k < (2 / 2.75)) {
	            return 7.5625 * (k -= (1.5 / 2.75)) * k + 0.75;
	        }
	        else if (k < (2.5 / 2.75)) {
	            return 7.5625 * (k -= (2.25 / 2.75)) * k + 0.9375;
	        }
	        else {
	            return 7.5625 * (k -= (2.625 / 2.75)) * k + 0.984375;
	        }
	    },
	    bounceInOut: function (k) {
	        if (k < 0.5) {
	            return easing.bounceIn(k * 2) * 0.5;
	        }
	        return easing.bounceOut(k * 2 - 1) * 0.5 + 0.5;
	    }
	};
	exports["default"] = easing;


/***/ },
/* 447 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	exports.__esModule = true;
	var tslib_1 = __webpack_require__(5);
	var util = __webpack_require__(1);
	var config_1 = __webpack_require__(49);
	var Eventful_1 = __webpack_require__(37);
	var Element_1 = __webpack_require__(36);
	var helper_1 = __webpack_require__(178);
	var graphic_1 = __webpack_require__(78);
	var BoundingRect_1 = __webpack_require__(17);
	function returnFalse() {
	    return false;
	}
	function createDom(id, painter, dpr) {
	    var newDom = util.createCanvas();
	    var width = painter.getWidth();
	    var height = painter.getHeight();
	    var newDomStyle = newDom.style;
	    if (newDomStyle) {
	        newDomStyle.position = 'absolute';
	        newDomStyle.left = '0';
	        newDomStyle.top = '0';
	        newDomStyle.width = width + 'px';
	        newDomStyle.height = height + 'px';
	        newDom.setAttribute('data-zr-dom-id', id);
	    }
	    newDom.width = width * dpr;
	    newDom.height = height * dpr;
	    return newDom;
	}
	;
	var Layer = (function (_super) {
	    tslib_1.__extends(Layer, _super);
	    function Layer(id, painter, dpr) {
	        var _this = _super.call(this) || this;
	        _this.motionBlur = false;
	        _this.lastFrameAlpha = 0.7;
	        _this.dpr = 1;
	        _this.virtual = false;
	        _this.config = {};
	        _this.incremental = false;
	        _this.zlevel = 0;
	        _this.maxRepaintRectCount = 5;
	        _this.__dirty = true;
	        _this.__firstTimePaint = true;
	        _this.__used = false;
	        _this.__drawIndex = 0;
	        _this.__startIndex = 0;
	        _this.__endIndex = 0;
	        _this.__prevStartIndex = null;
	        _this.__prevEndIndex = null;
	        var dom;
	        dpr = dpr || config_1.devicePixelRatio;
	        if (typeof id === 'string') {
	            dom = createDom(id, painter, dpr);
	        }
	        else if (util.isObject(id)) {
	            dom = id;
	            id = dom.id;
	        }
	        _this.id = id;
	        _this.dom = dom;
	        var domStyle = dom.style;
	        if (domStyle) {
	            dom.onselectstart = returnFalse;
	            domStyle.webkitUserSelect = 'none';
	            domStyle.userSelect = 'none';
	            domStyle.webkitTapHighlightColor = 'rgba(0,0,0,0)';
	            domStyle['-webkit-touch-callout'] = 'none';
	            domStyle.padding = '0';
	            domStyle.margin = '0';
	            domStyle.borderWidth = '0';
	        }
	        _this.domBack = null;
	        _this.ctxBack = null;
	        _this.painter = painter;
	        _this.config = null;
	        _this.dpr = dpr;
	        return _this;
	    }
	    Layer.prototype.getElementCount = function () {
	        return this.__endIndex - this.__startIndex;
	    };
	    Layer.prototype.afterBrush = function () {
	        this.__prevStartIndex = this.__startIndex;
	        this.__prevEndIndex = this.__endIndex;
	    };
	    Layer.prototype.initContext = function () {
	        this.ctx = this.dom.getContext('2d');
	        this.ctx.dpr = this.dpr;
	    };
	    Layer.prototype.setUnpainted = function () {
	        this.__firstTimePaint = true;
	    };
	    Layer.prototype.createBackBuffer = function () {
	        var dpr = this.dpr;
	        this.domBack = createDom('back-' + this.id, this.painter, dpr);
	        this.ctxBack = this.domBack.getContext('2d');
	        if (dpr !== 1) {
	            this.ctxBack.scale(dpr, dpr);
	        }
	    };
	    Layer.prototype.createRepaintRects = function (displayList, prevList, viewWidth, viewHeight) {
	        if (this.__firstTimePaint) {
	            this.__firstTimePaint = false;
	            return null;
	        }
	        var mergedRepaintRects = [];
	        var maxRepaintRectCount = this.maxRepaintRectCount;
	        var full = false;
	        var pendingRect = new BoundingRect_1["default"](0, 0, 0, 0);
	        function addRectToMergePool(rect) {
	            if (!rect.isFinite() || rect.isZero()) {
	                return;
	            }
	            if (mergedRepaintRects.length === 0) {
	                var boundingRect = new BoundingRect_1["default"](0, 0, 0, 0);
	                boundingRect.copy(rect);
	                mergedRepaintRects.push(boundingRect);
	            }
	            else {
	                var isMerged = false;
	                var minDeltaArea = Infinity;
	                var bestRectToMergeIdx = 0;
	                for (var i = 0; i < mergedRepaintRects.length; ++i) {
	                    var mergedRect = mergedRepaintRects[i];
	                    if (mergedRect.intersect(rect)) {
	                        var pendingRect_1 = new BoundingRect_1["default"](0, 0, 0, 0);
	                        pendingRect_1.copy(mergedRect);
	                        pendingRect_1.union(rect);
	                        mergedRepaintRects[i] = pendingRect_1;
	                        isMerged = true;
	                        break;
	                    }
	                    else if (full) {
	                        pendingRect.copy(rect);
	                        pendingRect.union(mergedRect);
	                        var aArea = rect.width * rect.height;
	                        var bArea = mergedRect.width * mergedRect.height;
	                        var pendingArea = pendingRect.width * pendingRect.height;
	                        var deltaArea = pendingArea - aArea - bArea;
	                        if (deltaArea < minDeltaArea) {
	                            minDeltaArea = minDeltaArea;
	                            bestRectToMergeIdx = i;
	                        }
	                    }
	                }
	                if (full) {
	                    mergedRepaintRects[bestRectToMergeIdx].union(rect);
	                    isMerged = true;
	                }
	                if (!isMerged) {
	                    var boundingRect = new BoundingRect_1["default"](0, 0, 0, 0);
	                    boundingRect.copy(rect);
	                    mergedRepaintRects.push(boundingRect);
	                }
	                if (!full) {
	                    full = mergedRepaintRects.length >= maxRepaintRectCount;
	                }
	            }
	        }
	        for (var i = this.__startIndex; i < this.__endIndex; ++i) {
	            var el = displayList[i];
	            if (el) {
	                var shouldPaint = el.shouldBePainted(viewWidth, viewHeight, true, true);
	                var prevRect = el.__isRendered && ((el.__dirty & Element_1["default"].REDARAW_BIT) || !shouldPaint)
	                    ? el.getPrevPaintRect()
	                    : null;
	                if (prevRect) {
	                    addRectToMergePool(prevRect);
	                }
	                var curRect = shouldPaint && ((el.__dirty & Element_1["default"].REDARAW_BIT) || !el.__isRendered)
	                    ? el.getPaintRect()
	                    : null;
	                if (curRect) {
	                    addRectToMergePool(curRect);
	                }
	            }
	        }
	        for (var i = this.__prevStartIndex; i < this.__prevEndIndex; ++i) {
	            var el = prevList[i];
	            var shouldPaint = el.shouldBePainted(viewWidth, viewHeight, true, true);
	            if (el && (!shouldPaint || !el.__zr) && el.__isRendered) {
	                var prevRect = el.getPrevPaintRect();
	                if (prevRect) {
	                    addRectToMergePool(prevRect);
	                }
	            }
	        }
	        var hasIntersections;
	        do {
	            hasIntersections = false;
	            for (var i = 0; i < mergedRepaintRects.length;) {
	                if (mergedRepaintRects[i].isZero()) {
	                    mergedRepaintRects.splice(i, 1);
	                    continue;
	                }
	                for (var j = i + 1; j < mergedRepaintRects.length;) {
	                    if (mergedRepaintRects[i].intersect(mergedRepaintRects[j])) {
	                        hasIntersections = true;
	                        mergedRepaintRects[i].union(mergedRepaintRects[j]);
	                        mergedRepaintRects.splice(j, 1);
	                    }
	                    else {
	                        j++;
	                    }
	                }
	                i++;
	            }
	        } while (hasIntersections);
	        this._paintRects = mergedRepaintRects;
	        return mergedRepaintRects;
	    };
	    Layer.prototype.debugGetPaintRects = function () {
	        return (this._paintRects || []).slice();
	    };
	    Layer.prototype.resize = function (width, height) {
	        var dpr = this.dpr;
	        var dom = this.dom;
	        var domStyle = dom.style;
	        var domBack = this.domBack;
	        if (domStyle) {
	            domStyle.width = width + 'px';
	            domStyle.height = height + 'px';
	        }
	        dom.width = width * dpr;
	        dom.height = height * dpr;
	        if (domBack) {
	            domBack.width = width * dpr;
	            domBack.height = height * dpr;
	            if (dpr !== 1) {
	                this.ctxBack.scale(dpr, dpr);
	            }
	        }
	    };
	    Layer.prototype.clear = function (clearAll, clearColor, repaintRects) {
	        var dom = this.dom;
	        var ctx = this.ctx;
	        var width = dom.width;
	        var height = dom.height;
	        clearColor = clearColor || this.clearColor;
	        var haveMotionBLur = this.motionBlur && !clearAll;
	        var lastFrameAlpha = this.lastFrameAlpha;
	        var dpr = this.dpr;
	        var self = this;
	        if (haveMotionBLur) {
	            if (!this.domBack) {
	                this.createBackBuffer();
	            }
	            this.ctxBack.globalCompositeOperation = 'copy';
	            this.ctxBack.drawImage(dom, 0, 0, width / dpr, height / dpr);
	        }
	        var domBack = this.domBack;
	        function doClear(x, y, width, height) {
	            ctx.clearRect(x, y, width, height);
	            if (clearColor && clearColor !== 'transparent') {
	                var clearColorGradientOrPattern = void 0;
	                if (util.isGradientObject(clearColor)) {
	                    clearColorGradientOrPattern = clearColor.__canvasGradient
	                        || helper_1.getCanvasGradient(ctx, clearColor, {
	                            x: 0,
	                            y: 0,
	                            width: width,
	                            height: height
	                        });
	                    clearColor.__canvasGradient = clearColorGradientOrPattern;
	                }
	                else if (util.isPatternObject(clearColor)) {
	                    clearColorGradientOrPattern = graphic_1.createCanvasPattern(ctx, clearColor, {
	                        dirty: function () {
	                            self.setUnpainted();
	                            self.__painter.refresh();
	                        }
	                    });
	                }
	                ctx.save();
	                ctx.fillStyle = clearColorGradientOrPattern || clearColor;
	                ctx.fillRect(x, y, width, height);
	                ctx.restore();
	            }
	            if (haveMotionBLur) {
	                ctx.save();
	                ctx.globalAlpha = lastFrameAlpha;
	                ctx.drawImage(domBack, x, y, width, height);
	                ctx.restore();
	            }
	        }
	        ;
	        if (!repaintRects || haveMotionBLur) {
	            doClear(0, 0, width, height);
	        }
	        else if (repaintRects.length) {
	            util.each(repaintRects, function (rect) {
	                doClear(rect.x * dpr, rect.y * dpr, rect.width * dpr, rect.height * dpr);
	            });
	        }
	    };
	    return Layer;
	}(Eventful_1["default"]));
	exports["default"] = Layer;


/***/ },
/* 448 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	exports.__esModule = true;
	var config_1 = __webpack_require__(49);
	var util = __webpack_require__(1);
	var Layer_1 = __webpack_require__(447);
	var requestAnimationFrame_1 = __webpack_require__(177);
	var Image_1 = __webpack_require__(43);
	var env_1 = __webpack_require__(13);
	var graphic_1 = __webpack_require__(78);
	var Element_1 = __webpack_require__(36);
	var HOVER_LAYER_ZLEVEL = 1e5;
	var CANVAS_ZLEVEL = 314159;
	var EL_AFTER_INCREMENTAL_INC = 0.01;
	var INCREMENTAL_INC = 0.001;
	function parseInt10(val) {
	    return parseInt(val, 10);
	}
	function isLayerValid(layer) {
	    if (!layer) {
	        return false;
	    }
	    if (layer.__builtin__) {
	        return true;
	    }
	    if (typeof (layer.resize) !== 'function'
	        || typeof (layer.refresh) !== 'function') {
	        return false;
	    }
	    return true;
	}
	function createRoot(width, height) {
	    var domRoot = document.createElement('div');
	    domRoot.style.cssText = [
	        'position:relative',
	        'width:' + width + 'px',
	        'height:' + height + 'px',
	        'padding:0',
	        'margin:0',
	        'border-width:0'
	    ].join(';') + ';';
	    return domRoot;
	}
	var CanvasPainter = (function () {
	    function CanvasPainter(root, storage, opts, id) {
	        this.type = 'canvas';
	        this._zlevelList = [];
	        this._prevDisplayList = [];
	        this._layers = {};
	        this._layerConfig = {};
	        this._needsManuallyCompositing = false;
	        this.type = 'canvas';
	        var singleCanvas = !root.nodeName
	            || root.nodeName.toUpperCase() === 'CANVAS';
	        this._opts = opts = util.extend({}, opts || {});
	        this.dpr = opts.devicePixelRatio || config_1.devicePixelRatio;
	        this._singleCanvas = singleCanvas;
	        this.root = root;
	        var rootStyle = root.style;
	        if (rootStyle) {
	            rootStyle.webkitTapHighlightColor = 'transparent';
	            rootStyle.webkitUserSelect = 'none';
	            rootStyle.userSelect = 'none';
	            rootStyle['-webkit-touch-callout'] = 'none';
	            root.innerHTML = '';
	        }
	        this.storage = storage;
	        var zlevelList = this._zlevelList;
	        this._prevDisplayList = [];
	        var layers = this._layers;
	        if (!singleCanvas) {
	            this._width = this._getSize(0);
	            this._height = this._getSize(1);
	            var domRoot = this._domRoot = createRoot(this._width, this._height);
	            root.appendChild(domRoot);
	        }
	        else {
	            var rootCanvas = root;
	            var width = rootCanvas.width;
	            var height = rootCanvas.height;
	            if (opts.width != null) {
	                width = opts.width;
	            }
	            if (opts.height != null) {
	                height = opts.height;
	            }
	            this.dpr = opts.devicePixelRatio || 1;
	            rootCanvas.width = width * this.dpr;
	            rootCanvas.height = height * this.dpr;
	            this._width = width;
	            this._height = height;
	            var mainLayer = new Layer_1["default"](rootCanvas, this, this.dpr);
	            mainLayer.__builtin__ = true;
	            mainLayer.initContext();
	            layers[CANVAS_ZLEVEL] = mainLayer;
	            mainLayer.zlevel = CANVAS_ZLEVEL;
	            zlevelList.push(CANVAS_ZLEVEL);
	            this._domRoot = root;
	        }
	    }
	    CanvasPainter.prototype.getType = function () {
	        return 'canvas';
	    };
	    CanvasPainter.prototype.isSingleCanvas = function () {
	        return this._singleCanvas;
	    };
	    CanvasPainter.prototype.getViewportRoot = function () {
	        return this._domRoot;
	    };
	    CanvasPainter.prototype.getViewportRootOffset = function () {
	        var viewportRoot = this.getViewportRoot();
	        if (viewportRoot) {
	            return {
	                offsetLeft: viewportRoot.offsetLeft || 0,
	                offsetTop: viewportRoot.offsetTop || 0
	            };
	        }
	    };
	    CanvasPainter.prototype.refresh = function (paintAll) {
	        var list = this.storage.getDisplayList(true);
	        var prevList = this._prevDisplayList;
	        var zlevelList = this._zlevelList;
	        this._redrawId = Math.random();
	        this._paintList(list, prevList, paintAll, this._redrawId);
	        for (var i = 0; i < zlevelList.length; i++) {
	            var z = zlevelList[i];
	            var layer = this._layers[z];
	            if (!layer.__builtin__ && layer.refresh) {
	                var clearColor = i === 0 ? this._backgroundColor : null;
	                layer.refresh(clearColor);
	            }
	        }
	        if (this._opts.useDirtyRect) {
	            this._prevDisplayList = list.slice();
	        }
	        return this;
	    };
	    CanvasPainter.prototype.refreshHover = function () {
	        this._paintHoverList(this.storage.getDisplayList(false));
	    };
	    CanvasPainter.prototype._paintHoverList = function (list) {
	        var len = list.length;
	        var hoverLayer = this._hoverlayer;
	        hoverLayer && hoverLayer.clear();
	        if (!len) {
	            return;
	        }
	        var scope = {
	            inHover: true,
	            viewWidth: this._width,
	            viewHeight: this._height
	        };
	        var ctx;
	        for (var i = 0; i < len; i++) {
	            var el = list[i];
	            if (el.__inHover) {
	                if (!hoverLayer) {
	                    hoverLayer = this._hoverlayer = this.getLayer(HOVER_LAYER_ZLEVEL);
	                }
	                if (!ctx) {
	                    ctx = hoverLayer.ctx;
	                    ctx.save();
	                }
	                graphic_1.brush(ctx, el, scope, i === len - 1);
	            }
	        }
	        if (ctx) {
	            ctx.restore();
	        }
	    };
	    CanvasPainter.prototype.getHoverLayer = function () {
	        return this.getLayer(HOVER_LAYER_ZLEVEL);
	    };
	    CanvasPainter.prototype.paintOne = function (ctx, el) {
	        graphic_1.brushSingle(ctx, el);
	    };
	    CanvasPainter.prototype._paintList = function (list, prevList, paintAll, redrawId) {
	        if (this._redrawId !== redrawId) {
	            return;
	        }
	        paintAll = paintAll || false;
	        this._updateLayerStatus(list);
	        var _a = this._doPaintList(list, prevList, paintAll), finished = _a.finished, needsRefreshHover = _a.needsRefreshHover;
	        if (this._needsManuallyCompositing) {
	            this._compositeManually();
	        }
	        if (needsRefreshHover) {
	            this._paintHoverList(list);
	        }
	        if (!finished) {
	            var self_1 = this;
	            requestAnimationFrame_1["default"](function () {
	                self_1._paintList(list, prevList, paintAll, redrawId);
	            });
	        }
	        else {
	            this.eachLayer(function (layer) {
	                layer.afterBrush && layer.afterBrush();
	            });
	        }
	    };
	    CanvasPainter.prototype._compositeManually = function () {
	        var ctx = this.getLayer(CANVAS_ZLEVEL).ctx;
	        var width = this._domRoot.width;
	        var height = this._domRoot.height;
	        ctx.clearRect(0, 0, width, height);
	        this.eachBuiltinLayer(function (layer) {
	            if (layer.virtual) {
	                ctx.drawImage(layer.dom, 0, 0, width, height);
	            }
	        });
	    };
	    CanvasPainter.prototype._doPaintList = function (list, prevList, paintAll) {
	        var _this = this;
	        var layerList = [];
	        var useDirtyRect = this._opts.useDirtyRect;
	        for (var zi = 0; zi < this._zlevelList.length; zi++) {
	            var zlevel = this._zlevelList[zi];
	            var layer = this._layers[zlevel];
	            if (layer.__builtin__
	                && layer !== this._hoverlayer
	                && (layer.__dirty || paintAll)) {
	                layerList.push(layer);
	            }
	        }
	        var finished = true;
	        var needsRefreshHover = false;
	        var _loop_1 = function (k) {
	            var layer = layerList[k];
	            var ctx = layer.ctx;
	            var repaintRects = useDirtyRect
	                && layer.createRepaintRects(list, prevList, this_1._width, this_1._height);
	            ctx.save();
	            var start = paintAll ? layer.__startIndex : layer.__drawIndex;
	            var useTimer = !paintAll && layer.incremental && Date.now;
	            var startTime = useTimer && Date.now();
	            var clearColor = layer.zlevel === this_1._zlevelList[0]
	                ? this_1._backgroundColor : null;
	            if (layer.__startIndex === layer.__endIndex) {
	                layer.clear(false, clearColor, repaintRects);
	            }
	            else if (start === layer.__startIndex) {
	                var firstEl = list[start];
	                if (!firstEl.incremental || !firstEl.notClear || paintAll) {
	                    layer.clear(false, clearColor, repaintRects);
	                }
	            }
	            if (start === -1) {
	                console.error('For some unknown reason. drawIndex is -1');
	                start = layer.__startIndex;
	            }
	            var i;
	            var repaint = function (repaintRect) {
	                var scope = {
	                    inHover: false,
	                    allClipped: false,
	                    prevEl: null,
	                    viewWidth: _this._width,
	                    viewHeight: _this._height
	                };
	                for (i = start; i < layer.__endIndex; i++) {
	                    var el = list[i];
	                    if (el.__inHover) {
	                        needsRefreshHover = true;
	                    }
	                    _this._doPaintEl(el, layer, useDirtyRect, repaintRect, scope, i === layer.__endIndex - 1);
	                    if (useTimer) {
	                        var dTime = Date.now() - startTime;
	                        if (dTime > 15) {
	                            break;
	                        }
	                    }
	                }
	                if (scope.prevElClipPaths) {
	                    ctx.restore();
	                }
	            };
	            if (repaintRects) {
	                if (repaintRects.length === 0) {
	                    i = layer.__endIndex;
	                }
	                else {
	                    var dpr = this_1.dpr;
	                    for (var r = 0; r < repaintRects.length; ++r) {
	                        var rect = repaintRects[r];
	                        ctx.save();
	                        ctx.beginPath();
	                        ctx.rect(rect.x * dpr, rect.y * dpr, rect.width * dpr, rect.height * dpr);
	                        ctx.clip();
	                        repaint(rect);
	                        ctx.restore();
	                    }
	                }
	            }
	            else {
	                ctx.save();
	                repaint();
	                ctx.restore();
	            }
	            layer.__drawIndex = i;
	            if (layer.__drawIndex < layer.__endIndex) {
	                finished = false;
	            }
	        };
	        var this_1 = this;
	        for (var k = 0; k < layerList.length; k++) {
	            _loop_1(k);
	        }
	        if (env_1["default"].wxa) {
	            util.each(this._layers, function (layer) {
	                if (layer && layer.ctx && layer.ctx.draw) {
	                    layer.ctx.draw();
	                }
	            });
	        }
	        return {
	            finished: finished,
	            needsRefreshHover: needsRefreshHover
	        };
	    };
	    CanvasPainter.prototype._doPaintEl = function (el, currentLayer, useDirtyRect, repaintRect, scope, isLast) {
	        var ctx = currentLayer.ctx;
	        if (useDirtyRect) {
	            var paintRect = el.getPaintRect();
	            if (!repaintRect || paintRect && paintRect.intersect(repaintRect)) {
	                graphic_1.brush(ctx, el, scope, isLast);
	                el.setPrevPaintRect(paintRect);
	            }
	        }
	        else {
	            graphic_1.brush(ctx, el, scope, isLast);
	        }
	    };
	    CanvasPainter.prototype.getLayer = function (zlevel, virtual) {
	        if (this._singleCanvas && !this._needsManuallyCompositing) {
	            zlevel = CANVAS_ZLEVEL;
	        }
	        var layer = this._layers[zlevel];
	        if (!layer) {
	            layer = new Layer_1["default"]('zr_' + zlevel, this, this.dpr);
	            layer.zlevel = zlevel;
	            layer.__builtin__ = true;
	            if (this._layerConfig[zlevel]) {
	                util.merge(layer, this._layerConfig[zlevel], true);
	            }
	            else if (this._layerConfig[zlevel - EL_AFTER_INCREMENTAL_INC]) {
	                util.merge(layer, this._layerConfig[zlevel - EL_AFTER_INCREMENTAL_INC], true);
	            }
	            if (virtual) {
	                layer.virtual = virtual;
	            }
	            this.insertLayer(zlevel, layer);
	            layer.initContext();
	        }
	        return layer;
	    };
	    CanvasPainter.prototype.insertLayer = function (zlevel, layer) {
	        var layersMap = this._layers;
	        var zlevelList = this._zlevelList;
	        var len = zlevelList.length;
	        var domRoot = this._domRoot;
	        var prevLayer = null;
	        var i = -1;
	        if (layersMap[zlevel]) {
	            util.logError('ZLevel ' + zlevel + ' has been used already');
	            return;
	        }
	        if (!isLayerValid(layer)) {
	            util.logError('Layer of zlevel ' + zlevel + ' is not valid');
	            return;
	        }
	        if (len > 0 && zlevel > zlevelList[0]) {
	            for (i = 0; i < len - 1; i++) {
	                if (zlevelList[i] < zlevel
	                    && zlevelList[i + 1] > zlevel) {
	                    break;
	                }
	            }
	            prevLayer = layersMap[zlevelList[i]];
	        }
	        zlevelList.splice(i + 1, 0, zlevel);
	        layersMap[zlevel] = layer;
	        if (!layer.virtual) {
	            if (prevLayer) {
	                var prevDom = prevLayer.dom;
	                if (prevDom.nextSibling) {
	                    domRoot.insertBefore(layer.dom, prevDom.nextSibling);
	                }
	                else {
	                    domRoot.appendChild(layer.dom);
	                }
	            }
	            else {
	                if (domRoot.firstChild) {
	                    domRoot.insertBefore(layer.dom, domRoot.firstChild);
	                }
	                else {
	                    domRoot.appendChild(layer.dom);
	                }
	            }
	        }
	        layer.__painter = this;
	    };
	    CanvasPainter.prototype.eachLayer = function (cb, context) {
	        var zlevelList = this._zlevelList;
	        for (var i = 0; i < zlevelList.length; i++) {
	            var z = zlevelList[i];
	            cb.call(context, this._layers[z], z);
	        }
	    };
	    CanvasPainter.prototype.eachBuiltinLayer = function (cb, context) {
	        var zlevelList = this._zlevelList;
	        for (var i = 0; i < zlevelList.length; i++) {
	            var z = zlevelList[i];
	            var layer = this._layers[z];
	            if (layer.__builtin__) {
	                cb.call(context, layer, z);
	            }
	        }
	    };
	    CanvasPainter.prototype.eachOtherLayer = function (cb, context) {
	        var zlevelList = this._zlevelList;
	        for (var i = 0; i < zlevelList.length; i++) {
	            var z = zlevelList[i];
	            var layer = this._layers[z];
	            if (!layer.__builtin__) {
	                cb.call(context, layer, z);
	            }
	        }
	    };
	    CanvasPainter.prototype.getLayers = function () {
	        return this._layers;
	    };
	    CanvasPainter.prototype._updateLayerStatus = function (list) {
	        this.eachBuiltinLayer(function (layer, z) {
	            layer.__dirty = layer.__used = false;
	        });
	        function updatePrevLayer(idx) {
	            if (prevLayer) {
	                if (prevLayer.__endIndex !== idx) {
	                    prevLayer.__dirty = true;
	                }
	                prevLayer.__endIndex = idx;
	            }
	        }
	        if (this._singleCanvas) {
	            for (var i_1 = 1; i_1 < list.length; i_1++) {
	                var el = list[i_1];
	                if (el.zlevel !== list[i_1 - 1].zlevel || el.incremental) {
	                    this._needsManuallyCompositing = true;
	                    break;
	                }
	            }
	        }
	        var prevLayer = null;
	        var incrementalLayerCount = 0;
	        var prevZlevel;
	        var i;
	        for (i = 0; i < list.length; i++) {
	            var el = list[i];
	            var zlevel = el.zlevel;
	            var layer = void 0;
	            if (prevZlevel !== zlevel) {
	                prevZlevel = zlevel;
	                incrementalLayerCount = 0;
	            }
	            if (el.incremental) {
	                layer = this.getLayer(zlevel + INCREMENTAL_INC, this._needsManuallyCompositing);
	                layer.incremental = true;
	                incrementalLayerCount = 1;
	            }
	            else {
	                layer = this.getLayer(zlevel + (incrementalLayerCount > 0 ? EL_AFTER_INCREMENTAL_INC : 0), this._needsManuallyCompositing);
	            }
	            if (!layer.__builtin__) {
	                util.logError('ZLevel ' + zlevel + ' has been used by unkown layer ' + layer.id);
	            }
	            if (layer !== prevLayer) {
	                layer.__used = true;
	                if (layer.__startIndex !== i) {
	                    layer.__dirty = true;
	                }
	                layer.__startIndex = i;
	                if (!layer.incremental) {
	                    layer.__drawIndex = i;
	                }
	                else {
	                    layer.__drawIndex = -1;
	                }
	                updatePrevLayer(i);
	                prevLayer = layer;
	            }
	            if ((el.__dirty & Element_1["default"].REDARAW_BIT) && !el.__inHover) {
	                layer.__dirty = true;
	                if (layer.incremental && layer.__drawIndex < 0) {
	                    layer.__drawIndex = i;
	                }
	            }
	        }
	        updatePrevLayer(i);
	        this.eachBuiltinLayer(function (layer, z) {
	            if (!layer.__used && layer.getElementCount() > 0) {
	                layer.__dirty = true;
	                layer.__startIndex = layer.__endIndex = layer.__drawIndex = 0;
	            }
	            if (layer.__dirty && layer.__drawIndex < 0) {
	                layer.__drawIndex = layer.__startIndex;
	            }
	        });
	    };
	    CanvasPainter.prototype.clear = function () {
	        this.eachBuiltinLayer(this._clearLayer);
	        return this;
	    };
	    CanvasPainter.prototype._clearLayer = function (layer) {
	        layer.clear();
	    };
	    CanvasPainter.prototype.setBackgroundColor = function (backgroundColor) {
	        this._backgroundColor = backgroundColor;
	        util.each(this._layers, function (layer) {
	            layer.setUnpainted();
	        });
	    };
	    CanvasPainter.prototype.configLayer = function (zlevel, config) {
	        if (config) {
	            var layerConfig = this._layerConfig;
	            if (!layerConfig[zlevel]) {
	                layerConfig[zlevel] = config;
	            }
	            else {
	                util.merge(layerConfig[zlevel], config, true);
	            }
	            for (var i = 0; i < this._zlevelList.length; i++) {
	                var _zlevel = this._zlevelList[i];
	                if (_zlevel === zlevel || _zlevel === zlevel + EL_AFTER_INCREMENTAL_INC) {
	                    var layer = this._layers[_zlevel];
	                    util.merge(layer, layerConfig[zlevel], true);
	                }
	            }
	        }
	    };
	    CanvasPainter.prototype.delLayer = function (zlevel) {
	        var layers = this._layers;
	        var zlevelList = this._zlevelList;
	        var layer = layers[zlevel];
	        if (!layer) {
	            return;
	        }
	        layer.dom.parentNode.removeChild(layer.dom);
	        delete layers[zlevel];
	        zlevelList.splice(util.indexOf(zlevelList, zlevel), 1);
	    };
	    CanvasPainter.prototype.resize = function (width, height) {
	        if (!this._domRoot.style) {
	            if (width == null || height == null) {
	                return;
	            }
	            this._width = width;
	            this._height = height;
	            this.getLayer(CANVAS_ZLEVEL).resize(width, height);
	        }
	        else {
	            var domRoot = this._domRoot;
	            domRoot.style.display = 'none';
	            var opts = this._opts;
	            width != null && (opts.width = width);
	            height != null && (opts.height = height);
	            width = this._getSize(0);
	            height = this._getSize(1);
	            domRoot.style.display = '';
	            if (this._width !== width || height !== this._height) {
	                domRoot.style.width = width + 'px';
	                domRoot.style.height = height + 'px';
	                for (var id in this._layers) {
	                    if (this._layers.hasOwnProperty(id)) {
	                        this._layers[id].resize(width, height);
	                    }
	                }
	                this.refresh(true);
	            }
	            this._width = width;
	            this._height = height;
	        }
	        return this;
	    };
	    CanvasPainter.prototype.clearLayer = function (zlevel) {
	        var layer = this._layers[zlevel];
	        if (layer) {
	            layer.clear();
	        }
	    };
	    CanvasPainter.prototype.dispose = function () {
	        this.root.innerHTML = '';
	        this.root =
	            this.storage =
	                this._domRoot =
	                    this._layers = null;
	    };
	    CanvasPainter.prototype.getRenderedCanvas = function (opts) {
	        opts = opts || {};
	        if (this._singleCanvas && !this._compositeManually) {
	            return this._layers[CANVAS_ZLEVEL].dom;
	        }
	        var imageLayer = new Layer_1["default"]('image', this, opts.pixelRatio || this.dpr);
	        var ctx = imageLayer.ctx;
	        imageLayer.initContext();
	        imageLayer.clear(false, opts.backgroundColor || this._backgroundColor);
	        if (opts.pixelRatio <= this.dpr) {
	            this.refresh();
	            var width_1 = imageLayer.dom.width;
	            var height_1 = imageLayer.dom.height;
	            var ctx_1 = imageLayer.ctx;
	            this.eachLayer(function (layer) {
	                if (layer.__builtin__) {
	                    ctx_1.drawImage(layer.dom, 0, 0, width_1, height_1);
	                }
	                else if (layer.renderToCanvas) {
	                    imageLayer.ctx.save();
	                    layer.renderToCanvas(imageLayer.ctx);
	                    imageLayer.ctx.restore();
	                }
	            });
	        }
	        else {
	            var scope = {
	                inHover: false,
	                viewWidth: this._width,
	                viewHeight: this._height
	            };
	            var displayList = this.storage.getDisplayList(true);
	            for (var i = 0, len = displayList.length; i < len; i++) {
	                var el = displayList[i];
	                graphic_1.brush(ctx, el, scope, i === len - 1);
	            }
	        }
	        return imageLayer.dom;
	    };
	    CanvasPainter.prototype.getWidth = function () {
	        return this._width;
	    };
	    CanvasPainter.prototype.getHeight = function () {
	        return this._height;
	    };
	    CanvasPainter.prototype._getSize = function (whIdx) {
	        var opts = this._opts;
	        var wh = ['width', 'height'][whIdx];
	        var cwh = ['clientWidth', 'clientHeight'][whIdx];
	        var plt = ['paddingLeft', 'paddingTop'][whIdx];
	        var prb = ['paddingRight', 'paddingBottom'][whIdx];
	        if (opts[wh] != null && opts[wh] !== 'auto') {
	            return parseFloat(opts[wh]);
	        }
	        var root = this.root;
	        var stl = document.defaultView.getComputedStyle(root);
	        return ((root[cwh] || parseInt10(stl[wh]) || parseInt10(root.style[wh]))
	            - (parseInt10(stl[plt]) || 0)
	            - (parseInt10(stl[prb]) || 0)) | 0;
	    };
	    CanvasPainter.prototype.pathToImage = function (path, dpr) {
	        dpr = dpr || this.dpr;
	        var canvas = document.createElement('canvas');
	        var ctx = canvas.getContext('2d');
	        var rect = path.getBoundingRect();
	        var style = path.style;
	        var shadowBlurSize = style.shadowBlur * dpr;
	        var shadowOffsetX = style.shadowOffsetX * dpr;
	        var shadowOffsetY = style.shadowOffsetY * dpr;
	        var lineWidth = path.hasStroke() ? style.lineWidth : 0;
	        var leftMargin = Math.max(lineWidth / 2, -shadowOffsetX + shadowBlurSize);
	        var rightMargin = Math.max(lineWidth / 2, shadowOffsetX + shadowBlurSize);
	        var topMargin = Math.max(lineWidth / 2, -shadowOffsetY + shadowBlurSize);
	        var bottomMargin = Math.max(lineWidth / 2, shadowOffsetY + shadowBlurSize);
	        var width = rect.width + leftMargin + rightMargin;
	        var height = rect.height + topMargin + bottomMargin;
	        canvas.width = width * dpr;
	        canvas.height = height * dpr;
	        ctx.scale(dpr, dpr);
	        ctx.clearRect(0, 0, width, height);
	        ctx.dpr = dpr;
	        var pathTransform = {
	            x: path.x,
	            y: path.y,
	            scaleX: path.scaleX,
	            scaleY: path.scaleY,
	            rotation: path.rotation,
	            originX: path.originX,
	            originY: path.originY
	        };
	        path.x = leftMargin - rect.x;
	        path.y = topMargin - rect.y;
	        path.rotation = 0;
	        path.scaleX = 1;
	        path.scaleY = 1;
	        path.updateTransform();
	        if (path) {
	            graphic_1.brush(ctx, path, {
	                inHover: false,
	                viewWidth: this._width,
	                viewHeight: this._height
	            }, true);
	        }
	        var imgShape = new Image_1["default"]({
	            style: {
	                x: 0,
	                y: 0,
	                image: canvas
	            }
	        });
	        util.extend(path, pathTransform);
	        return imgShape;
	    };
	    return CanvasPainter;
	}());
	exports["default"] = CanvasPainter;
	;


/***/ },
/* 449 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	exports.__esModule = true;
	__webpack_require__(78);
	var zrender_1 = __webpack_require__(195);
	var Painter_1 = __webpack_require__(448);
	zrender_1.registerPainter('canvas', Painter_1["default"]);


/***/ },
/* 450 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	exports.__esModule = true;
	var util_1 = __webpack_require__(179);
	var PI2 = Math.PI * 2;
	function containStroke(cx, cy, r, startAngle, endAngle, anticlockwise, lineWidth, x, y) {
	    if (lineWidth === 0) {
	        return false;
	    }
	    var _l = lineWidth;
	    x -= cx;
	    y -= cy;
	    var d = Math.sqrt(x * x + y * y);
	    if ((d - _l > r) || (d + _l < r)) {
	        return false;
	    }
	    if (Math.abs(startAngle - endAngle) % PI2 < 1e-4) {
	        return true;
	    }
	    if (anticlockwise) {
	        var tmp = startAngle;
	        startAngle = util_1.normalizeRadian(endAngle);
	        endAngle = util_1.normalizeRadian(tmp);
	    }
	    else {
	        startAngle = util_1.normalizeRadian(startAngle);
	        endAngle = util_1.normalizeRadian(endAngle);
	    }
	    if (startAngle > endAngle) {
	        endAngle += PI2;
	    }
	    var angle = Math.atan2(y, x);
	    if (angle < 0) {
	        angle += PI2;
	    }
	    return (angle >= startAngle && angle <= endAngle)
	        || (angle + PI2 >= startAngle && angle + PI2 <= endAngle);
	}
	exports.containStroke = containStroke;


/***/ },
/* 451 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	exports.__esModule = true;
	var curve = __webpack_require__(33);
	function containStroke(x0, y0, x1, y1, x2, y2, x3, y3, lineWidth, x, y) {
	    if (lineWidth === 0) {
	        return false;
	    }
	    var _l = lineWidth;
	    if ((y > y0 + _l && y > y1 + _l && y > y2 + _l && y > y3 + _l)
	        || (y < y0 - _l && y < y1 - _l && y < y2 - _l && y < y3 - _l)
	        || (x > x0 + _l && x > x1 + _l && x > x2 + _l && x > x3 + _l)
	        || (x < x0 - _l && x < x1 - _l && x < x2 - _l && x < x3 - _l)) {
	        return false;
	    }
	    var d = curve.cubicProjectPoint(x0, y0, x1, y1, x2, y2, x3, y3, x, y, null);
	    return d <= _l / 2;
	}
	exports.containStroke = containStroke;


/***/ },
/* 452 */
/***/ function(module, exports) {

	"use strict";
	exports.__esModule = true;
	function containStroke(x0, y0, x1, y1, lineWidth, x, y) {
	    if (lineWidth === 0) {
	        return false;
	    }
	    var _l = lineWidth;
	    var _a = 0;
	    var _b = x0;
	    if ((y > y0 + _l && y > y1 + _l)
	        || (y < y0 - _l && y < y1 - _l)
	        || (x > x0 + _l && x > x1 + _l)
	        || (x < x0 - _l && x < x1 - _l)) {
	        return false;
	    }
	    if (x0 !== x1) {
	        _a = (y0 - y1) / (x0 - x1);
	        _b = (x0 * y1 - x1 * y0) / (x0 - x1);
	    }
	    else {
	        return Math.abs(x - x0) <= _l / 2;
	    }
	    var tmp = _a * x - y + _b;
	    var _s = tmp * tmp / (_a * _a + 1);
	    return _s <= _l / 2 * _l / 2;
	}
	exports.containStroke = containStroke;


/***/ },
/* 453 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	exports.__esModule = true;
	var PathProxy_1 = __webpack_require__(32);
	var line = __webpack_require__(452);
	var cubic = __webpack_require__(451);
	var quadratic = __webpack_require__(454);
	var arc = __webpack_require__(450);
	var curve = __webpack_require__(33);
	var windingLine_1 = __webpack_require__(455);
	var CMD = PathProxy_1["default"].CMD;
	var PI2 = Math.PI * 2;
	var EPSILON = 1e-4;
	function isAroundEqual(a, b) {
	    return Math.abs(a - b) < EPSILON;
	}
	var roots = [-1, -1, -1];
	var extrema = [-1, -1];
	function swapExtrema() {
	    var tmp = extrema[0];
	    extrema[0] = extrema[1];
	    extrema[1] = tmp;
	}
	function windingCubic(x0, y0, x1, y1, x2, y2, x3, y3, x, y) {
	    if ((y > y0 && y > y1 && y > y2 && y > y3)
	        || (y < y0 && y < y1 && y < y2 && y < y3)) {
	        return 0;
	    }
	    var nRoots = curve.cubicRootAt(y0, y1, y2, y3, y, roots);
	    if (nRoots === 0) {
	        return 0;
	    }
	    else {
	        var w = 0;
	        var nExtrema = -1;
	        var y0_ = void 0;
	        var y1_ = void 0;
	        for (var i = 0; i < nRoots; i++) {
	            var t = roots[i];
	            var unit = (t === 0 || t === 1) ? 0.5 : 1;
	            var x_ = curve.cubicAt(x0, x1, x2, x3, t);
	            if (x_ < x) {
	                continue;
	            }
	            if (nExtrema < 0) {
	                nExtrema = curve.cubicExtrema(y0, y1, y2, y3, extrema);
	                if (extrema[1] < extrema[0] && nExtrema > 1) {
	                    swapExtrema();
	                }
	                y0_ = curve.cubicAt(y0, y1, y2, y3, extrema[0]);
	                if (nExtrema > 1) {
	                    y1_ = curve.cubicAt(y0, y1, y2, y3, extrema[1]);
	                }
	            }
	            if (nExtrema === 2) {
	                if (t < extrema[0]) {
	                    w += y0_ < y0 ? unit : -unit;
	                }
	                else if (t < extrema[1]) {
	                    w += y1_ < y0_ ? unit : -unit;
	                }
	                else {
	                    w += y3 < y1_ ? unit : -unit;
	                }
	            }
	            else {
	                if (t < extrema[0]) {
	                    w += y0_ < y0 ? unit : -unit;
	                }
	                else {
	                    w += y3 < y0_ ? unit : -unit;
	                }
	            }
	        }
	        return w;
	    }
	}
	function windingQuadratic(x0, y0, x1, y1, x2, y2, x, y) {
	    if ((y > y0 && y > y1 && y > y2)
	        || (y < y0 && y < y1 && y < y2)) {
	        return 0;
	    }
	    var nRoots = curve.quadraticRootAt(y0, y1, y2, y, roots);
	    if (nRoots === 0) {
	        return 0;
	    }
	    else {
	        var t = curve.quadraticExtremum(y0, y1, y2);
	        if (t >= 0 && t <= 1) {
	            var w = 0;
	            var y_ = curve.quadraticAt(y0, y1, y2, t);
	            for (var i = 0; i < nRoots; i++) {
	                var unit = (roots[i] === 0 || roots[i] === 1) ? 0.5 : 1;
	                var x_ = curve.quadraticAt(x0, x1, x2, roots[i]);
	                if (x_ < x) {
	                    continue;
	                }
	                if (roots[i] < t) {
	                    w += y_ < y0 ? unit : -unit;
	                }
	                else {
	                    w += y2 < y_ ? unit : -unit;
	                }
	            }
	            return w;
	        }
	        else {
	            var unit = (roots[0] === 0 || roots[0] === 1) ? 0.5 : 1;
	            var x_ = curve.quadraticAt(x0, x1, x2, roots[0]);
	            if (x_ < x) {
	                return 0;
	            }
	            return y2 < y0 ? unit : -unit;
	        }
	    }
	}
	function windingArc(cx, cy, r, startAngle, endAngle, anticlockwise, x, y) {
	    y -= cy;
	    if (y > r || y < -r) {
	        return 0;
	    }
	    var tmp = Math.sqrt(r * r - y * y);
	    roots[0] = -tmp;
	    roots[1] = tmp;
	    var dTheta = Math.abs(startAngle - endAngle);
	    if (dTheta < 1e-4) {
	        return 0;
	    }
	    if (dTheta >= PI2 - 1e-4) {
	        startAngle = 0;
	        endAngle = PI2;
	        var dir = anticlockwise ? 1 : -1;
	        if (x >= roots[0] + cx && x <= roots[1] + cx) {
	            return dir;
	        }
	        else {
	            return 0;
	        }
	    }
	    if (startAngle > endAngle) {
	        var tmp_1 = startAngle;
	        startAngle = endAngle;
	        endAngle = tmp_1;
	    }
	    if (startAngle < 0) {
	        startAngle += PI2;
	        endAngle += PI2;
	    }
	    var w = 0;
	    for (var i = 0; i < 2; i++) {
	        var x_ = roots[i];
	        if (x_ + cx > x) {
	            var angle = Math.atan2(y, x_);
	            var dir = anticlockwise ? 1 : -1;
	            if (angle < 0) {
	                angle = PI2 + angle;
	            }
	            if ((angle >= startAngle && angle <= endAngle)
	                || (angle + PI2 >= startAngle && angle + PI2 <= endAngle)) {
	                if (angle > Math.PI / 2 && angle < Math.PI * 1.5) {
	                    dir = -dir;
	                }
	                w += dir;
	            }
	        }
	    }
	    return w;
	}
	function containPath(path, lineWidth, isStroke, x, y) {
	    var data = path.data;
	    var len = path.len();
	    var w = 0;
	    var xi = 0;
	    var yi = 0;
	    var x0 = 0;
	    var y0 = 0;
	    var x1;
	    var y1;
	    for (var i = 0; i < len;) {
	        var cmd = data[i++];
	        var isFirst = i === 1;
	        if (cmd === CMD.M && i > 1) {
	            if (!isStroke) {
	                w += windingLine_1["default"](xi, yi, x0, y0, x, y);
	            }
	        }
	        if (isFirst) {
	            xi = data[i];
	            yi = data[i + 1];
	            x0 = xi;
	            y0 = yi;
	        }
	        switch (cmd) {
	            case CMD.M:
	                x0 = data[i++];
	                y0 = data[i++];
	                xi = x0;
	                yi = y0;
	                break;
	            case CMD.L:
	                if (isStroke) {
	                    if (line.containStroke(xi, yi, data[i], data[i + 1], lineWidth, x, y)) {
	                        return true;
	                    }
	                }
	                else {
	                    w += windingLine_1["default"](xi, yi, data[i], data[i + 1], x, y) || 0;
	                }
	                xi = data[i++];
	                yi = data[i++];
	                break;
	            case CMD.C:
	                if (isStroke) {
	                    if (cubic.containStroke(xi, yi, data[i++], data[i++], data[i++], data[i++], data[i], data[i + 1], lineWidth, x, y)) {
	                        return true;
	                    }
	                }
	                else {
	                    w += windingCubic(xi, yi, data[i++], data[i++], data[i++], data[i++], data[i], data[i + 1], x, y) || 0;
	                }
	                xi = data[i++];
	                yi = data[i++];
	                break;
	            case CMD.Q:
	                if (isStroke) {
	                    if (quadratic.containStroke(xi, yi, data[i++], data[i++], data[i], data[i + 1], lineWidth, x, y)) {
	                        return true;
	                    }
	                }
	                else {
	                    w += windingQuadratic(xi, yi, data[i++], data[i++], data[i], data[i + 1], x, y) || 0;
	                }
	                xi = data[i++];
	                yi = data[i++];
	                break;
	            case CMD.A:
	                var cx = data[i++];
	                var cy = data[i++];
	                var rx = data[i++];
	                var ry = data[i++];
	                var theta = data[i++];
	                var dTheta = data[i++];
	                i += 1;
	                var anticlockwise = !!(1 - data[i++]);
	                x1 = Math.cos(theta) * rx + cx;
	                y1 = Math.sin(theta) * ry + cy;
	                if (!isFirst) {
	                    w += windingLine_1["default"](xi, yi, x1, y1, x, y);
	                }
	                else {
	                    x0 = x1;
	                    y0 = y1;
	                }
	                var _x = (x - cx) * ry / rx + cx;
	                if (isStroke) {
	                    if (arc.containStroke(cx, cy, ry, theta, theta + dTheta, anticlockwise, lineWidth, _x, y)) {
	                        return true;
	                    }
	                }
	                else {
	                    w += windingArc(cx, cy, ry, theta, theta + dTheta, anticlockwise, _x, y);
	                }
	                xi = Math.cos(theta + dTheta) * rx + cx;
	                yi = Math.sin(theta + dTheta) * ry + cy;
	                break;
	            case CMD.R:
	                x0 = xi = data[i++];
	                y0 = yi = data[i++];
	                var width = data[i++];
	                var height = data[i++];
	                x1 = x0 + width;
	                y1 = y0 + height;
	                if (isStroke) {
	                    if (line.containStroke(x0, y0, x1, y0, lineWidth, x, y)
	                        || line.containStroke(x1, y0, x1, y1, lineWidth, x, y)
	                        || line.containStroke(x1, y1, x0, y1, lineWidth, x, y)
	                        || line.containStroke(x0, y1, x0, y0, lineWidth, x, y)) {
	                        return true;
	                    }
	                }
	                else {
	                    w += windingLine_1["default"](x1, y0, x1, y1, x, y);
	                    w += windingLine_1["default"](x0, y1, x0, y0, x, y);
	                }
	                break;
	            case CMD.Z:
	                if (isStroke) {
	                    if (line.containStroke(xi, yi, x0, y0, lineWidth, x, y)) {
	                        return true;
	                    }
	                }
	                else {
	                    w += windingLine_1["default"](xi, yi, x0, y0, x, y);
	                }
	                xi = x0;
	                yi = y0;
	                break;
	        }
	    }
	    if (!isStroke && !isAroundEqual(yi, y0)) {
	        w += windingLine_1["default"](xi, yi, x0, y0, x, y) || 0;
	    }
	    return w !== 0;
	}
	function contain(pathProxy, x, y) {
	    return containPath(pathProxy, 0, false, x, y);
	}
	exports.contain = contain;
	function containStroke(pathProxy, lineWidth, x, y) {
	    return containPath(pathProxy, lineWidth, true, x, y);
	}
	exports.containStroke = containStroke;


/***/ },
/* 454 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	exports.__esModule = true;
	var curve_1 = __webpack_require__(33);
	function containStroke(x0, y0, x1, y1, x2, y2, lineWidth, x, y) {
	    if (lineWidth === 0) {
	        return false;
	    }
	    var _l = lineWidth;
	    if ((y > y0 + _l && y > y1 + _l && y > y2 + _l)
	        || (y < y0 - _l && y < y1 - _l && y < y2 - _l)
	        || (x > x0 + _l && x > x1 + _l && x > x2 + _l)
	        || (x < x0 - _l && x < x1 - _l && x < x2 - _l)) {
	        return false;
	    }
	    var d = curve_1.quadraticProjectPoint(x0, y0, x1, y1, x2, y2, x, y, null);
	    return d <= _l / 2;
	}
	exports.containStroke = containStroke;


/***/ },
/* 455 */
/***/ function(module, exports) {

	"use strict";
	exports.__esModule = true;
	function windingLine(x0, y0, x1, y1, x, y) {
	    if ((y > y0 && y > y1) || (y < y0 && y < y1)) {
	        return 0;
	    }
	    if (y1 === y0) {
	        return 0;
	    }
	    var t = (y - y0) / (y1 - y0);
	    var dir = y1 < y0 ? 1 : -1;
	    if (t === 1 || t === 0) {
	        dir = y1 < y0 ? 0.5 : -0.5;
	    }
	    var x_ = t * (x1 - x0) + x0;
	    return x_ === x ? Infinity : x_ > x ? dir : 0;
	}
	exports["default"] = windingLine;


/***/ },
/* 456 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	exports.__esModule = true;
	var eventUtil = __webpack_require__(42);
	var GestureMgr = (function () {
	    function GestureMgr() {
	        this._track = [];
	    }
	    GestureMgr.prototype.recognize = function (event, target, root) {
	        this._doTrack(event, target, root);
	        return this._recognize(event);
	    };
	    GestureMgr.prototype.clear = function () {
	        this._track.length = 0;
	        return this;
	    };
	    GestureMgr.prototype._doTrack = function (event, target, root) {
	        var touches = event.touches;
	        if (!touches) {
	            return;
	        }
	        var trackItem = {
	            points: [],
	            touches: [],
	            target: target,
	            event: event
	        };
	        for (var i = 0, len = touches.length; i < len; i++) {
	            var touch = touches[i];
	            var pos = eventUtil.clientToLocal(root, touch, {});
	            trackItem.points.push([pos.zrX, pos.zrY]);
	            trackItem.touches.push(touch);
	        }
	        this._track.push(trackItem);
	    };
	    GestureMgr.prototype._recognize = function (event) {
	        for (var eventName in recognizers) {
	            if (recognizers.hasOwnProperty(eventName)) {
	                var gestureInfo = recognizers[eventName](this._track, event);
	                if (gestureInfo) {
	                    return gestureInfo;
	                }
	            }
	        }
	    };
	    return GestureMgr;
	}());
	exports.GestureMgr = GestureMgr;
	function dist(pointPair) {
	    var dx = pointPair[1][0] - pointPair[0][0];
	    var dy = pointPair[1][1] - pointPair[0][1];
	    return Math.sqrt(dx * dx + dy * dy);
	}
	function center(pointPair) {
	    return [
	        (pointPair[0][0] + pointPair[1][0]) / 2,
	        (pointPair[0][1] + pointPair[1][1]) / 2
	    ];
	}
	var recognizers = {
	    pinch: function (tracks, event) {
	        var trackLen = tracks.length;
	        if (!trackLen) {
	            return;
	        }
	        var pinchEnd = (tracks[trackLen - 1] || {}).points;
	        var pinchPre = (tracks[trackLen - 2] || {}).points || pinchEnd;
	        if (pinchPre
	            && pinchPre.length > 1
	            && pinchEnd
	            && pinchEnd.length > 1) {
	            var pinchScale = dist(pinchEnd) / dist(pinchPre);
	            !isFinite(pinchScale) && (pinchScale = 1);
	            event.pinchScale = pinchScale;
	            var pinchCenter = center(pinchEnd);
	            event.pinchX = pinchCenter[0];
	            event.pinchY = pinchCenter[1];
	            return {
	                type: 'pinch',
	                target: tracks[0].target,
	                event: event
	            };
	        }
	    }
	};


/***/ },
/* 457 */
/***/ function(module, exports) {

	"use strict";
	exports.__esModule = true;
	var wmUniqueIndex = Math.round(Math.random() * 9);
	var WeakMap = (function () {
	    function WeakMap() {
	        this._id = '__ec_inner_' + wmUniqueIndex++;
	    }
	    WeakMap.prototype.get = function (key) {
	        return this._guard(key)[this._id];
	    };
	    WeakMap.prototype.set = function (key, value) {
	        var target = this._guard(key);
	        if (typeof Object.defineProperty === 'function') {
	            Object.defineProperty(target, this._id, {
	                value: value,
	                enumerable: false,
	                configurable: true
	            });
	        }
	        else {
	            target[this._id] = value;
	        }
	        return this;
	    };
	    WeakMap.prototype["delete"] = function (key) {
	        if (this.has(key)) {
	            delete this._guard(key)[this._id];
	            return true;
	        }
	        return false;
	    };
	    WeakMap.prototype.has = function (key) {
	        return !!this._guard(key)[this._id];
	    };
	    WeakMap.prototype._guard = function (key) {
	        if (key !== Object(key)) {
	            throw TypeError('Value of WeakMap is not a non-null object.');
	        }
	        return key;
	    };
	    return WeakMap;
	}());
	exports["default"] = WeakMap;


/***/ },
/* 458 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	exports.__esModule = true;
	var vec2 = __webpack_require__(11);
	var curve = __webpack_require__(33);
	var mathMin = Math.min;
	var mathMax = Math.max;
	var mathSin = Math.sin;
	var mathCos = Math.cos;
	var PI2 = Math.PI * 2;
	var start = vec2.create();
	var end = vec2.create();
	var extremity = vec2.create();
	function fromPoints(points, min, max) {
	    if (points.length === 0) {
	        return;
	    }
	    var p = points[0];
	    var left = p[0];
	    var right = p[0];
	    var top = p[1];
	    var bottom = p[1];
	    for (var i = 1; i < points.length; i++) {
	        p = points[i];
	        left = mathMin(left, p[0]);
	        right = mathMax(right, p[0]);
	        top = mathMin(top, p[1]);
	        bottom = mathMax(bottom, p[1]);
	    }
	    min[0] = left;
	    min[1] = top;
	    max[0] = right;
	    max[1] = bottom;
	}
	exports.fromPoints = fromPoints;
	function fromLine(x0, y0, x1, y1, min, max) {
	    min[0] = mathMin(x0, x1);
	    min[1] = mathMin(y0, y1);
	    max[0] = mathMax(x0, x1);
	    max[1] = mathMax(y0, y1);
	}
	exports.fromLine = fromLine;
	var xDim = [];
	var yDim = [];
	function fromCubic(x0, y0, x1, y1, x2, y2, x3, y3, min, max) {
	    var cubicExtrema = curve.cubicExtrema;
	    var cubicAt = curve.cubicAt;
	    var n = cubicExtrema(x0, x1, x2, x3, xDim);
	    min[0] = Infinity;
	    min[1] = Infinity;
	    max[0] = -Infinity;
	    max[1] = -Infinity;
	    for (var i = 0; i < n; i++) {
	        var x = cubicAt(x0, x1, x2, x3, xDim[i]);
	        min[0] = mathMin(x, min[0]);
	        max[0] = mathMax(x, max[0]);
	    }
	    n = cubicExtrema(y0, y1, y2, y3, yDim);
	    for (var i = 0; i < n; i++) {
	        var y = cubicAt(y0, y1, y2, y3, yDim[i]);
	        min[1] = mathMin(y, min[1]);
	        max[1] = mathMax(y, max[1]);
	    }
	    min[0] = mathMin(x0, min[0]);
	    max[0] = mathMax(x0, max[0]);
	    min[0] = mathMin(x3, min[0]);
	    max[0] = mathMax(x3, max[0]);
	    min[1] = mathMin(y0, min[1]);
	    max[1] = mathMax(y0, max[1]);
	    min[1] = mathMin(y3, min[1]);
	    max[1] = mathMax(y3, max[1]);
	}
	exports.fromCubic = fromCubic;
	function fromQuadratic(x0, y0, x1, y1, x2, y2, min, max) {
	    var quadraticExtremum = curve.quadraticExtremum;
	    var quadraticAt = curve.quadraticAt;
	    var tx = mathMax(mathMin(quadraticExtremum(x0, x1, x2), 1), 0);
	    var ty = mathMax(mathMin(quadraticExtremum(y0, y1, y2), 1), 0);
	    var x = quadraticAt(x0, x1, x2, tx);
	    var y = quadraticAt(y0, y1, y2, ty);
	    min[0] = mathMin(x0, x2, x);
	    min[1] = mathMin(y0, y2, y);
	    max[0] = mathMax(x0, x2, x);
	    max[1] = mathMax(y0, y2, y);
	}
	exports.fromQuadratic = fromQuadratic;
	function fromArc(x, y, rx, ry, startAngle, endAngle, anticlockwise, min, max) {
	    var vec2Min = vec2.min;
	    var vec2Max = vec2.max;
	    var diff = Math.abs(startAngle - endAngle);
	    if (diff % PI2 < 1e-4 && diff > 1e-4) {
	        min[0] = x - rx;
	        min[1] = y - ry;
	        max[0] = x + rx;
	        max[1] = y + ry;
	        return;
	    }
	    start[0] = mathCos(startAngle) * rx + x;
	    start[1] = mathSin(startAngle) * ry + y;
	    end[0] = mathCos(endAngle) * rx + x;
	    end[1] = mathSin(endAngle) * ry + y;
	    vec2Min(min, start, end);
	    vec2Max(max, start, end);
	    startAngle = startAngle % (PI2);
	    if (startAngle < 0) {
	        startAngle = startAngle + PI2;
	    }
	    endAngle = endAngle % (PI2);
	    if (endAngle < 0) {
	        endAngle = endAngle + PI2;
	    }
	    if (startAngle > endAngle && !anticlockwise) {
	        endAngle += PI2;
	    }
	    else if (startAngle < endAngle && anticlockwise) {
	        startAngle += PI2;
	    }
	    if (anticlockwise) {
	        var tmp = endAngle;
	        endAngle = startAngle;
	        startAngle = tmp;
	    }
	    for (var angle = 0; angle < endAngle; angle += Math.PI / 2) {
	        if (angle > startAngle) {
	            extremity[0] = mathCos(angle) * rx + x;
	            extremity[1] = mathSin(angle) * ry + y;
	            vec2Min(min, extremity, min);
	            vec2Max(max, extremity, max);
	        }
	    }
	}
	exports.fromArc = fromArc;


/***/ },
/* 459 */
/***/ function(module, exports) {

	"use strict";
	exports.__esModule = true;
	var LN2 = Math.log(2);
	function determinant(rows, rank, rowStart, rowMask, colMask, detCache) {
	    var cacheKey = rowMask + '-' + colMask;
	    var fullRank = rows.length;
	    if (detCache.hasOwnProperty(cacheKey)) {
	        return detCache[cacheKey];
	    }
	    if (rank === 1) {
	        var colStart = Math.round(Math.log(((1 << fullRank) - 1) & ~colMask) / LN2);
	        return rows[rowStart][colStart];
	    }
	    var subRowMask = rowMask | (1 << rowStart);
	    var subRowStart = rowStart + 1;
	    while (rowMask & (1 << subRowStart)) {
	        subRowStart++;
	    }
	    var sum = 0;
	    for (var j = 0, colLocalIdx = 0; j < fullRank; j++) {
	        var colTag = 1 << j;
	        if (!(colTag & colMask)) {
	            sum += (colLocalIdx % 2 ? -1 : 1) * rows[rowStart][j]
	                * determinant(rows, rank - 1, subRowStart, subRowMask, colMask | colTag, detCache);
	            colLocalIdx++;
	        }
	    }
	    detCache[cacheKey] = sum;
	    return sum;
	}
	function buildTransformer(src, dest) {
	    var mA = [
	        [src[0], src[1], 1, 0, 0, 0, -dest[0] * src[0], -dest[0] * src[1]],
	        [0, 0, 0, src[0], src[1], 1, -dest[1] * src[0], -dest[1] * src[1]],
	        [src[2], src[3], 1, 0, 0, 0, -dest[2] * src[2], -dest[2] * src[3]],
	        [0, 0, 0, src[2], src[3], 1, -dest[3] * src[2], -dest[3] * src[3]],
	        [src[4], src[5], 1, 0, 0, 0, -dest[4] * src[4], -dest[4] * src[5]],
	        [0, 0, 0, src[4], src[5], 1, -dest[5] * src[4], -dest[5] * src[5]],
	        [src[6], src[7], 1, 0, 0, 0, -dest[6] * src[6], -dest[6] * src[7]],
	        [0, 0, 0, src[6], src[7], 1, -dest[7] * src[6], -dest[7] * src[7]]
	    ];
	    var detCache = {};
	    var det = determinant(mA, 8, 0, 0, 0, detCache);
	    if (det === 0) {
	        return;
	    }
	    var vh = [];
	    for (var i = 0; i < 8; i++) {
	        for (var j = 0; j < 8; j++) {
	            vh[j] == null && (vh[j] = 0);
	            vh[j] += ((i + j) % 2 ? -1 : 1)
	                * determinant(mA, 7, i === 0 ? 1 : 0, 1 << i, 1 << j, detCache)
	                / det * dest[i];
	        }
	    }
	    return function (out, srcPointX, srcPointY) {
	        var pk = srcPointX * vh[6] + srcPointY * vh[7] + 1;
	        out[0] = (srcPointX * vh[0] + srcPointY * vh[1] + vh[2]) / pk;
	        out[1] = (srcPointX * vh[3] + srcPointY * vh[4] + vh[5]) / pk;
	    };
	}
	exports.buildTransformer = buildTransformer;


/***/ },
/* 460 */
/***/ function(module, exports) {

	"use strict";
	exports.__esModule = true;
	var DebugRect = (function () {
	    function DebugRect(style) {
	        var dom = this.dom = document.createElement('div');
	        dom.className = 'ec-debug-dirty-rect';
	        style = Object.assign({}, style);
	        Object.assign(style, {
	            backgroundColor: 'rgba(0, 0, 255, 0.2)',
	            border: '1px solid #00f'
	        });
	        dom.style.cssText = "\nposition: absolute;\nopacity: 0;\ntransition: opacity 0.5s linear;\npointer-events: none;\n";
	        for (var key in style) {
	            if (style.hasOwnProperty(key)) {
	                dom.style[key] = style[key];
	            }
	        }
	    }
	    DebugRect.prototype.update = function (rect) {
	        var domStyle = this.dom.style;
	        domStyle.width = rect.width + 'px';
	        domStyle.height = rect.height + 'px';
	        domStyle.left = rect.x + 'px';
	        domStyle.top = rect.y + 'px';
	    };
	    DebugRect.prototype.hide = function () {
	        this.dom.style.opacity = '0';
	    };
	    DebugRect.prototype.show = function (autoHideDelay) {
	        var _this = this;
	        clearTimeout(this._hideTimeout);
	        this.dom.style.opacity = '1';
	        this._hideTimeout = setTimeout(function () {
	            _this.hide();
	        }, autoHideDelay || 1000);
	    };
	    return DebugRect;
	}());
	function showDebugDirtyRect(zr, opts) {
	    opts = opts || {};
	    var painter = zr.painter;
	    if (!painter.getLayers) {
	        throw new Error('Debug dirty rect can only been used on canvas renderer.');
	    }
	    if (painter.isSingleCanvas()) {
	        throw new Error('Debug dirty rect can only been used on zrender inited with container.');
	    }
	    var debugViewRoot = document.createElement('div');
	    debugViewRoot.style.cssText = "\nposition:absolute;\nleft:0;\ntop:0;\nright:0;\nbottom:0;\npointer-events:none;\n";
	    debugViewRoot.className = 'ec-debug-dirty-rect-container';
	    var debugRects = [];
	    var dom = zr.dom;
	    dom.appendChild(debugViewRoot);
	    var computedStyle = getComputedStyle(dom);
	    if (computedStyle.position === 'static') {
	        dom.style.position = 'relative';
	    }
	    zr.on('rendered', function () {
	        if (painter.getLayers) {
	            var idx_1 = 0;
	            painter.eachBuiltinLayer(function (layer) {
	                if (!layer.debugGetPaintRects) {
	                    return;
	                }
	                var paintRects = layer.debugGetPaintRects();
	                for (var i = 0; i < paintRects.length; i++) {
	                    if (!paintRects[i].width || !paintRects[i].height) {
	                        continue;
	                    }
	                    if (!debugRects[idx_1]) {
	                        debugRects[idx_1] = new DebugRect(opts.style);
	                        debugViewRoot.appendChild(debugRects[idx_1].dom);
	                    }
	                    debugRects[idx_1].show(opts.autoHideDelay);
	                    debugRects[idx_1].update(paintRects[i]);
	                    idx_1++;
	                }
	            });
	            for (var i = idx_1; i < debugRects.length; i++) {
	                debugRects[i].hide();
	            }
	        }
	    });
	}
	exports["default"] = showDebugDirtyRect;


/***/ },
/* 461 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	exports.__esModule = true;
	var tslib_1 = __webpack_require__(5);
	var event_1 = __webpack_require__(42);
	var zrUtil = __webpack_require__(1);
	var Eventful_1 = __webpack_require__(37);
	var env_1 = __webpack_require__(13);
	var TOUCH_CLICK_DELAY = 300;
	var globalEventSupported = env_1["default"].domSupported;
	var localNativeListenerNames = (function () {
	    var mouseHandlerNames = [
	        'click', 'dblclick', 'mousewheel', 'wheel', 'mouseout',
	        'mouseup', 'mousedown', 'mousemove', 'contextmenu'
	    ];
	    var touchHandlerNames = [
	        'touchstart', 'touchend', 'touchmove'
	    ];
	    var pointerEventNameMap = {
	        pointerdown: 1, pointerup: 1, pointermove: 1, pointerout: 1
	    };
	    var pointerHandlerNames = zrUtil.map(mouseHandlerNames, function (name) {
	        var nm = name.replace('mouse', 'pointer');
	        return pointerEventNameMap.hasOwnProperty(nm) ? nm : name;
	    });
	    return {
	        mouse: mouseHandlerNames,
	        touch: touchHandlerNames,
	        pointer: pointerHandlerNames
	    };
	})();
	var globalNativeListenerNames = {
	    mouse: ['mousemove', 'mouseup'],
	    pointer: ['pointermove', 'pointerup']
	};
	var wheelEventSupported = false;
	function isPointerFromTouch(event) {
	    var pointerType = event.pointerType;
	    return pointerType === 'pen' || pointerType === 'touch';
	}
	function setTouchTimer(scope) {
	    scope.touching = true;
	    if (scope.touchTimer != null) {
	        clearTimeout(scope.touchTimer);
	        scope.touchTimer = null;
	    }
	    scope.touchTimer = setTimeout(function () {
	        scope.touching = false;
	        scope.touchTimer = null;
	    }, 700);
	}
	function markTouch(event) {
	    event && (event.zrByTouch = true);
	}
	function normalizeGlobalEvent(instance, event) {
	    return event_1.normalizeEvent(instance.dom, new FakeGlobalEvent(instance, event), true);
	}
	function isLocalEl(instance, el) {
	    var elTmp = el;
	    var isLocal = false;
	    while (elTmp && elTmp.nodeType !== 9
	        && !(isLocal = elTmp.domBelongToZr
	            || (elTmp !== el && elTmp === instance.painterRoot))) {
	        elTmp = elTmp.parentNode;
	    }
	    return isLocal;
	}
	var FakeGlobalEvent = (function () {
	    function FakeGlobalEvent(instance, event) {
	        this.stopPropagation = zrUtil.noop;
	        this.stopImmediatePropagation = zrUtil.noop;
	        this.preventDefault = zrUtil.noop;
	        this.type = event.type;
	        this.target = this.currentTarget = instance.dom;
	        this.pointerType = event.pointerType;
	        this.clientX = event.clientX;
	        this.clientY = event.clientY;
	    }
	    return FakeGlobalEvent;
	}());
	var localDOMHandlers = {
	    mousedown: function (event) {
	        event = event_1.normalizeEvent(this.dom, event);
	        this.__mayPointerCapture = [event.zrX, event.zrY];
	        this.trigger('mousedown', event);
	    },
	    mousemove: function (event) {
	        event = event_1.normalizeEvent(this.dom, event);
	        var downPoint = this.__mayPointerCapture;
	        if (downPoint && (event.zrX !== downPoint[0] || event.zrY !== downPoint[1])) {
	            this.__togglePointerCapture(true);
	        }
	        this.trigger('mousemove', event);
	    },
	    mouseup: function (event) {
	        event = event_1.normalizeEvent(this.dom, event);
	        this.__togglePointerCapture(false);
	        this.trigger('mouseup', event);
	    },
	    mouseout: function (event) {
	        if (event.target !== this.dom) {
	            return;
	        }
	        event = event_1.normalizeEvent(this.dom, event);
	        if (this.__pointerCapturing) {
	            event.zrEventControl = 'no_globalout';
	        }
	        var element = event.toElement || event.relatedTarget;
	        event.zrIsToLocalDOM = isLocalEl(this, element);
	        this.trigger('mouseout', event);
	    },
	    wheel: function (event) {
	        wheelEventSupported = true;
	        event = event_1.normalizeEvent(this.dom, event);
	        this.trigger('mousewheel', event);
	    },
	    mousewheel: function (event) {
	        if (wheelEventSupported) {
	            return;
	        }
	        event = event_1.normalizeEvent(this.dom, event);
	        this.trigger('mousewheel', event);
	    },
	    touchstart: function (event) {
	        event = event_1.normalizeEvent(this.dom, event);
	        markTouch(event);
	        this.__lastTouchMoment = new Date();
	        this.handler.processGesture(event, 'start');
	        localDOMHandlers.mousemove.call(this, event);
	        localDOMHandlers.mousedown.call(this, event);
	    },
	    touchmove: function (event) {
	        event = event_1.normalizeEvent(this.dom, event);
	        markTouch(event);
	        this.handler.processGesture(event, 'change');
	        localDOMHandlers.mousemove.call(this, event);
	    },
	    touchend: function (event) {
	        event = event_1.normalizeEvent(this.dom, event);
	        markTouch(event);
	        this.handler.processGesture(event, 'end');
	        localDOMHandlers.mouseup.call(this, event);
	        if (+new Date() - (+this.__lastTouchMoment) < TOUCH_CLICK_DELAY) {
	            localDOMHandlers.click.call(this, event);
	        }
	    },
	    pointerdown: function (event) {
	        localDOMHandlers.mousedown.call(this, event);
	    },
	    pointermove: function (event) {
	        if (!isPointerFromTouch(event)) {
	            localDOMHandlers.mousemove.call(this, event);
	        }
	    },
	    pointerup: function (event) {
	        localDOMHandlers.mouseup.call(this, event);
	    },
	    pointerout: function (event) {
	        if (!isPointerFromTouch(event)) {
	            localDOMHandlers.mouseout.call(this, event);
	        }
	    }
	};
	zrUtil.each(['click', 'dblclick', 'contextmenu'], function (name) {
	    localDOMHandlers[name] = function (event) {
	        event = event_1.normalizeEvent(this.dom, event);
	        this.trigger(name, event);
	    };
	});
	var globalDOMHandlers = {
	    pointermove: function (event) {
	        if (!isPointerFromTouch(event)) {
	            globalDOMHandlers.mousemove.call(this, event);
	        }
	    },
	    pointerup: function (event) {
	        globalDOMHandlers.mouseup.call(this, event);
	    },
	    mousemove: function (event) {
	        this.trigger('mousemove', event);
	    },
	    mouseup: function (event) {
	        var pointerCaptureReleasing = this.__pointerCapturing;
	        this.__togglePointerCapture(false);
	        this.trigger('mouseup', event);
	        if (pointerCaptureReleasing) {
	            event.zrEventControl = 'only_globalout';
	            this.trigger('mouseout', event);
	        }
	    }
	};
	function mountLocalDOMEventListeners(instance, scope) {
	    var domHandlers = scope.domHandlers;
	    if (env_1["default"].pointerEventsSupported) {
	        zrUtil.each(localNativeListenerNames.pointer, function (nativeEventName) {
	            mountSingleDOMEventListener(scope, nativeEventName, function (event) {
	                domHandlers[nativeEventName].call(instance, event);
	            });
	        });
	    }
	    else {
	        if (env_1["default"].touchEventsSupported) {
	            zrUtil.each(localNativeListenerNames.touch, function (nativeEventName) {
	                mountSingleDOMEventListener(scope, nativeEventName, function (event) {
	                    domHandlers[nativeEventName].call(instance, event);
	                    setTouchTimer(scope);
	                });
	            });
	        }
	        zrUtil.each(localNativeListenerNames.mouse, function (nativeEventName) {
	            mountSingleDOMEventListener(scope, nativeEventName, function (event) {
	                event = event_1.getNativeEvent(event);
	                if (!scope.touching) {
	                    domHandlers[nativeEventName].call(instance, event);
	                }
	            });
	        });
	    }
	}
	function mountGlobalDOMEventListeners(instance, scope) {
	    if (env_1["default"].pointerEventsSupported) {
	        zrUtil.each(globalNativeListenerNames.pointer, mount);
	    }
	    else if (!env_1["default"].touchEventsSupported) {
	        zrUtil.each(globalNativeListenerNames.mouse, mount);
	    }
	    function mount(nativeEventName) {
	        function nativeEventListener(event) {
	            event = event_1.getNativeEvent(event);
	            if (!isLocalEl(instance, event.target)) {
	                event = normalizeGlobalEvent(instance, event);
	                scope.domHandlers[nativeEventName].call(instance, event);
	            }
	        }
	        mountSingleDOMEventListener(scope, nativeEventName, nativeEventListener, { capture: true });
	    }
	}
	function mountSingleDOMEventListener(scope, nativeEventName, listener, opt) {
	    scope.mounted[nativeEventName] = listener;
	    scope.listenerOpts[nativeEventName] = opt;
	    event_1.addEventListener(scope.domTarget, nativeEventName, listener, opt);
	}
	function unmountDOMEventListeners(scope) {
	    var mounted = scope.mounted;
	    for (var nativeEventName in mounted) {
	        if (mounted.hasOwnProperty(nativeEventName)) {
	            event_1.removeEventListener(scope.domTarget, nativeEventName, mounted[nativeEventName], scope.listenerOpts[nativeEventName]);
	        }
	    }
	    scope.mounted = {};
	}
	var DOMHandlerScope = (function () {
	    function DOMHandlerScope(domTarget, domHandlers) {
	        this.mounted = {};
	        this.listenerOpts = {};
	        this.touching = false;
	        this.domTarget = domTarget;
	        this.domHandlers = domHandlers;
	    }
	    return DOMHandlerScope;
	}());
	var HandlerDomProxy = (function (_super) {
	    tslib_1.__extends(HandlerDomProxy, _super);
	    function HandlerDomProxy(dom, painterRoot) {
	        var _this = _super.call(this) || this;
	        _this.__pointerCapturing = false;
	        _this.dom = dom;
	        _this.painterRoot = painterRoot;
	        _this._localHandlerScope = new DOMHandlerScope(dom, localDOMHandlers);
	        if (globalEventSupported) {
	            _this._globalHandlerScope = new DOMHandlerScope(document, globalDOMHandlers);
	        }
	        mountLocalDOMEventListeners(_this, _this._localHandlerScope);
	        return _this;
	    }
	    HandlerDomProxy.prototype.dispose = function () {
	        unmountDOMEventListeners(this._localHandlerScope);
	        if (globalEventSupported) {
	            unmountDOMEventListeners(this._globalHandlerScope);
	        }
	    };
	    HandlerDomProxy.prototype.setCursor = function (cursorStyle) {
	        this.dom.style && (this.dom.style.cursor = cursorStyle || 'default');
	    };
	    HandlerDomProxy.prototype.__togglePointerCapture = function (isPointerCapturing) {
	        this.__mayPointerCapture = null;
	        if (globalEventSupported
	            && ((+this.__pointerCapturing) ^ (+isPointerCapturing))) {
	            this.__pointerCapturing = isPointerCapturing;
	            var globalHandlerScope = this._globalHandlerScope;
	            isPointerCapturing
	                ? mountGlobalDOMEventListeners(this, globalHandlerScope)
	                : unmountDOMEventListeners(globalHandlerScope);
	        }
	    };
	    return HandlerDomProxy;
	}(Eventful_1["default"]));
	exports["default"] = HandlerDomProxy;


/***/ },
/* 462 */
/***/ function(module, exports) {

	"use strict";
	exports.__esModule = true;
	var Pattern = (function () {
	    function Pattern(image, repeat) {
	        this.image = image;
	        this.repeat = repeat;
	        this.x = 0;
	        this.y = 0;
	        this.rotation = 0;
	        this.scaleX = 1;
	        this.scaleY = 1;
	    }
	    return Pattern;
	}());
	exports["default"] = Pattern;


/***/ },
/* 463 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	exports.__esModule = true;
	var util_1 = __webpack_require__(1);
	function normalizeLineDash(lineType, lineWidth) {
	    if (!lineType || lineType === 'solid' || !(lineWidth > 0)) {
	        return null;
	    }
	    lineWidth = lineWidth || 1;
	    return lineType === 'dashed'
	        ? [4 * lineWidth, 2 * lineWidth]
	        : lineType === 'dotted'
	            ? [lineWidth]
	            : util_1.isNumber(lineType)
	                ? [lineType] : util_1.isArray(lineType) ? lineType : null;
	}
	exports.normalizeLineDash = normalizeLineDash;


/***/ },
/* 464 */
/***/ function(module, exports) {

	"use strict";
	exports.__esModule = true;
	function buildPath(ctx, shape) {
	    var x = shape.x;
	    var y = shape.y;
	    var width = shape.width;
	    var height = shape.height;
	    var r = shape.r;
	    var r1;
	    var r2;
	    var r3;
	    var r4;
	    if (width < 0) {
	        x = x + width;
	        width = -width;
	    }
	    if (height < 0) {
	        y = y + height;
	        height = -height;
	    }
	    if (typeof r === 'number') {
	        r1 = r2 = r3 = r4 = r;
	    }
	    else if (r instanceof Array) {
	        if (r.length === 1) {
	            r1 = r2 = r3 = r4 = r[0];
	        }
	        else if (r.length === 2) {
	            r1 = r3 = r[0];
	            r2 = r4 = r[1];
	        }
	        else if (r.length === 3) {
	            r1 = r[0];
	            r2 = r4 = r[1];
	            r3 = r[2];
	        }
	        else {
	            r1 = r[0];
	            r2 = r[1];
	            r3 = r[2];
	            r4 = r[3];
	        }
	    }
	    else {
	        r1 = r2 = r3 = r4 = 0;
	    }
	    var total;
	    if (r1 + r2 > width) {
	        total = r1 + r2;
	        r1 *= width / total;
	        r2 *= width / total;
	    }
	    if (r3 + r4 > width) {
	        total = r3 + r4;
	        r3 *= width / total;
	        r4 *= width / total;
	    }
	    if (r2 + r3 > height) {
	        total = r2 + r3;
	        r2 *= height / total;
	        r3 *= height / total;
	    }
	    if (r1 + r4 > height) {
	        total = r1 + r4;
	        r1 *= height / total;
	        r4 *= height / total;
	    }
	    ctx.moveTo(x + r1, y);
	    ctx.lineTo(x + width - r2, y);
	    r2 !== 0 && ctx.arc(x + width - r2, y + r2, r2, -Math.PI / 2, 0);
	    ctx.lineTo(x + width, y + height - r3);
	    r3 !== 0 && ctx.arc(x + width - r3, y + height - r3, r3, 0, Math.PI / 2);
	    ctx.lineTo(x + r4, y + height);
	    r4 !== 0 && ctx.arc(x + r4, y + height - r4, r4, Math.PI / 2, Math.PI);
	    ctx.lineTo(x, y + r1);
	    r1 !== 0 && ctx.arc(x + r1, y + r1, r1, Math.PI, Math.PI * 1.5);
	}
	exports.buildPath = buildPath;


/***/ },
/* 465 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	exports.__esModule = true;
	var PathProxy_1 = __webpack_require__(32);
	var PI = Math.PI;
	var PI2 = PI * 2;
	var mathSin = Math.sin;
	var mathCos = Math.cos;
	var mathACos = Math.acos;
	var mathATan2 = Math.atan2;
	var mathAbs = Math.abs;
	var mathSqrt = Math.sqrt;
	var mathMax = Math.max;
	var mathMin = Math.min;
	var e = 1e-4;
	function intersect(x0, y0, x1, y1, x2, y2, x3, y3) {
	    var x10 = x1 - x0;
	    var y10 = y1 - y0;
	    var x32 = x3 - x2;
	    var y32 = y3 - y2;
	    var t = y32 * x10 - x32 * y10;
	    if (t * t < e) {
	        return;
	    }
	    t = (x32 * (y0 - y2) - y32 * (x0 - x2)) / t;
	    return [x0 + t * x10, y0 + t * y10];
	}
	function computeCornerTangents(x0, y0, x1, y1, radius, cr, clockwise) {
	    var x01 = x0 - x1;
	    var y01 = y0 - y1;
	    var lo = (clockwise ? cr : -cr) / mathSqrt(x01 * x01 + y01 * y01);
	    var ox = lo * y01;
	    var oy = -lo * x01;
	    var x11 = x0 + ox;
	    var y11 = y0 + oy;
	    var x10 = x1 + ox;
	    var y10 = y1 + oy;
	    var x00 = (x11 + x10) / 2;
	    var y00 = (y11 + y10) / 2;
	    var dx = x10 - x11;
	    var dy = y10 - y11;
	    var d2 = dx * dx + dy * dy;
	    var r = radius - cr;
	    var s = x11 * y10 - x10 * y11;
	    var d = (dy < 0 ? -1 : 1) * mathSqrt(mathMax(0, r * r * d2 - s * s));
	    var cx0 = (s * dy - dx * d) / d2;
	    var cy0 = (-s * dx - dy * d) / d2;
	    var cx1 = (s * dy + dx * d) / d2;
	    var cy1 = (-s * dx + dy * d) / d2;
	    var dx0 = cx0 - x00;
	    var dy0 = cy0 - y00;
	    var dx1 = cx1 - x00;
	    var dy1 = cy1 - y00;
	    if (dx0 * dx0 + dy0 * dy0 > dx1 * dx1 + dy1 * dy1) {
	        cx0 = cx1;
	        cy0 = cy1;
	    }
	    return {
	        cx: cx0,
	        cy: cy0,
	        x01: -ox,
	        y01: -oy,
	        x11: cx0 * (radius / r - 1),
	        y11: cy0 * (radius / r - 1)
	    };
	}
	function buildPath(ctx, shape) {
	    var radius = mathMax(shape.r, 0);
	    var innerRadius = mathMax(shape.r0 || 0, 0);
	    var hasRadius = radius > 0;
	    var hasInnerRadius = innerRadius > 0;
	    if (!hasRadius && !hasInnerRadius) {
	        return;
	    }
	    if (!hasRadius) {
	        radius = innerRadius;
	        innerRadius = 0;
	    }
	    if (innerRadius > radius) {
	        var tmp = radius;
	        radius = innerRadius;
	        innerRadius = tmp;
	    }
	    var clockwise = !!shape.clockwise;
	    var startAngle = shape.startAngle;
	    var endAngle = shape.endAngle;
	    var tmpAngles = [startAngle, endAngle];
	    PathProxy_1.normalizeArcAngles(tmpAngles, !clockwise);
	    var arc = mathAbs(tmpAngles[0] - tmpAngles[1]);
	    var x = shape.cx;
	    var y = shape.cy;
	    var cornerRadius = shape.cornerRadius || 0;
	    var innerCornerRadius = shape.innerCornerRadius || 0;
	    if (!(radius > e)) {
	        ctx.moveTo(x, y);
	    }
	    else if (arc > PI2 - e) {
	        ctx.moveTo(x + radius * mathCos(startAngle), y + radius * mathSin(startAngle));
	        ctx.arc(x, y, radius, startAngle, endAngle, !clockwise);
	        if (innerRadius > e) {
	            ctx.moveTo(x + innerRadius * mathCos(endAngle), y + innerRadius * mathSin(endAngle));
	            ctx.arc(x, y, innerRadius, endAngle, startAngle, clockwise);
	        }
	    }
	    else {
	        var halfRd = mathAbs(radius - innerRadius) / 2;
	        var cr = mathMin(halfRd, cornerRadius);
	        var icr = mathMin(halfRd, innerCornerRadius);
	        var cr0 = icr;
	        var cr1 = cr;
	        var xrs = radius * mathCos(startAngle);
	        var yrs = radius * mathSin(startAngle);
	        var xire = innerRadius * mathCos(endAngle);
	        var yire = innerRadius * mathSin(endAngle);
	        var xre = void 0;
	        var yre = void 0;
	        var xirs = void 0;
	        var yirs = void 0;
	        if (cr > e || icr > e) {
	            xre = radius * mathCos(endAngle);
	            yre = radius * mathSin(endAngle);
	            xirs = innerRadius * mathCos(startAngle);
	            yirs = innerRadius * mathSin(startAngle);
	            if (arc < PI) {
	                var it_1 = intersect(xrs, yrs, xirs, yirs, xre, yre, xire, yire);
	                if (it_1) {
	                    var x0 = xrs - it_1[0];
	                    var y0 = yrs - it_1[1];
	                    var x1 = xre - it_1[0];
	                    var y1 = yre - it_1[1];
	                    var a = 1 / mathSin(mathACos((x0 * x1 + y0 * y1) / (mathSqrt(x0 * x0 + y0 * y0) * mathSqrt(x1 * x1 + y1 * y1))) / 2);
	                    var b = mathSqrt(it_1[0] * it_1[0] + it_1[1] * it_1[1]);
	                    cr0 = mathMin(icr, (innerRadius - b) / (a - 1));
	                    cr1 = mathMin(cr, (radius - b) / (a + 1));
	                }
	            }
	        }
	        if (!(arc > e)) {
	            ctx.moveTo(x + xrs, y + yrs);
	        }
	        else if (cr1 > e) {
	            var ct0 = computeCornerTangents(xirs, yirs, xrs, yrs, radius, cr1, clockwise);
	            var ct1 = computeCornerTangents(xre, yre, xire, yire, radius, cr1, clockwise);
	            ctx.moveTo(x + ct0.cx + ct0.x01, y + ct0.cy + ct0.y01);
	            if (cr1 < cr) {
	                ctx.arc(x + ct0.cx, y + ct0.cy, cr1, mathATan2(ct0.y01, ct0.x01), mathATan2(ct1.y01, ct1.x01), !clockwise);
	            }
	            else {
	                ctx.arc(x + ct0.cx, y + ct0.cy, cr1, mathATan2(ct0.y01, ct0.x01), mathATan2(ct0.y11, ct0.x11), !clockwise);
	                ctx.arc(x, y, radius, mathATan2(ct0.cy + ct0.y11, ct0.cx + ct0.x11), mathATan2(ct1.cy + ct1.y11, ct1.cx + ct1.x11), !clockwise);
	                ctx.arc(x + ct1.cx, y + ct1.cy, cr1, mathATan2(ct1.y11, ct1.x11), mathATan2(ct1.y01, ct1.x01), !clockwise);
	            }
	        }
	        else {
	            ctx.moveTo(x + xrs, y + yrs);
	            ctx.arc(x, y, radius, startAngle, endAngle, !clockwise);
	        }
	        if (!(innerRadius > e) || !(arc > e)) {
	            ctx.lineTo(x + xire, y + yire);
	        }
	        else if (cr0 > e) {
	            var ct0 = computeCornerTangents(xire, yire, xre, yre, innerRadius, -cr0, clockwise);
	            var ct1 = computeCornerTangents(xrs, yrs, xirs, yirs, innerRadius, -cr0, clockwise);
	            ctx.lineTo(x + ct0.cx + ct0.x01, y + ct0.cy + ct0.y01);
	            if (cr0 < icr) {
	                ctx.arc(x + ct0.cx, y + ct0.cy, cr0, mathATan2(ct0.y01, ct0.x01), mathATan2(ct1.y01, ct1.x01), !clockwise);
	            }
	            else {
	                ctx.arc(x + ct0.cx, y + ct0.cy, cr0, mathATan2(ct0.y01, ct0.x01), mathATan2(ct0.y11, ct0.x11), !clockwise);
	                ctx.arc(x, y, innerRadius, mathATan2(ct0.cy + ct0.y11, ct0.cx + ct0.x11), mathATan2(ct1.cy + ct1.y11, ct1.cx + ct1.x11), clockwise);
	                ctx.arc(x + ct1.cx, y + ct1.cy, cr0, mathATan2(ct1.y11, ct1.x11), mathATan2(ct1.y01, ct1.x01), !clockwise);
	            }
	        }
	        else {
	            ctx.lineTo(x + xire, y + yire);
	            ctx.arc(x, y, innerRadius, endAngle, startAngle, clockwise);
	        }
	    }
	    ctx.closePath();
	}
	exports.buildPath = buildPath;


/***/ },
/* 466 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	exports.__esModule = true;
	var vector_1 = __webpack_require__(11);
	function smoothBezier(points, smooth, isLoop, constraint) {
	    var cps = [];
	    var v = [];
	    var v1 = [];
	    var v2 = [];
	    var prevPoint;
	    var nextPoint;
	    var min;
	    var max;
	    if (constraint) {
	        min = [Infinity, Infinity];
	        max = [-Infinity, -Infinity];
	        for (var i = 0, len = points.length; i < len; i++) {
	            vector_1.min(min, min, points[i]);
	            vector_1.max(max, max, points[i]);
	        }
	        vector_1.min(min, min, constraint[0]);
	        vector_1.max(max, max, constraint[1]);
	    }
	    for (var i = 0, len = points.length; i < len; i++) {
	        var point = points[i];
	        if (isLoop) {
	            prevPoint = points[i ? i - 1 : len - 1];
	            nextPoint = points[(i + 1) % len];
	        }
	        else {
	            if (i === 0 || i === len - 1) {
	                cps.push(vector_1.clone(points[i]));
	                continue;
	            }
	            else {
	                prevPoint = points[i - 1];
	                nextPoint = points[i + 1];
	            }
	        }
	        vector_1.sub(v, nextPoint, prevPoint);
	        vector_1.scale(v, v, smooth);
	        var d0 = vector_1.distance(point, prevPoint);
	        var d1 = vector_1.distance(point, nextPoint);
	        var sum = d0 + d1;
	        if (sum !== 0) {
	            d0 /= sum;
	            d1 /= sum;
	        }
	        vector_1.scale(v1, v, -d0);
	        vector_1.scale(v2, v, d1);
	        var cp0 = vector_1.add([], point, v1);
	        var cp1 = vector_1.add([], point, v2);
	        if (constraint) {
	            vector_1.max(cp0, cp0, min);
	            vector_1.min(cp0, cp0, max);
	            vector_1.max(cp1, cp1, min);
	            vector_1.min(cp1, cp1, max);
	        }
	        cps.push(cp0);
	        cps.push(cp1);
	    }
	    if (isLoop) {
	        cps.push(cps.shift());
	    }
	    return cps;
	}
	exports["default"] = smoothBezier;


/***/ },
/* 467 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	exports.__esModule = true;
	var vector_1 = __webpack_require__(11);
	function interpolate(p0, p1, p2, p3, t, t2, t3) {
	    var v0 = (p2 - p0) * 0.5;
	    var v1 = (p3 - p1) * 0.5;
	    return (2 * (p1 - p2) + v0 + v1) * t3
	        + (-3 * (p1 - p2) - 2 * v0 - v1) * t2
	        + v0 * t + p1;
	}
	function smoothSpline(points, isLoop) {
	    var len = points.length;
	    var ret = [];
	    var distance = 0;
	    for (var i = 1; i < len; i++) {
	        distance += vector_1.distance(points[i - 1], points[i]);
	    }
	    var segs = distance / 2;
	    segs = segs < len ? len : segs;
	    for (var i = 0; i < segs; i++) {
	        var pos = i / (segs - 1) * (isLoop ? len : len - 1);
	        var idx = Math.floor(pos);
	        var w = pos - idx;
	        var p0 = void 0;
	        var p1 = points[idx % len];
	        var p2 = void 0;
	        var p3 = void 0;
	        if (!isLoop) {
	            p0 = points[idx === 0 ? idx : idx - 1];
	            p2 = points[idx > len - 2 ? len - 1 : idx + 1];
	            p3 = points[idx > len - 3 ? len - 1 : idx + 2];
	        }
	        else {
	            p0 = points[(idx - 1 + len) % len];
	            p2 = points[(idx + 1) % len];
	            p3 = points[(idx + 2) % len];
	        }
	        var w2 = w * w;
	        var w3 = w * w2;
	        ret.push([
	            interpolate(p0[0], p1[0], p2[0], p3[0], w, w2, w3),
	            interpolate(p0[1], p1[1], p2[1], p3[1], w, w2, w3)
	        ]);
	    }
	    return ret;
	}
	exports["default"] = smoothSpline;


/***/ },
/* 468 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	exports.__esModule = true;
	var tslib_1 = __webpack_require__(5);
	var Path_1 = __webpack_require__(8);
	var DropletShape = (function () {
	    function DropletShape() {
	        this.cx = 0;
	        this.cy = 0;
	        this.width = 0;
	        this.height = 0;
	    }
	    return DropletShape;
	}());
	var Droplet = (function (_super) {
	    tslib_1.__extends(Droplet, _super);
	    function Droplet(opts) {
	        return _super.call(this, opts) || this;
	    }
	    Droplet.prototype.getDefaultShape = function () {
	        return new DropletShape();
	    };
	    Droplet.prototype.buildPath = function (ctx, shape) {
	        var x = shape.cx;
	        var y = shape.cy;
	        var a = shape.width;
	        var b = shape.height;
	        ctx.moveTo(x, y + a);
	        ctx.bezierCurveTo(x + a, y + a, x + a * 3 / 2, y - a / 3, x, y - b);
	        ctx.bezierCurveTo(x - a * 3 / 2, y - a / 3, x - a, y + a, x, y + a);
	        ctx.closePath();
	    };
	    return Droplet;
	}(Path_1["default"]));
	Droplet.prototype.type = 'droplet';
	exports["default"] = Droplet;


/***/ },
/* 469 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	exports.__esModule = true;
	var tslib_1 = __webpack_require__(5);
	var Path_1 = __webpack_require__(8);
	var HeartShape = (function () {
	    function HeartShape() {
	        this.cx = 0;
	        this.cy = 0;
	        this.width = 0;
	        this.height = 0;
	    }
	    return HeartShape;
	}());
	var Heart = (function (_super) {
	    tslib_1.__extends(Heart, _super);
	    function Heart(opts) {
	        return _super.call(this, opts) || this;
	    }
	    Heart.prototype.getDefaultShape = function () {
	        return new HeartShape();
	    };
	    Heart.prototype.buildPath = function (ctx, shape) {
	        var x = shape.cx;
	        var y = shape.cy;
	        var a = shape.width;
	        var b = shape.height;
	        ctx.moveTo(x, y);
	        ctx.bezierCurveTo(x + a / 2, y - b * 2 / 3, x + a * 2, y + b / 3, x, y + b);
	        ctx.bezierCurveTo(x - a * 2, y + b / 3, x - a / 2, y - b * 2 / 3, x, y);
	    };
	    return Heart;
	}(Path_1["default"]));
	Heart.prototype.type = 'heart';
	exports["default"] = Heart;


/***/ },
/* 470 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	exports.__esModule = true;
	var tslib_1 = __webpack_require__(5);
	var Path_1 = __webpack_require__(8);
	var PI = Math.PI;
	var sin = Math.sin;
	var cos = Math.cos;
	var IsogonShape = (function () {
	    function IsogonShape() {
	        this.x = 0;
	        this.y = 0;
	        this.r = 0;
	        this.n = 0;
	    }
	    return IsogonShape;
	}());
	var Isogon = (function (_super) {
	    tslib_1.__extends(Isogon, _super);
	    function Isogon(opts) {
	        return _super.call(this, opts) || this;
	    }
	    Isogon.prototype.getDefaultShape = function () {
	        return new IsogonShape();
	    };
	    Isogon.prototype.buildPath = function (ctx, shape) {
	        var n = shape.n;
	        if (!n || n < 2) {
	            return;
	        }
	        var x = shape.x;
	        var y = shape.y;
	        var r = shape.r;
	        var dStep = 2 * PI / n;
	        var deg = -PI / 2;
	        ctx.moveTo(x + r * cos(deg), y + r * sin(deg));
	        for (var i = 0, end = n - 1; i < end; i++) {
	            deg += dStep;
	            ctx.lineTo(x + r * cos(deg), y + r * sin(deg));
	        }
	        ctx.closePath();
	        return;
	    };
	    return Isogon;
	}(Path_1["default"]));
	Isogon.prototype.type = 'isogon';
	exports["default"] = Isogon;


/***/ },
/* 471 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	exports.__esModule = true;
	var tslib_1 = __webpack_require__(5);
	var Path_1 = __webpack_require__(8);
	var sin = Math.sin;
	var cos = Math.cos;
	var radian = Math.PI / 180;
	var RoseShape = (function () {
	    function RoseShape() {
	        this.cx = 0;
	        this.cy = 0;
	        this.r = [];
	        this.k = 0;
	        this.n = 1;
	    }
	    return RoseShape;
	}());
	var Rose = (function (_super) {
	    tslib_1.__extends(Rose, _super);
	    function Rose(opts) {
	        return _super.call(this, opts) || this;
	    }
	    Rose.prototype.getDefaultStyle = function () {
	        return {
	            stroke: '#000',
	            fill: null
	        };
	    };
	    Rose.prototype.getDefaultShape = function () {
	        return new RoseShape();
	    };
	    Rose.prototype.buildPath = function (ctx, shape) {
	        var R = shape.r;
	        var k = shape.k;
	        var n = shape.n;
	        var x0 = shape.cx;
	        var y0 = shape.cy;
	        var x;
	        var y;
	        var r;
	        ctx.moveTo(x0, y0);
	        for (var i = 0, len = R.length; i < len; i++) {
	            r = R[i];
	            for (var j = 0; j <= 360 * n; j++) {
	                x = r
	                    * sin(k / n * j % 360 * radian)
	                    * cos(j * radian)
	                    + x0;
	                y = r
	                    * sin(k / n * j % 360 * radian)
	                    * sin(j * radian)
	                    + y0;
	                ctx.lineTo(x, y);
	            }
	        }
	    };
	    return Rose;
	}(Path_1["default"]));
	Rose.prototype.type = 'rose';
	exports["default"] = Rose;


/***/ },
/* 472 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	exports.__esModule = true;
	var tslib_1 = __webpack_require__(5);
	var Path_1 = __webpack_require__(8);
	var PI = Math.PI;
	var cos = Math.cos;
	var sin = Math.sin;
	var StarShape = (function () {
	    function StarShape() {
	        this.cx = 0;
	        this.cy = 0;
	        this.n = 3;
	        this.r = 0;
	    }
	    return StarShape;
	}());
	var Star = (function (_super) {
	    tslib_1.__extends(Star, _super);
	    function Star(opts) {
	        return _super.call(this, opts) || this;
	    }
	    Star.prototype.getDefaultShape = function () {
	        return new StarShape();
	    };
	    Star.prototype.buildPath = function (ctx, shape) {
	        var n = shape.n;
	        if (!n || n < 2) {
	            return;
	        }
	        var x = shape.cx;
	        var y = shape.cy;
	        var r = shape.r;
	        var r0 = shape.r0;
	        if (r0 == null) {
	            r0 = n > 4
	                ? r * cos(2 * PI / n) / cos(PI / n)
	                : r / 3;
	        }
	        var dStep = PI / n;
	        var deg = -PI / 2;
	        var xStart = x + r * cos(deg);
	        var yStart = y + r * sin(deg);
	        deg += dStep;
	        ctx.moveTo(xStart, yStart);
	        for (var i = 0, end = n * 2 - 1, ri = void 0; i < end; i++) {
	            ri = i % 2 === 0 ? r0 : r;
	            ctx.lineTo(x + ri * cos(deg), y + ri * sin(deg));
	            deg += dStep;
	        }
	        ctx.closePath();
	    };
	    return Star;
	}(Path_1["default"]));
	Star.prototype.type = 'star';
	exports["default"] = Star;


/***/ },
/* 473 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	exports.__esModule = true;
	var tslib_1 = __webpack_require__(5);
	var Path_1 = __webpack_require__(8);
	var cos = Math.cos;
	var sin = Math.sin;
	var TrochoidShape = (function () {
	    function TrochoidShape() {
	        this.cx = 0;
	        this.cy = 0;
	        this.r = 0;
	        this.r0 = 0;
	        this.d = 0;
	        this.location = 'out';
	    }
	    return TrochoidShape;
	}());
	var Trochoid = (function (_super) {
	    tslib_1.__extends(Trochoid, _super);
	    function Trochoid(opts) {
	        return _super.call(this, opts) || this;
	    }
	    Trochoid.prototype.getDefaultStyle = function () {
	        return {
	            stroke: '#000',
	            fill: null
	        };
	    };
	    Trochoid.prototype.getDefaultShape = function () {
	        return new TrochoidShape();
	    };
	    Trochoid.prototype.buildPath = function (ctx, shape) {
	        var R = shape.r;
	        var r = shape.r0;
	        var d = shape.d;
	        var offsetX = shape.cx;
	        var offsetY = shape.cy;
	        var delta = shape.location === 'out' ? 1 : -1;
	        var x1;
	        var y1;
	        var x2;
	        var y2;
	        if (shape.location && R <= r) {
	            return;
	        }
	        var num = 0;
	        var i = 1;
	        var theta;
	        x1 = (R + delta * r) * cos(0)
	            - delta * d * cos(0) + offsetX;
	        y1 = (R + delta * r) * sin(0)
	            - d * sin(0) + offsetY;
	        ctx.moveTo(x1, y1);
	        do {
	            num++;
	        } while ((r * num) % (R + delta * r) !== 0);
	        do {
	            theta = Math.PI / 180 * i;
	            x2 = (R + delta * r) * cos(theta)
	                - delta * d * cos((R / r + delta) * theta)
	                + offsetX;
	            y2 = (R + delta * r) * sin(theta)
	                - d * sin((R / r + delta) * theta)
	                + offsetY;
	            ctx.lineTo(x2, y2);
	            i++;
	        } while (i <= (r * num) / (R + delta * r) * 360);
	    };
	    return Trochoid;
	}(Path_1["default"]));
	Trochoid.prototype.type = 'trochoid';
	exports["default"] = Trochoid;


/***/ },
/* 474 */
/***/ function(module, exports) {

	"use strict";
	exports.__esModule = true;
	var Param = (function () {
	    function Param(target, e) {
	        this.target = target;
	        this.topTarget = e && e.topTarget;
	    }
	    return Param;
	}());
	var Draggable = (function () {
	    function Draggable(handler) {
	        this.handler = handler;
	        handler.on('mousedown', this._dragStart, this);
	        handler.on('mousemove', this._drag, this);
	        handler.on('mouseup', this._dragEnd, this);
	    }
	    Draggable.prototype._dragStart = function (e) {
	        var draggingTarget = e.target;
	        while (draggingTarget && !draggingTarget.draggable) {
	            draggingTarget = draggingTarget.parent;
	        }
	        if (draggingTarget) {
	            this._draggingTarget = draggingTarget;
	            draggingTarget.dragging = true;
	            this._x = e.offsetX;
	            this._y = e.offsetY;
	            this.handler.dispatchToElement(new Param(draggingTarget, e), 'dragstart', e.event);
	        }
	    };
	    Draggable.prototype._drag = function (e) {
	        var draggingTarget = this._draggingTarget;
	        if (draggingTarget) {
	            var x = e.offsetX;
	            var y = e.offsetY;
	            var dx = x - this._x;
	            var dy = y - this._y;
	            this._x = x;
	            this._y = y;
	            draggingTarget.drift(dx, dy, e);
	            this.handler.dispatchToElement(new Param(draggingTarget, e), 'drag', e.event);
	            var dropTarget = this.handler.findHover(x, y, draggingTarget).target;
	            var lastDropTarget = this._dropTarget;
	            this._dropTarget = dropTarget;
	            if (draggingTarget !== dropTarget) {
	                if (lastDropTarget && dropTarget !== lastDropTarget) {
	                    this.handler.dispatchToElement(new Param(lastDropTarget, e), 'dragleave', e.event);
	                }
	                if (dropTarget && dropTarget !== lastDropTarget) {
	                    this.handler.dispatchToElement(new Param(dropTarget, e), 'dragenter', e.event);
	                }
	            }
	        }
	    };
	    Draggable.prototype._dragEnd = function (e) {
	        var draggingTarget = this._draggingTarget;
	        if (draggingTarget) {
	            draggingTarget.dragging = false;
	        }
	        this.handler.dispatchToElement(new Param(draggingTarget, e), 'dragend', e.event);
	        if (this._dropTarget) {
	            this.handler.dispatchToElement(new Param(this._dropTarget, e), 'drop', e.event);
	        }
	        this._draggingTarget = null;
	        this._dropTarget = null;
	    };
	    return Draggable;
	}());
	exports["default"] = Draggable;


/***/ },
/* 475 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	exports.__esModule = true;
	var PathProxy_1 = __webpack_require__(32);
	var curve_1 = __webpack_require__(33);
	var util_1 = __webpack_require__(1);
	var vector_1 = __webpack_require__(11);
	var Rect_1 = __webpack_require__(61);
	var Sector_1 = __webpack_require__(116);
	var CMD = PathProxy_1["default"].CMD;
	var PI2 = Math.PI * 2;
	var PROP_XY = ['x', 'y'];
	var PROP_WH = ['width', 'height'];
	var tmpArr = [];
	function aroundEqual(a, b) {
	    return Math.abs(a - b) < 1e-5;
	}
	function pathToBezierCurves(path) {
	    var data = path.data;
	    var len = path.len();
	    var bezierArray = [];
	    var currentSubpath;
	    var xi = 0;
	    var yi = 0;
	    var x0 = 0;
	    var y0 = 0;
	    function createNewSubpath(x, y) {
	        if (currentSubpath && currentSubpath.length > 2) {
	            bezierArray.push(currentSubpath);
	        }
	        currentSubpath = [x, y];
	    }
	    function addLine(x0, y0, x1, y1) {
	        if (!(aroundEqual(x0, x1) && aroundEqual(y0, y1))) {
	            currentSubpath.push(x0, y0, x1, y1, x1, y1);
	        }
	    }
	    function addArc(startAngle, endAngle, cx, cy, rx, ry) {
	        var delta = Math.abs(endAngle - startAngle);
	        var len = Math.tan(delta / 4) * 4 / 3;
	        var dir = endAngle < startAngle ? -1 : 1;
	        var c1 = Math.cos(startAngle);
	        var s1 = Math.sin(startAngle);
	        var c2 = Math.cos(endAngle);
	        var s2 = Math.sin(endAngle);
	        var x1 = c1 * rx + cx;
	        var y1 = s1 * ry + cy;
	        var x4 = c2 * rx + cx;
	        var y4 = s2 * ry + cy;
	        var hx = rx * len * dir;
	        var hy = ry * len * dir;
	        currentSubpath.push(x1 - hx * s1, y1 + hy * c1, x4 + hx * s2, y4 - hy * c2, x4, y4);
	    }
	    var x1;
	    var y1;
	    var x2;
	    var y2;
	    for (var i = 0; i < len;) {
	        var cmd = data[i++];
	        var isFirst = i === 1;
	        if (isFirst) {
	            xi = data[i];
	            yi = data[i + 1];
	            x0 = xi;
	            y0 = yi;
	            if (cmd === CMD.L || cmd === CMD.C || cmd === CMD.Q) {
	                currentSubpath = [x0, y0];
	            }
	        }
	        switch (cmd) {
	            case CMD.M:
	                xi = x0 = data[i++];
	                yi = y0 = data[i++];
	                createNewSubpath(x0, y0);
	                break;
	            case CMD.L:
	                x1 = data[i++];
	                y1 = data[i++];
	                addLine(xi, yi, x1, y1);
	                xi = x1;
	                yi = y1;
	                break;
	            case CMD.C:
	                currentSubpath.push(data[i++], data[i++], data[i++], data[i++], xi = data[i++], yi = data[i++]);
	                break;
	            case CMD.Q:
	                x1 = data[i++];
	                y1 = data[i++];
	                x2 = data[i++];
	                y2 = data[i++];
	                currentSubpath.push(xi + 2 / 3 * (x1 - xi), yi + 2 / 3 * (y1 - yi), x2 + 2 / 3 * (x1 - x2), y2 + 2 / 3 * (y1 - y2), x2, y2);
	                xi = x2;
	                yi = y2;
	                break;
	            case CMD.A:
	                var cx = data[i++];
	                var cy = data[i++];
	                var rx = data[i++];
	                var ry = data[i++];
	                var startAngle = data[i++];
	                var endAngle = data[i++] + startAngle;
	                i += 1;
	                var anticlockwise = !data[i++];
	                x1 = Math.cos(startAngle) * rx + cx;
	                y1 = Math.sin(startAngle) * ry + cy;
	                if (isFirst) {
	                    x0 = x1;
	                    y0 = y1;
	                    createNewSubpath(x0, y0);
	                }
	                else {
	                    addLine(xi, yi, x1, y1);
	                }
	                xi = Math.cos(endAngle) * rx + cx;
	                yi = Math.sin(endAngle) * ry + cy;
	                var step = (anticlockwise ? -1 : 1) * Math.PI / 2;
	                for (var angle = startAngle; anticlockwise ? angle > endAngle : angle < endAngle; angle += step) {
	                    var nextAngle = anticlockwise ? Math.max(angle + step, endAngle)
	                        : Math.min(angle + step, endAngle);
	                    addArc(angle, nextAngle, cx, cy, rx, ry);
	                }
	                break;
	            case CMD.R:
	                x0 = xi = data[i++];
	                y0 = yi = data[i++];
	                x1 = x0 + data[i++];
	                y1 = y0 + data[i++];
	                createNewSubpath(x1, y0);
	                addLine(x1, y0, x1, y1);
	                addLine(x1, y1, x0, y1);
	                addLine(x0, y1, x0, y0);
	                addLine(x0, y0, x1, y0);
	                break;
	            case CMD.Z:
	                currentSubpath && addLine(xi, yi, x0, y0);
	                xi = x0;
	                yi = y0;
	                break;
	        }
	    }
	    if (currentSubpath && currentSubpath.length > 2) {
	        bezierArray.push(currentSubpath);
	    }
	    return bezierArray;
	}
	exports.pathToBezierCurves = pathToBezierCurves;
	function alignSubpath(subpath1, subpath2) {
	    var len1 = subpath1.length;
	    var len2 = subpath2.length;
	    if (len1 === len2) {
	        return [subpath1, subpath2];
	    }
	    var shorterPath = len1 < len2 ? subpath1 : subpath2;
	    var shorterLen = Math.min(len1, len2);
	    var diff = Math.abs(len2 - len1) / 6;
	    var shorterBezierCount = (shorterLen - 2) / 6;
	    var eachCurveSubDivCount = Math.ceil(diff / shorterBezierCount) + 1;
	    var newSubpath = [shorterPath[0], shorterPath[1]];
	    var remained = diff;
	    var tmpSegX = [];
	    var tmpSegY = [];
	    for (var i = 2; i < shorterLen;) {
	        var x0 = shorterPath[i - 2];
	        var y0 = shorterPath[i - 1];
	        var x1 = shorterPath[i++];
	        var y1 = shorterPath[i++];
	        var x2 = shorterPath[i++];
	        var y2 = shorterPath[i++];
	        var x3 = shorterPath[i++];
	        var y3 = shorterPath[i++];
	        if (remained <= 0) {
	            newSubpath.push(x1, y1, x2, y2, x3, y3);
	            continue;
	        }
	        var actualSubDivCount = Math.min(remained, eachCurveSubDivCount - 1) + 1;
	        for (var k = 1; k <= actualSubDivCount; k++) {
	            var p = k / actualSubDivCount;
	            curve_1.cubicSubdivide(x0, x1, x2, x3, p, tmpSegX);
	            curve_1.cubicSubdivide(y0, y1, y2, y3, p, tmpSegY);
	            x0 = tmpSegX[3];
	            y0 = tmpSegY[3];
	            newSubpath.push(tmpSegX[1], tmpSegY[1], tmpSegX[2], tmpSegY[2], x0, y0);
	            x1 = tmpSegX[5];
	            y1 = tmpSegY[5];
	            x2 = tmpSegX[6];
	            y2 = tmpSegY[6];
	        }
	        remained -= actualSubDivCount - 1;
	    }
	    return shorterPath === subpath1 ? [newSubpath, subpath2] : [subpath1, newSubpath];
	}
	function createSubpath(lastSubpathSubpath, otherSubpath) {
	    var len = lastSubpathSubpath.length;
	    var lastX = lastSubpathSubpath[len - 2];
	    var lastY = lastSubpathSubpath[len - 1];
	    var newSubpath = [];
	    for (var i = 0; i < otherSubpath.length;) {
	        newSubpath[i++] = lastX;
	        newSubpath[i++] = lastY;
	    }
	    return newSubpath;
	}
	function alignBezierCurves(array1, array2) {
	    var _a;
	    var lastSubpath1;
	    var lastSubpath2;
	    var newArray1 = [];
	    var newArray2 = [];
	    for (var i = 0; i < Math.max(array1.length, array2.length); i++) {
	        var subpath1 = array1[i];
	        var subpath2 = array2[i];
	        var newSubpath1 = void 0;
	        var newSubpath2 = void 0;
	        if (!subpath1) {
	            newSubpath1 = createSubpath(lastSubpath1 || subpath2, subpath2);
	            newSubpath2 = subpath2;
	        }
	        else if (!subpath2) {
	            newSubpath2 = createSubpath(lastSubpath2 || subpath1, subpath1);
	            newSubpath1 = subpath1;
	        }
	        else {
	            _a = alignSubpath(subpath1, subpath2), newSubpath1 = _a[0], newSubpath2 = _a[1];
	            lastSubpath1 = newSubpath1;
	            lastSubpath2 = newSubpath2;
	        }
	        newArray1.push(newSubpath1);
	        newArray2.push(newSubpath2);
	    }
	    return [newArray1, newArray2];
	}
	exports.alignBezierCurves = alignBezierCurves;
	function centroid(array) {
	    var signedArea = 0;
	    var cx = 0;
	    var cy = 0;
	    var len = array.length;
	    for (var i = 0, j = len - 2; i < len; j = i, i += 2) {
	        var x0 = array[j];
	        var y0 = array[j + 1];
	        var x1 = array[i];
	        var y1 = array[i + 1];
	        var a = x0 * y1 - x1 * y0;
	        signedArea += a;
	        cx += (x0 + x1) * a;
	        cy += (y0 + y1) * a;
	    }
	    if (signedArea === 0) {
	        return [array[0] || 0, array[1] || 0];
	    }
	    return [cx / signedArea / 3, cy / signedArea / 3, signedArea];
	}
	exports.centroid = centroid;
	function findBestRingOffset(fromSubBeziers, toSubBeziers, fromCp, toCp) {
	    var bezierCount = (fromSubBeziers.length - 2) / 6;
	    var bestScore = Infinity;
	    var bestOffset = 0;
	    var len = fromSubBeziers.length;
	    var len2 = len - 2;
	    for (var offset = 0; offset < bezierCount; offset++) {
	        var cursorOffset = offset * 6;
	        var score = 0;
	        for (var k = 0; k < len; k += 2) {
	            var idx = k === 0 ? cursorOffset : ((cursorOffset + k - 2) % len2 + 2);
	            var x0 = fromSubBeziers[idx] - fromCp[0];
	            var y0 = fromSubBeziers[idx + 1] - fromCp[1];
	            var x1 = toSubBeziers[k] - toCp[0];
	            var y1 = toSubBeziers[k + 1] - toCp[1];
	            var dx = x1 - x0;
	            var dy = y1 - y0;
	            score += dx * dx + dy * dy;
	        }
	        if (score < bestScore) {
	            bestScore = score;
	            bestOffset = offset;
	        }
	    }
	    return bestOffset;
	}
	function reverse(array) {
	    var newArr = [];
	    var len = array.length;
	    for (var i = 0; i < len; i += 2) {
	        newArr[i] = array[len - i - 2];
	        newArr[i + 1] = array[len - i - 1];
	    }
	    return newArr;
	}
	function findBestMorphingRotation(fromArr, toArr, searchAngleIteration, searchAngleRange) {
	    var result = [];
	    var fromNeedsReverse;
	    for (var i = 0; i < fromArr.length; i++) {
	        var fromSubpathBezier = fromArr[i];
	        var toSubpathBezier = toArr[i];
	        var fromCp = centroid(fromSubpathBezier);
	        var toCp = centroid(toSubpathBezier);
	        if (fromNeedsReverse == null) {
	            fromNeedsReverse = fromCp[2] < 0 !== toCp[2] < 0;
	        }
	        var newFromSubpathBezier = [];
	        var newToSubpathBezier = [];
	        var bestAngle = 0;
	        var bestScore = Infinity;
	        var tmpArr_1 = [];
	        var len = fromSubpathBezier.length;
	        if (fromNeedsReverse) {
	            fromSubpathBezier = reverse(fromSubpathBezier);
	        }
	        var offset = findBestRingOffset(fromSubpathBezier, toSubpathBezier, fromCp, toCp) * 6;
	        var len2 = len - 2;
	        for (var k = 0; k < len2; k += 2) {
	            var idx = (offset + k) % len2 + 2;
	            newFromSubpathBezier[k + 2] = fromSubpathBezier[idx] - fromCp[0];
	            newFromSubpathBezier[k + 3] = fromSubpathBezier[idx + 1] - fromCp[1];
	        }
	        newFromSubpathBezier[0] = fromSubpathBezier[offset] - fromCp[0];
	        newFromSubpathBezier[1] = fromSubpathBezier[offset + 1] - fromCp[1];
	        if (searchAngleIteration > 0) {
	            var step = searchAngleRange / searchAngleIteration;
	            for (var angle = -searchAngleRange / 2; angle <= searchAngleRange / 2; angle += step) {
	                var sa = Math.sin(angle);
	                var ca = Math.cos(angle);
	                var score = 0;
	                for (var k = 0; k < fromSubpathBezier.length; k += 2) {
	                    var x0 = newFromSubpathBezier[k];
	                    var y0 = newFromSubpathBezier[k + 1];
	                    var x1 = toSubpathBezier[k] - toCp[0];
	                    var y1 = toSubpathBezier[k + 1] - toCp[1];
	                    var newX1 = x1 * ca - y1 * sa;
	                    var newY1 = x1 * sa + y1 * ca;
	                    tmpArr_1[k] = newX1;
	                    tmpArr_1[k + 1] = newY1;
	                    var dx = newX1 - x0;
	                    var dy = newY1 - y0;
	                    score += dx * dx + dy * dy;
	                }
	                if (score < bestScore) {
	                    bestScore = score;
	                    bestAngle = angle;
	                    for (var m = 0; m < tmpArr_1.length; m++) {
	                        newToSubpathBezier[m] = tmpArr_1[m];
	                    }
	                }
	            }
	        }
	        else {
	            for (var i_1 = 0; i_1 < len; i_1 += 2) {
	                newToSubpathBezier[i_1] = toSubpathBezier[i_1] - toCp[0];
	                newToSubpathBezier[i_1 + 1] = toSubpathBezier[i_1 + 1] - toCp[1];
	            }
	        }
	        result.push({
	            from: newFromSubpathBezier,
	            to: newToSubpathBezier,
	            fromCp: fromCp,
	            toCp: toCp,
	            rotation: -bestAngle
	        });
	    }
	    return result;
	}
	function morphPath(fromPath, toPath, animationOpts) {
	    var fromPathProxy;
	    var toPathProxy;
	    if (!fromPath || !toPath) {
	        return toPath;
	    }
	    !fromPath.path && fromPath.createPathProxy();
	    fromPathProxy = fromPath.path;
	    fromPathProxy.beginPath();
	    fromPath.buildPath(fromPathProxy, fromPath.shape);
	    !toPath.path && toPath.createPathProxy();
	    toPathProxy = toPath.path;
	    toPathProxy === fromPathProxy && (toPathProxy = new PathProxy_1["default"](false));
	    toPathProxy.beginPath();
	    if (isIndividualMorphingPath(toPath)) {
	        toPath.__oldBuildPath(toPathProxy, toPath.shape);
	    }
	    else {
	        toPath.buildPath(toPathProxy, toPath.shape);
	    }
	    var _a = alignBezierCurves(pathToBezierCurves(fromPathProxy), pathToBezierCurves(toPathProxy)), fromBezierCurves = _a[0], toBezierCurves = _a[1];
	    var morphingData = findBestMorphingRotation(fromBezierCurves, toBezierCurves, 10, Math.PI);
	    becomeIndividualMorphingPath(toPath, morphingData, 0);
	    var oldDone = animationOpts && animationOpts.done;
	    var oldAborted = animationOpts && animationOpts.aborted;
	    var oldDuring = animationOpts && animationOpts.during;
	    toPath.animateTo({
	        __morphT: 1
	    }, util_1.defaults({
	        during: function (p) {
	            toPath.dirtyShape();
	            oldDuring && oldDuring(p);
	        },
	        done: function () {
	            restoreIndividualMorphingPath(toPath);
	            toPath.createPathProxy();
	            toPath.dirtyShape();
	            oldDone && oldDone();
	        },
	        aborted: function () {
	            oldAborted && oldAborted();
	        }
	    }, animationOpts));
	    return toPath;
	}
	exports.morphPath = morphPath;
	function morphingPathBuildPath(path) {
	    var morphingData = this.__morphingData;
	    var t = this.__morphT;
	    var onet = 1 - t;
	    var newCp = [];
	    for (var i = 0; i < morphingData.length; i++) {
	        var item = morphingData[i];
	        var from = item.from;
	        var to = item.to;
	        var angle = item.rotation * t;
	        var fromCp = item.fromCp;
	        var toCp = item.toCp;
	        var sa = Math.sin(angle);
	        var ca = Math.cos(angle);
	        vector_1.lerp(newCp, fromCp, toCp, t);
	        for (var m = 0; m < from.length; m += 2) {
	            var x0 = from[m];
	            var y0 = from[m + 1];
	            var x1 = to[m];
	            var y1 = to[m + 1];
	            var x = x0 * onet + x1 * t;
	            var y = y0 * onet + y1 * t;
	            tmpArr[m] = (x * ca - y * sa) + newCp[0];
	            tmpArr[m + 1] = (x * sa + y * ca) + newCp[1];
	        }
	        for (var m = 0; m < from.length;) {
	            if (m === 0) {
	                path.moveTo(tmpArr[m++], tmpArr[m++]);
	            }
	            path.bezierCurveTo(tmpArr[m++], tmpArr[m++], tmpArr[m++], tmpArr[m++], tmpArr[m++], tmpArr[m++]);
	        }
	    }
	}
	;
	function becomeIndividualMorphingPath(path, morphingData, morphT) {
	    if (isIndividualMorphingPath(path)) {
	        updateIndividualMorphingPath(path, morphingData, morphT);
	        return;
	    }
	    var morphingPath = path;
	    morphingPath.__oldBuildPath = morphingPath.buildPath;
	    morphingPath.buildPath = morphingPathBuildPath;
	    updateIndividualMorphingPath(morphingPath, morphingData, morphT);
	}
	function updateIndividualMorphingPath(morphingPath, morphingData, morphT) {
	    morphingPath.__morphingData = morphingData;
	    morphingPath.__morphT = morphT;
	}
	function restoreIndividualMorphingPath(path) {
	    if (isIndividualMorphingPath(path)) {
	        path.buildPath = path.__oldBuildPath;
	        path.__oldBuildPath = path.__morphingData = null;
	    }
	}
	function isIndividualMorphingPath(path) {
	    return path.__oldBuildPath != null;
	}
	function isCombiningPath(path) {
	    return !!path.__combiningSubList;
	}
	exports.isCombiningPath = isCombiningPath;
	function isInAnyMorphing(path) {
	    return isIndividualMorphingPath(path) || isCombiningPath(path);
	}
	exports.isInAnyMorphing = isInAnyMorphing;
	function combine(fromPathList, toPath, animationOpts, copyPropsIfDivided) {
	    var fromIndividuals = [];
	    var separateCount = 0;
	    for (var i = 0; i < fromPathList.length; i++) {
	        var fromPath = fromPathList[i];
	        if (isCombiningPath(fromPath)) {
	            var fromCombiningSubList = fromPath.__combiningSubList;
	            for (var j = 0; j < fromCombiningSubList.length; j++) {
	                fromIndividuals.push(fromCombiningSubList[j]);
	            }
	            separateCount += fromCombiningSubList.length;
	        }
	        else {
	            fromIndividuals.push(fromPath);
	            separateCount++;
	        }
	    }
	    if (!separateCount) {
	        return;
	    }
	    var dividingMethod = animationOpts ? animationOpts.dividingMethod : null;
	    var toPathSplittedList = divideShape(toPath, separateCount, dividingMethod);
	    util_1.assert(toPathSplittedList.length === separateCount);
	    var oldDone = animationOpts && animationOpts.done;
	    var oldAborted = animationOpts && animationOpts.aborted;
	    var oldDuring = animationOpts && animationOpts.during;
	    var doneCount = 0;
	    var abortedCalled = false;
	    var morphAnimationOpts = util_1.defaults({
	        during: function (p) {
	            oldDuring && oldDuring(p);
	        },
	        done: function () {
	            doneCount++;
	            if (doneCount === toPathSplittedList.length) {
	                restoreCombiningPath(toPath);
	                oldDone && oldDone();
	            }
	        },
	        aborted: function () {
	            if (!abortedCalled) {
	                abortedCalled = true;
	                oldAborted && oldAborted();
	            }
	        }
	    }, animationOpts);
	    for (var i = 0; i < separateCount; i++) {
	        var from = fromIndividuals[i];
	        var to = toPathSplittedList[i];
	        copyPropsIfDivided && copyPropsIfDivided(toPath, to, true);
	        morphPath(from, to, morphAnimationOpts);
	    }
	    becomeCombiningPath(toPath, toPathSplittedList);
	    return {
	        fromIndividuals: fromIndividuals,
	        toIndividuals: toPathSplittedList,
	        count: separateCount
	    };
	}
	exports.combine = combine;
	function becomeCombiningPath(path, combiningSubList) {
	    if (isCombiningPath(path)) {
	        updateCombiningPathSubList(path, combiningSubList);
	        return;
	    }
	    var combiningPath = path;
	    updateCombiningPathSubList(combiningPath, combiningSubList);
	    combiningPath.__oldAddSelfToZr = path.addSelfToZr;
	    combiningPath.__oldRemoveSelfFromZr = path.removeSelfFromZr;
	    combiningPath.addSelfToZr = combiningAddSelfToZr;
	    combiningPath.removeSelfFromZr = combiningRemoveSelfFromZr;
	    combiningPath.__oldBuildPath = combiningPath.buildPath;
	    combiningPath.buildPath = util_1.noop;
	    combiningPath.childrenRef = combiningChildrenRef;
	}
	function restoreCombiningPath(path) {
	    if (!isCombiningPath(path)) {
	        return;
	    }
	    var combiningPath = path;
	    updateCombiningPathSubList(combiningPath, null);
	    combiningPath.addSelfToZr = combiningPath.__oldAddSelfToZr;
	    combiningPath.removeSelfFromZr = combiningPath.__oldRemoveSelfFromZr;
	    combiningPath.buildPath = combiningPath.__oldBuildPath;
	    combiningPath.childrenRef =
	        combiningPath.__combiningSubList =
	            combiningPath.__oldAddSelfToZr =
	                combiningPath.__oldRemoveSelfFromZr =
	                    combiningPath.__oldBuildPath = null;
	}
	function updateCombiningPathSubList(combiningPath, combiningSubList) {
	    if (combiningPath.__combiningSubList !== combiningSubList) {
	        combiningPathSubListAddRemoveWithZr(combiningPath, 'removeSelfFromZr');
	        combiningPath.__combiningSubList = combiningSubList;
	        if (combiningSubList) {
	            for (var i = 0; i < combiningSubList.length; i++) {
	                combiningSubList[i].parent = combiningPath;
	            }
	        }
	        combiningPathSubListAddRemoveWithZr(combiningPath, 'addSelfToZr');
	    }
	}
	function combiningAddSelfToZr(zr) {
	    this.__oldAddSelfToZr(zr);
	    combiningPathSubListAddRemoveWithZr(this, 'addSelfToZr');
	}
	function combiningPathSubListAddRemoveWithZr(path, method) {
	    var combiningSubList = path.__combiningSubList;
	    var zr = path.__zr;
	    if (combiningSubList && zr) {
	        for (var i = 0; i < combiningSubList.length; i++) {
	            var child = combiningSubList[i];
	            child[method](zr);
	        }
	    }
	}
	function combiningRemoveSelfFromZr(zr) {
	    this.__oldRemoveSelfFromZr(zr);
	    var combiningSubList = this.__combiningSubList;
	    for (var i = 0; i < combiningSubList.length; i++) {
	        var child = combiningSubList[i];
	        child.removeSelfFromZr(zr);
	    }
	}
	function combiningChildrenRef() {
	    return this.__combiningSubList;
	}
	function separate(fromPath, toPathList, animationOpts, copyPropsIfDivided) {
	    var toPathListLen = toPathList.length;
	    var fromPathList;
	    var dividingMethod = animationOpts ? animationOpts.dividingMethod : null;
	    var copyProps = false;
	    if (isCombiningPath(fromPath)) {
	        var fromCombiningSubList = fromPath.__combiningSubList;
	        if (fromCombiningSubList.length === toPathListLen) {
	            fromPathList = fromCombiningSubList;
	        }
	        else {
	            fromPathList = divideShape(fromPath, toPathListLen, dividingMethod);
	            copyProps = true;
	        }
	    }
	    else {
	        fromPathList = divideShape(fromPath, toPathListLen, dividingMethod);
	        copyProps = true;
	    }
	    util_1.assert(fromPathList.length === toPathListLen);
	    for (var i = 0; i < toPathListLen; i++) {
	        if (copyProps && copyPropsIfDivided) {
	            copyPropsIfDivided(fromPath, fromPathList[i], false);
	        }
	        morphPath(fromPathList[i], toPathList[i], animationOpts);
	    }
	    return {
	        fromIndividuals: fromPathList,
	        toIndividuals: toPathList,
	        count: toPathListLen
	    };
	}
	exports.separate = separate;
	function divideShape(path, separateCount, dividingMethod) {
	    return dividingMethod === 'duplicate'
	        ? duplicateShape(path, separateCount)
	        : splitShape(path, separateCount);
	}
	function splitShape(path, separateCount) {
	    var resultPaths = [];
	    if (separateCount <= 0) {
	        return resultPaths;
	    }
	    if (separateCount === 1) {
	        return duplicateShape(path, separateCount);
	    }
	    if (path instanceof Rect_1["default"]) {
	        var toPathShape = path.shape;
	        var splitPropIdx = toPathShape.height > toPathShape.width ? 1 : 0;
	        var propWH = PROP_WH[splitPropIdx];
	        var propXY = PROP_XY[splitPropIdx];
	        var subWH = toPathShape[propWH] / separateCount;
	        var xyCurr = toPathShape[propXY];
	        for (var i = 0; i < separateCount; i++, xyCurr += subWH) {
	            var subShape = {
	                x: toPathShape.x,
	                y: toPathShape.y,
	                width: toPathShape.width,
	                height: toPathShape.height
	            };
	            subShape[propXY] = xyCurr;
	            subShape[propWH] = i < separateCount - 1
	                ? subWH
	                : toPathShape[propXY] + toPathShape[propWH] - xyCurr;
	            var splitted = new Rect_1["default"]({ shape: subShape });
	            resultPaths.push(splitted);
	        }
	    }
	    else if (path instanceof Sector_1["default"]) {
	        var toPathShape = path.shape;
	        var clockwise = toPathShape.clockwise;
	        var startAngle = toPathShape.startAngle;
	        var endAngle = toPathShape.endAngle;
	        var endAngleNormalized = normalizeRadian(startAngle, toPathShape.endAngle, clockwise);
	        var step = (endAngleNormalized - startAngle) / separateCount;
	        var angleCurr = startAngle;
	        for (var i = 0; i < separateCount; i++, angleCurr += step) {
	            var splitted = new Sector_1["default"]({
	                shape: {
	                    cx: toPathShape.cx,
	                    cy: toPathShape.cy,
	                    r: toPathShape.r,
	                    r0: toPathShape.r0,
	                    clockwise: clockwise,
	                    startAngle: angleCurr,
	                    endAngle: i === separateCount - 1 ? endAngle : angleCurr + step
	                }
	            });
	            resultPaths.push(splitted);
	        }
	    }
	    else {
	        return duplicateShape(path, separateCount);
	    }
	    return resultPaths;
	}
	function duplicateShape(path, separateCount) {
	    var resultPaths = [];
	    if (separateCount <= 0) {
	        return resultPaths;
	    }
	    var ctor = path.constructor;
	    for (var i = 0; i < separateCount; i++) {
	        var sub = new ctor({
	            shape: util_1.clone(path.shape)
	        });
	        resultPaths.push(sub);
	    }
	    return resultPaths;
	}
	function normalizeRadian(start, end, clockwise) {
	    return end + PI2 * (Math[clockwise ? 'ceil' : 'floor']((start - end) / PI2));
	}


/***/ },
/* 476 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	exports.__esModule = true;
	var PathProxy_1 = __webpack_require__(32);
	var vector_1 = __webpack_require__(11);
	var CMD = PathProxy_1["default"].CMD;
	var points = [[], [], []];
	var mathSqrt = Math.sqrt;
	var mathAtan2 = Math.atan2;
	function transformPath(path, m) {
	    var data = path.data;
	    var len = path.len();
	    var cmd;
	    var nPoint;
	    var i;
	    var j;
	    var k;
	    var p;
	    var M = CMD.M;
	    var C = CMD.C;
	    var L = CMD.L;
	    var R = CMD.R;
	    var A = CMD.A;
	    var Q = CMD.Q;
	    for (i = 0, j = 0; i < len;) {
	        cmd = data[i++];
	        j = i;
	        nPoint = 0;
	        switch (cmd) {
	            case M:
	                nPoint = 1;
	                break;
	            case L:
	                nPoint = 1;
	                break;
	            case C:
	                nPoint = 3;
	                break;
	            case Q:
	                nPoint = 2;
	                break;
	            case A:
	                var x = m[4];
	                var y = m[5];
	                var sx = mathSqrt(m[0] * m[0] + m[1] * m[1]);
	                var sy = mathSqrt(m[2] * m[2] + m[3] * m[3]);
	                var angle = mathAtan2(-m[1] / sy, m[0] / sx);
	                data[i] *= sx;
	                data[i++] += x;
	                data[i] *= sy;
	                data[i++] += y;
	                data[i++] *= sx;
	                data[i++] *= sy;
	                data[i++] += angle;
	                data[i++] += angle;
	                i += 2;
	                j = i;
	                break;
	            case R:
	                p[0] = data[i++];
	                p[1] = data[i++];
	                vector_1.applyTransform(p, p, m);
	                data[j++] = p[0];
	                data[j++] = p[1];
	                p[0] += data[i++];
	                p[1] += data[i++];
	                vector_1.applyTransform(p, p, m);
	                data[j++] = p[0];
	                data[j++] = p[1];
	        }
	        for (k = 0; k < nPoint; k++) {
	            var p_1 = points[k];
	            p_1[0] = data[i++];
	            p_1[1] = data[i++];
	            vector_1.applyTransform(p_1, p_1, m);
	            data[j++] = p_1[0];
	            data[j++] = p_1[1];
	        }
	    }
	    path.increaseVersion();
	}
	exports["default"] = transformPath;


/***/ },
/* 477 */
/***/ function(module, exports, __webpack_require__, __webpack_module_template_argument_0__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	
	var _Chat = __webpack_require__(__webpack_module_template_argument_0__);
	
	Object.defineProperty(exports, 'default', {
	  enumerable: true,
	  get: function get() {
	    return _interopRequireDefault(_Chat).default;
	  }
	});

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/***/ },
/* 478 */
/***/ function(module, exports, __webpack_require__, __webpack_module_template_argument_0__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	
	var _Pulse = __webpack_require__(__webpack_module_template_argument_0__);
	
	Object.defineProperty(exports, 'default', {
	  enumerable: true,
	  get: function get() {
	    return _interopRequireDefault(_Pulse).default;
	  }
	});

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/***/ },
/* 479 */
/***/ function(module, exports, __webpack_require__, __webpack_module_template_argument_0__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	
	var _Temperature = __webpack_require__(__webpack_module_template_argument_0__);
	
	Object.defineProperty(exports, 'default', {
	  enumerable: true,
	  get: function get() {
	    return _interopRequireDefault(_Temperature).default;
	  }
	});

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/***/ },
/* 480 */
/***/ function(module, exports, __webpack_require__, __webpack_module_template_argument_0__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	
	var _Weight = __webpack_require__(__webpack_module_template_argument_0__);
	
	Object.defineProperty(exports, 'default', {
	  enumerable: true,
	  get: function get() {
	    return _interopRequireDefault(_Weight).default;
	  }
	});

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/***/ },
/* 481 */
/***/ function(module, exports, __webpack_require__, __webpack_module_template_argument_0__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	
	var _BloodPressure = __webpack_require__(__webpack_module_template_argument_0__);
	
	Object.defineProperty(exports, 'default', {
	  enumerable: true,
	  get: function get() {
	    return _interopRequireDefault(_BloodPressure).default;
	  }
	});

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/***/ },
/* 482 */
/***/ function(module, exports, __webpack_require__, __webpack_module_template_argument_0__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	
	var _Confirmation = __webpack_require__(__webpack_module_template_argument_0__);
	
	Object.defineProperty(exports, 'default', {
	  enumerable: true,
	  get: function get() {
	    return _interopRequireDefault(_Confirmation).default;
	  }
	});

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/***/ },
/* 483 */
/***/ function(module, exports, __webpack_require__, __webpack_module_template_argument_0__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	
	var _History = __webpack_require__(__webpack_module_template_argument_0__);
	
	Object.defineProperty(exports, 'default', {
	  enumerable: true,
	  get: function get() {
	    return _interopRequireDefault(_History).default;
	  }
	});

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/***/ },
/* 484 */
/***/ function(module, exports, __webpack_require__, __webpack_module_template_argument_0__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	
	var _MissedConfirmation = __webpack_require__(__webpack_module_template_argument_0__);
	
	Object.defineProperty(exports, 'default', {
	  enumerable: true,
	  get: function get() {
	    return _interopRequireDefault(_MissedConfirmation).default;
	  }
	});

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/***/ },
/* 485 */
/***/ function(module, exports, __webpack_require__, __webpack_module_template_argument_0__) {

	/* WEBPACK VAR INJECTION */(function(process) {/* eslint-env browser */
	
	/**
	 * This is the web browser implementation of `debug()`.
	 */
	
	exports.formatArgs = formatArgs;
	exports.save = save;
	exports.load = load;
	exports.useColors = useColors;
	exports.storage = localstorage();
	exports.destroy = (() => {
		let warned = false;
	
		return () => {
			if (!warned) {
				warned = true;
				console.warn('Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`.');
			}
		};
	})();
	
	/**
	 * Colors.
	 */
	
	exports.colors = [
		'#0000CC',
		'#0000FF',
		'#0033CC',
		'#0033FF',
		'#0066CC',
		'#0066FF',
		'#0099CC',
		'#0099FF',
		'#00CC00',
		'#00CC33',
		'#00CC66',
		'#00CC99',
		'#00CCCC',
		'#00CCFF',
		'#3300CC',
		'#3300FF',
		'#3333CC',
		'#3333FF',
		'#3366CC',
		'#3366FF',
		'#3399CC',
		'#3399FF',
		'#33CC00',
		'#33CC33',
		'#33CC66',
		'#33CC99',
		'#33CCCC',
		'#33CCFF',
		'#6600CC',
		'#6600FF',
		'#6633CC',
		'#6633FF',
		'#66CC00',
		'#66CC33',
		'#9900CC',
		'#9900FF',
		'#9933CC',
		'#9933FF',
		'#99CC00',
		'#99CC33',
		'#CC0000',
		'#CC0033',
		'#CC0066',
		'#CC0099',
		'#CC00CC',
		'#CC00FF',
		'#CC3300',
		'#CC3333',
		'#CC3366',
		'#CC3399',
		'#CC33CC',
		'#CC33FF',
		'#CC6600',
		'#CC6633',
		'#CC9900',
		'#CC9933',
		'#CCCC00',
		'#CCCC33',
		'#FF0000',
		'#FF0033',
		'#FF0066',
		'#FF0099',
		'#FF00CC',
		'#FF00FF',
		'#FF3300',
		'#FF3333',
		'#FF3366',
		'#FF3399',
		'#FF33CC',
		'#FF33FF',
		'#FF6600',
		'#FF6633',
		'#FF9900',
		'#FF9933',
		'#FFCC00',
		'#FFCC33'
	];
	
	/**
	 * Currently only WebKit-based Web Inspectors, Firefox >= v31,
	 * and the Firebug extension (any Firefox version) are known
	 * to support "%c" CSS customizations.
	 *
	 * TODO: add a `localStorage` variable to explicitly enable/disable colors
	 */
	
	// eslint-disable-next-line complexity
	function useColors() {
		// NB: In an Electron preload script, document will be defined but not fully
		// initialized. Since we know we're in Chrome, we'll just detect this case
		// explicitly
		if (typeof window !== 'undefined' && window.process && (window.process.type === 'renderer' || window.process.__nwjs)) {
			return true;
		}
	
		// Internet Explorer and Edge do not support colors.
		if (typeof navigator !== 'undefined' && navigator.userAgent && navigator.userAgent.toLowerCase().match(/(edge|trident)\/(\d+)/)) {
			return false;
		}
	
		// Is webkit? http://stackoverflow.com/a/16459606/376773
		// document is undefined in react-native: https://github.com/facebook/react-native/pull/1632
		return (typeof document !== 'undefined' && document.documentElement && document.documentElement.style && document.documentElement.style.WebkitAppearance) ||
			// Is firebug? http://stackoverflow.com/a/398120/376773
			(typeof window !== 'undefined' && window.console && (window.console.firebug || (window.console.exception && window.console.table))) ||
			// Is firefox >= v31?
			// https://developer.mozilla.org/en-US/docs/Tools/Web_Console#Styling_messages
			(typeof navigator !== 'undefined' && navigator.userAgent && navigator.userAgent.toLowerCase().match(/firefox\/(\d+)/) && parseInt(RegExp.$1, 10) >= 31) ||
			// Double check webkit in userAgent just in case we are in a worker
			(typeof navigator !== 'undefined' && navigator.userAgent && navigator.userAgent.toLowerCase().match(/applewebkit\/(\d+)/));
	}
	
	/**
	 * Colorize log arguments if enabled.
	 *
	 * @api public
	 */
	
	function formatArgs(args) {
		args[0] = (this.useColors ? '%c' : '') +
			this.namespace +
			(this.useColors ? ' %c' : ' ') +
			args[0] +
			(this.useColors ? '%c ' : ' ') +
			'+' + module.exports.humanize(this.diff);
	
		if (!this.useColors) {
			return;
		}
	
		const c = 'color: ' + this.color;
		args.splice(1, 0, c, 'color: inherit');
	
		// The final "%c" is somewhat tricky, because there could be other
		// arguments passed either before or after the %c, so we need to
		// figure out the correct index to insert the CSS into
		let index = 0;
		let lastC = 0;
		args[0].replace(/%[a-zA-Z%]/g, match => {
			if (match === '%%') {
				return;
			}
			index++;
			if (match === '%c') {
				// We only are interested in the *last* %c
				// (the user may have provided their own)
				lastC = index;
			}
		});
	
		args.splice(lastC, 0, c);
	}
	
	/**
	 * Invokes `console.debug()` when available.
	 * No-op when `console.debug` is not a "function".
	 * If `console.debug` is not available, falls back
	 * to `console.log`.
	 *
	 * @api public
	 */
	exports.log = console.debug || console.log || (() => {});
	
	/**
	 * Save `namespaces`.
	 *
	 * @param {String} namespaces
	 * @api private
	 */
	function save(namespaces) {
		try {
			if (namespaces) {
				exports.storage.setItem('debug', namespaces);
			} else {
				exports.storage.removeItem('debug');
			}
		} catch (error) {
			// Swallow
			// XXX (@Qix-) should we be logging these?
		}
	}
	
	/**
	 * Load `namespaces`.
	 *
	 * @return {String} returns the previously persisted debug modes
	 * @api private
	 */
	function load() {
		let r;
		try {
			r = exports.storage.getItem('debug');
		} catch (error) {
			// Swallow
			// XXX (@Qix-) should we be logging these?
		}
	
		// If debug isn't set in LS, and we're in Electron, try to load $DEBUG
		if (!r && typeof process !== 'undefined' && 'env' in process) {
			r = ({"NODE_ENV":"production","PUBLIC_URL":""}).DEBUG;
		}
	
		return r;
	}
	
	/**
	 * Localstorage attempts to return the localstorage.
	 *
	 * This is necessary because safari throws
	 * when a user disables cookies/localstorage
	 * and you attempt to access it.
	 *
	 * @return {LocalStorage}
	 * @api private
	 */
	
	function localstorage() {
		try {
			// TVMLKit (Apple TV JS Runtime) does not have a window object, just localStorage in the global context
			// The Browser also has localStorage in the global context.
			return localStorage;
		} catch (error) {
			// Swallow
			// XXX (@Qix-) should we be logging these?
		}
	}
	
	module.exports = __webpack_require__(__webpack_module_template_argument_0__)(exports);
	
	const {formatters} = module.exports;
	
	/**
	 * Map %j to `JSON.stringify()`, since no Web Inspectors do that by default.
	 */
	
	formatters.j = function (v) {
		try {
			return JSON.stringify(v);
		} catch (error) {
			return '[UnexpectedJSONParseError]: ' + error.message;
		}
	};
	
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(100)))

/***/ },
/* 486 */
/***/ function(module, exports, __webpack_require__, __webpack_module_template_argument_0__) {

	
	/**
	 * This is the common logic for both the Node.js and web browser
	 * implementations of `debug()`.
	 */
	
	function setup(env) {
		createDebug.debug = createDebug;
		createDebug.default = createDebug;
		createDebug.coerce = coerce;
		createDebug.disable = disable;
		createDebug.enable = enable;
		createDebug.enabled = enabled;
		createDebug.humanize = __webpack_require__(__webpack_module_template_argument_0__);
		createDebug.destroy = destroy;
	
		Object.keys(env).forEach(key => {
			createDebug[key] = env[key];
		});
	
		/**
		* The currently active debug mode names, and names to skip.
		*/
	
		createDebug.names = [];
		createDebug.skips = [];
	
		/**
		* Map of special "%n" handling functions, for the debug "format" argument.
		*
		* Valid key names are a single, lower or upper-case letter, i.e. "n" and "N".
		*/
		createDebug.formatters = {};
	
		/**
		* Selects a color for a debug namespace
		* @param {String} namespace The namespace string for the for the debug instance to be colored
		* @return {Number|String} An ANSI color code for the given namespace
		* @api private
		*/
		function selectColor(namespace) {
			let hash = 0;
	
			for (let i = 0; i < namespace.length; i++) {
				hash = ((hash << 5) - hash) + namespace.charCodeAt(i);
				hash |= 0; // Convert to 32bit integer
			}
	
			return createDebug.colors[Math.abs(hash) % createDebug.colors.length];
		}
		createDebug.selectColor = selectColor;
	
		/**
		* Create a debugger with the given `namespace`.
		*
		* @param {String} namespace
		* @return {Function}
		* @api public
		*/
		function createDebug(namespace) {
			let prevTime;
			let enableOverride = null;
	
			function debug(...args) {
				// Disabled?
				if (!debug.enabled) {
					return;
				}
	
				const self = debug;
	
				// Set `diff` timestamp
				const curr = Number(new Date());
				const ms = curr - (prevTime || curr);
				self.diff = ms;
				self.prev = prevTime;
				self.curr = curr;
				prevTime = curr;
	
				args[0] = createDebug.coerce(args[0]);
	
				if (typeof args[0] !== 'string') {
					// Anything else let's inspect with %O
					args.unshift('%O');
				}
	
				// Apply any `formatters` transformations
				let index = 0;
				args[0] = args[0].replace(/%([a-zA-Z%])/g, (match, format) => {
					// If we encounter an escaped % then don't increase the array index
					if (match === '%%') {
						return '%';
					}
					index++;
					const formatter = createDebug.formatters[format];
					if (typeof formatter === 'function') {
						const val = args[index];
						match = formatter.call(self, val);
	
						// Now we need to remove `args[index]` since it's inlined in the `format`
						args.splice(index, 1);
						index--;
					}
					return match;
				});
	
				// Apply env-specific formatting (colors, etc.)
				createDebug.formatArgs.call(self, args);
	
				const logFn = self.log || createDebug.log;
				logFn.apply(self, args);
			}
	
			debug.namespace = namespace;
			debug.useColors = createDebug.useColors();
			debug.color = createDebug.selectColor(namespace);
			debug.extend = extend;
			debug.destroy = createDebug.destroy; // XXX Temporary. Will be removed in the next major release.
	
			Object.defineProperty(debug, 'enabled', {
				enumerable: true,
				configurable: false,
				get: () => enableOverride === null ? createDebug.enabled(namespace) : enableOverride,
				set: v => {
					enableOverride = v;
				}
			});
	
			// Env-specific initialization logic for debug instances
			if (typeof createDebug.init === 'function') {
				createDebug.init(debug);
			}
	
			return debug;
		}
	
		function extend(namespace, delimiter) {
			const newDebug = createDebug(this.namespace + (typeof delimiter === 'undefined' ? ':' : delimiter) + namespace);
			newDebug.log = this.log;
			return newDebug;
		}
	
		/**
		* Enables a debug mode by namespaces. This can include modes
		* separated by a colon and wildcards.
		*
		* @param {String} namespaces
		* @api public
		*/
		function enable(namespaces) {
			createDebug.save(namespaces);
	
			createDebug.names = [];
			createDebug.skips = [];
	
			let i;
			const split = (typeof namespaces === 'string' ? namespaces : '').split(/[\s,]+/);
			const len = split.length;
	
			for (i = 0; i < len; i++) {
				if (!split[i]) {
					// ignore empty strings
					continue;
				}
	
				namespaces = split[i].replace(/\*/g, '.*?');
	
				if (namespaces[0] === '-') {
					createDebug.skips.push(new RegExp('^' + namespaces.substr(1) + '$'));
				} else {
					createDebug.names.push(new RegExp('^' + namespaces + '$'));
				}
			}
		}
	
		/**
		* Disable debug output.
		*
		* @return {String} namespaces
		* @api public
		*/
		function disable() {
			const namespaces = [
				...createDebug.names.map(toNamespace),
				...createDebug.skips.map(toNamespace).map(namespace => '-' + namespace)
			].join(',');
			createDebug.enable('');
			return namespaces;
		}
	
		/**
		* Returns true if the given mode name is enabled, false otherwise.
		*
		* @param {String} name
		* @return {Boolean}
		* @api public
		*/
		function enabled(name) {
			if (name[name.length - 1] === '*') {
				return true;
			}
	
			let i;
			let len;
	
			for (i = 0, len = createDebug.skips.length; i < len; i++) {
				if (createDebug.skips[i].test(name)) {
					return false;
				}
			}
	
			for (i = 0, len = createDebug.names.length; i < len; i++) {
				if (createDebug.names[i].test(name)) {
					return true;
				}
			}
	
			return false;
		}
	
		/**
		* Convert regexp to namespace
		*
		* @param {RegExp} regxep
		* @return {String} namespace
		* @api private
		*/
		function toNamespace(regexp) {
			return regexp.toString()
				.substring(2, regexp.toString().length - 2)
				.replace(/\.\*\?$/, '*');
		}
	
		/**
		* Coerce `val`.
		*
		* @param {Mixed} val
		* @return {Mixed}
		* @api private
		*/
		function coerce(val) {
			if (val instanceof Error) {
				return val.stack || val.message;
			}
			return val;
		}
	
		/**
		* XXX DO NOT USE. This is a temporary stub function.
		* XXX It WILL be removed in the next major release.
		*/
		function destroy() {
			console.warn('Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`.');
		}
	
		createDebug.enable(createDebug.load());
	
		return createDebug;
	}
	
	module.exports = setup;


/***/ }
/******/ ])));
//# sourceMappingURL=main.f297e0db.js.map